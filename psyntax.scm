;;; Copyright (c) 2006, 2007 Abdulaziz Ghuloum and Kent Dybvig
;;; automatically generated from psyntax sources
;;; for copyright details, see psyntax/main.ss

(begin (set! bf28bb@library-file-path->cache-path (unspecified)) (set! bf28bd@read-annotated (unspecified)) (set! bf28bf@annotation-stripped (unspecified)) (set! bf28c1@annotation? (unspecified)) (set! bf28c3@annotation-source (unspecified)) (set! bf28c5@annotation-expression (unspecified)) (set! bf28c7@scm->fasl (unspecified)) (set! bf28c9@fasl-save (unspecified)) (set! bf28cb@fasl-load (unspecified)) (set! bf28cd@verbose? (unspecified)) (set! bf28cf@serialize-library (unspecified)) (set! bf28d1@load-serialized-library (unspecified)) (set! bf28d3@make-record-printer (unspecified)) (set! bf28d5@compile-core (unspecified)) (set! bf28d7@read-library-source-file (unspecified)) (set! bf28d9@make-parameter (unspecified)) (set! bf28db@mosh-cache-dir (unspecified)) (set! bf2971@file-options-spec (unspecified)) (set! bf28bb@library-file-path->cache-path (lambda (bf2972@x) (call-with-values (lambda () (open-string-output-port)) (lambda (bf2978@bf2975 bf2979@bf2977) (let ((bf297c@extract bf2979@bf2977) (bf297d@p bf2978@bf2975)) (letrec* ((bf2981@display-hex (lambda (bf298a@n) (if (<= '0 bf298a@n '9) (display bf298a@n bf297d@p) (display (integer->char (+ (char->integer '#\a) (- bf298a@n '10))) bf297d@p))))) (begin (let bf2984@f ((bf2982@ls (string-split bf2972@x '#\/))) (if (not (null? bf2982@ls)) (begin (display '"_" bf297d@p) (for-each (lambda (bf2986@c) (if (or (char<=? '#\a bf2986@c '#\z) (char<=? '#\A bf2986@c '#\Z) (char<=? '#\0 bf2986@c '#\9) (memv bf2986@c '(#\- #\. #\_ #\~))) (display bf2986@c bf297d@p) (begin (display '"%" bf297d@p) (let ((bf2988@n (char->integer bf2986@c))) (begin (bf2981@display-hex (quotient bf2988@n '16)) (bf2981@display-hex (remainder bf2988@n '16))))))) (string->list (car bf2982@ls))) (bf2984@f (cdr bf2982@ls))) (void))) (bf297c@extract)))))))) (set! bf29ec@bf28bb@library-file-path->cache-path bf28bb@library-file-path->cache-path) (set! bf28bd@read-annotated read) (set! bf29ed@bf28bd@read-annotated bf28bd@read-annotated) (set! bf28bf@annotation-stripped (lambda (bf298c@x) (if (pair? bf298c@x) (cons (bf28bf@annotation-stripped (car bf298c@x)) (bf28bf@annotation-stripped (cdr bf298c@x))) (if (procedure? bf298c@x) (set-source-info! bf298c@x '#f) bf298c@x)))) (set! bf29ee@bf28bf@annotation-stripped bf28bf@annotation-stripped) (set! bf28c1@annotation? (lambda (bf298e@x) (or (and (annotated-pair? bf298e@x) (source-info bf298e@x)) (and (procedure? bf298e@x) (source-info bf298e@x))))) (set! bf29ef@bf28c1@annotation? bf28c1@annotation?) (set! bf28c3@annotation-source (lambda (bf2990@x) (source-info bf2990@x))) (set! bf29f0@bf28c3@annotation-source bf28c3@annotation-source) (set! bf28c5@annotation-expression (lambda (bf2992@x) (if (annotated-pair? bf2992@x) (cons (car bf2992@x) (cdr bf2992@x)) (if (procedure? bf2992@x) (set-source-info! bf2992@x '#f) bf2992@x)))) (set! bf29f1@bf28c5@annotation-expression bf28c5@annotation-expression) (set! bf28c7@scm->fasl (lambda (bf2994@filename) (string-append (bf28db@mosh-cache-dir) '"/" (bf28bb@library-file-path->cache-path bf2994@filename) '".mosh-fasl"))) (set! bf29f2@bf28c7@scm->fasl bf28c7@scm->fasl) (set! bf28c9@fasl-save (lambda (bf2996@filename bf2997@obj) (call-with-port (open-file-output-port bf2996@filename) (lambda (bf299a@port) ((symbol-value 'fasl-write!) bf2997@obj bf299a@port))))) (set! bf29f3@bf28c9@fasl-save bf28c9@fasl-save) (set! bf28cb@fasl-load (lambda (bf299c@filename) (call-with-port (open-file-input-port bf299c@filename) (symbol-value 'fasl-read!)))) (set! bf29f4@bf28cb@fasl-load bf28cb@fasl-load) (set! bf28cd@verbose? (symbol-value '%verbose)) (set! bf29f5@bf28cd@verbose? bf28cd@verbose?) (set! bf28cf@serialize-library (lambda (bf299e@filename bf299f@obj) (begin (if bf28cd@verbose? (format (current-error-port) '"serialize-library ~a\n..." bf299e@filename) (void)) (let ((bf29a2@expanded2core (symbol-value 'expanded2core))) (let ((bf29a4@compile (symbol-value 'compile-w/o-halt))) (let ((bf29a6@code bf299f@obj)) (let ((bf29a8@pivot (cddddr (cddddr bf29a6@code)))) (let ((bf29aa@visit (bf29a4@compile (bf29a2@expanded2core (car bf29a8@pivot))))) (begin (set-car! bf29a8@pivot bf29aa@visit) (let ((bf29ac@pivot (cdr bf29a8@pivot))) (let ((bf29ae@invoke (bf29a4@compile (bf29a2@expanded2core (car bf29ac@pivot))))) (set-car! bf29ac@pivot bf29ae@invoke))))))))) (let ((bf29b0@fasl-file (bf28c7@scm->fasl bf299e@filename))) (begin (if (file-exists? bf29b0@fasl-file) (delete-file bf29b0@fasl-file) (void)) ((call/cc (lambda (bf29b4@bf29b2) (lambda () (with-exception-handler (lambda (bf29b6@c) ((call/cc (lambda (bf29b8@bf29b3) (bf29b4@bf29b2 (lambda () (if '#t (begin (if bf28cd@verbose? (format (current-error-port) '"Warning:serialize-library failed ~a\n" bf299e@filename) (void)) (if (file-exists? bf29b0@fasl-file) (delete-file bf29b0@fasl-file) (void)) '#f) (bf29b8@bf29b3 (lambda () (raise-continuable bf29b6@c)))))))))) (lambda () (bf28c9@fasl-save bf29b0@fasl-file bf299f@obj)))))))))))) (set! bf29f6@bf28cf@serialize-library bf28cf@serialize-library) (set! bf28d1@load-serialized-library (lambda (bf29ba@filename bf29bb@obj) (and (bf28db@mosh-cache-dir) (let ((bf29be@fasl-file (bf28c7@scm->fasl bf29ba@filename))) (if (and (file-exists? bf29be@fasl-file) ((symbol-value 'file-newer?) bf29be@fasl-file bf29ba@filename)) (let ((bf29c0@expanded2core (symbol-value 'expanded2core))) (let ((bf29c2@eval-compiled-core (symbol-value 'eval-compiled!))) (let ((bf29c4@code (bf28cb@fasl-load bf29be@fasl-file))) (let ((bf29c6@pivot (cddddr (cddddr bf29c4@code)))) (let ((bf29c8@visit (car bf29c6@pivot))) (let ((bf29ca@visit-proc (lambda () (bf29c2@eval-compiled-core bf29c8@visit)))) (begin (set-car! bf29c6@pivot bf29ca@visit-proc) (let ((bf29cc@pivot (cdr bf29c6@pivot))) (let ((bf29ce@invoke (car bf29cc@pivot))) (begin (set-car! bf29cc@pivot (lambda () (bf29c2@eval-compiled-core bf29ce@invoke))) (apply bf29bb@obj bf29c4@code))))))))))) '#f))))) (set! bf29f7@bf28d1@load-serialized-library bf28d1@load-serialized-library) (set! bf28d3@make-record-printer (lambda (bf29d0@name bf29d1@printer) (lambda bf29d4@x (begin (display '"record printer") (for-each display bf29d4@x))))) (set! bf29f8@bf28d3@make-record-printer bf28d3@make-record-printer) (set! bf28d5@compile-core (lambda bf29d6@x (apply error 'comile-core '"not implementated" bf29d6@x))) (set! bf29f9@bf28d5@compile-core bf28d5@compile-core) (set! bf28d7@read-library-source-file (lambda (bf29d8@file-name) (with-input-from-file bf29d8@file-name bf28bd@read-annotated))) (set! bf29fa@bf28d7@read-library-source-file bf28d7@read-library-source-file) (set! bf28d9@make-parameter (lambda bf29e8 (let ((bf29e9 (length bf29e8))) (if (= bf29e9 '1) (apply (lambda (bf29da@x) (bf28d9@make-parameter bf29da@x (lambda (bf29dc@x) bf29dc@x))) bf29e8) (if (= bf29e9 '2) (apply (lambda (bf29de@x bf29df@fender) (let ((bf29e2@x (bf29df@fender bf29de@x))) (lambda bf29e6 (let ((bf29e7 (length bf29e6))) (if (= bf29e7 '0) (apply (lambda () bf29e2@x) bf29e6) (if (= bf29e7 '1) (apply (lambda (bf29e4@v) (set! bf29e2@x (bf29df@fender bf29e4@v))) bf29e6) (error 'apply '"invalid arg count"))))))) bf29e8) (error 'apply '"invalid arg count")))))) (set! bf29fb@bf28d9@make-parameter bf28d9@make-parameter) (set! bf28db@mosh-cache-dir (bf28d9@make-parameter '#f)) (set! bf29fc@bf28db@mosh-cache-dir bf28db@mosh-cache-dir) (set! bf2971@file-options-spec (lambda (bf29ea@x) bf29ea@x)) (set! bf29fd@bf2971@file-options-spec bf2971@file-options-spec) (void))
(begin (set! bf2a03@current-primitive-locations (unspecified)) (set! bf2a05@mutable? (unspecified)) (set! bf2a07@rewriter (unspecified)) (set! bf2a09@expanded->core (unspecified)) (set! bf2a0b@compile-core-expr (unspecified)) (set! bf2a0d@pretty-print (unspecified)) (set! bf2a0f@compile-core-expr-to-port (unspecified)) (set! bf2a03@current-primitive-locations (bf29fb@bf28d9@make-parameter (lambda (bf2a10@x) '#f) (lambda (bf2a12@p) bf2a12@p))) (set! bf2a4e@bf2a03@current-primitive-locations bf2a03@current-primitive-locations) (set! bf2a05@mutable? (lambda (bf2a14@x) (or (pair? bf2a14@x) (vector? bf2a14@x) (hashtable? bf2a14@x)))) (set! bf2a4f@bf2a05@mutable? bf2a05@mutable?) (set! bf2a07@rewriter (lambda (bf2a16@quote-hack?) (letrec* ((bf2a19@f (lambda (bf2a1a@x) (if (pair? bf2a1a@x) (let ((bf2a1c@t (car bf2a1a@x))) (if (memv bf2a1c@t '(quote)) (if (and bf2a16@quote-hack? (bf2a05@mutable? (cadr bf2a1a@x))) (let ((bf2a1e@g (gensym))) (begin (set-symbol-value! bf2a1e@g (cadr bf2a1a@x)) bf2a1e@g)) bf2a1a@x) (if (memv bf2a1c@t '(case-lambda)) (cons 'case-lambda (map (lambda (bf2a20@x) (cons (car bf2a20@x) (map bf2a19@f (cdr bf2a20@x)))) (cdr bf2a1a@x))) (if (memv bf2a1c@t '(lambda)) (cons* 'lambda (cadr bf2a1a@x) (map bf2a19@f (cddr bf2a1a@x))) (if (memv bf2a1c@t '(letrec)) (let ((bf2a22@bindings (cadr bf2a1a@x)) (bf2a23@body* (cddr bf2a1a@x))) (let ((bf2a26@lhs* (map car bf2a22@bindings)) (bf2a27@rhs* (map cadr bf2a22@bindings))) (cons* 'letrec (map list bf2a26@lhs* (map bf2a19@f bf2a27@rhs*)) (map bf2a19@f bf2a23@body*)))) (if (memv bf2a1c@t '(letrec*)) (let ((bf2a2a@bindings (cadr bf2a1a@x)) (bf2a2b@body* (cddr bf2a1a@x))) (let ((bf2a2e@lhs* (map car bf2a2a@bindings)) (bf2a2f@rhs* (map cadr bf2a2a@bindings))) (cons* 'letrec* (map list bf2a2e@lhs* (map bf2a19@f bf2a2f@rhs*)) (map bf2a19@f bf2a2b@body*)))) (if (memv bf2a1c@t '(library-letrec*)) (let ((bf2a32@name (cadr bf2a1a@x)) (bf2a33@x (cdr bf2a1a@x))) (let ((bf2a36@bindings (cadr bf2a33@x)) (bf2a37@body* (cddr bf2a33@x))) (let ((bf2a3a@lhs* (map car bf2a36@bindings)) (bf2a3b@lhs** (map cadr bf2a36@bindings)) (bf2a3c@rhs* (map caddr bf2a36@bindings))) (cons* 'library-letrec* bf2a32@name (map list bf2a3a@lhs* bf2a3b@lhs** (map bf2a19@f bf2a3c@rhs*)) (map bf2a19@f bf2a37@body*))))) (if (memv bf2a1c@t '(begin)) (cons 'begin (map bf2a19@f (cdr bf2a1a@x))) (if (memv bf2a1c@t '(set!)) (list 'set! (cadr bf2a1a@x) (bf2a19@f (caddr bf2a1a@x))) (if (memv bf2a1c@t '(primitive)) (let ((bf2a40@op (cadr bf2a1a@x))) (let ((bf2a42@t ((bf2a03@current-primitive-locations) bf2a40@op))) (if bf2a42@t ((lambda (bf2a44@loc) bf2a44@loc) bf2a42@t) bf2a40@op))) (if (memv bf2a1c@t '(define)) bf2a1a@x (if (list? bf2a1a@x) (map bf2a19@f bf2a1a@x) (error 'rewrite '"invalid form ~s ~s" bf2a1a@x (list? bf2a1a@x)))))))))))))) bf2a1a@x)))) bf2a19@f))) (set! bf2a50@bf2a07@rewriter bf2a07@rewriter) (set! bf2a09@expanded->core (lambda (bf2a46@x) ((bf2a07@rewriter '#f) bf2a46@x))) (set! bf2a51@bf2a09@expanded->core bf2a09@expanded->core) (set! bf2a0b@compile-core-expr (lambda (bf2a48@x) ((bf2a07@rewriter '#f) bf2a48@x))) (set! bf2a52@bf2a0b@compile-core-expr bf2a0b@compile-core-expr) (set! bf2a0d@pretty-print write) (set! bf2a53@bf2a0d@pretty-print bf2a0d@pretty-print) (set! bf2a0f@compile-core-expr-to-port (lambda (bf2a4a@x bf2a4b@p) (bf2a0d@pretty-print ((bf2a07@rewriter '#f) bf2a4a@x) bf2a4b@p))) (set! bf2a54@bf2a0f@compile-core-expr-to-port bf2a0f@compile-core-expr-to-port) (void))
(begin (void))
(begin (set! bf2aa3@make-collection (unspecified)) (set! bf2aa5@current-library-collection (unspecified)) (set! bf2aa7@rp (unspecified)) (set! bf2ab1@library? (unspecified)) (set! bf2ab3@library-id (unspecified)) (set! bf2ab5@set-library-id! (unspecified)) (set! bf2ab7@library-name (unspecified)) (set! bf2ab9@set-library-name! (unspecified)) (set! bf2abb@library-version (unspecified)) (set! bf2abd@set-library-version! (unspecified)) (set! bf2abf@library-imp* (unspecified)) (set! bf2ac1@set-library-imp*! (unspecified)) (set! bf2ac3@library-vis* (unspecified)) (set! bf2ac5@set-library-vis*! (unspecified)) (set! bf2ac7@library-inv* (unspecified)) (set! bf2ac9@set-library-inv*! (unspecified)) (set! bf2acb@library-subst (unspecified)) (set! bf2acd@set-library-subst! (unspecified)) (set! bf2acf@library-env (unspecified)) (set! bf2ad1@set-library-env! (unspecified)) (set! bf2ad3@library-visit-state (unspecified)) (set! bf2ad5@set-library-visit-state! (unspecified)) (set! bf2ad7@library-invoke-state (unspecified)) (set! bf2ad9@set-library-invoke-state! (unspecified)) (set! bf2adb@library-visit-code (unspecified)) (set! bf2add@set-library-visit-code! (unspecified)) (set! bf2adf@library-invoke-code (unspecified)) (set! bf2ae1@set-library-invoke-code! (unspecified)) (set! bf2ae3@library-visible? (unspecified)) (set! bf2ae5@set-library-visible?! (unspecified)) (set! bf2ae7@library-source-file-name (unspecified)) (set! bf2ae9@set-library-source-file-name! (unspecified)) (set! bf2aeb@dummy (unspecified)) (set! bf2aed@find-dependencies (unspecified)) (set! bf2aef@find-library-by (unspecified)) (set! bf2af1@library-path (unspecified)) (set! bf2af3@library-extensions (unspecified)) (set! bf2af5@library-name->file-name (unspecified)) (set! bf2af7@file-locator (unspecified)) (set! bf2af9@serialize-all (unspecified)) (set! bf2afb@current-precompiled-library-loader (unspecified)) (set! bf2afd@try-load-from-file (unspecified)) (set! bf2aff@library-loader (unspecified)) (set! bf2b01@current-library-expander (unspecified)) (set! bf2b03@external-pending-libraries (unspecified)) (set! bf2b05@find-external-library (unspecified)) (set! bf2b07@find-library-by-name (unspecified)) (set! bf2b09@library-exists? (unspecified)) (set! bf2b0b@find-library-by-spec/die (unspecified)) (set! bf2b0d@label->binding-table (unspecified)) (set! bf2b0f@install-library-record (unspecified)) (set! bf2b11@install-library (unspecified)) (set! bf2b13@imported-label->binding (unspecified)) (set! bf2b15@invoke-library (unspecified)) (set! bf2b17@visit-library (unspecified)) (set! bf2b19@invoke-library-by-spec (unspecified)) (set! bf2b1b@installed-libraries (unspecified)) (set! bf2b1d@library-spec (unspecified)) (set! bf2aa3@make-collection (lambda () (let ((bf2b1e@set '())) (letrec* ((bf2b21@set-cons (lambda (bf2b26@x bf2b27@ls) (if (memq bf2b26@x bf2b27@ls) bf2b27@ls (cons bf2b26@x bf2b27@ls))))) (lambda bf2b24 (let ((bf2b25 (length bf2b24))) (if (= bf2b25 '0) (apply (lambda () bf2b1e@set) bf2b24) (if (= bf2b25 '1) (apply (lambda (bf2b22@x) (set! bf2b1e@set (bf2b21@set-cons bf2b22@x bf2b1e@set))) bf2b24) (error 'apply '"invalid arg count"))))))))) (set! bf2c92@bf2aa3@make-collection bf2aa3@make-collection) (set! bf2aa5@current-library-collection (bf29fb@bf28d9@make-parameter (bf2aa3@make-collection) (lambda (bf2b2a@x) (begin (if (not (procedure? bf2b2a@x)) (assertion-violation 'current-library-collection '"not a procedure" bf2b2a@x) (void)) bf2b2a@x)))) (set! bf2c93@bf2aa5@current-library-collection bf2aa5@current-library-collection) (set! bf2aa7@rp (bf29f8@bf28d3@make-record-printer 'library (lambda (bf2b2c@x bf2b2d@p bf2b2e@wr) (begin (if (not (bf2ab1@library? bf2b2c@x)) (assertion-violation 'record-type-printer '"not a library") (void)) (display (format '"#<library ~s>" (if (null? (bf2abb@library-version bf2b2c@x)) (bf2ab7@library-name bf2b2c@x) (append (bf2ab7@library-name bf2b2c@x) (list (bf2abb@library-version bf2b2c@x))))) bf2b2d@p))))) (set! bf2c94@bf2aa7@rp bf2aa7@rp) (set! bf2ab1@library? (lambda (bf2b32@x) (and (simple-struct? bf2b32@x) (eq? (simple-struct-name bf2b32@x) 'library)))) (set! bf2c95@bf2ab1@library? bf2ab1@library?) (set! bf2ab3@library-id (lambda (bf2b34@x) (simple-struct-ref bf2b34@x '0))) (set! bf2c96@bf2ab3@library-id bf2ab3@library-id) (set! bf2ab5@set-library-id! (lambda (bf2b36@x bf2b37@val) (simple-struct-set! bf2b36@x '0 bf2b37@val))) (set! bf2c97@bf2ab5@set-library-id! bf2ab5@set-library-id!) (set! bf2ab7@library-name (lambda (bf2b3a@x) (simple-struct-ref bf2b3a@x '1))) (set! bf2c98@bf2ab7@library-name bf2ab7@library-name) (set! bf2ab9@set-library-name! (lambda (bf2b3c@x bf2b3d@val) (simple-struct-set! bf2b3c@x '1 bf2b3d@val))) (set! bf2c99@bf2ab9@set-library-name! bf2ab9@set-library-name!) (set! bf2abb@library-version (lambda (bf2b40@x) (simple-struct-ref bf2b40@x '2))) (set! bf2c9a@bf2abb@library-version bf2abb@library-version) (set! bf2abd@set-library-version! (lambda (bf2b42@x bf2b43@val) (simple-struct-set! bf2b42@x '2 bf2b43@val))) (set! bf2c9b@bf2abd@set-library-version! bf2abd@set-library-version!) (set! bf2abf@library-imp* (lambda (bf2b46@x) (simple-struct-ref bf2b46@x '3))) (set! bf2c9c@bf2abf@library-imp* bf2abf@library-imp*) (set! bf2ac1@set-library-imp*! (lambda (bf2b48@x bf2b49@val) (simple-struct-set! bf2b48@x '3 bf2b49@val))) (set! bf2c9d@bf2ac1@set-library-imp*! bf2ac1@set-library-imp*!) (set! bf2ac3@library-vis* (lambda (bf2b4c@x) (simple-struct-ref bf2b4c@x '4))) (set! bf2c9e@bf2ac3@library-vis* bf2ac3@library-vis*) (set! bf2ac5@set-library-vis*! (lambda (bf2b4e@x bf2b4f@val) (simple-struct-set! bf2b4e@x '4 bf2b4f@val))) (set! bf2c9f@bf2ac5@set-library-vis*! bf2ac5@set-library-vis*!) (set! bf2ac7@library-inv* (lambda (bf2b52@x) (simple-struct-ref bf2b52@x '5))) (set! bf2ca0@bf2ac7@library-inv* bf2ac7@library-inv*) (set! bf2ac9@set-library-inv*! (lambda (bf2b54@x bf2b55@val) (simple-struct-set! bf2b54@x '5 bf2b55@val))) (set! bf2ca1@bf2ac9@set-library-inv*! bf2ac9@set-library-inv*!) (set! bf2acb@library-subst (lambda (bf2b58@x) (simple-struct-ref bf2b58@x '6))) (set! bf2ca2@bf2acb@library-subst bf2acb@library-subst) (set! bf2acd@set-library-subst! (lambda (bf2b5a@x bf2b5b@val) (simple-struct-set! bf2b5a@x '6 bf2b5b@val))) (set! bf2ca3@bf2acd@set-library-subst! bf2acd@set-library-subst!) (set! bf2acf@library-env (lambda (bf2b5e@x) (simple-struct-ref bf2b5e@x '7))) (set! bf2ca4@bf2acf@library-env bf2acf@library-env) (set! bf2ad1@set-library-env! (lambda (bf2b60@x bf2b61@val) (simple-struct-set! bf2b60@x '7 bf2b61@val))) (set! bf2ca5@bf2ad1@set-library-env! bf2ad1@set-library-env!) (set! bf2ad3@library-visit-state (lambda (bf2b64@x) (simple-struct-ref bf2b64@x '8))) (set! bf2ca6@bf2ad3@library-visit-state bf2ad3@library-visit-state) (set! bf2ad5@set-library-visit-state! (lambda (bf2b66@x bf2b67@val) (simple-struct-set! bf2b66@x '8 bf2b67@val))) (set! bf2ca7@bf2ad5@set-library-visit-state! bf2ad5@set-library-visit-state!) (set! bf2ad7@library-invoke-state (lambda (bf2b6a@x) (simple-struct-ref bf2b6a@x '9))) (set! bf2ca8@bf2ad7@library-invoke-state bf2ad7@library-invoke-state) (set! bf2ad9@set-library-invoke-state! (lambda (bf2b6c@x bf2b6d@val) (simple-struct-set! bf2b6c@x '9 bf2b6d@val))) (set! bf2ca9@bf2ad9@set-library-invoke-state! bf2ad9@set-library-invoke-state!) (set! bf2adb@library-visit-code (lambda (bf2b70@x) (simple-struct-ref bf2b70@x '10))) (set! bf2caa@bf2adb@library-visit-code bf2adb@library-visit-code) (set! bf2add@set-library-visit-code! (lambda (bf2b72@x bf2b73@val) (simple-struct-set! bf2b72@x '10 bf2b73@val))) (set! bf2cab@bf2add@set-library-visit-code! bf2add@set-library-visit-code!) (set! bf2adf@library-invoke-code (lambda (bf2b76@x) (simple-struct-ref bf2b76@x '11))) (set! bf2cac@bf2adf@library-invoke-code bf2adf@library-invoke-code) (set! bf2ae1@set-library-invoke-code! (lambda (bf2b78@x bf2b79@val) (simple-struct-set! bf2b78@x '11 bf2b79@val))) (set! bf2cad@bf2ae1@set-library-invoke-code! bf2ae1@set-library-invoke-code!) (set! bf2ae3@library-visible? (lambda (bf2b7c@x) (simple-struct-ref bf2b7c@x '12))) (set! bf2cae@bf2ae3@library-visible? bf2ae3@library-visible?) (set! bf2ae5@set-library-visible?! (lambda (bf2b7e@x bf2b7f@val) (simple-struct-set! bf2b7e@x '12 bf2b7f@val))) (set! bf2caf@bf2ae5@set-library-visible?! bf2ae5@set-library-visible?!) (set! bf2ae7@library-source-file-name (lambda (bf2b82@x) (simple-struct-ref bf2b82@x '13))) (set! bf2cb0@bf2ae7@library-source-file-name bf2ae7@library-source-file-name) (set! bf2ae9@set-library-source-file-name! (lambda (bf2b84@x bf2b85@val) (simple-struct-set! bf2b84@x '13 bf2b85@val))) (set! bf2cb1@bf2ae9@set-library-source-file-name! bf2ae9@set-library-source-file-name!) (set! bf2aeb@dummy '3) (set! bf2cb2@bf2aeb@dummy bf2aeb@dummy) (set! bf2aed@find-dependencies (lambda (bf2b88@ls) (if (null? bf2b88@ls) '() (assertion-violation 'find-dependencies '"cannot handle deps yet")))) (set! bf2cb3@bf2aed@find-dependencies bf2aed@find-dependencies) (set! bf2aef@find-library-by (lambda (bf2b8a@pred) (let bf2b8e@f ((bf2b8c@ls ((bf2aa5@current-library-collection)))) (if (null? bf2b8c@ls) '#f (if (bf2b8a@pred (car bf2b8c@ls)) (car bf2b8c@ls) (bf2b8e@f (cdr bf2b8c@ls))))))) (set! bf2cb4@bf2aef@find-library-by bf2aef@find-library-by) (set! bf2af1@library-path (bf29fb@bf28d9@make-parameter '(".") (lambda (bf2b90@x) (if (and (list? bf2b90@x) (for-all string? bf2b90@x)) (map (lambda (bf2b92@x) bf2b92@x) bf2b90@x) (assertion-violation 'library-path '"not a list of strings" bf2b90@x))))) (set! bf2cb5@bf2af1@library-path bf2af1@library-path) (set! bf2af3@library-extensions (bf29fb@bf28d9@make-parameter '(".sls" ".ss" ".scm") (lambda (bf2b94@x) (if (and (list? bf2b94@x) (for-all string? bf2b94@x)) (map (lambda (bf2b96@x) bf2b96@x) bf2b94@x) (assertion-violation 'library-extensions '"not a list of strings" bf2b94@x))))) (set! bf2cb6@bf2af3@library-extensions bf2af3@library-extensions) (set! bf2af5@library-name->file-name (lambda (bf2b98@x) (call-with-values (lambda () (open-string-output-port)) (lambda (bf2b9e@bf2b9b bf2b9f@bf2b9d) (let ((bf2ba2@extract bf2b9f@bf2b9d) (bf2ba3@p bf2b9e@bf2b9b)) (letrec* ((bf2ba7@display-hex (lambda (bf2bb0@n) (if (<= '0 bf2bb0@n '9) (display bf2bb0@n bf2ba3@p) (display (integer->char (+ (char->integer '#\a) (- bf2bb0@n '10))) bf2ba3@p))))) (begin (let bf2baa@f ((bf2ba8@ls bf2b98@x)) (if (not (null? bf2ba8@ls)) (begin (display '"/" bf2ba3@p) (for-each (lambda (bf2bac@c) (if (or (char<=? '#\a bf2bac@c '#\z) (char<=? '#\A bf2bac@c '#\Z) (char<=? '#\0 bf2bac@c '#\9) (memv bf2bac@c '(#\- #\. #\_ #\~))) (display bf2bac@c bf2ba3@p) (begin (display '"%" bf2ba3@p) (let ((bf2bae@n (char->integer bf2bac@c))) (begin (bf2ba7@display-hex (quotient bf2bae@n '16)) (bf2ba7@display-hex (remainder bf2bae@n '16))))))) (string->list (symbol->string (car bf2ba8@ls)))) (bf2baa@f (cdr bf2ba8@ls))) (void))) (bf2ba2@extract)))))))) (set! bf2cb7@bf2af5@library-name->file-name bf2af5@library-name->file-name) (set! bf2af7@file-locator (bf29fb@bf28d9@make-parameter (lambda (bf2bb2@x) (let ((bf2bb4@str (bf2af5@library-name->file-name bf2bb2@x))) (let bf2bbc@f ((bf2bb6@ls (bf2af1@library-path)) (bf2bb7@exts (bf2af3@library-extensions)) (bf2bb8@failed-list '())) (if (null? bf2bb6@ls) (letrec* ((bf2bc6@bf2bc1 (make-record-type-descriptor '&library-resolution &condition-rtd 'bf2bc4 '#f '#f '#((immutable library) (immutable files)))) (bf2bc8@bf2bc3 '#f) (bf2bca@bf2bc2 (make-record-constructor-descriptor bf2bc6@bf2bc1 &condition-rcd bf2bc8@bf2bc3)) (bf2bcd@bf2bc0 (record-predicate bf2bc6@bf2bc1)) (bf2bcf@make-library-resolution-condition (record-constructor bf2bca@bf2bc2)) (bf2bd1@bf2bbe (record-accessor bf2bc6@bf2bc1 '0)) (bf2bd3@bf2bbf (record-accessor bf2bc6@bf2bc1 '1)) (bf2bd5@library-resolution-condition? (condition-predicate bf2bc6@bf2bc1)) (bf2bd7@condition-library (condition-accessor bf2bc6@bf2bc1 bf2bd1@bf2bbe)) (bf2bd9@condition-files (condition-accessor bf2bc6@bf2bc1 bf2bd3@bf2bbf))) (raise (condition (make-error) (make-who-condition 'expander) (make-message-condition '"cannot locate library in library-path") (bf2bcf@make-library-resolution-condition bf2bb2@x (reverse bf2bb8@failed-list))))) (if (null? bf2bb7@exts) (bf2bbc@f (cdr bf2bb6@ls) (bf2af3@library-extensions) bf2bb8@failed-list) (let ((bf2bda@name (string-append (car bf2bb6@ls) bf2bb4@str (car bf2bb7@exts)))) (if (file-exists? bf2bda@name) bf2bda@name (bf2bbc@f bf2bb6@ls (cdr bf2bb7@exts) (cons bf2bda@name bf2bb8@failed-list))))))))) (lambda (bf2bdc@f) (if (procedure? bf2bdc@f) bf2bdc@f (assertion-violation 'file-locator '"not a procedure" bf2bdc@f))))) (set! bf2cb8@bf2af7@file-locator bf2af7@file-locator) (set! bf2af9@serialize-all (lambda (bf2bde@serialize bf2bdf@compile) (letrec* ((bf2be3@library-desc (lambda (bf2be6@x) (list (bf2ab3@library-id bf2be6@x) (bf2ab7@library-name bf2be6@x))))) (for-each (lambda (bf2be4@x) (if (bf2ae7@library-source-file-name bf2be4@x) (bf2bde@serialize (bf2ae7@library-source-file-name bf2be4@x) (list (bf2ab3@library-id bf2be4@x) (bf2ab7@library-name bf2be4@x) (bf2abb@library-version bf2be4@x) (map bf2be3@library-desc (bf2abf@library-imp* bf2be4@x)) (map bf2be3@library-desc (bf2ac3@library-vis* bf2be4@x)) (map bf2be3@library-desc (bf2ac7@library-inv* bf2be4@x)) (bf2acb@library-subst bf2be4@x) (bf2acf@library-env bf2be4@x) (bf2bdf@compile (bf2adb@library-visit-code bf2be4@x)) (bf2bdf@compile (bf2adf@library-invoke-code bf2be4@x)) (bf2ae3@library-visible? bf2be4@x))) (void))) ((bf2aa5@current-library-collection)))))) (set! bf2cb9@bf2af9@serialize-all bf2af9@serialize-all) (set! bf2afb@current-precompiled-library-loader (bf29fb@bf28d9@make-parameter (lambda (bf2be8@filename bf2be9@sk) '#f))) (set! bf2cba@bf2afb@current-precompiled-library-loader bf2afb@current-precompiled-library-loader) (set! bf2afd@try-load-from-file (lambda (bf2bec@filename) ((bf2afb@current-precompiled-library-loader) bf2bec@filename (lambda bf2c12 (let ((bf2c13 (length bf2c12))) (if (= bf2c13 '11) (apply (lambda (bf2bee@id bf2bef@name bf2bf0@ver bf2bf1@imp* bf2bf2@vis* bf2bf3@inv* bf2bf4@exp-subst bf2bf5@exp-env bf2bf6@visit-proc bf2bf7@invoke-proc bf2bf8@visible?) (let bf2c06@f ((bf2c04@deps (append bf2bf1@imp* bf2bf2@vis* bf2bf3@inv*))) (if (null? bf2c04@deps) (begin (bf2b11@install-library bf2bee@id bf2bef@name bf2bf0@ver bf2bf1@imp* bf2bf2@vis* bf2bf3@inv* bf2bf4@exp-subst bf2bf5@exp-env bf2bf6@visit-proc bf2bf7@invoke-proc '#f '#f bf2bf8@visible? '#f) '#t) (let ((bf2c08@d (car bf2c04@deps))) (let ((bf2c0a@label (car bf2c08@d)) (bf2c0b@dname (cadr bf2c08@d))) (let ((bf2c0e@l (bf2b07@find-library-by-name bf2c0b@dname))) (if (and (bf2ab1@library? bf2c0e@l) (eq? bf2c0a@label (bf2ab3@library-id bf2c0e@l))) (bf2c06@f (cdr bf2c04@deps)) (begin (if bf29f5@bf28cd@verbose? (format (current-error-port) '"WARNING: library ~e has an inconsistent dependency on library ~e; file ~e will be recompiled from source. \n" bf2bef@name bf2c0b@dname bf2bec@filename) (void)) '#f)))))))) bf2c12) (if (>= bf2c13 '0) (apply (lambda bf2c10@others '#f) bf2c12) (error 'apply '"invalid arg count")))))))) (set! bf2cbb@bf2afd@try-load-from-file bf2afd@try-load-from-file) (set! bf2aff@library-loader (bf29fb@bf28d9@make-parameter (lambda (bf2c14@x) (let ((bf2c16@file-name ((bf2af7@file-locator) bf2c14@x))) (if (not bf2c16@file-name) (assertion-violation '#f '"cannot file library" bf2c14@x) (or (bf2afd@try-load-from-file bf2c16@file-name) ((bf2b01@current-library-expander) (bf29fa@bf28d7@read-library-source-file bf2c16@file-name) bf2c16@file-name (lambda (bf2c18@name) (if (not (fast-equal? bf2c18@name bf2c14@x)) (assertion-violation 'import (call-with-values (lambda () (open-string-output-port)) (lambda (bf2c1e@bf2c1b bf2c1f@bf2c1d) (let ((bf2c22@e bf2c1f@bf2c1d) (bf2c23@p bf2c1e@bf2c1b)) (begin (display '"expected to find library " bf2c23@p) (write bf2c14@x bf2c23@p) (display '" in file " bf2c23@p) (display bf2c16@file-name bf2c23@p) (display '", found " bf2c23@p) (write bf2c18@name bf2c23@p) (display '" instead" bf2c23@p) (bf2c22@e)))))) (void)))))))) (lambda (bf2c26@f) (if (procedure? bf2c26@f) bf2c26@f (assertion-violation 'library-locator '"not a procedure" bf2c26@f))))) (set! bf2cbc@bf2aff@library-loader bf2aff@library-loader) (set! bf2b01@current-library-expander (bf29fb@bf28d9@make-parameter (lambda (bf2c28@x) (assertion-violation 'library-expander '"not initialized")) (lambda (bf2c2a@f) (if (procedure? bf2c2a@f) bf2c2a@f (assertion-violation 'library-expander '"not a procedure" bf2c2a@f))))) (set! bf2cbd@bf2b01@current-library-expander bf2b01@current-library-expander) (set! bf2b03@external-pending-libraries (bf29fb@bf28d9@make-parameter '())) (set! bf2cbe@bf2b03@external-pending-libraries bf2b03@external-pending-libraries) (set! bf2b05@find-external-library (lambda (bf2c2c@name) (begin (if (member bf2c2c@name (bf2b03@external-pending-libraries)) (assertion-violation '#f '"circular attempt to import library was detected" bf2c2c@name) (void)) (let ((bf2c32@bf2c2f bf2b03@external-pending-libraries) (bf2c33@bf2c31 (cons bf2c2c@name (bf2b03@external-pending-libraries)))) (let ((bf2c36@swap (lambda () (let ((bf2c38@t (bf2c32@bf2c2f))) (begin (bf2c32@bf2c2f bf2c33@bf2c31) (set! bf2c33@bf2c31 bf2c38@t)))))) (dynamic-wind bf2c36@swap (lambda () (begin ((bf2aff@library-loader) bf2c2c@name) (or (bf2aef@find-library-by (lambda (bf2c3a@x) (fast-equal? (bf2ab7@library-name bf2c3a@x) bf2c2c@name))) (assertion-violation '#f '"handling external library did not yield the correct library" bf2c2c@name)))) bf2c36@swap)))))) (set! bf2cbf@bf2b05@find-external-library bf2b05@find-external-library) (set! bf2b07@find-library-by-name (lambda (bf2c3c@name) (or (bf2aef@find-library-by (lambda (bf2c3e@x) (fast-equal? (bf2ab7@library-name bf2c3e@x) bf2c3c@name))) (bf2b05@find-external-library bf2c3c@name)))) (set! bf2cc0@bf2b07@find-library-by-name bf2b07@find-library-by-name) (set! bf2b09@library-exists? (lambda (bf2c40@name) (and (bf2aef@find-library-by (lambda (bf2c42@x) (fast-equal? (bf2ab7@library-name bf2c42@x) bf2c40@name))) '#t))) (set! bf2cc1@bf2b09@library-exists? bf2b09@library-exists?) (set! bf2b0b@find-library-by-spec/die (lambda (bf2c44@spec) (let ((bf2c46@id (car bf2c44@spec))) (or (bf2aef@find-library-by (lambda (bf2c48@x) (eq? bf2c46@id (bf2ab3@library-id bf2c48@x)))) (assertion-violation '#f '"cannot find library with required spec" bf2c44@spec))))) (set! bf2cc2@bf2b0b@find-library-by-spec/die bf2b0b@find-library-by-spec/die) (set! bf2b0d@label->binding-table (make-eq-hashtable)) (set! bf2cc3@bf2b0d@label->binding-table bf2b0d@label->binding-table) (set! bf2b0f@install-library-record (lambda (bf2c4a@lib) (begin (let ((bf2c4c@exp-env (bf2acf@library-env bf2c4a@lib))) (for-each (lambda (bf2c4e@x) (let ((bf2c50@label (car bf2c4e@x)) (bf2c51@binding (cdr bf2c4e@x))) (let ((bf2c54@binding (let ((bf2c56@t (car bf2c51@binding))) (if (memv bf2c56@t '(global)) (cons 'global (cons bf2c4a@lib (cdr bf2c51@binding))) (if (memv bf2c56@t '(global-macro)) (cons 'global-macro (cons bf2c4a@lib (cdr bf2c51@binding))) (if (memv bf2c56@t '(global-macro!)) (cons 'global-macro! (cons bf2c4a@lib (cdr bf2c51@binding))) bf2c51@binding)))))) (begin (if (hashtable-ref bf2b0d@label->binding-table bf2c50@label '#f) (begin (format (current-error-port) '"FATAL overwrite !! key=~a value=~a to ~a\n" bf2c50@label (hashtable-ref bf2b0d@label->binding-table bf2c50@label '#f) bf2c54@binding) (exit)) (void)) (hashtable-set! bf2b0d@label->binding-table bf2c50@label bf2c54@binding))))) bf2c4c@exp-env)) ((bf2aa5@current-library-collection) bf2c4a@lib)))) (set! bf2cc4@bf2b0f@install-library-record bf2b0f@install-library-record) (set! bf2b11@install-library (lambda (bf2c58@id bf2c59@name bf2c5a@ver bf2c5b@imp* bf2c5c@vis* bf2c5d@inv* bf2c5e@exp-subst bf2c5f@exp-env bf2c60@visit-proc bf2c61@invoke-proc bf2c62@visit-code bf2c63@invoke-code bf2c64@visible? bf2c65@source-file-name) (let ((bf2c74@imp-lib* (map bf2b0b@find-library-by-spec/die bf2c5b@imp*)) (bf2c75@vis-lib* (map bf2b0b@find-library-by-spec/die bf2c5c@vis*)) (bf2c76@inv-lib* (map bf2b0b@find-library-by-spec/die bf2c5d@inv*))) (begin (if (not (and (symbol? bf2c58@id) (list? bf2c59@name) (list? bf2c5a@ver))) (assertion-violation 'install-library '"invalid spec with id/name/ver" bf2c58@id bf2c59@name bf2c5a@ver) (void)) (if (bf2b09@library-exists? bf2c59@name) (assertion-violation 'install-library '"library is already installed" bf2c59@name) (void)) (let ((bf2c7a@lib (make-simple-struct 'library '15 (list bf2c58@id bf2c59@name bf2c5a@ver bf2c74@imp-lib* bf2c75@vis-lib* bf2c76@inv-lib* bf2c5e@exp-subst bf2c5f@exp-env bf2c60@visit-proc bf2c61@invoke-proc bf2c62@visit-code bf2c63@invoke-code bf2c64@visible? bf2c65@source-file-name)))) (bf2b0f@install-library-record bf2c7a@lib)))))) (set! bf2cc5@bf2b11@install-library bf2b11@install-library) (set! bf2b13@imported-label->binding (lambda (bf2c7c@lab) (hashtable-ref bf2b0d@label->binding-table bf2c7c@lab '#f))) (set! bf2cc6@bf2b13@imported-label->binding bf2b13@imported-label->binding) (set! bf2b15@invoke-library (lambda (bf2c7e@lib) (let ((bf2c80@invoke (bf2ad7@library-invoke-state bf2c7e@lib))) (if (procedure? bf2c80@invoke) (begin (bf2ad9@set-library-invoke-state! bf2c7e@lib (lambda () (assertion-violation 'invoke '"circularity detected" bf2c7e@lib))) (for-each bf2b15@invoke-library (bf2ac7@library-inv* bf2c7e@lib)) (bf2ad9@set-library-invoke-state! bf2c7e@lib (lambda () (assertion-violation 'invoke '"first invoke did not return" bf2c7e@lib))) (bf2c80@invoke) (bf2ad9@set-library-invoke-state! bf2c7e@lib '#t)) (void))))) (set! bf2cc7@bf2b15@invoke-library bf2b15@invoke-library) (set! bf2b17@visit-library (lambda (bf2c82@lib) (let ((bf2c84@visit (bf2ad3@library-visit-state bf2c82@lib))) (if (procedure? bf2c84@visit) (begin (bf2ad5@set-library-visit-state! bf2c82@lib (lambda () (assertion-violation 'visit '"circularity detected" bf2c82@lib))) (for-each bf2b15@invoke-library (bf2ac3@library-vis* bf2c82@lib)) (bf2ad5@set-library-visit-state! bf2c82@lib (lambda () (assertion-violation 'invoke '"first visit did not return" bf2c82@lib))) (bf2c84@visit) (bf2ad5@set-library-visit-state! bf2c82@lib '#t)) (void))))) (set! bf2cc8@bf2b17@visit-library bf2b17@visit-library) (set! bf2b19@invoke-library-by-spec (lambda (bf2c86@spec) (bf2b15@invoke-library (bf2b0b@find-library-by-spec/die bf2c86@spec)))) (set! bf2cc9@bf2b19@invoke-library-by-spec bf2b19@invoke-library-by-spec) (set! bf2b1b@installed-libraries (lambda bf2c8e (let ((bf2c8f (length bf2c8e))) (if (= bf2c8f '1) (apply (lambda (bf2c88@all?) (let bf2c8c@f ((bf2c8a@ls ((bf2aa5@current-library-collection)))) (if (null? bf2c8a@ls) '() (if (or bf2c88@all? (bf2ae3@library-visible? (car bf2c8a@ls))) (cons (car bf2c8a@ls) (bf2c8c@f (cdr bf2c8a@ls))) (bf2c8c@f (cdr bf2c8a@ls)))))) bf2c8e) (if (= bf2c8f '0) (apply (lambda () (bf2b1b@installed-libraries '#f)) bf2c8e) (error 'apply '"invalid arg count")))))) (set! bf2cca@bf2b1b@installed-libraries bf2b1b@installed-libraries) (set! bf2b1d@library-spec (lambda (bf2c90@x) (begin (if (not (bf2ab1@library? bf2c90@x)) (assertion-violation 'library-spec '"not a library" bf2c90@x) (void)) (list (bf2ab3@library-id bf2c90@x) (bf2ab7@library-name bf2c90@x) (bf2abb@library-version bf2c90@x))))) (set! bf2ccb@bf2b1d@library-spec bf2b1d@library-spec) (void))
(begin (set! bf2ccf@build-global-define (unspecified)) (set! bf2d40@build-lambda (unspecified)) (set! bf2d42@build-case-lambda (unspecified)) (set! bf2d70@build-sequence (unspecified)) (set! bf2d72@build-void (unspecified)) (set! bf2d74@build-letrec (unspecified)) (set! bf2d76@build-let (unspecified)) (set! bf2d78@build-named-let (unspecified)) (set! bf2d7a@build-letrec* (unspecified)) (set! bf2d7c@build-library-letrec* (unspecified)) (set! bf2d7e@build-receive (unspecified)) (set! bf2ccf@build-global-define (lambda (bf2d7f@x) (bf2d72@build-void))) (set! bf2e0d@bf2ccf@build-global-define bf2ccf@build-global-define) (set! bf2d40@build-lambda (lambda (bf2d81@ae bf2d82@vars bf2d83@exp) (list 'lambda bf2d82@vars bf2d83@exp))) (set! bf2e0e@bf2d40@build-lambda bf2d40@build-lambda) (set! bf2d42@build-case-lambda (lambda (bf2d87@ae bf2d88@vars* bf2d89@exp*) (letrec* ((bf2d8e@build-error (lambda (bf2dc5@ae) (list '(primitive error) ''apply (list 'quote '"invalid arg count")))) (bf2d90@build-pred (lambda (bf2dad@ae bf2dae@n bf2daf@vars) (call-with-values (lambda () (let bf2dbb@f ((bf2db7@vars bf2daf@vars) (bf2db8@count '0)) (if (pair? bf2db7@vars) (bf2dbb@f (cdr bf2db7@vars) (+ bf2db8@count '1)) (if (null? bf2db7@vars) (values bf2db8@count '=) (values bf2db8@count '>=))))) (lambda (bf2dbd@bf2db4 bf2dbe@bf2db6) (let ((bf2dc1@pred bf2dbe@bf2db6) (bf2dc2@count bf2dbd@bf2db4)) (list (list 'primitive bf2dc1@pred) bf2dae@n (list 'quote bf2dc2@count))))))) (bf2d92@build-apply (lambda (bf2da5@ae bf2da6@g bf2da7@vars bf2da8@exp) (list '(primitive apply) (bf2d40@build-lambda bf2da5@ae bf2da7@vars bf2da8@exp) bf2da6@g))) (bf2d94@expand-case-lambda (lambda (bf2d95@ae bf2d96@vars bf2d97@exp*) (let ((bf2d9b@g (gensym)) (bf2d9c@n (gensym))) (list 'lambda bf2d9b@g (bf2d76@build-let bf2d95@ae (list bf2d9c@n) (list (list '(primitive length) bf2d9b@g)) (let bf2da3@f ((bf2d9f@vars* bf2d88@vars*) (bf2da0@exp* bf2d97@exp*)) (if (null? bf2d9f@vars*) (bf2d8e@build-error bf2d95@ae) (list 'if (bf2d90@build-pred bf2d95@ae bf2d9c@n (car bf2d9f@vars*)) (bf2d92@build-apply bf2d95@ae bf2d9b@g (car bf2d9f@vars*) (car bf2da0@exp*)) (bf2da3@f (cdr bf2d9f@vars*) (cdr bf2da0@exp*))))))))))) (if (= (length bf2d89@exp*) '1) (bf2d40@build-lambda bf2d87@ae (car bf2d88@vars*) (car bf2d89@exp*)) (bf2d94@expand-case-lambda bf2d87@ae bf2d88@vars* bf2d89@exp*))))) (set! bf2e0f@bf2d42@build-case-lambda bf2d42@build-case-lambda) (set! bf2d70@build-sequence (lambda (bf2dc7@ae bf2dc8@exps) (let bf2dcd@loop ((bf2dcb@exps bf2dc8@exps)) (if (null? (cdr bf2dcb@exps)) (car bf2dcb@exps) (if (equal? (car bf2dcb@exps) (bf2d72@build-void)) (bf2dcd@loop (cdr bf2dcb@exps)) (cons 'begin bf2dcb@exps)))))) (set! bf2e10@bf2d70@build-sequence bf2d70@build-sequence) (set! bf2d72@build-void (lambda () '((primitive void)))) (set! bf2e11@bf2d72@build-void bf2d72@build-void) (set! bf2d74@build-letrec (lambda (bf2dcf@ae bf2dd0@vars bf2dd1@val-exps bf2dd2@body-exp) (if (null? bf2dd0@vars) bf2dd2@body-exp (list 'letrec (map list bf2dd0@vars bf2dd1@val-exps) bf2dd2@body-exp)))) (set! bf2e12@bf2d74@build-letrec bf2d74@build-letrec) (set! bf2d76@build-let (lambda (bf2dd7@ae bf2dd8@vars bf2dd9@val-exps bf2dda@body-exp) (if (null? bf2dd8@vars) bf2dda@body-exp (list 'let (map list bf2dd8@vars bf2dd9@val-exps) bf2dda@body-exp)))) (set! bf2e13@bf2d76@build-let bf2d76@build-let) (set! bf2d78@build-named-let (lambda (bf2ddf@ae bf2de0@name bf2de1@vars bf2de2@val-exps bf2de3@body-exp) (list 'let bf2de0@name (map list bf2de1@vars bf2de2@val-exps) bf2de3@body-exp))) (set! bf2e14@bf2d78@build-named-let bf2d78@build-named-let) (set! bf2d7a@build-letrec* (lambda (bf2de9@ae bf2dea@vars bf2deb@val-exps bf2dec@body-exp) (if (null? bf2dea@vars) bf2dec@body-exp (list 'letrec* (map list bf2dea@vars bf2deb@val-exps) bf2dec@body-exp)))) (set! bf2e15@bf2d7a@build-letrec* bf2d7a@build-letrec*) (set! bf2d7c@build-library-letrec* (lambda (bf2df1@ae bf2df2@name bf2df3@vars bf2df4@locs bf2df5@val-exps bf2df6@body-exp) (cons 'begin (append (map (lambda (bf2dfd@var) (cons 'set! (cons bf2dfd@var '((unspecified))))) bf2df3@vars) (append (apply append (map (lambda (bf2dff@var bf2e00@loc bf2e01@val-exp) (list (list 'set! bf2dff@var bf2e01@val-exp) (list 'set! bf2e00@loc bf2dff@var))) bf2df3@vars bf2df4@locs bf2df5@val-exps)) (list bf2df6@body-exp)))))) (set! bf2e16@bf2d7c@build-library-letrec* bf2d7c@build-library-letrec*) (set! bf2d7e@build-receive (lambda (bf2e05@ae bf2e06@vars bf2e07@producer bf2e08@body*) (begin (display '"************** in ") (cons 'receive (cons bf2e06@vars (cons bf2e07@producer bf2e08@body*)))))) (set! bf2e17@bf2d7e@build-receive bf2d7e@build-receive) (void))
(begin (set! bf2e26@file-options-macro (unspecified)) (set! bf2e28@set-cons (unspecified)) (set! bf2e2a@set-union (unspecified)) (set! bf2e2f@top-mark* (unspecified)) (set! bf2e31@top-marked? (unspecified)) (set! bf2e33@gen-lexical (unspecified)) (set! bf2e35@gen-global (unspecified)) (set! bf2e37@gen-label (unspecified)) (set! bf2e39@gen-top-level-label (unspecified)) (set! bf2e3b@gen-define-label+loc (unspecified)) (set! bf2e3d@gen-define-label (unspecified)) (set! bf2e47@rib? (unspecified)) (set! bf2e49@rib-sym* (unspecified)) (set! bf2e4b@set-rib-sym*! (unspecified)) (set! bf2e4d@rib-mark** (unspecified)) (set! bf2e4f@set-rib-mark**! (unspecified)) (set! bf2e51@rib-label* (unspecified)) (set! bf2e53@set-rib-label*! (unspecified)) (set! bf2e55@rib-sealed/freq (unspecified)) (set! bf2e57@set-rib-sealed/freq! (unspecified)) (set! bf2e59@rib-cache (unspecified)) (set! bf2e5b@set-rib-cache! (unspecified)) (set! bf2e5d@dummy (unspecified)) (set! bf2e5f@make-empty-rib (unspecified)) (set! bf2e61@extend-rib! (unspecified)) (set! bf2e63@extend-rib/nc! (unspecified)) (set! bf2e65@make-rib-map (unspecified)) (set! bf2e67@seal-rib! (unspecified)) (set! bf2e69@unseal-rib! (unspecified)) (set! bf2e6b@make-full-rib (unspecified)) (set! bf2e6d@rp (unspecified)) (set! bf2e77@stx? (unspecified)) (set! bf2e79@stx-expr (unspecified)) (set! bf2e7b@set-stx-expr! (unspecified)) (set! bf2e7d@stx-mark* (unspecified)) (set! bf2e7f@set-stx-mark*! (unspecified)) (set! bf2e81@stx-subst* (unspecified)) (set! bf2e83@set-stx-subst*! (unspecified)) (set! bf2e85@stx-ae* (unspecified)) (set! bf2e87@set-stx-ae*! (unspecified)) (set! bf2e89@dummy (unspecified)) (set! bf2e8b@datum->stx (unspecified)) (set! bf2e8d@gen-mark (unspecified)) (set! bf2e8f@anti-mark (unspecified)) (set! bf2e91@anti-mark? (unspecified)) (set! bf2e93@mkstx (unspecified)) (set! bf2e95@add-subst (unspecified)) (set! bf2e97@add-mark (unspecified)) (set! bf2e99@syntax-kind? (unspecified)) (set! bf2e9b@syntax-vector->list (unspecified)) (set! bf2e9d@syntax-pair? (unspecified)) (set! bf2e9f@syntax-vector? (unspecified)) (set! bf2ea1@syntax-null? (unspecified)) (set! bf2ea3@syntax-list? (unspecified)) (set! bf2ea5@syntax-car (unspecified)) (set! bf2ea7@syntax-cdr (unspecified)) (set! bf2ea9@syntax->list (unspecified)) (set! bf2eab@id? (unspecified)) (set! bf2ead@id->sym (unspecified)) (set! bf2eaf@bound-id=? (unspecified)) (set! bf2eb1@free-id=? (unspecified)) (set! bf2eb3@valid-bound-ids? (unspecified)) (set! bf2eb5@distinct-bound-ids? (unspecified)) (set! bf2eb7@bound-id-member? (unspecified)) (set! bf2eb9@self-evaluating? (unspecified)) (set! bf2ebb@strip-annotations (unspecified)) (set! bf2ebd@strip (unspecified)) (set! bf2ebf@stx->datum (unspecified)) (set! bf2ec1@id->label (unspecified)) (set! bf2ec3@label->binding (unspecified)) (set! bf2ec5@make-binding (unspecified)) (set! bf2ec7@binding-type (unspecified)) (set! bf2ec9@binding-value (unspecified)) (set! bf2ecb@raise-unbound-error (unspecified)) (set! bf2ecd@syntax-type (unspecified)) (set! bf2edb@sanitize-binding (unspecified)) (set! bf2edd@make-variable-transformer (unspecified)) (set! bf2edf@variable-transformer? (unspecified)) (set! bf2ee1@variable-transformer-procedure (unspecified)) (set! bf2ee3@make-eval-transformer (unspecified)) (set! bf3034@parse-define (unspecified)) (set! bf3036@parse-define-syntax (unspecified)) (set! bf3038@scheme-stx-hashtable (unspecified)) (set! bf303a@scheme-stx (unspecified)) (set! bf303c@lexical-var (unspecified)) (set! bf303e@lexical-mutable? (unspecified)) (set! bf3040@set-lexical-mutable! (unspecified)) (set! bf3042@add-lexical (unspecified)) (set! bf3044@add-lexicals (unspecified)) (set! bf3046@letrec-helper (unspecified)) (set! bf3048@let-transformer (unspecified)) (set! bf304a@letrec-transformer (unspecified)) (set! bf304c@letrec*-transformer (unspecified)) (set! bf304e@fluid-let-syntax-transformer (unspecified)) (set! bf3050@type-descriptor-transformer (unspecified)) (set! bf3052@record-type-descriptor-transformer (unspecified)) (set! bf3054@record-constructor-descriptor-transformer (unspecified)) (set! bf3056@when-macro (unspecified)) (set! bf3058@unless-macro (unspecified)) (set! bf305a@if-transformer (unspecified)) (set! bf305c@and-transformer (unspecified)) (set! bf305e@or-transformer (unspecified)) (set! bf3060@case-macro (unspecified)) (set! bf3062@quote-transformer (unspecified)) (set! bf3064@case-lambda-transformer (unspecified)) (set! bf3066@lambda-transformer (unspecified)) (set! bf3068@bless (unspecified)) (set! bf306a@with-syntax-macro (unspecified)) (set! bf306c@invalid-fmls-error (unspecified)) (set! bf306e@let-macro (unspecified)) (set! bf3070@let-values-macro (unspecified)) (set! bf3072@let*-values-macro (unspecified)) (set! bf3074@trace-lambda-macro (unspecified)) (set! bf3076@trace-define-macro (unspecified)) (set! bf3078@trace-define-syntax-macro (unspecified)) (set! bf307a@trace-let/rec-syntax (unspecified)) (set! bf307c@trace-let-syntax-macro (unspecified)) (set! bf307e@trace-letrec-syntax-macro (unspecified)) (set! bf3080@guard-macro (unspecified)) (set! bf3082@define-enumeration-macro (unspecified)) (set! bf3084@time-macro (unspecified)) (set! bf3086@delay-macro (unspecified)) (set! bf3088@assert-macro (unspecified)) (set! bf308a@endianness-macro (unspecified)) (set! bf308c@identifier-syntax-macro (unspecified)) (set! bf308e@do-macro (unspecified)) (set! bf3090@let*-macro (unspecified)) (set! bf3092@or-macro (unspecified)) (set! bf3094@and-macro (unspecified)) (set! bf3096@cond-macro (unspecified)) (set! bf3098@do-include (unspecified)) (set! bf309a@include-macro (unspecified)) (set! bf309c@include-into-macro (unspecified)) (set! bf309e@syntax-rules-macro (unspecified)) (set! bf30a0@quasiquote-macro (unspecified)) (set! bf30a2@quasisyntax-macro (unspecified)) (set! bf30a4@define-struct-macro (unspecified)) (set! bf30a6@define-record-type-macro (unspecified)) (set! bf30a8@define-condition-type-macro (unspecified)) (set! bf30aa@incorrect-usage-macro (unspecified)) (set! bf30ac@parameterize-macro (unspecified)) (set! bf30ae@foreign-call-transformer (unspecified)) (set! bf30b0@convert-pattern (unspecified)) (set! bf30b2@syntax-dispatch (unspecified)) (set! bf30b4@ellipsis? (unspecified)) (set! bf30b6@underscore? (unspecified)) (set! bf30b8@verify-literals (unspecified)) (set! bf30ba@syntax-case-transformer (unspecified)) (set! bf30bc@ellipsis-map (unspecified)) (set! bf30be@syntax-transformer (unspecified)) (set! bf30c0@core-macro-transformer (unspecified)) (set! bf30c2@symbol-macro (unspecified)) (set! bf30c4@macro-transformer (unspecified)) (set! bf30c6@local-macro-transformer (unspecified)) (set! bf30c8@do-macro-call (unspecified)) (set! bf30ca@chi-macro (unspecified)) (set! bf30cc@chi-local-macro (unspecified)) (set! bf30ce@chi-global-macro (unspecified)) (set! bf30d0@chi-expr* (unspecified)) (set! bf30d2@chi-application (unspecified)) (set! bf30d4@chi-expr (unspecified)) (set! bf30d6@chi-set! (unspecified)) (set! bf30d8@verify-formals (unspecified)) (set! bf30da@chi-lambda-clause (unspecified)) (set! bf30dc@chi-lambda-clause* (unspecified)) (set! bf30de@chi-defun (unspecified)) (set! bf30e0@chi-rhs (unspecified)) (set! bf30e2@expand-interaction-rhs*/init* (unspecified)) (set! bf30e4@chi-rhs* (unspecified)) (set! bf30e6@find-bound=? (unspecified)) (set! bf30e8@find-dups (unspecified)) (set! bf30ea@chi-internal (unspecified)) (set! bf30ec@parse-module (unspecified)) (set! bf30f6@module-interface? (unspecified)) (set! bf30f8@module-interface-first-mark (unspecified)) (set! bf30fa@set-module-interface-first-mark! (unspecified)) (set! bf30fc@module-interface-exp-id-vec (unspecified)) (set! bf30fe@set-module-interface-exp-id-vec! (unspecified)) (set! bf3100@module-interface-exp-lab-vec (unspecified)) (set! bf3102@set-module-interface-exp-lab-vec! (unspecified)) (set! bf3104@dummy (unspecified)) (set! bf3106@module-interface-exp-id* (unspecified)) (set! bf3108@chi-internal-module (unspecified)) (set! bf310a@chi-body* (unspecified)) (set! bf310c@expand-transformer (unspecified)) (set! bf310e@parse-exports (unspecified)) (set! bf3110@parse-library-name (unspecified)) (set! bf3112@parse-library (unspecified)) (set! bf3114@parse-import-spec* (unspecified)) (set! bf3116@make-top-rib (unspecified)) (set! bf3118@make-collector (unspecified)) (set! bf311a@inv-collector (unspecified)) (set! bf311c@vis-collector (unspecified)) (set! bf311e@imp-collector (unspecified)) (set! bf3120@chi-library-internal (unspecified)) (set! bf3122@chi-interaction-expr (unspecified)) (set! bf3124@library-body-expander (unspecified)) (set! bf3126@core-library-expander (unspecified)) (set! bf3128@parse-top-level-program (unspecified)) (set! bf312a@top-level-expander (unspecified)) (set! bf312c@rp (unspecified)) (set! bf3136@env? (unspecified)) (set! bf3138@env-names (unspecified)) (set! bf313a@set-env-names! (unspecified)) (set! bf313c@env-labels (unspecified)) (set! bf313e@set-env-labels! (unspecified)) (set! bf3140@env-itc (unspecified)) (set! bf3142@set-env-itc! (unspecified)) (set! bf3144@dummy (unspecified)) (set! bf3146@rp (unspecified)) (set! bf3150@interaction-env? (unspecified)) (set! bf3152@interaction-env-rib (unspecified)) (set! bf3154@set-interaction-env-rib! (unspecified)) (set! bf3156@interaction-env-r (unspecified)) (set! bf3158@set-interaction-env-r! (unspecified)) (set! bf315a@interaction-env-locs (unspecified)) (set! bf315c@set-interaction-env-locs! (unspecified)) (set! bf315e@dummy (unspecified)) (set! bf3160@interaction-environment-symbols (unspecified)) (set! bf3162@environment-bindings (unspecified)) (set! bf3164@parse-binding (unspecified)) (set! bf3166@environment? (unspecified)) (set! bf3168@environment-symbols (unspecified)) (set! bf316a@environment (unspecified)) (set! bf316c@null-environment (unspecified)) (set! bf316e@scheme-report-environment (unspecified)) (set! bf3170@expand (unspecified)) (set! bf3172@eval (unspecified)) (set! bf3174@library-expander (unspecified)) (set! bf3176@boot-library-expand (unspecified)) (set! bf3178@rev-map-append (unspecified)) (set! bf317a@build-exports (unspecified)) (set! bf317c@make-export-subst (unspecified)) (set! bf317e@make-export-env/macros (unspecified)) (set! bf3180@generate-temporaries (unspecified)) (set! bf3182@free-identifier=? (unspecified)) (set! bf3184@bound-identifier=? (unspecified)) (set! bf3186@make-source-condition (unspecified)) (set! bf3188@extract-position-condition (unspecified)) (set! bf318a@expression-position (unspecified)) (set! bf318c@assertion-error (unspecified)) (set! bf318e@syntax-error (unspecified)) (set! bf3190@syntax-violation* (unspecified)) (set! bf3192@syntax-violation (unspecified)) (set! bf3194@identifier? (unspecified)) (set! bf3196@datum->syntax (unspecified)) (set! bf3198@syntax->datum (unspecified)) (set! bf319a@ungensym-all (unspecified)) (set! bf319c@compile-r6rs-top-level (unspecified)) (set! bf319e@pre-compile-r6rs-top-level (unspecified)) (set! bf31a0@interaction-environment (unspecified)) (set! bf31a2@top-level-context (unspecified)) (set! bf2e26@file-options-macro (lambda (bf31a3@x) (letrec* ((bf31a6@valid-option? (lambda (bf31af@x) (and (bf2eab@id? bf31af@x) (memq (bf2ead@id->sym bf31af@x) '(no-fail no-create no-truncate)))))) (let ((bf31a7@t bf31a3@x)) (let ((bf31a9@ls/false (bf30b2@syntax-dispatch bf31a7@t '(_ . each-any)))) (if (and bf31a9@ls/false (apply (lambda (bf31ab@opt*) (for-all bf31a6@valid-option? bf31ab@opt*)) bf31a9@ls/false)) (apply (lambda (bf31ad@opt*) (bf3068@bless (list 'make-file-options (list 'quote bf31ad@opt*)))) bf31a9@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf31a7@t))))))) (set! bf4b2f@bf2e26@file-options-macro bf2e26@file-options-macro) (set! bf2e28@set-cons (lambda (bf31b1@x bf31b2@ls) (if (memq bf31b1@x bf31b2@ls) bf31b2@ls (cons bf31b1@x bf31b2@ls)))) (set! bf4b30@bf2e28@set-cons bf2e28@set-cons) (set! bf2e2a@set-union (lambda (bf31b5@ls1 bf31b6@ls2) (if (null? bf31b5@ls1) bf31b6@ls2 (if (memq (car bf31b5@ls1) bf31b6@ls2) (bf2e2a@set-union (cdr bf31b5@ls1) bf31b6@ls2) (cons (car bf31b5@ls1) (bf2e2a@set-union (cdr bf31b5@ls1) bf31b6@ls2)))))) (set! bf4b31@bf2e2a@set-union bf2e2a@set-union) (set! bf2e2f@top-mark* '(top)) (set! bf4b32@bf2e2f@top-mark* bf2e2f@top-mark*) (set! bf2e31@top-marked? (lambda (bf31b9@m*) (memq 'top bf31b9@m*))) (set! bf4b33@bf2e31@top-marked? bf2e31@top-marked?) (set! bf2e33@gen-lexical (lambda (bf31bb@sym) (if (symbol? bf31bb@sym) (gensym bf31bb@sym) (if (bf2e77@stx? bf31bb@sym) (bf2e33@gen-lexical (bf2ead@id->sym bf31bb@sym)) (assertion-violation 'gen-lexical '"BUG: invalid arg" bf31bb@sym))))) (set! bf4b34@bf2e33@gen-lexical bf2e33@gen-lexical) (set! bf2e35@gen-global (lambda (bf31bd@x) (bf2e33@gen-lexical bf31bd@x))) (set! bf4b35@bf2e35@gen-global bf2e35@gen-global) (set! bf2e37@gen-label (lambda (bf31bf@_) (gensym))) (set! bf4b36@bf2e37@gen-label bf2e37@gen-label) (set! bf2e39@gen-top-level-label (lambda (bf31c1@id bf31c2@rib) (letrec* ((bf31c6@find (lambda (bf31d1@sym bf31d2@mark* bf31d3@sym* bf31d4@mark** bf31d5@label*) (and (pair? bf31d3@sym*) (if (and (eq? bf31d1@sym (car bf31d3@sym*)) (same-marks? bf31d2@mark* (car bf31d4@mark**))) (car bf31d5@label*) (bf31c6@find bf31d1@sym bf31d2@mark* (cdr bf31d3@sym*) (cdr bf31d4@mark**) (cdr bf31d5@label*))))))) (let ((bf31c7@sym (bf2ead@id->sym bf31c1@id)) (bf31c8@mark* (bf2e7d@stx-mark* bf31c1@id))) (let ((bf31cb@sym* (bf2e49@rib-sym* bf31c2@rib))) (let ((bf31cd@t (and (memq bf31c7@sym (bf2e49@rib-sym* bf31c2@rib)) (bf31c6@find bf31c7@sym bf31c8@mark* bf31cb@sym* (bf2e4d@rib-mark** bf31c2@rib) (bf2e51@rib-label* bf31c2@rib))))) (if bf31cd@t ((lambda (bf31cf@label) (if (bf2cc6@bf2b13@imported-label->binding bf31cf@label) (gensym) bf31cf@label)) bf31cd@t) (gensym)))))))) (set! bf4b37@bf2e39@gen-top-level-label bf2e39@gen-top-level-label) (set! bf2e3b@gen-define-label+loc (lambda (bf31db@id bf31dc@rib) (let ((bf31df@t (bf31a2@top-level-context))) (if bf31df@t ((lambda (bf31e1@env) (let ((bf31e3@label (bf2e39@gen-top-level-label bf31db@id bf31dc@rib)) (bf31e4@locs (bf315a@interaction-env-locs bf31e1@env))) (values bf31e3@label (let ((bf31e7@t (assq bf31e3@label bf31e4@locs))) (if bf31e7@t (cdr bf31e7@t) (let ((bf31e9@loc (bf2e33@gen-lexical bf31db@id))) (begin (bf315c@set-interaction-env-locs! bf31e1@env (cons (cons bf31e3@label bf31e9@loc) bf31e4@locs)) bf31e9@loc))))))) bf31df@t) (values (gensym) (bf2e33@gen-lexical bf31db@id)))))) (set! bf4b38@bf2e3b@gen-define-label+loc bf2e3b@gen-define-label+loc) (set! bf2e3d@gen-define-label (lambda (bf31eb@id bf31ec@rib) (if (bf31a2@top-level-context) (bf2e39@gen-top-level-label bf31eb@id bf31ec@rib) (gensym)))) (set! bf4b39@bf2e3d@gen-define-label bf2e3d@gen-define-label) (set! bf2e47@rib? (lambda (bf31ef@x) (and (simple-struct? bf31ef@x) (eq? (simple-struct-name bf31ef@x) 'rib)))) (set! bf4b3a@bf2e47@rib? bf2e47@rib?) (set! bf2e49@rib-sym* (lambda (bf31f1@x) (simple-struct-ref bf31f1@x '0))) (set! bf4b3b@bf2e49@rib-sym* bf2e49@rib-sym*) (set! bf2e4b@set-rib-sym*! (lambda (bf31f3@x bf31f4@val) (simple-struct-set! bf31f3@x '0 bf31f4@val))) (set! bf4b3c@bf2e4b@set-rib-sym*! bf2e4b@set-rib-sym*!) (set! bf2e4d@rib-mark** (lambda (bf31f7@x) (simple-struct-ref bf31f7@x '1))) (set! bf4b3d@bf2e4d@rib-mark** bf2e4d@rib-mark**) (set! bf2e4f@set-rib-mark**! (lambda (bf31f9@x bf31fa@val) (simple-struct-set! bf31f9@x '1 bf31fa@val))) (set! bf4b3e@bf2e4f@set-rib-mark**! bf2e4f@set-rib-mark**!) (set! bf2e51@rib-label* (lambda (bf31fd@x) (simple-struct-ref bf31fd@x '2))) (set! bf4b3f@bf2e51@rib-label* bf2e51@rib-label*) (set! bf2e53@set-rib-label*! (lambda (bf31ff@x bf3200@val) (simple-struct-set! bf31ff@x '2 bf3200@val))) (set! bf4b40@bf2e53@set-rib-label*! bf2e53@set-rib-label*!) (set! bf2e55@rib-sealed/freq (lambda (bf3203@x) (simple-struct-ref bf3203@x '3))) (set! bf4b41@bf2e55@rib-sealed/freq bf2e55@rib-sealed/freq) (set! bf2e57@set-rib-sealed/freq! (lambda (bf3205@x bf3206@val) (simple-struct-set! bf3205@x '3 bf3206@val))) (set! bf4b42@bf2e57@set-rib-sealed/freq! bf2e57@set-rib-sealed/freq!) (set! bf2e59@rib-cache (lambda (bf3209@x) (simple-struct-ref bf3209@x '4))) (set! bf4b43@bf2e59@rib-cache bf2e59@rib-cache) (set! bf2e5b@set-rib-cache! (lambda (bf320b@x bf320c@val) (simple-struct-set! bf320b@x '4 bf320c@val))) (set! bf4b44@bf2e5b@set-rib-cache! bf2e5b@set-rib-cache!) (set! bf2e5d@dummy '3) (set! bf4b45@bf2e5d@dummy bf2e5d@dummy) (set! bf2e5f@make-empty-rib (lambda () (make-simple-struct 'rib '6 (list '() '() '() '#f '#f)))) (set! bf4b46@bf2e5f@make-empty-rib bf2e5f@make-empty-rib) (set! bf2e61@extend-rib! (lambda (bf320f@rib bf3210@id bf3211@label) (letrec* ((bf3216@find (lambda (bf3223@sym bf3224@mark* bf3225@sym* bf3226@mark** bf3227@label*) (and (pair? bf3225@sym*) (if (and (eq? bf3223@sym (car bf3225@sym*)) (same-marks? bf3224@mark* (car bf3226@mark**))) bf3227@label* (bf3216@find bf3223@sym bf3224@mark* (cdr bf3225@sym*) (cdr bf3226@mark**) (cdr bf3227@label*))))))) (begin (if (bf2e55@rib-sealed/freq bf320f@rib) (assertion-violation 'extend-rib! '"BUG: rib is sealed" bf320f@rib) (void)) (let ((bf3217@sym (bf2ead@id->sym bf3210@id)) (bf3218@mark* (bf2e7d@stx-mark* bf3210@id))) (let ((bf321b@sym* (bf2e49@rib-sym* bf320f@rib))) (let ((bf321d@t (and (memq bf3217@sym (bf2e49@rib-sym* bf320f@rib)) (bf3216@find bf3217@sym bf3218@mark* bf321b@sym* (bf2e4d@rib-mark** bf320f@rib) (bf2e51@rib-label* bf320f@rib))))) (if bf321d@t ((lambda (bf321f@p) (if (not (eq? bf3211@label (car bf321f@p))) (if (bf31a2@top-level-context) (set-car! bf321f@p bf3211@label) (bf3192@syntax-violation '#f '"multiple definitions of identifier" bf3210@id)) (void))) bf321d@t) (begin (if (bf2e59@rib-cache bf320f@rib) (hashtable-update! (bf2e59@rib-cache bf320f@rib) bf3217@sym (lambda (bf3221@e) (cons (cons bf3218@mark* bf3211@label) bf3221@e)) '()) (void)) (bf2e4b@set-rib-sym*! bf320f@rib (cons bf3217@sym bf321b@sym*)) (bf2e4f@set-rib-mark**! bf320f@rib (cons bf3218@mark* (bf2e4d@rib-mark** bf320f@rib))) (bf2e53@set-rib-label*! bf320f@rib (cons bf3211@label (bf2e51@rib-label* bf320f@rib)))))))))))) (set! bf4b47@bf2e61@extend-rib! bf2e61@extend-rib!) (set! bf2e63@extend-rib/nc! (lambda (bf322d@rib bf322e@id bf322f@label) (let ((bf3233@sym (bf2ead@id->sym bf322e@id)) (bf3234@mark* (bf2e7d@stx-mark* bf322e@id))) (let ((bf3237@sym* (bf2e49@rib-sym* bf322d@rib))) (begin (if (bf2e59@rib-cache bf322d@rib) (hashtable-update! (bf2e59@rib-cache bf322d@rib) bf3233@sym (lambda (bf3239@e) (cons (cons bf3234@mark* bf322f@label) bf3239@e)) '()) (void)) (bf2e4b@set-rib-sym*! bf322d@rib (cons bf3233@sym bf3237@sym*)) (bf2e4f@set-rib-mark**! bf322d@rib (cons bf3234@mark* (bf2e4d@rib-mark** bf322d@rib))) (bf2e53@set-rib-label*! bf322d@rib (cons bf322f@label (bf2e51@rib-label* bf322d@rib)))))))) (set! bf4b48@bf2e63@extend-rib/nc! bf2e63@extend-rib/nc!) (set! bf2e65@make-rib-map (lambda (bf323b@sym*) (let ((bf323d@ht (make-eq-hashtable))) (let bf3243@f ((bf323f@i '0) (bf3240@sym* bf323b@sym*)) (if (null? bf3240@sym*) bf323d@ht (begin (hashtable-update! bf323d@ht (car bf3240@sym*) (lambda (bf3245@x) (cons bf323f@i bf3245@x)) '()) (bf3243@f (+ bf323f@i '1) (cdr bf3240@sym*)))))))) (set! bf4b49@bf2e65@make-rib-map bf2e65@make-rib-map) (set! bf2e67@seal-rib! (lambda (bf3247@rib) (let ((bf3249@sym* (bf2e49@rib-sym* bf3247@rib))) (if (not (null? bf3249@sym*)) (begin (bf2e4b@set-rib-sym*! bf3247@rib (list->vector bf3249@sym*)) (bf2e4f@set-rib-mark**! bf3247@rib (list->vector (bf2e4d@rib-mark** bf3247@rib))) (bf2e53@set-rib-label*! bf3247@rib (list->vector (bf2e51@rib-label* bf3247@rib))) (bf2e57@set-rib-sealed/freq! bf3247@rib (bf2e65@make-rib-map bf3249@sym*))) (void))))) (set! bf4b4a@bf2e67@seal-rib! bf2e67@seal-rib!) (set! bf2e69@unseal-rib! (lambda (bf324b@rib) (if (bf2e55@rib-sealed/freq bf324b@rib) (begin (bf2e57@set-rib-sealed/freq! bf324b@rib '#f) (bf2e4b@set-rib-sym*! bf324b@rib (vector->list (bf2e49@rib-sym* bf324b@rib))) (bf2e4f@set-rib-mark**! bf324b@rib (vector->list (bf2e4d@rib-mark** bf324b@rib))) (bf2e53@set-rib-label*! bf324b@rib (vector->list (bf2e51@rib-label* bf324b@rib)))) (void)))) (set! bf4b4b@bf2e69@unseal-rib! bf2e69@unseal-rib!) (set! bf2e6b@make-full-rib (lambda (bf324d@id* bf324e@label*) (let ((bf3251@r (make-simple-struct 'rib '6 (list (map bf2ead@id->sym bf324d@id*) (map bf2e7d@stx-mark* bf324d@id*) bf324e@label* '#f '#f)))) (begin (bf2e67@seal-rib! bf3251@r) bf3251@r)))) (set! bf4b4c@bf2e6b@make-full-rib bf2e6b@make-full-rib) (set! bf2e6d@rp (bf29f8@bf28d3@make-record-printer 'stx (lambda (bf3253@x bf3254@p bf3255@wr) (begin (display '"#<syntax " bf3254@p) (write (bf2ebf@stx->datum bf3253@x) bf3254@p) (let ((bf3259@expr (bf2e79@stx-expr bf3253@x))) (if (bf29ef@bf28c1@annotation? bf3259@expr) (let ((bf325b@src (bf29f0@bf28c3@annotation-source bf3259@expr))) (if (pair? bf325b@src) (begin (display '" [" bf3254@p) (display (cdr bf325b@src) bf3254@p) (display '" of " bf3254@p) (display (car bf325b@src) bf3254@p) (display '"]" bf3254@p)) (void))) (void))) (display '">" bf3254@p))))) (set! bf4b4d@bf2e6d@rp bf2e6d@rp) (set! bf2e77@stx? (lambda (bf325d@x) (and (simple-struct? bf325d@x) (eq? (simple-struct-name bf325d@x) 'stx)))) (set! bf4b4e@bf2e77@stx? bf2e77@stx?) (set! bf2e79@stx-expr (lambda (bf325f@x) (simple-struct-ref bf325f@x '0))) (set! bf4b4f@bf2e79@stx-expr bf2e79@stx-expr) (set! bf2e7b@set-stx-expr! (lambda (bf3261@x bf3262@val) (simple-struct-set! bf3261@x '0 bf3262@val))) (set! bf4b50@bf2e7b@set-stx-expr! bf2e7b@set-stx-expr!) (set! bf2e7d@stx-mark* (lambda (bf3265@x) (simple-struct-ref bf3265@x '1))) (set! bf4b51@bf2e7d@stx-mark* bf2e7d@stx-mark*) (set! bf2e7f@set-stx-mark*! (lambda (bf3267@x bf3268@val) (simple-struct-set! bf3267@x '1 bf3268@val))) (set! bf4b52@bf2e7f@set-stx-mark*! bf2e7f@set-stx-mark*!) (set! bf2e81@stx-subst* (lambda (bf326b@x) (simple-struct-ref bf326b@x '2))) (set! bf4b53@bf2e81@stx-subst* bf2e81@stx-subst*) (set! bf2e83@set-stx-subst*! (lambda (bf326d@x bf326e@val) (simple-struct-set! bf326d@x '2 bf326e@val))) (set! bf4b54@bf2e83@set-stx-subst*! bf2e83@set-stx-subst*!) (set! bf2e85@stx-ae* (lambda (bf3271@x) (simple-struct-ref bf3271@x '3))) (set! bf4b55@bf2e85@stx-ae* bf2e85@stx-ae*) (set! bf2e87@set-stx-ae*! (lambda (bf3273@x bf3274@val) (simple-struct-set! bf3273@x '3 bf3274@val))) (set! bf4b56@bf2e87@set-stx-ae*! bf2e87@set-stx-ae*!) (set! bf2e89@dummy '3) (set! bf4b57@bf2e89@dummy bf2e89@dummy) (set! bf2e8b@datum->stx (lambda (bf3277@id bf3278@datum) (make-simple-struct 'stx '5 (list bf3278@datum (bf2e7d@stx-mark* bf3277@id) (bf2e81@stx-subst* bf3277@id) (bf2e85@stx-ae* bf3277@id))))) (set! bf4b58@bf2e8b@datum->stx bf2e8b@datum->stx) (set! bf2e8d@gen-mark (lambda () (string '#\m))) (set! bf4b59@bf2e8d@gen-mark bf2e8d@gen-mark) (set! bf2e8f@anti-mark '#f) (set! bf4b5a@bf2e8f@anti-mark bf2e8f@anti-mark) (set! bf2e91@anti-mark? not) (set! bf4b5b@bf2e91@anti-mark? bf2e91@anti-mark?) (set! bf2e93@mkstx (lambda (bf327b@e bf327c@m* bf327d@s* bf327e@ae*) (if (and (bf2e77@stx? bf327b@e) (not (bf2e31@top-marked? bf327c@m*))) (call-with-values (lambda () (join-wraps bf327c@m* bf327d@s* bf327e@ae* bf327b@e)) (lambda (bf3289@bf3284 bf328a@bf3286 bf328b@bf3288) (let ((bf328f@ae* bf328b@bf3288) (bf3290@s* bf328a@bf3286) (bf3291@m* bf3289@bf3284)) (make-simple-struct 'stx '5 (list (bf2e79@stx-expr bf327b@e) bf3291@m* bf3290@s* bf328f@ae*))))) (make-simple-struct 'stx '5 (list bf327b@e bf327c@m* bf327d@s* bf327e@ae*))))) (set! bf4b5c@bf2e93@mkstx bf2e93@mkstx) (set! bf2e95@add-subst (lambda (bf3295@subst bf3296@e) (bf2e93@mkstx bf3296@e '() (list bf3295@subst) '()))) (set! bf4b5d@bf2e95@add-subst bf2e95@add-subst) (set! bf2e97@add-mark (lambda (bf3299@mark bf329a@subst bf329b@expr bf329c@ae) (letrec* ((bf32a2@merge-ae* (lambda (bf32c9@ls1 bf32ca@ls2) (if (and (pair? bf32c9@ls1) (pair? bf32ca@ls2) (not (car bf32ca@ls2))) (bf32a4@cancel bf32c9@ls1 bf32ca@ls2) (append bf32c9@ls1 bf32ca@ls2)))) (bf32a4@cancel (lambda (bf32bf@ls1 bf32c0@ls2) (let bf32c7@f ((bf32c3@x (car bf32bf@ls1)) (bf32c4@ls1 (cdr bf32bf@ls1))) (if (null? bf32c4@ls1) (cdr bf32c0@ls2) (cons bf32c3@x (bf32c7@f (car bf32c4@ls1) (cdr bf32c4@ls1))))))) (bf32a6@f (lambda (bf32a7@e bf32a8@m bf32a9@s1* bf32aa@ae*) (if (pair? bf32a7@e) (let ((bf32af@a (bf32a6@f (car bf32a7@e) bf32a8@m bf32a9@s1* bf32aa@ae*)) (bf32b0@d (bf32a6@f (cdr bf32a7@e) bf32a8@m bf32a9@s1* bf32aa@ae*))) (if (eq? bf32af@a bf32b0@d) bf32a7@e (cons bf32af@a bf32b0@d))) (if (vector? bf32a7@e) (let ((bf32b3@ls1 (vector->list bf32a7@e))) (let ((bf32b5@ls2 (map (lambda (bf32b7@x) (bf32a6@f bf32b7@x bf32a8@m bf32a9@s1* bf32aa@ae*)) bf32b3@ls1))) (if (for-all eq? bf32b3@ls1 bf32b5@ls2) bf32a7@e (list->vector bf32b5@ls2)))) (if (bf2e77@stx? bf32a7@e) (let ((bf32b9@m* (bf2e7d@stx-mark* bf32a7@e)) (bf32ba@s2* (bf2e81@stx-subst* bf32a7@e))) (if (null? bf32b9@m*) (bf32a6@f (bf2e79@stx-expr bf32a7@e) bf32a8@m (append bf32a9@s1* bf32ba@s2*) (bf32a2@merge-ae* bf32aa@ae* (bf2e85@stx-ae* bf32a7@e))) (if (eq? (car bf32b9@m*) bf2e8f@anti-mark) (make-simple-struct 'stx '5 (list (bf2e79@stx-expr bf32a7@e) (cdr bf32b9@m*) (cdr (append bf32a9@s1* bf32ba@s2*)) (bf32a2@merge-ae* bf32aa@ae* (bf2e85@stx-ae* bf32a7@e)))) (make-simple-struct 'stx '5 (list (bf2e79@stx-expr bf32a7@e) (cons bf32a8@m bf32b9@m*) (let ((bf32bd@s* (cons 'shift (append bf32a9@s1* bf32ba@s2*)))) (if bf329a@subst (cons bf329a@subst bf32bd@s*) bf32bd@s*)) (bf32a2@merge-ae* bf32aa@ae* (bf2e85@stx-ae* bf32a7@e))))))) (if (symbol? bf32a7@e) (bf3192@syntax-violation '#f '"raw symbol encountered in output of macro" bf329b@expr bf32a7@e) (make-simple-struct 'stx '5 (list bf32a7@e (list bf32a8@m) bf32a9@s1* bf32aa@ae*))))))))) (bf2e93@mkstx (bf32a6@f bf329b@expr bf3299@mark '() '()) '() '() (list bf329c@ae))))) (set! bf4b5e@bf2e97@add-mark bf2e97@add-mark) (set! bf2e99@syntax-kind? (lambda (bf32cd@x bf32ce@p?) (if (bf2e77@stx? bf32cd@x) (bf2e99@syntax-kind? (bf2e79@stx-expr bf32cd@x) bf32ce@p?) (if (bf29ef@bf28c1@annotation? bf32cd@x) (bf2e99@syntax-kind? (bf29f1@bf28c5@annotation-expression bf32cd@x) bf32ce@p?) (bf32ce@p? bf32cd@x))))) (set! bf4b5f@bf2e99@syntax-kind? bf2e99@syntax-kind?) (set! bf2e9b@syntax-vector->list (lambda (bf32d1@x) (if (bf2e77@stx? bf32d1@x) (let ((bf32d3@ls (bf2e9b@syntax-vector->list (bf2e79@stx-expr bf32d1@x))) (bf32d4@m* (bf2e7d@stx-mark* bf32d1@x)) (bf32d5@s* (bf2e81@stx-subst* bf32d1@x)) (bf32d6@ae* (bf2e85@stx-ae* bf32d1@x))) (map (lambda (bf32db@x) (bf2e93@mkstx bf32db@x bf32d4@m* bf32d5@s* bf32d6@ae*)) bf32d3@ls)) (if (bf29ef@bf28c1@annotation? bf32d1@x) (bf2e9b@syntax-vector->list (bf29f1@bf28c5@annotation-expression bf32d1@x)) (if (vector? bf32d1@x) (vector->list bf32d1@x) (assertion-violation 'syntax-vector->list '"BUG: not a syntax vector" bf32d1@x)))))) (set! bf4b60@bf2e9b@syntax-vector->list bf2e9b@syntax-vector->list) (set! bf2e9d@syntax-pair? (lambda (bf32dd@x) (bf2e99@syntax-kind? bf32dd@x pair?))) (set! bf4b61@bf2e9d@syntax-pair? bf2e9d@syntax-pair?) (set! bf2e9f@syntax-vector? (lambda (bf32df@x) (bf2e99@syntax-kind? bf32df@x vector?))) (set! bf4b62@bf2e9f@syntax-vector? bf2e9f@syntax-vector?) (set! bf2ea1@syntax-null? (lambda (bf32e1@x) (bf2e99@syntax-kind? bf32e1@x null?))) (set! bf4b63@bf2ea1@syntax-null? bf2ea1@syntax-null?) (set! bf2ea3@syntax-list? (lambda (bf32e3@x) (or (bf2ea1@syntax-null? bf32e3@x) (and (bf2e9d@syntax-pair? bf32e3@x) (bf2ea3@syntax-list? (bf2ea7@syntax-cdr bf32e3@x)))))) (set! bf4b64@bf2ea3@syntax-list? bf2ea3@syntax-list?) (set! bf2ea5@syntax-car (lambda (bf32e5@x) (if (bf2e77@stx? bf32e5@x) (bf2e93@mkstx (bf2ea5@syntax-car (bf2e79@stx-expr bf32e5@x)) (bf2e7d@stx-mark* bf32e5@x) (bf2e81@stx-subst* bf32e5@x) (bf2e85@stx-ae* bf32e5@x)) (if (bf29ef@bf28c1@annotation? bf32e5@x) (bf2ea5@syntax-car (bf29f1@bf28c5@annotation-expression bf32e5@x)) (if (pair? bf32e5@x) (car bf32e5@x) (assertion-violation 'syntax-car '"BUG: not a pair" bf32e5@x)))))) (set! bf4b65@bf2ea5@syntax-car bf2ea5@syntax-car) (set! bf2ea7@syntax-cdr (lambda (bf32e7@x) (if (bf2e77@stx? bf32e7@x) (bf2e93@mkstx (bf2ea7@syntax-cdr (bf2e79@stx-expr bf32e7@x)) (bf2e7d@stx-mark* bf32e7@x) (bf2e81@stx-subst* bf32e7@x) (bf2e85@stx-ae* bf32e7@x)) (if (bf29ef@bf28c1@annotation? bf32e7@x) (bf2ea7@syntax-cdr (bf29f1@bf28c5@annotation-expression bf32e7@x)) (if (pair? bf32e7@x) (cdr bf32e7@x) (assertion-violation 'syntax-cdr '"BUG: not a pair" bf32e7@x)))))) (set! bf4b66@bf2ea7@syntax-cdr bf2ea7@syntax-cdr) (set! bf2ea9@syntax->list (lambda (bf32e9@x) (if (bf2e9d@syntax-pair? bf32e9@x) (cons (bf2ea5@syntax-car bf32e9@x) (bf2ea9@syntax->list (bf2ea7@syntax-cdr bf32e9@x))) (if (bf2ea1@syntax-null? bf32e9@x) '() (assertion-violation 'syntax->list '"BUG: invalid argument" bf32e9@x))))) (set! bf4b67@bf2ea9@syntax->list bf2ea9@syntax->list) (set! bf2eab@id? (lambda (bf32eb@x) (and (bf2e77@stx? bf32eb@x) (symbol? (bf2e79@stx-expr bf32eb@x))))) (set! bf4b68@bf2eab@id? bf2eab@id?) (set! bf2ead@id->sym (lambda (bf32ed@x) (bf2e79@stx-expr bf32ed@x))) (set! bf4b69@bf2ead@id->sym bf2ead@id->sym) (set! bf2eaf@bound-id=? (lambda (bf32ef@x bf32f0@y) (and (eq? (bf2ead@id->sym bf32ef@x) (bf2ead@id->sym bf32f0@y)) (same-marks? (bf2e7d@stx-mark* bf32ef@x) (bf2e7d@stx-mark* bf32f0@y))))) (set! bf4b6a@bf2eaf@bound-id=? bf2eaf@bound-id=?) (set! bf2eb1@free-id=? (lambda (bf32f3@i bf32f4@j) (let ((bf32f7@t0 (id->real-label bf32f3@i)) (bf32f8@t1 (id->real-label bf32f4@j))) (if (or bf32f7@t0 bf32f8@t1) (eq? bf32f7@t0 bf32f8@t1) (eq? (bf2ead@id->sym bf32f3@i) (bf2ead@id->sym bf32f4@j)))))) (set! bf4b6b@bf2eb1@free-id=? bf2eb1@free-id=?) (set! bf2eb3@valid-bound-ids? (lambda (bf32fb@id*) (and (for-all bf2eab@id? bf32fb@id*) (bf2eb5@distinct-bound-ids? bf32fb@id*)))) (set! bf4b6c@bf2eb3@valid-bound-ids? bf2eb3@valid-bound-ids?) (set! bf2eb5@distinct-bound-ids? (lambda (bf32fd@id*) (or (null? bf32fd@id*) (and (not (bf2eb7@bound-id-member? (car bf32fd@id*) (cdr bf32fd@id*))) (bf2eb5@distinct-bound-ids? (cdr bf32fd@id*)))))) (set! bf4b6d@bf2eb5@distinct-bound-ids? bf2eb5@distinct-bound-ids?) (set! bf2eb7@bound-id-member? (lambda (bf32ff@id bf3300@id*) (and (pair? bf3300@id*) (or (bf2eaf@bound-id=? bf32ff@id (car bf3300@id*)) (bf2eb7@bound-id-member? bf32ff@id (cdr bf3300@id*)))))) (set! bf4b6e@bf2eb7@bound-id-member? bf2eb7@bound-id-member?) (set! bf2eb9@self-evaluating? (lambda (bf3303@x) (or (number? bf3303@x) (string? bf3303@x) (char? bf3303@x) (boolean? bf3303@x) (regexp? bf3303@x) (bytevector? bf3303@x)))) (set! bf4b6f@bf2eb9@self-evaluating? bf2eb9@self-evaluating?) (set! bf2ebb@strip-annotations (lambda (bf3305@x) (if (pair? bf3305@x) (cons (bf2ebb@strip-annotations (car bf3305@x)) (bf2ebb@strip-annotations (cdr bf3305@x))) (if (vector? bf3305@x) (vector-map bf2ebb@strip-annotations bf3305@x) (if (bf29ef@bf28c1@annotation? bf3305@x) (bf29ee@bf28bf@annotation-stripped bf3305@x) bf3305@x))))) (set! bf4b70@bf2ebb@strip-annotations bf2ebb@strip-annotations) (set! bf2ebd@strip (lambda (bf3307@x bf3308@m*) (if (bf2e31@top-marked? bf3308@m*) (if (or (bf29ef@bf28c1@annotation? bf3307@x) (and (pair? bf3307@x) (bf29ef@bf28c1@annotation? (car bf3307@x))) (and (vector? bf3307@x) (> (vector-length bf3307@x) '0) (bf29ef@bf28c1@annotation? (vector-ref bf3307@x '0)))) (bf2ebb@strip-annotations bf3307@x) bf3307@x) (let bf330d@f ((bf330b@x bf3307@x)) (if (bf2e77@stx? bf330b@x) (begin (if (pair? (bf2e79@stx-expr bf330b@x)) (begin (set-source-info! (bf2e79@stx-expr bf330b@x) '#f) (set-source-info! (cdr (bf2e79@stx-expr bf330b@x)) '#f) (set-source-info! (car (bf2e79@stx-expr bf330b@x)) '#f)) (void)) (bf2ebd@strip (bf2e79@stx-expr bf330b@x) (bf2e7d@stx-mark* bf330b@x))) (if (bf29ef@bf28c1@annotation? bf330b@x) (bf29ee@bf28bf@annotation-stripped bf330b@x) (if (pair? bf330b@x) (let ((bf330f@a (bf330d@f (car bf330b@x))) (bf3310@d (bf330d@f (cdr bf330b@x)))) (if (and (eq? bf330f@a (car bf330b@x)) (eq? bf3310@d (cdr bf330b@x))) bf330b@x (cons bf330f@a bf3310@d))) (if (vector? bf330b@x) (let ((bf3313@old (vector->list bf330b@x))) (let ((bf3315@new (map bf330d@f bf3313@old))) (if (for-all eq? bf3313@old bf3315@new) bf330b@x (list->vector bf3315@new)))) bf330b@x)))))))) (set! bf4b71@bf2ebd@strip bf2ebd@strip) (set! bf2ebf@stx->datum (lambda (bf3317@x) (bf2ebd@strip bf3317@x '()))) (set! bf4b72@bf2ebf@stx->datum bf2ebf@stx->datum) (set! bf2ec1@id->label (lambda (bf3319@id) (or (id->real-label bf3319@id) (let ((bf331b@t (bf31a2@top-level-context))) (if bf331b@t ((lambda (bf331d@env) (let ((bf331f@rib (bf3152@interaction-env-rib bf331d@env))) (call-with-values (lambda () (bf2e3b@gen-define-label+loc bf3319@id bf331f@rib)) (lambda (bf3325@bf3322 bf3326@bf3324) (let ((bf3329@loc_ bf3326@bf3324) (bf332a@lab bf3325@bf3322)) (begin (bf2e61@extend-rib! bf331f@rib bf3319@id bf332a@lab) bf332a@lab)))))) bf331b@t) '#f))))) (set! bf4b73@bf2ec1@id->label bf2ec1@id->label) (set! bf2ec3@label->binding (lambda (bf332d@x bf332e@r) (let ((bf3331@t (bf2cc6@bf2b13@imported-label->binding bf332d@x))) (if bf3331@t ((lambda (bf3333@b) (if (and (pair? bf3333@b) (eq? (car bf3333@b) '$core-rtd)) (cons '$rtd (map bf3068@bless (cdr bf3333@b))) (if (and (pair? bf3333@b) (eq? (car bf3333@b) 'global-rtd)) (let ((bf3335@lib (cadr bf3333@b)) (bf3336@loc (cddr bf3333@b))) (cons '$rtd (symbol-value bf3336@loc))) bf3333@b))) bf3331@t) (let ((bf3339@t (assq bf332d@x bf332e@r))) (if bf3339@t (cdr bf3339@t) (let ((bf333b@t (bf31a2@top-level-context))) (if bf333b@t ((lambda (bf333d@env) (let ((bf333f@t (assq bf332d@x (bf315a@interaction-env-locs bf333d@env)))) (if bf333f@t ((lambda (bf3341@p) (cons* 'lexical (cdr bf3341@p) '#f)) bf333f@t) '(displaced-lexical . #f)))) bf333b@t) '(displaced-lexical . #f))))))))) (set! bf4b74@bf2ec3@label->binding bf2ec3@label->binding) (set! bf2ec5@make-binding cons) (set! bf4b75@bf2ec5@make-binding bf2ec5@make-binding) (set! bf2ec7@binding-type car) (set! bf4b76@bf2ec7@binding-type bf2ec7@binding-type) (set! bf2ec9@binding-value cdr) (set! bf4b77@bf2ec9@binding-value bf2ec9@binding-value) (set! bf2ecb@raise-unbound-error (lambda (bf3343@id) (bf3190@syntax-violation* '#f '"unbound identifier" bf3343@id (make-undefined-violation)))) (set! bf4b78@bf2ecb@raise-unbound-error bf2ecb@raise-unbound-error) (set! bf2ecd@syntax-type (lambda (bf3345@e bf3346@r) (if (bf2eab@id? bf3345@e) (let ((bf3349@id bf3345@e)) (let ((bf334b@label (bf2ec1@id->label bf3349@id))) (let ((bf334d@b (bf2ec3@label->binding bf334b@label bf3346@r))) (let ((bf334f@type (bf2ec7@binding-type bf334d@b))) (begin (if (not bf334b@label) (bf2ecb@raise-unbound-error bf3349@id) (void)) (let ((bf3351@t bf334f@type)) (if (memv bf3351@t '(lexical core-prim macro macro! global local-macro local-macro! global-macro global-macro! displaced-lexical syntax import export $module $core-rtd library mutable)) (values bf334f@type (bf2ec9@binding-value bf334d@b) bf3349@id) (values 'other '#f '#f)))))))) (if (bf2e9d@syntax-pair? bf3345@e) (let ((bf3353@id (bf2ea5@syntax-car bf3345@e))) (if (bf2eab@id? bf3353@id) (let ((bf3355@label (bf2ec1@id->label bf3353@id))) (let ((bf3357@b (bf2ec3@label->binding bf3355@label bf3346@r))) (let ((bf3359@type (bf2ec7@binding-type bf3357@b))) (begin (if (not bf3355@label) (bf2ecb@raise-unbound-error bf3353@id) (void)) (let ((bf335b@t bf3359@type)) (if (memv bf335b@t '(define define-syntax core-macro begin macro macro! local-macro local-macro! global-macro global-macro! module library set! let-syntax letrec-syntax import export $core-rtd)) (values bf3359@type (bf2ec9@binding-value bf3357@b) bf3353@id) (values 'call '#f '#f))))))) (values 'call '#f '#f))) (let ((bf335d@d (bf2ebf@stx->datum bf3345@e))) (if (bf2eb9@self-evaluating? bf335d@d) (values 'constant bf335d@d '#f) (values 'other '#f '#f))))))) (set! bf4b79@bf2ecd@syntax-type bf2ecd@syntax-type) (set! bf2edb@sanitize-binding (lambda (bf335f@x bf3360@src) (if (procedure? bf335f@x) (cons* 'local-macro bf335f@x bf3360@src) (if (and (pair? bf335f@x) (eq? (car bf335f@x) 'macro!) (procedure? (cdr bf335f@x))) (cons* 'local-macro! (cdr bf335f@x) bf3360@src) (if (and (pair? bf335f@x) (eq? (car bf335f@x) '$rtd)) bf335f@x (assertion-violation 'expand '"invalid transformer" bf335f@x)))))) (set! bf4b7a@bf2edb@sanitize-binding bf2edb@sanitize-binding) (set! bf2edd@make-variable-transformer (lambda (bf3363@x) (if (procedure? bf3363@x) (cons 'macro! bf3363@x) (assertion-violation 'make-variable-transformer '"not a procedure" bf3363@x)))) (set! bf4b7b@bf2edd@make-variable-transformer bf2edd@make-variable-transformer) (set! bf2edf@variable-transformer? (lambda (bf3365@x) (and (pair? bf3365@x) (eq? (car bf3365@x) 'macro!) (procedure? (cdr bf3365@x))))) (set! bf4b7c@bf2edf@variable-transformer? bf2edf@variable-transformer?) (set! bf2ee1@variable-transformer-procedure (lambda (bf3367@x) (if (bf2edf@variable-transformer? bf3367@x) (cdr bf3367@x) (assertion-violation 'variable-transformer-procedure '"not a variable transformer" bf3367@x)))) (set! bf4b7d@bf2ee1@variable-transformer-procedure bf2ee1@variable-transformer-procedure) (set! bf2ee3@make-eval-transformer (lambda (bf3369@x) (bf2edb@sanitize-binding (eval-core (bf2a51@bf2a09@expanded->core bf3369@x)) bf3369@x))) (set! bf4b7e@bf2ee3@make-eval-transformer bf2ee3@make-eval-transformer) (set! bf3034@parse-define (lambda (bf336b@x) (let ((bf336d@t bf336b@x)) (let ((bf336f@ls/false (bf30b2@syntax-dispatch bf336d@t '(_ (any . any) any . each-any)))) (if (and bf336f@ls/false (apply (lambda (bf3371@id bf3372@fmls bf3373@b bf3374@b*) (bf2eab@id? bf3371@id)) bf336f@ls/false)) (apply (lambda (bf3379@id bf337a@fmls bf337b@b bf337c@b*) (begin (bf30d8@verify-formals bf337a@fmls bf336b@x) (values bf3379@id (cons 'defun (cons bf337a@fmls (cons bf337b@b bf337c@b*)))))) bf336f@ls/false) (let ((bf3381@t bf336d@t)) (let ((bf3383@ls/false (bf30b2@syntax-dispatch bf3381@t '(_ any any)))) (if (and bf3383@ls/false (apply (lambda (bf3385@id bf3386@val) (bf2eab@id? bf3385@id)) bf3383@ls/false)) (apply (lambda (bf3389@id bf338a@val) (values bf3389@id (cons 'expr bf338a@val))) bf3383@ls/false) (let ((bf338d@t bf3381@t)) (let ((bf338f@ls/false (bf30b2@syntax-dispatch bf338d@t '(_ any)))) (if (and bf338f@ls/false (apply (lambda (bf3391@id) (bf2eab@id? bf3391@id)) bf338f@ls/false)) (apply (lambda (bf3393@id) (values bf3393@id (cons 'expr (bf3068@bless '(void))))) bf338f@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf338d@t)))))))))))) (set! bf4b7f@bf3034@parse-define bf3034@parse-define) (set! bf3036@parse-define-syntax (lambda (bf3395@x) (let ((bf3397@t bf3395@x)) (let ((bf3399@ls/false (bf30b2@syntax-dispatch bf3397@t '(_ any any)))) (if (and bf3399@ls/false (apply (lambda (bf339b@id bf339c@val) (bf2eab@id? bf339b@id)) bf3399@ls/false)) (apply (lambda (bf339f@id bf33a0@val) (values bf339f@id bf33a0@val)) bf3399@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3397@t)))))) (set! bf4b80@bf3036@parse-define-syntax bf3036@parse-define-syntax) (set! bf3038@scheme-stx-hashtable (make-eq-hashtable)) (set! bf4b81@bf3038@scheme-stx-hashtable bf3038@scheme-stx-hashtable) (set! bf303a@scheme-stx (lambda (bf33a3@sym) (or (hashtable-ref bf3038@scheme-stx-hashtable bf33a3@sym '#f) (let ((bf33a5@subst (bf2ca2@bf2acb@library-subst (bf2cc0@bf2b07@find-library-by-name '(psyntax system $all))))) (let ((bf33a7@stx (make-simple-struct 'stx '5 (list bf33a3@sym bf2e2f@top-mark* '() '())))) (let ((bf33a9@stx (let ((bf33ab@t (assq bf33a3@sym bf33a5@subst))) (if bf33ab@t ((lambda (bf33ad@x) (let ((bf33af@name (car bf33ad@x)) (bf33b0@label (cdr bf33ad@x))) (bf2e95@add-subst (make-simple-struct 'rib '6 (list (list bf33af@name) (list bf2e2f@top-mark*) (list bf33b0@label) '#f '#f)) bf33a7@stx))) bf33ab@t) bf33a7@stx)))) (begin (hashtable-set! bf3038@scheme-stx-hashtable bf33a3@sym bf33a9@stx) bf33a9@stx))))))) (set! bf4b82@bf303a@scheme-stx bf303a@scheme-stx) (set! bf303c@lexical-var car) (set! bf4b83@bf303c@lexical-var bf303c@lexical-var) (set! bf303e@lexical-mutable? cdr) (set! bf4b84@bf303e@lexical-mutable? bf303e@lexical-mutable?) (set! bf3040@set-lexical-mutable! set-cdr!) (set! bf4b85@bf3040@set-lexical-mutable! bf3040@set-lexical-mutable!) (set! bf3042@add-lexical (lambda (bf33b3@lab bf33b4@lex bf33b5@r) (cons (cons* bf33b3@lab 'lexical bf33b4@lex '#f) bf33b5@r))) (set! bf4b86@bf3042@add-lexical bf3042@add-lexical) (set! bf3044@add-lexicals (lambda (bf33b9@lab* bf33ba@lex* bf33bb@r) (if (null? bf33b9@lab*) bf33bb@r (bf3044@add-lexicals (cdr bf33b9@lab*) (cdr bf33ba@lex*) (bf3042@add-lexical (car bf33b9@lab*) (car bf33ba@lex*) bf33bb@r))))) (set! bf4b87@bf3044@add-lexicals bf3044@add-lexicals) (set! bf3046@letrec-helper (lambda (bf33bf@e bf33c0@r bf33c1@mr bf33c2@build) (let ((bf33c7@t bf33bf@e)) (let ((bf33c9@ls/false (bf30b2@syntax-dispatch bf33c7@t '(_ #(each (any any)) any . each-any)))) (if bf33c9@ls/false (apply (lambda (bf33cb@lhs* bf33cc@rhs* bf33cd@b bf33ce@b*) (if (not (bf2eb3@valid-bound-ids? bf33cb@lhs*)) (bf306c@invalid-fmls-error bf33bf@e bf33cb@lhs*) (let ((bf33d3@lex* (map bf2e33@gen-lexical bf33cb@lhs*)) (bf33d4@lab* (map bf2e37@gen-label bf33cb@lhs*))) (let ((bf33d7@rib (bf2e6b@make-full-rib bf33cb@lhs* bf33d4@lab*)) (bf33d8@r (bf3044@add-lexicals bf33d4@lab* bf33d3@lex* bf33c0@r))) (let ((bf33db@body (bf30ea@chi-internal (bf2e95@add-subst bf33d7@rib (cons bf33cd@b bf33ce@b*)) bf33d8@r bf33c1@mr)) (bf33dc@rhs* (bf30d0@chi-expr* (map (lambda (bf33df@x) (bf2e95@add-subst bf33d7@rib bf33df@x)) bf33cc@rhs*) bf33d8@r bf33c1@mr))) (bf33c2@build '#f bf33d3@lex* bf33dc@rhs* bf33db@body)))))) bf33c9@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf33c7@t)))))) (set! bf4b88@bf3046@letrec-helper bf3046@letrec-helper) (set! bf3048@let-transformer (lambda (bf33e1@e bf33e2@r bf33e3@mr) (let ((bf33e7@t bf33e1@e)) (let ((bf33e9@ls/false (bf30b2@syntax-dispatch bf33e7@t '(_ #(each (any any)) any . each-any)))) (if bf33e9@ls/false (apply (lambda (bf33eb@lhs* bf33ec@rhs* bf33ed@b bf33ee@b*) (if (not (bf2eb3@valid-bound-ids? bf33eb@lhs*)) (bf306c@invalid-fmls-error bf33e1@e bf33eb@lhs*) (let ((bf33f3@lex* (map bf2e33@gen-lexical bf33eb@lhs*)) (bf33f4@lab* (map bf2e37@gen-label bf33eb@lhs*)) (bf33f5@rhs* (bf30d0@chi-expr* bf33ec@rhs* bf33e2@r bf33e3@mr))) (let ((bf33f9@rib (bf2e6b@make-full-rib bf33eb@lhs* bf33f4@lab*)) (bf33fa@r (bf3044@add-lexicals bf33f4@lab* bf33f3@lex* bf33e2@r))) (let ((bf33fd@body (bf30ea@chi-internal (bf2e95@add-subst bf33f9@rib (cons bf33ed@b bf33ee@b*)) bf33fa@r bf33e3@mr))) (bf2e13@bf2d76@build-let '#f bf33f3@lex* bf33f5@rhs* bf33fd@body)))))) bf33e9@ls/false) (let ((bf33ff@t bf33e7@t)) (let ((bf3401@ls/false (bf30b2@syntax-dispatch bf33ff@t '(_ any #(each (any any)) any . each-any)))) (if bf3401@ls/false (apply (lambda (bf3403@loop bf3404@lhs* bf3405@rhs* bf3406@b bf3407@b*) (if (not (bf2eb3@valid-bound-ids? bf3404@lhs*)) (bf306c@invalid-fmls-error bf33e1@e bf3404@lhs*) (let ((bf340d@lex* (map bf2e33@gen-lexical bf3404@lhs*)) (bf340e@lab* (map bf2e37@gen-label bf3404@lhs*)) (bf340f@rhs* (bf30d0@chi-expr* bf3405@rhs* bf33e2@r bf33e3@mr)) (bf3410@loop-lex (bf2e33@gen-lexical bf3403@loop)) (bf3411@loop-lab (bf2e37@gen-label bf3403@loop))) (let ((bf3417@loop-rib (bf2e6b@make-full-rib (list bf3403@loop) (list bf3411@loop-lab))) (bf3418@rib (bf2e6b@make-full-rib bf3404@lhs* bf340e@lab*)) (bf3419@r (bf3044@add-lexicals (cons bf3411@loop-lab bf340e@lab*) (cons bf3410@loop-lex bf340d@lex*) bf33e2@r))) (let ((bf341d@body (bf30ea@chi-internal (bf2e95@add-subst bf3417@loop-rib (bf2e95@add-subst bf3418@rib (cons bf3406@b bf3407@b*))) bf3419@r bf33e3@mr))) (bf2e14@bf2d78@build-named-let '#f bf3410@loop-lex bf340d@lex* bf340f@rhs* bf341d@body)))))) bf3401@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf33ff@t))))))))) (set! bf4b89@bf3048@let-transformer bf3048@let-transformer) (set! bf304a@letrec-transformer (lambda (bf341f@e bf3420@r bf3421@mr) (bf3046@letrec-helper bf341f@e bf3420@r bf3421@mr bf2e12@bf2d74@build-letrec))) (set! bf4b8a@bf304a@letrec-transformer bf304a@letrec-transformer) (set! bf304c@letrec*-transformer (lambda (bf3425@e bf3426@r bf3427@mr) (bf3046@letrec-helper bf3425@e bf3426@r bf3427@mr bf2e15@bf2d7a@build-letrec*))) (set! bf4b8b@bf304c@letrec*-transformer bf304c@letrec*-transformer) (set! bf304e@fluid-let-syntax-transformer (lambda (bf342b@e bf342c@r bf342d@mr) (letrec* ((bf3432@lookup (lambda (bf3445@x) (or (bf2ec1@id->label bf3445@x) (bf3192@syntax-violation '#f '"unbound identifier" bf342b@e bf3445@x))))) (let ((bf3433@t bf342b@e)) (let ((bf3435@ls/false (bf30b2@syntax-dispatch bf3433@t '(_ #(each (any any)) any . each-any)))) (if bf3435@ls/false (apply (lambda (bf3437@lhs* bf3438@rhs* bf3439@b bf343a@b*) (if (not (bf2eb3@valid-bound-ids? bf3437@lhs*)) (bf306c@invalid-fmls-error bf342b@e bf3437@lhs*) (let ((bf343f@lab* (map bf3432@lookup bf3437@lhs*)) (bf3440@rhs* (map (lambda (bf3443@x) (bf2ee3@make-eval-transformer (bf310c@expand-transformer bf3443@x bf342d@mr))) bf3438@rhs*))) (bf30ea@chi-internal (cons bf3439@b bf343a@b*) (append (map cons bf343f@lab* bf3440@rhs*) bf342c@r) (append (map cons bf343f@lab* bf3440@rhs*) bf342d@mr))))) bf3435@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3433@t))))))) (set! bf4b8c@bf304e@fluid-let-syntax-transformer bf304e@fluid-let-syntax-transformer) (set! bf3050@type-descriptor-transformer (lambda (bf3447@e bf3448@r bf3449@mr) (let ((bf344d@t bf3447@e)) (let ((bf344f@ls/false (bf30b2@syntax-dispatch bf344d@t '(_ any)))) (if (and bf344f@ls/false (apply (lambda (bf3451@id) (bf2eab@id? bf3451@id)) bf344f@ls/false)) (apply (lambda (bf3453@id) (let ((bf3455@lab (bf2ec1@id->label bf3453@id))) (let ((bf3457@b (bf2ec3@label->binding bf3455@lab bf3448@r))) (let ((bf3459@type (bf2ec7@binding-type bf3457@b))) (begin (if (not bf3455@lab) (bf2ecb@raise-unbound-error bf3453@id) (void)) (if (not (and (eq? bf3459@type '$rtd) (not (list? (bf2ec9@binding-value bf3457@b))))) (bf3192@syntax-violation '#f '"not a record type" bf3447@e) (void)) (list 'quote (bf2ec9@binding-value bf3457@b))))))) bf344f@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf344d@t)))))) (set! bf4b8d@bf3050@type-descriptor-transformer bf3050@type-descriptor-transformer) (set! bf3052@record-type-descriptor-transformer (lambda (bf345b@e bf345c@r bf345d@mr) (let ((bf3461@t bf345b@e)) (let ((bf3463@ls/false (bf30b2@syntax-dispatch bf3461@t '(_ any)))) (if (and bf3463@ls/false (apply (lambda (bf3465@id) (bf2eab@id? bf3465@id)) bf3463@ls/false)) (apply (lambda (bf3467@id) (let ((bf3469@lab (bf2ec1@id->label bf3467@id))) (let ((bf346b@b (bf2ec3@label->binding bf3469@lab bf345c@r))) (let ((bf346d@type (bf2ec7@binding-type bf346b@b))) (begin (if (not bf3469@lab) (bf2ecb@raise-unbound-error bf3467@id) (void)) (if (not (and (eq? bf346d@type '$rtd) (list? (bf2ec9@binding-value bf346b@b)))) (bf3192@syntax-violation '#f '"not a record type" bf345b@e) (void)) (bf30d4@chi-expr (car (bf2ec9@binding-value bf346b@b)) bf345c@r bf345d@mr)))))) bf3463@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3461@t)))))) (set! bf4b8e@bf3052@record-type-descriptor-transformer bf3052@record-type-descriptor-transformer) (set! bf3054@record-constructor-descriptor-transformer (lambda (bf346f@e bf3470@r bf3471@mr) (let ((bf3475@t bf346f@e)) (let ((bf3477@ls/false (bf30b2@syntax-dispatch bf3475@t '(_ any)))) (if (and bf3477@ls/false (apply (lambda (bf3479@id) (bf2eab@id? bf3479@id)) bf3477@ls/false)) (apply (lambda (bf347b@id) (let ((bf347d@lab (bf2ec1@id->label bf347b@id))) (let ((bf347f@b (bf2ec3@label->binding bf347d@lab bf3470@r))) (let ((bf3481@type (bf2ec7@binding-type bf347f@b))) (begin (if (not bf347d@lab) (bf2ecb@raise-unbound-error bf347b@id) (void)) (if (not (and (eq? bf3481@type '$rtd) (list? (bf2ec9@binding-value bf347f@b)))) (bf3192@syntax-violation '#f '"invalid type" bf346f@e) (void)) (bf30d4@chi-expr (cadr (bf2ec9@binding-value bf347f@b)) bf3470@r bf3471@mr)))))) bf3477@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3475@t)))))) (set! bf4b8f@bf3054@record-constructor-descriptor-transformer bf3054@record-constructor-descriptor-transformer) (set! bf3056@when-macro (lambda (bf3483@e) (let ((bf3485@t bf3483@e)) (let ((bf3487@ls/false (bf30b2@syntax-dispatch bf3485@t '(_ any any . each-any)))) (if bf3487@ls/false (apply (lambda (bf3489@test bf348a@e bf348b@e*) (bf3068@bless (list 'if bf3489@test (cons 'begin (cons bf348a@e bf348b@e*))))) bf3487@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3485@t)))))) (set! bf4b90@bf3056@when-macro bf3056@when-macro) (set! bf3058@unless-macro (lambda (bf348f@e) (let ((bf3491@t bf348f@e)) (let ((bf3493@ls/false (bf30b2@syntax-dispatch bf3491@t '(_ any any . each-any)))) (if bf3493@ls/false (apply (lambda (bf3495@test bf3496@e bf3497@e*) (bf3068@bless (list 'if (list 'not bf3495@test) (cons 'begin (cons bf3496@e bf3497@e*))))) bf3493@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3491@t)))))) (set! bf4b91@bf3058@unless-macro bf3058@unless-macro) (set! bf305a@if-transformer (lambda (bf349b@e bf349c@r bf349d@mr) (let ((bf34a1@t bf349b@e)) (let ((bf34a3@ls/false (bf30b2@syntax-dispatch bf34a1@t '(_ any any any)))) (if bf34a3@ls/false (apply (lambda (bf34a5@e0 bf34a6@e1 bf34a7@e2) (list 'if (bf30d4@chi-expr bf34a5@e0 bf349c@r bf349d@mr) (bf30d4@chi-expr bf34a6@e1 bf349c@r bf349d@mr) (bf30d4@chi-expr bf34a7@e2 bf349c@r bf349d@mr))) bf34a3@ls/false) (let ((bf34ab@t bf34a1@t)) (let ((bf34ad@ls/false (bf30b2@syntax-dispatch bf34ab@t '(_ any any)))) (if bf34ad@ls/false (apply (lambda (bf34af@e0 bf34b0@e1) (list 'if (bf30d4@chi-expr bf34af@e0 bf349c@r bf349d@mr) (bf30d4@chi-expr bf34b0@e1 bf349c@r bf349d@mr) (bf2e11@bf2d72@build-void))) bf34ad@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf34ab@t))))))))) (set! bf4b92@bf305a@if-transformer bf305a@if-transformer) (set! bf305c@and-transformer (lambda (bf34b3@e bf34b4@r bf34b5@mr) (let ((bf34b9@t bf34b3@e)) (let ((bf34bb@ls/false (bf30b2@syntax-dispatch bf34b9@t '(_ . each-any)))) (if bf34bb@ls/false (apply (lambda (bf34bd@e*) (cons 'and (bf30d0@chi-expr* bf34bd@e* bf34b4@r bf34b5@mr))) bf34bb@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf34b9@t)))))) (set! bf4b93@bf305c@and-transformer bf305c@and-transformer) (set! bf305e@or-transformer (lambda (bf34bf@e bf34c0@r bf34c1@mr) (let ((bf34c5@t bf34bf@e)) (let ((bf34c7@ls/false (bf30b2@syntax-dispatch bf34c5@t '(_ . each-any)))) (if bf34c7@ls/false (apply (lambda (bf34c9@e*) (cons 'or (bf30d0@chi-expr* bf34c9@e* bf34c0@r bf34c1@mr))) bf34c7@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf34c5@t)))))) (set! bf4b94@bf305e@or-transformer bf305e@or-transformer) (set! bf3060@case-macro (lambda (bf34cb@e) (letrec* ((bf34ce@build-last (lambda (bf34f5@cls) (let ((bf34f7@t bf34f5@cls)) (let ((bf34f9@ls/false (bf30b2@syntax-dispatch bf34f7@t '(#(scheme-id else) any . each-any)))) (if bf34f9@ls/false (apply (lambda (bf34fb@e bf34fc@e*) (cons 'begin (cons bf34fb@e bf34fc@e*))) bf34f9@ls/false) (let ((bf34ff@t bf34f7@t)) (let ((bf3501@ls/false (bf30b2@syntax-dispatch bf34ff@t '_))) (if bf3501@ls/false (apply (lambda () (bf34d0@build-one bf34f5@cls '(if #f #f))) bf3501@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf34ff@t))))))))) (bf34d0@build-one (lambda (bf34e7@cls bf34e8@k) (let ((bf34eb@t bf34e7@cls)) (let ((bf34ed@ls/false (bf30b2@syntax-dispatch bf34eb@t '(each-any any . each-any)))) (if bf34ed@ls/false (apply (lambda (bf34ef@d* bf34f0@e bf34f1@e*) (list 'if (list 'memv 't (list 'quote bf34ef@d*)) (cons 'begin (cons bf34f0@e bf34f1@e*)) bf34e8@k)) bf34ed@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf34eb@t))))))) (let ((bf34d1@t bf34cb@e)) (let ((bf34d3@ls/false (bf30b2@syntax-dispatch bf34d1@t '(_ any)))) (if bf34d3@ls/false (apply (lambda (bf34d5@expr) (bf3068@bless (cons 'let (cons (list (list 't bf34d5@expr)) '((if #f #f)))))) bf34d3@ls/false) (let ((bf34d7@t bf34d1@t)) (let ((bf34d9@ls/false (bf30b2@syntax-dispatch bf34d7@t '(_ any any . each-any)))) (if bf34d9@ls/false (apply (lambda (bf34db@expr bf34dc@cls bf34dd@cls*) (bf3068@bless (list 'let (list (list 't bf34db@expr)) (let bf34e5@f ((bf34e1@cls bf34dc@cls) (bf34e2@cls* bf34dd@cls*)) (if (null? bf34e2@cls*) (bf34ce@build-last bf34e1@cls) (bf34d0@build-one bf34e1@cls (bf34e5@f (car bf34e2@cls*) (cdr bf34e2@cls*)))))))) bf34d9@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf34d7@t)))))))))) (set! bf4b95@bf3060@case-macro bf3060@case-macro) (set! bf3062@quote-transformer (lambda (bf3503@e bf3504@r bf3505@mr) (let ((bf3509@t bf3503@e)) (let ((bf350b@ls/false (bf30b2@syntax-dispatch bf3509@t '(_ any)))) (if bf350b@ls/false (apply (lambda (bf350d@datum) (list 'quote (bf2ebf@stx->datum bf350d@datum))) bf350b@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3509@t)))))) (set! bf4b96@bf3062@quote-transformer bf3062@quote-transformer) (set! bf3064@case-lambda-transformer (lambda (bf350f@e bf3510@r bf3511@mr) (let ((bf3515@t bf350f@e)) (let ((bf3517@ls/false (bf30b2@syntax-dispatch bf3515@t '(_ . #(each (any any . each-any)))))) (if bf3517@ls/false (apply (lambda (bf3519@fmls* bf351a@b* bf351b@b**) (call-with-values (lambda () (bf30dc@chi-lambda-clause* bf350f@e bf3519@fmls* (map cons bf351a@b* bf351b@b**) bf3510@r bf3511@mr)) (lambda (bf3523@bf3520 bf3524@bf3522) (let ((bf3527@body* bf3524@bf3522) (bf3528@fmls* bf3523@bf3520)) (bf2e0f@bf2d42@build-case-lambda '#f bf3528@fmls* bf3527@body*))))) bf3517@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3515@t)))))) (set! bf4b97@bf3064@case-lambda-transformer bf3064@case-lambda-transformer) (set! bf3066@lambda-transformer (lambda (bf352b@e bf352c@r bf352d@mr) (let ((bf3531@t bf352b@e)) (let ((bf3533@ls/false (bf30b2@syntax-dispatch bf3531@t '(_ any any . each-any)))) (if bf3533@ls/false (apply (lambda (bf3535@fmls bf3536@b bf3537@b*) (call-with-values (lambda () (bf30da@chi-lambda-clause bf352b@e bf3535@fmls (cons bf3536@b bf3537@b*) bf352c@r bf352d@mr)) (lambda (bf353f@bf353c bf3540@bf353e) (let ((bf3543@body bf3540@bf353e) (bf3544@fmls bf353f@bf353c)) (bf2e0e@bf2d40@build-lambda '#f bf3544@fmls bf3543@body))))) bf3533@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3531@t)))))) (set! bf4b98@bf3066@lambda-transformer bf3066@lambda-transformer) (set! bf3068@bless (lambda (bf3547@x) (bf2e93@mkstx (let bf354b@f ((bf3549@x bf3547@x)) (if (bf2e77@stx? bf3549@x) bf3549@x (if (pair? bf3549@x) (cons (bf354b@f (car bf3549@x)) (bf354b@f (cdr bf3549@x))) (if (symbol? bf3549@x) (bf303a@scheme-stx bf3549@x) (if (vector? bf3549@x) (vector-map bf354b@f bf3549@x) bf3549@x))))) '() '() '()))) (set! bf4b99@bf3068@bless bf3068@bless) (set! bf306a@with-syntax-macro (lambda (bf354d@e) (let ((bf354f@t bf354d@e)) (let ((bf3551@ls/false (bf30b2@syntax-dispatch bf354f@t '(_ #(each (any any)) any . each-any)))) (if bf3551@ls/false (apply (lambda (bf3553@pat* bf3554@expr* bf3555@b bf3556@b*) (let ((bf355b@idn* (let bf355f@f ((bf355d@pat* bf3553@pat*)) (if (null? bf355d@pat*) '() (call-with-values (lambda () (bf30b0@convert-pattern (car bf355d@pat*) '())) (lambda (bf3565@bf3562 bf3566@bf3564) (let ((bf3569@idn* bf3566@bf3564) (bf356a@pat bf3565@bf3562)) (append bf3569@idn* (bf355f@f (cdr bf355d@pat*)))))))))) (begin (bf30d8@verify-formals (map car bf355b@idn*) bf354d@e) (let ((bf356d@t* (bf3180@generate-temporaries bf3554@expr*))) (bf3068@bless (list 'let (map list bf356d@t* bf3554@expr*) (let bf3573@f ((bf356f@pat* bf3553@pat*) (bf3570@t* bf356d@t*)) (if (null? bf356f@pat*) (cons 'let (cons '() (cons bf3555@b bf3556@b*))) (list 'syntax-case (car bf3570@t*) '() (list (car bf356f@pat*) (bf3573@f (cdr bf356f@pat*) (cdr bf3570@t*))) (list '_ (list 'assertion-violation ''with-syntax '"pattern does not match value" (list 'quote (car bf356f@pat*)) (car bf3570@t*)))))))))))) bf3551@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf354f@t)))))) (set! bf4b9a@bf306a@with-syntax-macro bf306a@with-syntax-macro) (set! bf306c@invalid-fmls-error (lambda (bf3575@stx bf3576@fmls) (let ((bf3579@t bf3576@fmls)) (let ((bf357b@ls/false (bf30b2@syntax-dispatch bf3579@t '#(each+ any () any)))) (if bf357b@ls/false (apply (lambda (bf357d@id* bf357e@last) (let bf3583@f ((bf3581@id* (if (bf2eab@id? bf357e@last) (cons bf357e@last bf357d@id*) (if (bf2ea1@syntax-null? bf357e@last) bf357d@id* (bf3192@syntax-violation '#f '"not an identifier" bf3575@stx bf357e@last))))) (if (null? bf3581@id*) (values) (if (not (bf2eab@id? (car bf3581@id*))) (bf3192@syntax-violation '#f '"not an identifier" bf3575@stx (car bf3581@id*)) (begin (bf3583@f (cdr bf3581@id*)) (if (bf2eb7@bound-id-member? (car bf3581@id*) (cdr bf3581@id*)) (bf3192@syntax-violation '#f '"duplicate binding" bf3575@stx (car bf3581@id*)) (void))))))) bf357b@ls/false) (let ((bf3585@t bf3579@t)) (let ((bf3587@ls/false (bf30b2@syntax-dispatch bf3585@t '_))) (if bf3587@ls/false (apply (lambda () (bf3192@syntax-violation '#f '"malformed binding form" bf3575@stx bf3576@fmls)) bf3587@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3585@t))))))))) (set! bf4b9b@bf306c@invalid-fmls-error bf306c@invalid-fmls-error) (set! bf306e@let-macro (lambda (bf3589@stx) (let ((bf358b@t bf3589@stx)) (let ((bf358d@ls/false (bf30b2@syntax-dispatch bf358b@t '(_ #(each (any any)) any . each-any)))) (if bf358d@ls/false (apply (lambda (bf358f@lhs* bf3590@rhs* bf3591@b bf3592@b*) (if (bf2eb3@valid-bound-ids? bf358f@lhs*) (bf3068@bless (cons (cons 'lambda (cons bf358f@lhs* (cons bf3591@b bf3592@b*))) bf3590@rhs*)) (bf306c@invalid-fmls-error bf3589@stx bf358f@lhs*))) bf358d@ls/false) (let ((bf3597@t bf358b@t)) (let ((bf3599@ls/false (bf30b2@syntax-dispatch bf3597@t '(_ any #(each (any any)) any . each-any)))) (if (and bf3599@ls/false (apply (lambda (bf359b@f bf359c@lhs* bf359d@rhs* bf359e@b bf359f@b*) (bf2eab@id? bf359b@f)) bf3599@ls/false)) (apply (lambda (bf35a5@f bf35a6@lhs* bf35a7@rhs* bf35a8@b bf35a9@b*) (if (bf2eb3@valid-bound-ids? bf35a6@lhs*) (bf3068@bless (cons (list 'letrec (list (list bf35a5@f (cons 'lambda (cons bf35a6@lhs* (cons bf35a8@b bf35a9@b*))))) bf35a5@f) bf35a7@rhs*)) (bf306c@invalid-fmls-error bf3589@stx bf35a6@lhs*))) bf3599@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3597@t))))))))) (set! bf4b9c@bf306e@let-macro bf306e@let-macro) (set! bf3070@let-values-macro (lambda (bf35af@stx) (letrec* ((bf35b2@rename (lambda (bf3617@x bf3618@old* bf3619@new*) (begin (if (not (bf2eab@id? bf3617@x)) (bf3192@syntax-violation '#f '"not an indentifier" bf35af@stx bf3617@x) (void)) (if (bf2eb7@bound-id-member? bf3617@x bf3618@old*) (bf3192@syntax-violation '#f '"duplicate binding" bf35af@stx bf3617@x) (void)) (let ((bf361d@y (gensym (bf3198@syntax->datum bf3617@x)))) (values bf361d@y (cons bf3617@x bf3618@old*) (cons bf361d@y bf3619@new*)))))) (bf35b4@rename* (lambda (bf3605@x* bf3606@old* bf3607@new*) (if (null? bf3605@x*) (values '() bf3606@old* bf3607@new*) (call-with-values (lambda () (bf35b2@rename (car bf3605@x*) bf3606@old* bf3607@new*)) (lambda (bf360b@x bf360c@old* bf360d@new*) (call-with-values (lambda () (bf35b4@rename* (cdr bf3605@x*) bf360c@old* bf360d@new*)) (lambda (bf3611@x* bf3612@old* bf3613@new*) (values (cons bf360b@x bf3611@x*) bf3612@old* bf3613@new*))))))))) (let ((bf35b5@t bf35af@stx)) (let ((bf35b7@ls/false (bf30b2@syntax-dispatch bf35b5@t '(_ () any . each-any)))) (if bf35b7@ls/false (apply (lambda (bf35b9@b bf35ba@b*) (cons* (bf3068@bless 'let) '() bf35b9@b bf35ba@b*)) bf35b7@ls/false) (let ((bf35bd@t bf35b5@t)) (let ((bf35bf@ls/false (bf30b2@syntax-dispatch bf35bd@t '(_ #(each (any any)) any . each-any)))) (if bf35bf@ls/false (apply (lambda (bf35c1@lhs* bf35c2@rhs* bf35c3@b bf35c4@b*) (bf3068@bless (let bf35d1@f ((bf35c9@lhs* bf35c1@lhs*) (bf35ca@rhs* bf35c2@rhs*) (bf35cb@old* '()) (bf35cc@new* '())) (if (null? bf35c9@lhs*) (cons 'let (cons (map list bf35cb@old* bf35cc@new*) (cons bf35c3@b bf35c4@b*))) (let ((bf35d3@t (car bf35c9@lhs*))) (let ((bf35d5@ls/false (bf30b2@syntax-dispatch bf35d3@t 'each-any))) (if bf35d5@ls/false (apply (lambda (bf35d7@x*) (call-with-values (lambda () (bf35b4@rename* bf35d7@x* bf35cb@old* bf35cc@new*)) (lambda (bf35df@bf35da bf35e0@bf35dc bf35e1@bf35de) (let ((bf35e5@new* bf35e1@bf35de) (bf35e6@old* bf35e0@bf35dc) (bf35e7@y* bf35df@bf35da)) (list 'call-with-values (list 'lambda '() (car bf35ca@rhs*)) (list 'lambda bf35e7@y* (bf35d1@f (cdr bf35c9@lhs*) (cdr bf35ca@rhs*) bf35e6@old* bf35e5@new*))))))) bf35d5@ls/false) (let ((bf35eb@t bf35d3@t)) (let ((bf35ed@ls/false (bf30b2@syntax-dispatch bf35eb@t '#(each+ any () any)))) (if bf35ed@ls/false (apply (lambda (bf35ef@x* bf35f0@x) (call-with-values (lambda () (bf35b2@rename bf35f0@x bf35cb@old* bf35cc@new*)) (lambda (bf35f3@y bf35f4@old* bf35f5@new*) (call-with-values (lambda () (bf35b4@rename* bf35ef@x* bf35f4@old* bf35f5@new*)) (lambda (bf35f9@y* bf35fa@old* bf35fb@new*) (list 'call-with-values (list 'lambda '() (car bf35ca@rhs*)) (list 'lambda (append bf35f9@y* bf35f3@y) (bf35d1@f (cdr bf35c9@lhs*) (cdr bf35ca@rhs*) bf35fa@old* bf35fb@new*)))))))) bf35ed@ls/false) (let ((bf35ff@t bf35eb@t)) (let ((bf3601@ls/false (bf30b2@syntax-dispatch bf35ff@t 'any))) (if bf3601@ls/false (apply (lambda (bf3603@others) (bf3192@syntax-violation '#f '"malformed bindings" bf35af@stx bf3603@others)) bf3601@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf35ff@t)))))))))))))) bf35bf@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf35bd@t)))))))))) (set! bf4b9d@bf3070@let-values-macro bf3070@let-values-macro) (set! bf3072@let*-values-macro (lambda (bf361f@stx) (letrec* ((bf3622@check (lambda (bf3651@x*) (if (not (null? bf3651@x*)) (let ((bf3653@x (car bf3651@x*))) (begin (if (not (bf2eab@id? bf3653@x)) (bf3192@syntax-violation '#f '"not an identifier" bf361f@stx bf3653@x) (void)) (bf3622@check (cdr bf3651@x*)) (if (bf2eb7@bound-id-member? bf3653@x (cdr bf3651@x*)) (bf3192@syntax-violation '#f '"duplicate identifier" bf361f@stx bf3653@x) (void)))) (void))))) (let ((bf3623@t bf361f@stx)) (let ((bf3625@ls/false (bf30b2@syntax-dispatch bf3623@t '(_ () any . each-any)))) (if bf3625@ls/false (apply (lambda (bf3627@b bf3628@b*) (cons* (bf3068@bless 'let) '() bf3627@b bf3628@b*)) bf3625@ls/false) (let ((bf362b@t bf3623@t)) (let ((bf362d@ls/false (bf30b2@syntax-dispatch bf362b@t '(_ #(each (any any)) any . each-any)))) (if bf362d@ls/false (apply (lambda (bf362f@lhs* bf3630@rhs* bf3631@b bf3632@b*) (bf3068@bless (let bf363b@f ((bf3637@lhs* bf362f@lhs*) (bf3638@rhs* bf3630@rhs*)) (if (null? bf3637@lhs*) (cons 'begin (cons bf3631@b bf3632@b*)) (let ((bf363d@t (car bf3637@lhs*))) (let ((bf363f@ls/false (bf30b2@syntax-dispatch bf363d@t 'each-any))) (if bf363f@ls/false (apply (lambda (bf3641@x*) (begin (bf3622@check bf3641@x*) (list 'call-with-values (list 'lambda '() (car bf3638@rhs*)) (list 'lambda bf3641@x* (bf363b@f (cdr bf3637@lhs*) (cdr bf3638@rhs*)))))) bf363f@ls/false) (let ((bf3643@t bf363d@t)) (let ((bf3645@ls/false (bf30b2@syntax-dispatch bf3643@t '#(each+ any () any)))) (if bf3645@ls/false (apply (lambda (bf3647@x* bf3648@x) (begin (bf3622@check (cons bf3648@x bf3647@x*)) (list 'call-with-values (list 'lambda '() (car bf3638@rhs*)) (list 'lambda (append bf3647@x* bf3648@x) (bf363b@f (cdr bf3637@lhs*) (cdr bf3638@rhs*)))))) bf3645@ls/false) (let ((bf364b@t bf3643@t)) (let ((bf364d@ls/false (bf30b2@syntax-dispatch bf364b@t 'any))) (if bf364d@ls/false (apply (lambda (bf364f@others) (bf3192@syntax-violation '#f '"malformed bindings" bf361f@stx bf364f@others)) bf364d@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf364b@t)))))))))))))) bf362d@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf362b@t)))))))))) (set! bf4b9e@bf3072@let*-values-macro bf3072@let*-values-macro) (set! bf3074@trace-lambda-macro (lambda (bf3655@stx) (let ((bf3657@t bf3655@stx)) (let ((bf3659@ls/false (bf30b2@syntax-dispatch bf3657@t '(_ any each-any any . each-any)))) (if bf3659@ls/false (apply (lambda (bf365b@who bf365c@fmls bf365d@b bf365e@b*) (if (bf2eb3@valid-bound-ids? bf365c@fmls) (bf3068@bless (list 'make-traced-procedure (list 'quote bf365b@who) (cons 'lambda (cons bf365c@fmls (cons bf365d@b bf365e@b*))))) (bf306c@invalid-fmls-error bf3655@stx bf365c@fmls))) bf3659@ls/false) (let ((bf3663@t bf3657@t)) (let ((bf3665@ls/false (bf30b2@syntax-dispatch bf3663@t '(_ any #(each+ any () any) any . each-any)))) (if bf3665@ls/false (apply (lambda (bf3667@who bf3668@fmls bf3669@last bf366a@b bf366b@b*) (if (bf2eb3@valid-bound-ids? (cons bf3669@last bf3668@fmls)) (bf3068@bless (list 'make-traced-procedure (list 'quote bf3667@who) (cons 'lambda (cons (append bf3668@fmls bf3669@last) (cons bf366a@b bf366b@b*))))) (bf306c@invalid-fmls-error bf3655@stx (append bf3668@fmls bf3669@last)))) bf3665@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3663@t))))))))) (set! bf4b9f@bf3074@trace-lambda-macro bf3074@trace-lambda-macro) (set! bf3076@trace-define-macro (lambda (bf3671@stx) (let ((bf3673@t bf3671@stx)) (let ((bf3675@ls/false (bf30b2@syntax-dispatch bf3673@t '(_ (any . each-any) any . each-any)))) (if bf3675@ls/false (apply (lambda (bf3677@who bf3678@fmls bf3679@b bf367a@b*) (if (bf2eb3@valid-bound-ids? bf3678@fmls) (bf3068@bless (list 'define bf3677@who (list 'make-traced-procedure (list 'quote bf3677@who) (cons 'lambda (cons bf3678@fmls (cons bf3679@b bf367a@b*)))))) (bf306c@invalid-fmls-error bf3671@stx bf3678@fmls))) bf3675@ls/false) (let ((bf367f@t bf3673@t)) (let ((bf3681@ls/false (bf30b2@syntax-dispatch bf367f@t '(_ (any . #(each+ any () any)) any . each-any)))) (if bf3681@ls/false (apply (lambda (bf3683@who bf3684@fmls bf3685@last bf3686@b bf3687@b*) (if (bf2eb3@valid-bound-ids? (cons bf3685@last bf3684@fmls)) (bf3068@bless (list 'define bf3683@who (list 'make-traced-procedure (list 'quote bf3683@who) (cons 'lambda (cons (append bf3684@fmls bf3685@last) (cons bf3686@b bf3687@b*)))))) (bf306c@invalid-fmls-error bf3671@stx (append bf3684@fmls bf3685@last)))) bf3681@ls/false) (let ((bf368d@t bf367f@t)) (let ((bf368f@ls/false (bf30b2@syntax-dispatch bf368d@t '(_ any any)))) (if bf368f@ls/false (apply (lambda (bf3691@who bf3692@expr) (if (bf2eab@id? bf3691@who) (bf3068@bless (list 'define bf3691@who (list 'let (list (list 'v bf3692@expr)) (cons 'if (cons '(procedure? v) (cons (cons 'make-traced-procedure (cons (list 'quote bf3691@who) '(v))) '((assertion-violation 'trace-define "not a procedure" v)))))))) (bf3192@syntax-violation '#f '"invalid name" bf3671@stx))) bf368f@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf368d@t)))))))))))) (set! bf4ba0@bf3076@trace-define-macro bf3076@trace-define-macro) (set! bf3078@trace-define-syntax-macro (lambda (bf3695@stx) (let ((bf3697@t bf3695@stx)) (let ((bf3699@ls/false (bf30b2@syntax-dispatch bf3697@t '(_ any any)))) (if bf3699@ls/false (apply (lambda (bf369b@who bf369c@expr) (if (bf2eab@id? bf369b@who) (bf3068@bless (list 'define-syntax bf369b@who (list 'make-traced-macro (list 'quote bf369b@who) bf369c@expr))) (bf3192@syntax-violation '#f '"invalid name" bf3695@stx))) bf3699@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3697@t)))))) (set! bf4ba1@bf3078@trace-define-syntax-macro bf3078@trace-define-syntax-macro) (set! bf307a@trace-let/rec-syntax (lambda (bf369f@who) (lambda (bf36a1@stx) (let ((bf36a3@t bf36a1@stx)) (let ((bf36a5@ls/false (bf30b2@syntax-dispatch bf36a3@t '(_ #(each (any any)) any . each-any)))) (if bf36a5@ls/false (apply (lambda (bf36a7@lhs* bf36a8@rhs* bf36a9@b bf36aa@b*) (if (bf2eb3@valid-bound-ids? bf36a7@lhs*) (let ((bf36af@rhs* (map (lambda (bf36b1@lhs bf36b2@rhs) (list 'make-traced-macro (list 'quote bf36b1@lhs) bf36b2@rhs)) bf36a7@lhs* bf36a8@rhs*))) (bf3068@bless (cons bf369f@who (cons (map list bf36a7@lhs* bf36af@rhs*) (cons bf36a9@b bf36aa@b*))))) (bf306c@invalid-fmls-error bf36a1@stx bf36a7@lhs*))) bf36a5@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf36a3@t))))))) (set! bf4ba2@bf307a@trace-let/rec-syntax bf307a@trace-let/rec-syntax) (set! bf307c@trace-let-syntax-macro (bf307a@trace-let/rec-syntax 'let-syntax)) (set! bf4ba3@bf307c@trace-let-syntax-macro bf307c@trace-let-syntax-macro) (set! bf307e@trace-letrec-syntax-macro (bf307a@trace-let/rec-syntax 'letrec-syntax)) (set! bf4ba4@bf307e@trace-letrec-syntax-macro bf307e@trace-letrec-syntax-macro) (set! bf3080@guard-macro (lambda (bf36b5@x) (letrec* ((bf36b8@gen-clauses (lambda (bf36cf@con bf36d0@outerk bf36d1@clause*) (letrec* ((bf36d6@f (lambda (bf370f@x bf3710@k) (let ((bf3713@t bf370f@x)) (let ((bf3715@ls/false (bf30b2@syntax-dispatch bf3713@t '(any #(scheme-id =>) any)))) (if bf3715@ls/false (apply (lambda (bf3717@e bf3718@p) (let ((bf371b@t (gensym))) (list 'let (list (list bf371b@t bf3717@e)) (list 'if bf371b@t (list bf3718@p bf371b@t) bf3710@k)))) bf3715@ls/false) (let ((bf371d@t bf3713@t)) (let ((bf371f@ls/false (bf30b2@syntax-dispatch bf371d@t '(any)))) (if bf371f@ls/false (apply (lambda (bf3721@e) (let ((bf3723@t (gensym))) (list 'let (list (list bf3723@t bf3721@e)) (list 'if bf3723@t bf3723@t bf3710@k)))) bf371f@ls/false) (let ((bf3725@t bf371d@t)) (let ((bf3727@ls/false (bf30b2@syntax-dispatch bf3725@t '(any any . each-any)))) (if bf3727@ls/false (apply (lambda (bf3729@e bf372a@v bf372b@v*) (list 'if bf3729@e (cons 'begin (cons bf372a@v bf372b@v*)) bf3710@k)) bf3727@ls/false) (let ((bf372f@t bf3725@t)) (let ((bf3731@ls/false (bf30b2@syntax-dispatch bf372f@t '_))) (if bf3731@ls/false (apply (lambda () (bf3192@syntax-violation '#f '"invalid guard clause" bf370f@x)) bf3731@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf372f@t))))))))))))))) (bf36d8@f* (lambda (bf36e5@x*) (let ((bf36e7@t bf36e5@x*)) (let ((bf36e9@ls/false (bf30b2@syntax-dispatch bf36e7@t '()))) (if bf36e9@ls/false (apply (lambda () (let ((bf36eb@g (gensym))) (values (list bf36eb@g (list 'lambda '() (list 'raise-continuable bf36cf@con))) bf36eb@g))) bf36e9@ls/false) (let ((bf36ed@t bf36e7@t)) (let ((bf36ef@ls/false (bf30b2@syntax-dispatch bf36ed@t '((#(scheme-id else) any . each-any))))) (if bf36ef@ls/false (apply (lambda (bf36f1@e bf36f2@e*) (values (cons 'begin (cons bf36f1@e bf36f2@e*)) '#f)) bf36ef@ls/false) (let ((bf36f5@t bf36ed@t)) (let ((bf36f7@ls/false (bf30b2@syntax-dispatch bf36f5@t '(any . any)))) (if bf36f7@ls/false (apply (lambda (bf36f9@cls bf36fa@cls*) (call-with-values (lambda () (bf36d8@f* bf36fa@cls*)) (lambda (bf3701@bf36fe bf3702@bf3700) (let ((bf3705@g bf3702@bf3700) (bf3706@e bf3701@bf36fe)) (values (bf36d6@f bf36f9@cls bf3706@e) bf3705@g))))) bf36f7@ls/false) (let ((bf3709@t bf36f5@t)) (let ((bf370b@ls/false (bf30b2@syntax-dispatch bf3709@t 'any))) (if bf370b@ls/false (apply (lambda (bf370d@others) (bf3192@syntax-violation '#f '"invalid guard clause" bf370d@others)) bf370b@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3709@t)))))))))))))))) (call-with-values (lambda () (bf36d8@f* bf36d1@clause*)) (lambda (bf36dd@bf36da bf36de@bf36dc) (let ((bf36e1@raisek bf36de@bf36dc) (bf36e2@code bf36dd@bf36da)) (if bf36e1@raisek (list (list 'call/cc (list 'lambda (list bf36e1@raisek) (list bf36d0@outerk (list 'lambda '() bf36e2@code))))) (list bf36d0@outerk (list 'lambda '() bf36e2@code)))))))))) (let ((bf36b9@t bf36b5@x)) (let ((bf36bb@ls/false (bf30b2@syntax-dispatch bf36b9@t '(_ (any . each-any) any . each-any)))) (if (and bf36bb@ls/false (apply (lambda (bf36bd@con bf36be@clause* bf36bf@b bf36c0@b*) (bf2eab@id? bf36bd@con)) bf36bb@ls/false)) (apply (lambda (bf36c5@con bf36c6@clause* bf36c7@b bf36c8@b*) (let ((bf36cd@outerk (gensym))) (bf3068@bless (list (list 'call/cc (list 'lambda (list bf36cd@outerk) (list 'lambda '() (list 'with-exception-handler (list 'lambda (list bf36c5@con) (bf36b8@gen-clauses bf36c5@con bf36cd@outerk bf36c6@clause*)) (cons 'lambda (cons '() (cons bf36c7@b bf36c8@b*))))))))))) bf36bb@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf36b9@t))))))) (set! bf4ba5@bf3080@guard-macro bf3080@guard-macro) (set! bf3082@define-enumeration-macro (lambda (bf3733@stx) (letrec* ((bf3736@set? (lambda (bf374f@x) (or (null? bf374f@x) (and (not (memq (car bf374f@x) (cdr bf374f@x))) (bf3736@set? (cdr bf374f@x)))))) (bf3738@remove-dups (lambda (bf374d@ls) (if (null? bf374d@ls) '() (cons (car bf374d@ls) (bf3738@remove-dups (remq (car bf374d@ls) (cdr bf374d@ls)))))))) (let ((bf3739@t bf3733@stx)) (let ((bf373b@ls/false (bf30b2@syntax-dispatch bf3739@t '(_ any each-any any)))) (if (and bf373b@ls/false (apply (lambda (bf373d@name bf373e@id* bf373f@maker) (and (bf2eab@id? bf373d@name) (bf2eab@id? bf373f@maker) (for-all bf2eab@id? bf373e@id*))) bf373b@ls/false)) (apply (lambda (bf3743@name bf3744@id* bf3745@maker) (let ((bf3749@name* (bf3738@remove-dups (bf3198@syntax->datum bf3744@id*))) (bf374a@mk (gensym))) (bf3068@bless (list 'begin (list 'define bf374a@mk (list 'enum-set-constructor (list 'make-enumeration (list 'quote bf3749@name*)))) (list 'define-syntax bf3743@name (list 'lambda '(x) (list 'syntax-case 'x '() (list '(_ n) '(identifier? (syntax n)) (list 'if (list 'memq '(syntax->datum (syntax n)) (list 'quote bf3749@name*)) '(syntax 'n) (cons 'syntax-violation (cons (list 'quote bf3743@name) '("not a member of set" x (syntax n))))))))) (list 'define-syntax bf3745@maker (list 'lambda '(x) (list 'syntax-case 'x '() (list '(_ n* ...) (list 'begin (cons 'for-each (cons (list 'lambda '(n) (list 'unless '(identifier? n) (cons 'syntax-violation (cons (list 'quote bf3745@maker) '("non-identifier argument" x n)))) (list 'unless (list 'memq '(syntax->datum n) (list 'quote bf3749@name*)) (cons 'syntax-violation (cons (list 'quote bf3745@maker) '("not a member of set" x n))))) '((syntax (n* ...))))) (list 'syntax (cons bf374a@mk '('(n* ...))))))))))))) bf373b@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3739@t))))))) (set! bf4ba6@bf3082@define-enumeration-macro bf3082@define-enumeration-macro) (set! bf3084@time-macro (lambda (bf3751@stx) (let ((bf3753@t bf3751@stx)) (let ((bf3755@ls/false (bf30b2@syntax-dispatch bf3753@t '(_ any)))) (if bf3755@ls/false (apply (lambda (bf3757@expr) (bf3068@bless (cons 'let* (cons (cons '(start (time-usage)) (cons (list 'result (list (list 'lambda '() bf3757@expr))) '((end (time-usage)) (used (map - end start)) (real (car used)) (user (cadr used)) (sys (caddr used))))) '((format #t "~%;;~a real ~a user ~a sys~%~!" real user sys) result))))) bf3755@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3753@t)))))) (set! bf4ba7@bf3084@time-macro bf3084@time-macro) (set! bf3086@delay-macro (lambda (bf3759@stx) (let ((bf375b@t bf3759@stx)) (let ((bf375d@ls/false (bf30b2@syntax-dispatch bf375b@t '(_ any)))) (if bf375d@ls/false (apply (lambda (bf375f@expr) (bf3068@bless (list 'make-promise (list 'lambda '() bf375f@expr)))) bf375d@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf375b@t)))))) (set! bf4ba8@bf3086@delay-macro bf3086@delay-macro) (set! bf3088@assert-macro (lambda (bf3761@stx) (let ((bf3763@t bf3761@stx)) (let ((bf3765@ls/false (bf30b2@syntax-dispatch bf3763@t '(_ any)))) (if bf3765@ls/false (apply (lambda (bf3767@expr) (let ((bf3769@pos (or (bf318a@expression-position bf3761@stx) (bf318a@expression-position bf3767@expr)))) (bf3068@bless (list 'let (list (list 'x bf3767@expr)) (list 'if 'x 'x (list 'assertion-error (list 'quote bf3767@expr) (list 'quote bf3769@pos))))))) bf3765@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3763@t)))))) (set! bf4ba9@bf3088@assert-macro bf3088@assert-macro) (set! bf308a@endianness-macro (lambda (bf376b@stx) (let ((bf376d@t bf376b@stx)) (let ((bf376f@ls/false (bf30b2@syntax-dispatch bf376d@t '(_ any)))) (if bf376f@ls/false (apply (lambda (bf3771@e) (let ((bf3773@t (bf3198@syntax->datum bf3771@e))) (if (memv bf3773@t '(little)) (bf3068@bless ''little) (if (memv bf3773@t '(big)) (bf3068@bless ''big) (bf3192@syntax-violation '#f '"endianness must be big or little" bf376b@stx))))) bf376f@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf376d@t)))))) (set! bf4baa@bf308a@endianness-macro bf308a@endianness-macro) (set! bf308c@identifier-syntax-macro (lambda (bf3775@stx) (let ((bf3777@t bf3775@stx)) (let ((bf3779@ls/false (bf30b2@syntax-dispatch bf3777@t '(_ any)))) (if bf3779@ls/false (apply (lambda (bf377b@expr) (bf3068@bless (list 'lambda '(x) (list 'syntax-case 'x '() (list 'id '(identifier? (syntax id)) (list 'syntax bf377b@expr)) (list '(id e* ...) '(identifier? (syntax id)) (cons 'cons (cons (list 'syntax bf377b@expr) '((syntax (e* ...)))))))))) bf3779@ls/false) (let ((bf377d@t bf3777@t)) (let ((bf377f@ls/false (bf30b2@syntax-dispatch bf377d@t '(_ (any any) ((#(scheme-id set!) any any) any))))) (if (and bf377f@ls/false (apply (lambda (bf3781@id1 bf3782@expr1 bf3783@id2 bf3784@expr2 bf3785@expr3) (and (bf2eab@id? bf3781@id1) (bf2eab@id? bf3783@id2) (bf2eab@id? bf3784@expr2))) bf377f@ls/false)) (apply (lambda (bf378b@id1 bf378c@expr1 bf378d@id2 bf378e@expr2 bf378f@expr3) (bf3068@bless (list 'cons ''macro! (list 'lambda '(x) (list 'syntax-case 'x '(set!) (list 'id '(identifier? (syntax id)) (list 'syntax bf378c@expr1)) (list (list 'set! 'id bf378e@expr2) (list 'syntax bf378f@expr3)) (list '(id e* ...) '(identifier? (syntax id)) (list 'syntax (cons bf378c@expr1 '(e* ...))))))))) bf377f@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf377d@t))))))))) (set! bf4bab@bf308c@identifier-syntax-macro bf308c@identifier-syntax-macro) (set! bf308e@do-macro (lambda (bf3795@stx) (letrec* ((bf3798@bind (lambda (bf37af@x) (let ((bf37b1@t bf37af@x)) (let ((bf37b3@ls/false (bf30b2@syntax-dispatch bf37b1@t '(any any)))) (if bf37b3@ls/false (apply (lambda (bf37b5@x bf37b6@init) (list bf37b5@x bf37b6@init bf37b5@x)) bf37b3@ls/false) (let ((bf37b9@t bf37b1@t)) (let ((bf37bb@ls/false (bf30b2@syntax-dispatch bf37b9@t '(any any any)))) (if bf37bb@ls/false (apply (lambda (bf37bd@x bf37be@init bf37bf@step) (list bf37bd@x bf37be@init bf37bf@step)) bf37bb@ls/false) (let ((bf37c3@t bf37b9@t)) (let ((bf37c5@ls/false (bf30b2@syntax-dispatch bf37c3@t '_))) (if bf37c5@ls/false (apply (lambda () (bf3192@syntax-violation '#f '"invalid binding" bf3795@stx)) bf37c5@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf37c3@t))))))))))))) (let ((bf3799@t bf3795@stx)) (let ((bf379b@ls/false (bf30b2@syntax-dispatch bf3799@t '(_ each-any (any . each-any) . each-any)))) (if bf379b@ls/false (apply (lambda (bf379d@binding* bf379e@test bf379f@expr* bf37a0@command*) (let ((bf37a5@t (map bf3798@bind bf379d@binding*))) (let ((bf37a7@ls/false (bf30b2@syntax-dispatch bf37a5@t '#(each (any any any))))) (if bf37a7@ls/false (apply (lambda (bf37a9@x* bf37aa@init* bf37ab@step*) (if (bf2eb3@valid-bound-ids? bf37a9@x*) (bf3068@bless (list 'letrec (list (list 'loop (list 'lambda bf37a9@x* (list 'if bf379e@test (cons 'begin (cons '(if #f #f) bf379f@expr*)) (cons 'begin (append bf37a0@command* (list (cons 'loop bf37ab@step*)))))))) (cons 'loop bf37aa@init*))) (bf3192@syntax-violation '#f '"invalid bindings" bf3795@stx))) bf37a7@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf37a5@t))))) bf379b@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3799@t))))))) (set! bf4bac@bf308e@do-macro bf308e@do-macro) (set! bf3090@let*-macro (lambda (bf37c7@stx) (let ((bf37c9@t bf37c7@stx)) (let ((bf37cb@ls/false (bf30b2@syntax-dispatch bf37c9@t '(_ #(each (any any)) any . each-any)))) (if (and bf37cb@ls/false (apply (lambda (bf37cd@lhs* bf37ce@rhs* bf37cf@b bf37d0@b*) (for-all bf2eab@id? bf37cd@lhs*)) bf37cb@ls/false)) (apply (lambda (bf37d5@lhs* bf37d6@rhs* bf37d7@b bf37d8@b*) (bf3068@bless (let bf37df@f ((bf37dd@x* (map list bf37d5@lhs* bf37d6@rhs*))) (if (null? bf37dd@x*) (cons 'let (cons '() (cons bf37d7@b bf37d8@b*))) (list 'let (list (car bf37dd@x*)) (bf37df@f (cdr bf37dd@x*))))))) bf37cb@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf37c9@t)))))) (set! bf4bad@bf3090@let*-macro bf3090@let*-macro) (set! bf3092@or-macro (lambda (bf37e1@stx) (let ((bf37e3@t bf37e1@stx)) (let ((bf37e5@ls/false (bf30b2@syntax-dispatch bf37e3@t '(_)))) (if bf37e5@ls/false (apply (lambda () '#f) bf37e5@ls/false) (let ((bf37e7@t bf37e3@t)) (let ((bf37e9@ls/false (bf30b2@syntax-dispatch bf37e7@t '(_ any . each-any)))) (if bf37e9@ls/false (apply (lambda (bf37eb@e bf37ec@e*) (bf3068@bless (let bf37f3@f ((bf37ef@e bf37eb@e) (bf37f0@e* bf37ec@e*)) (if (null? bf37f0@e*) (list 'begin '#f bf37ef@e) (list 'let (list (list 't bf37ef@e)) (list 'if 't 't (bf37f3@f (car bf37f0@e*) (cdr bf37f0@e*)))))))) bf37e9@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf37e7@t))))))))) (set! bf4bae@bf3092@or-macro bf3092@or-macro) (set! bf3094@and-macro (lambda (bf37f5@stx) (let ((bf37f7@t bf37f5@stx)) (let ((bf37f9@ls/false (bf30b2@syntax-dispatch bf37f7@t '(_)))) (if bf37f9@ls/false (apply (lambda () '#t) bf37f9@ls/false) (let ((bf37fb@t bf37f7@t)) (let ((bf37fd@ls/false (bf30b2@syntax-dispatch bf37fb@t '(_ any . each-any)))) (if bf37fd@ls/false (apply (lambda (bf37ff@e bf3800@e*) (bf3068@bless (let bf3807@f ((bf3803@e bf37ff@e) (bf3804@e* bf3800@e*)) (if (null? bf3804@e*) (list 'begin '#f bf3803@e) (cons 'if (cons bf3803@e (cons (bf3807@f (car bf3804@e*) (cdr bf3804@e*)) '(#f)))))))) bf37fd@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf37fb@t))))))))) (set! bf4baf@bf3094@and-macro bf3094@and-macro) (set! bf3096@cond-macro (lambda (bf3809@stx) (let ((bf380b@t bf3809@stx)) (let ((bf380d@ls/false (bf30b2@syntax-dispatch bf380b@t '(_ any . each-any)))) (if bf380d@ls/false (apply (lambda (bf380f@cls bf3810@cls*) (bf3068@bless (let bf3817@f ((bf3813@cls bf380f@cls) (bf3814@cls* bf3810@cls*)) (if (null? bf3814@cls*) (let ((bf3819@t bf3813@cls)) (let ((bf381b@ls/false (bf30b2@syntax-dispatch bf3819@t '(#(scheme-id else) any . each-any)))) (if bf381b@ls/false (apply (lambda (bf381d@e bf381e@e*) (cons 'begin (cons bf381d@e bf381e@e*))) bf381b@ls/false) (let ((bf3821@t bf3819@t)) (let ((bf3823@ls/false (bf30b2@syntax-dispatch bf3821@t '(any #(scheme-id =>) any)))) (if bf3823@ls/false (apply (lambda (bf3825@e bf3826@p) (list 'let (list (list 't bf3825@e)) (list 'if 't (cons bf3826@p '(t))))) bf3823@ls/false) (let ((bf3829@t bf3821@t)) (let ((bf382b@ls/false (bf30b2@syntax-dispatch bf3829@t '(any)))) (if bf382b@ls/false (apply (lambda (bf382d@e) (cons 'or (cons bf382d@e '((if #f #f))))) bf382b@ls/false) (let ((bf382f@t bf3829@t)) (let ((bf3831@ls/false (bf30b2@syntax-dispatch bf382f@t '(any . each-any)))) (if bf3831@ls/false (apply (lambda (bf3833@e bf3834@e*) (list 'if bf3833@e (cons 'begin bf3834@e*))) bf3831@ls/false) (let ((bf3837@t bf382f@t)) (let ((bf3839@ls/false (bf30b2@syntax-dispatch bf3837@t '_))) (if bf3839@ls/false (apply (lambda () (bf3192@syntax-violation '#f '"invalid last clause" bf3809@stx)) bf3839@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3837@t)))))))))))))))) (let ((bf383b@t bf3813@cls)) (let ((bf383d@ls/false (bf30b2@syntax-dispatch bf383b@t '(#(scheme-id else) any . each-any)))) (if bf383d@ls/false (apply (lambda (bf383f@e bf3840@e*) (bf3192@syntax-violation '#f '"incorrect position of keyword else" bf3809@stx)) bf383d@ls/false) (let ((bf3843@t bf383b@t)) (let ((bf3845@ls/false (bf30b2@syntax-dispatch bf3843@t '(any #(scheme-id =>) any)))) (if bf3845@ls/false (apply (lambda (bf3847@e bf3848@p) (list 'let (list (list 't bf3847@e)) (list 'if 't (cons bf3848@p '(t)) (bf3817@f (car bf3814@cls*) (cdr bf3814@cls*))))) bf3845@ls/false) (let ((bf384b@t bf3843@t)) (let ((bf384d@ls/false (bf30b2@syntax-dispatch bf384b@t '(any)))) (if bf384d@ls/false (apply (lambda (bf384f@e) (list 'or bf384f@e (bf3817@f (car bf3814@cls*) (cdr bf3814@cls*)))) bf384d@ls/false) (let ((bf3851@t bf384b@t)) (let ((bf3853@ls/false (bf30b2@syntax-dispatch bf3851@t '(any . each-any)))) (if bf3853@ls/false (apply (lambda (bf3855@e bf3856@e*) (list 'if bf3855@e (cons 'begin bf3856@e*) (bf3817@f (car bf3814@cls*) (cdr bf3814@cls*)))) bf3853@ls/false) (let ((bf3859@t bf3851@t)) (let ((bf385b@ls/false (bf30b2@syntax-dispatch bf3859@t '_))) (if bf385b@ls/false (apply (lambda () (bf3192@syntax-violation '#f '"invalid last clause" bf3809@stx)) bf385b@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3859@t)))))))))))))))))))) bf380d@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf380b@t)))))) (set! bf4bb0@bf3096@cond-macro bf3096@cond-macro) (set! bf3098@do-include (lambda (bf385d@stx bf385e@id bf385f@filename) (let ((bf3863@filename (bf2ebf@stx->datum bf385f@filename))) (begin (if (not (and (string? bf3863@filename) (bf2eab@id? bf385e@id))) (bf3192@syntax-violation '#f '"invalid syntax" bf385d@stx) (void)) (cons (bf3068@bless 'begin) (with-input-from-file bf3863@filename (lambda () (let bf3867@f ((bf3865@ls '())) (let ((bf3869@x (bf29ed@bf28bd@read-annotated))) (if (eof-object? bf3869@x) (reverse bf3865@ls) (bf3867@f (cons (bf2e8b@datum->stx bf385e@id bf3869@x) bf3865@ls)))))))))))) (set! bf4bb1@bf3098@do-include bf3098@do-include) (set! bf309a@include-macro (lambda (bf386b@e) (let ((bf386d@t bf386b@e)) (let ((bf386f@ls/false (bf30b2@syntax-dispatch bf386d@t '(any any)))) (if bf386f@ls/false (apply (lambda (bf3871@id bf3872@filename) (bf3098@do-include bf386b@e bf3871@id bf3872@filename)) bf386f@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf386d@t)))))) (set! bf4bb2@bf309a@include-macro bf309a@include-macro) (set! bf309c@include-into-macro (lambda (bf3875@e) (let ((bf3877@t bf3875@e)) (let ((bf3879@ls/false (bf30b2@syntax-dispatch bf3877@t '(_ any any)))) (if bf3879@ls/false (apply (lambda (bf387b@id bf387c@filename) (bf3098@do-include bf3875@e bf387b@id bf387c@filename)) bf3879@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3877@t)))))) (set! bf4bb3@bf309c@include-into-macro bf309c@include-into-macro) (set! bf309e@syntax-rules-macro (lambda (bf387f@e) (let ((bf3881@t bf387f@e)) (let ((bf3883@ls/false (bf30b2@syntax-dispatch bf3881@t '(_ each-any . #(each (any any)))))) (if bf3883@ls/false (apply (lambda (bf3885@lits bf3886@pat* bf3887@tmp*) (begin (bf30b8@verify-literals bf3885@lits bf387f@e) (bf3068@bless (list 'lambda '(x) (cons 'syntax-case (cons 'x (cons bf3885@lits (map (lambda (bf388b@pat bf388c@tmp) (let ((bf388f@t bf388b@pat)) (let ((bf3891@ls/false (bf30b2@syntax-dispatch bf388f@t '(_ . any)))) (if bf3891@ls/false (apply (lambda (bf3893@rest) (list (cons 'g bf3893@rest) (list 'syntax bf388c@tmp))) bf3891@ls/false) (let ((bf3895@t bf388f@t)) (let ((bf3897@ls/false (bf30b2@syntax-dispatch bf3895@t '_))) (if bf3897@ls/false (apply (lambda () (bf3192@syntax-violation '#f '"invalid syntax-rules pattern" bf387f@e bf388b@pat)) bf3897@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3895@t)))))))) bf3886@pat* bf3887@tmp*)))))))) bf3883@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3881@t)))))) (set! bf4bb4@bf309e@syntax-rules-macro bf309e@syntax-rules-macro) (set! bf30a0@quasiquote-macro (letrec* ((bf389a@datum (lambda (bf399b@x) (list (bf303a@scheme-stx 'quote) (bf2e93@mkstx bf399b@x bf2e2f@top-mark* '() '())))) (bf38b6@quasicons* (lambda (bf3993@x bf3994@y) (let bf3999@f ((bf3997@x bf3993@x)) (if (null? bf3997@x) bf3994@y (bf38b8@quasicons (car bf3997@x) (bf3999@f (cdr bf3997@x))))))) (bf38b8@quasicons (lambda (bf396d@x bf396e@y) (let ((bf3971@t bf396e@y)) (let ((bf3973@ls/false (bf30b2@syntax-dispatch bf3971@t '(#(scheme-id quote) any)))) (if bf3973@ls/false (apply (lambda (bf3975@dy) (let ((bf3977@t bf396d@x)) (let ((bf3979@ls/false (bf30b2@syntax-dispatch bf3977@t '(#(scheme-id quote) any)))) (if bf3979@ls/false (apply (lambda (bf397b@dx) (list (bf303a@scheme-stx 'quote) (cons bf397b@dx bf3975@dy))) bf3979@ls/false) (let ((bf397d@t bf3977@t)) (let ((bf397f@ls/false (bf30b2@syntax-dispatch bf397d@t '_))) (if bf397f@ls/false (apply (lambda () (let ((bf3981@t bf3975@dy)) (let ((bf3983@ls/false (bf30b2@syntax-dispatch bf3981@t '()))) (if bf3983@ls/false (apply (lambda () (list (bf303a@scheme-stx 'list) bf396d@x)) bf3983@ls/false) (let ((bf3985@t bf3981@t)) (let ((bf3987@ls/false (bf30b2@syntax-dispatch bf3985@t '_))) (if bf3987@ls/false (apply (lambda () (list (bf303a@scheme-stx 'cons) bf396d@x bf396e@y)) bf3987@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3985@t)))))))) bf397f@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf397d@t)))))))) bf3973@ls/false) (let ((bf3989@t bf3971@t)) (let ((bf398b@ls/false (bf30b2@syntax-dispatch bf3989@t '(#(scheme-id list) . each-any)))) (if bf398b@ls/false (apply (lambda (bf398d@stuff) (cons* (bf303a@scheme-stx 'list) bf396d@x bf398d@stuff)) bf398b@ls/false) (let ((bf398f@t bf3989@t)) (let ((bf3991@ls/false (bf30b2@syntax-dispatch bf398f@t '_))) (if bf3991@ls/false (apply (lambda () (list (bf303a@scheme-stx 'cons) bf396d@x bf396e@y)) bf3991@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf398f@t)))))))))))) (bf38ba@quasiappend (lambda (bf3953@x bf3954@y) (let ((bf3957@ls (let bf395b@f ((bf3959@x bf3953@x)) (if (null? bf3959@x) (let ((bf395d@t bf3954@y)) (let ((bf395f@ls/false (bf30b2@syntax-dispatch bf395d@t '(#(scheme-id quote) ())))) (if bf395f@ls/false (apply (lambda () '()) bf395f@ls/false) (let ((bf3961@t bf395d@t)) (let ((bf3963@ls/false (bf30b2@syntax-dispatch bf3961@t '_))) (if bf3963@ls/false (apply (lambda () (list bf3954@y)) bf3963@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3961@t))))))) (let ((bf3965@t (car bf3959@x))) (let ((bf3967@ls/false (bf30b2@syntax-dispatch bf3965@t '(#(scheme-id quote) ())))) (if bf3967@ls/false (apply (lambda () (bf395b@f (cdr bf3959@x))) bf3967@ls/false) (let ((bf3969@t bf3965@t)) (let ((bf396b@ls/false (bf30b2@syntax-dispatch bf3969@t '_))) (if bf396b@ls/false (apply (lambda () (cons (car bf3959@x) (bf395b@f (cdr bf3959@x)))) bf396b@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3969@t))))))))))) (if (null? bf3957@ls) (list (bf303a@scheme-stx 'quote) '()) (if (null? (cdr bf3957@ls)) (car bf3957@ls) (cons* (bf303a@scheme-stx 'append) bf3957@ls)))))) (bf38bc@quasivector (lambda (bf3921@x) (let ((bf3923@pat-x bf3921@x)) (let ((bf3925@t bf3923@pat-x)) (let ((bf3927@ls/false (bf30b2@syntax-dispatch bf3925@t '(#(scheme-id quote) each-any)))) (if bf3927@ls/false (apply (lambda (bf3929@x*) (list (bf303a@scheme-stx 'quote) (list->vector bf3929@x*))) bf3927@ls/false) (let ((bf392b@t bf3925@t)) (let ((bf392d@ls/false (bf30b2@syntax-dispatch bf392b@t '_))) (if bf392d@ls/false (apply (lambda () (let bf3935@f ((bf392f@x bf3921@x) (bf3930@k (lambda (bf3933@ls) (cons* (bf303a@scheme-stx 'vector) bf3933@ls)))) (let ((bf3937@t bf392f@x)) (let ((bf3939@ls/false (bf30b2@syntax-dispatch bf3937@t '(#(scheme-id quote) each-any)))) (if bf3939@ls/false (apply (lambda (bf393b@x*) (bf3930@k (map (lambda (bf393d@x) (list (bf303a@scheme-stx 'quote) bf393d@x)) bf393b@x*))) bf3939@ls/false) (let ((bf393f@t bf3937@t)) (let ((bf3941@ls/false (bf30b2@syntax-dispatch bf393f@t '(#(scheme-id list) . each-any)))) (if bf3941@ls/false (apply (lambda (bf3943@x*) (bf3930@k bf3943@x*)) bf3941@ls/false) (let ((bf3945@t bf393f@t)) (let ((bf3947@ls/false (bf30b2@syntax-dispatch bf3945@t '(#(scheme-id cons) any any)))) (if bf3947@ls/false (apply (lambda (bf3949@x bf394a@y) (bf3935@f bf394a@y (lambda (bf394d@ls) (bf3930@k (cons bf3949@x bf394d@ls))))) bf3947@ls/false) (let ((bf394f@t bf3945@t)) (let ((bf3951@ls/false (bf30b2@syntax-dispatch bf394f@t '_))) (if bf3951@ls/false (apply (lambda () (list (bf303a@scheme-stx 'list->vector) bf3923@pat-x)) bf3951@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf394f@t))))))))))))))) bf392d@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf392b@t)))))))))) (bf38be@vquasi (lambda (bf38ff@p bf3900@lev) (let ((bf3903@t bf38ff@p)) (let ((bf3905@ls/false (bf30b2@syntax-dispatch bf3903@t '(any . any)))) (if bf3905@ls/false (apply (lambda (bf3907@p bf3908@q) (let ((bf390b@t bf3907@p)) (let ((bf390d@ls/false (bf30b2@syntax-dispatch bf390b@t '(#(scheme-id unquote) . each-any)))) (if bf390d@ls/false (apply (lambda (bf390f@p) (if (= bf3900@lev '0) (bf38b6@quasicons* bf390f@p (bf38be@vquasi bf3908@q bf3900@lev)) (bf38b8@quasicons (bf38b8@quasicons (bf389a@datum 'unquote) (bf38c0@quasi bf390f@p (- bf3900@lev '1))) (bf38be@vquasi bf3908@q bf3900@lev)))) bf390d@ls/false) (let ((bf3911@t bf390b@t)) (let ((bf3913@ls/false (bf30b2@syntax-dispatch bf3911@t '(#(scheme-id unquote-splicing) . each-any)))) (if bf3913@ls/false (apply (lambda (bf3915@p) (if (= bf3900@lev '0) (bf38ba@quasiappend bf3915@p (bf38be@vquasi bf3908@q bf3900@lev)) (bf38b8@quasicons (bf38b8@quasicons (bf389a@datum 'unquote-splicing) (bf38c0@quasi bf3915@p (- bf3900@lev '1))) (bf38be@vquasi bf3908@q bf3900@lev)))) bf3913@ls/false) (let ((bf3917@t bf3911@t)) (let ((bf3919@ls/false (bf30b2@syntax-dispatch bf3917@t 'any))) (if bf3919@ls/false (apply (lambda (bf391b@p) (bf38b8@quasicons (bf38c0@quasi bf391b@p bf3900@lev) (bf38be@vquasi bf3908@q bf3900@lev))) bf3919@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3917@t))))))))))) bf3905@ls/false) (let ((bf391d@t bf3903@t)) (let ((bf391f@ls/false (bf30b2@syntax-dispatch bf391d@t '()))) (if bf391f@ls/false (apply (lambda () (list (bf303a@scheme-stx 'quote) '())) bf391f@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf391d@t))))))))) (bf38c0@quasi (lambda (bf38c9@p bf38ca@lev) (let ((bf38cd@t bf38c9@p)) (let ((bf38cf@ls/false (bf30b2@syntax-dispatch bf38cd@t '(#(scheme-id unquote) any)))) (if bf38cf@ls/false (apply (lambda (bf38d1@p) (if (= bf38ca@lev '0) bf38d1@p (bf38b8@quasicons (bf389a@datum 'unquote) (bf38c0@quasi (list bf38d1@p) (- bf38ca@lev '1))))) bf38cf@ls/false) (let ((bf38d3@t bf38cd@t)) (let ((bf38d5@ls/false (bf30b2@syntax-dispatch bf38d3@t '((#(scheme-id unquote) . each-any) . any)))) (if bf38d5@ls/false (apply (lambda (bf38d7@p bf38d8@q) (if (= bf38ca@lev '0) (bf38b6@quasicons* bf38d7@p (bf38c0@quasi bf38d8@q bf38ca@lev)) (bf38b8@quasicons (bf38b8@quasicons (bf389a@datum 'unquote) (bf38c0@quasi bf38d7@p (- bf38ca@lev '1))) (bf38c0@quasi bf38d8@q bf38ca@lev)))) bf38d5@ls/false) (let ((bf38db@t bf38d3@t)) (let ((bf38dd@ls/false (bf30b2@syntax-dispatch bf38db@t '((#(scheme-id unquote-splicing) . each-any) . any)))) (if bf38dd@ls/false (apply (lambda (bf38df@p bf38e0@q) (if (= bf38ca@lev '0) (bf38ba@quasiappend bf38df@p (bf38c0@quasi bf38e0@q bf38ca@lev)) (bf38b8@quasicons (bf38b8@quasicons (bf389a@datum 'unquote-splicing) (bf38c0@quasi bf38df@p (- bf38ca@lev '1))) (bf38c0@quasi bf38e0@q bf38ca@lev)))) bf38dd@ls/false) (let ((bf38e3@t bf38db@t)) (let ((bf38e5@ls/false (bf30b2@syntax-dispatch bf38e3@t '(#(scheme-id quasiquote) any)))) (if bf38e5@ls/false (apply (lambda (bf38e7@p) (bf38b8@quasicons (bf389a@datum 'quasiquote) (bf38c0@quasi (list bf38e7@p) (+ bf38ca@lev '1)))) bf38e5@ls/false) (let ((bf38e9@t bf38e3@t)) (let ((bf38eb@ls/false (bf30b2@syntax-dispatch bf38e9@t '(any . any)))) (if bf38eb@ls/false (apply (lambda (bf38ed@p bf38ee@q) (bf38b8@quasicons (bf38c0@quasi bf38ed@p bf38ca@lev) (bf38c0@quasi bf38ee@q bf38ca@lev))) bf38eb@ls/false) (let ((bf38f1@t bf38e9@t)) (let ((bf38f3@ls/false (bf30b2@syntax-dispatch bf38f1@t '#(vector each-any)))) (if (and bf38f3@ls/false (apply (lambda (bf38f5@x) (not (bf2e77@stx? bf38f5@x))) bf38f3@ls/false)) (apply (lambda (bf38f7@x) (bf38bc@quasivector (bf38be@vquasi bf38f7@x bf38ca@lev))) bf38f3@ls/false) (let ((bf38f9@t bf38f1@t)) (let ((bf38fb@ls/false (bf30b2@syntax-dispatch bf38f9@t 'any))) (if bf38fb@ls/false (apply (lambda (bf38fd@p) (list (bf303a@scheme-stx 'quote) bf38fd@p)) bf38fb@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf38f9@t))))))))))))))))))))))))) (lambda (bf38c1@x) (let ((bf38c3@t bf38c1@x)) (let ((bf38c5@ls/false (bf30b2@syntax-dispatch bf38c3@t '(_ any)))) (if bf38c5@ls/false (apply (lambda (bf38c7@e) (bf38c0@quasi bf38c7@e '0)) bf38c5@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf38c3@t))))))) (set! bf4bb5@bf30a0@quasiquote-macro bf30a0@quasiquote-macro) (set! bf30a2@quasisyntax-macro (letrec* ((bf399e@quasi (lambda (bf39b9@p bf39ba@lev) (let ((bf39bd@t bf39b9@p)) (let ((bf39bf@ls/false (bf30b2@syntax-dispatch bf39bd@t '(#(scheme-id unsyntax) any)))) (if bf39bf@ls/false (apply (lambda (bf39c1@p) (if (= bf39ba@lev '0) (let ((bf39c3@g (gensym))) (values (list bf39c3@g) (list bf39c1@p) bf39c3@g)) (call-with-values (lambda () (bf399e@quasi bf39c1@p (- bf39ba@lev '1))) (lambda (bf39cb@bf39c6 bf39cc@bf39c8 bf39cd@bf39ca) (let ((bf39d1@p bf39cd@bf39ca) (bf39d2@rhs* bf39cc@bf39c8) (bf39d3@lhs* bf39cb@bf39c6)) (values bf39d3@lhs* bf39d2@rhs* (list 'unsyntax bf39d1@p))))))) bf39bf@ls/false) (let ((bf39d7@t bf39bd@t)) (let ((bf39d9@ls/false (bf30b2@syntax-dispatch bf39d7@t '#(scheme-id unsyntax)))) (if (and bf39d9@ls/false (apply (lambda () (= bf39ba@lev '0)) bf39d9@ls/false)) (apply (lambda () (bf3192@syntax-violation '#f '"incorrect use of unsyntax" bf39b9@p)) bf39d9@ls/false) (let ((bf39db@t bf39d7@t)) (let ((bf39dd@ls/false (bf30b2@syntax-dispatch bf39db@t '((#(scheme-id unsyntax) . each-any) . any)))) (if bf39dd@ls/false (apply (lambda (bf39df@p* bf39e0@q) (call-with-values (lambda () (bf399e@quasi bf39e0@q bf39ba@lev)) (lambda (bf39e9@bf39e4 bf39ea@bf39e6 bf39eb@bf39e8) (let ((bf39ef@q bf39eb@bf39e8) (bf39f0@rhs* bf39ea@bf39e6) (bf39f1@lhs* bf39e9@bf39e4)) (if (= bf39ba@lev '0) (let ((bf39f5@g* (map (lambda (bf39f7@x) (gensym)) bf39df@p*))) (values (append bf39f5@g* bf39f1@lhs*) (append bf39df@p* bf39f0@rhs*) (append bf39f5@g* bf39ef@q))) (call-with-values (lambda () (bf399e@quasi bf39df@p* (- bf39ba@lev '1))) (lambda (bf39ff@bf39fa bf3a00@bf39fc bf3a01@bf39fe) (let ((bf3a05@p* bf3a01@bf39fe) (bf3a06@rhs2* bf3a00@bf39fc) (bf3a07@lhs2* bf39ff@bf39fa)) (values (append bf3a07@lhs2* bf39f1@lhs*) (append bf3a06@rhs2* bf39f0@rhs*) (cons (cons 'unsyntax bf3a05@p*) bf39ef@q)))))))))) bf39dd@ls/false) (let ((bf3a0b@t bf39db@t)) (let ((bf3a0d@ls/false (bf30b2@syntax-dispatch bf3a0b@t '((#(scheme-id unsyntax-splicing) . each-any) . any)))) (if bf3a0d@ls/false (apply (lambda (bf3a0f@p* bf3a10@q) (call-with-values (lambda () (bf399e@quasi bf3a10@q bf39ba@lev)) (lambda (bf3a19@bf3a14 bf3a1a@bf3a16 bf3a1b@bf3a18) (let ((bf3a1f@q bf3a1b@bf3a18) (bf3a20@rhs* bf3a1a@bf3a16) (bf3a21@lhs* bf3a19@bf3a14)) (if (= bf39ba@lev '0) (let ((bf3a25@g* (map (lambda (bf3a27@x) (gensym)) bf3a0f@p*))) (values (append (map (lambda (bf3a29@g) (cons bf3a29@g '(...))) bf3a25@g*) bf3a21@lhs*) (append bf3a0f@p* bf3a20@rhs*) (append (apply append (map (lambda (bf3a2b@g) (cons bf3a2b@g '(...))) bf3a25@g*)) bf3a1f@q))) (call-with-values (lambda () (bf399e@quasi bf3a0f@p* (- bf39ba@lev '1))) (lambda (bf3a33@bf3a2e bf3a34@bf3a30 bf3a35@bf3a32) (let ((bf3a39@p* bf3a35@bf3a32) (bf3a3a@rhs2* bf3a34@bf3a30) (bf3a3b@lhs2* bf3a33@bf3a2e)) (values (append bf3a3b@lhs2* bf3a21@lhs*) (append bf3a3a@rhs2* bf3a20@rhs*) (cons (cons 'unsyntax-splicing bf3a39@p*) bf3a1f@q)))))))))) bf3a0d@ls/false) (let ((bf3a3f@t bf3a0b@t)) (let ((bf3a41@ls/false (bf30b2@syntax-dispatch bf3a3f@t '#(scheme-id unsyntax-splicing)))) (if (and bf3a41@ls/false (apply (lambda () (= bf39ba@lev '0)) bf3a41@ls/false)) (apply (lambda () (bf3192@syntax-violation '#f '"incorrect use of unsyntax-splicing" bf39b9@p)) bf3a41@ls/false) (let ((bf3a43@t bf3a3f@t)) (let ((bf3a45@ls/false (bf30b2@syntax-dispatch bf3a43@t '(#(scheme-id quasisyntax) any)))) (if bf3a45@ls/false (apply (lambda (bf3a47@p) (call-with-values (lambda () (bf399e@quasi bf3a47@p (+ bf39ba@lev '1))) (lambda (bf3a4f@bf3a4a bf3a50@bf3a4c bf3a51@bf3a4e) (let ((bf3a55@p bf3a51@bf3a4e) (bf3a56@rhs* bf3a50@bf3a4c) (bf3a57@lhs* bf3a4f@bf3a4a)) (values bf3a57@lhs* bf3a56@rhs* (list 'quasisyntax bf3a55@p)))))) bf3a45@ls/false) (let ((bf3a5b@t bf3a43@t)) (let ((bf3a5d@ls/false (bf30b2@syntax-dispatch bf3a5b@t '(any . any)))) (if bf3a5d@ls/false (apply (lambda (bf3a5f@p bf3a60@q) (call-with-values (lambda () (bf399e@quasi bf3a5f@p bf39ba@lev)) (lambda (bf3a6f@bf3a64 bf3a70@bf3a66 bf3a71@bf3a68) (call-with-values (lambda () (bf399e@quasi bf3a60@q bf39ba@lev)) (lambda (bf3a75@bf3a6a bf3a76@bf3a6c bf3a77@bf3a6e) (let ((bf3a7b@q bf3a77@bf3a6e) (bf3a7c@rhs2* bf3a76@bf3a6c) (bf3a7d@lhs2* bf3a75@bf3a6a) (bf3a7e@p bf3a71@bf3a68) (bf3a7f@rhs* bf3a70@bf3a66) (bf3a80@lhs* bf3a6f@bf3a64)) (values (append bf3a7d@lhs2* bf3a80@lhs*) (append bf3a7c@rhs2* bf3a7f@rhs*) (cons bf3a7e@p bf3a7b@q)))))))) bf3a5d@ls/false) (let ((bf3a87@t bf3a5b@t)) (let ((bf3a89@ls/false (bf30b2@syntax-dispatch bf3a87@t '#(vector each-any)))) (if bf3a89@ls/false (apply (lambda (bf3a8b@x*) (call-with-values (lambda () (bf399e@quasi bf3a8b@x* bf39ba@lev)) (lambda (bf3a93@bf3a8e bf3a94@bf3a90 bf3a95@bf3a92) (let ((bf3a99@x* bf3a95@bf3a92) (bf3a9a@rhs* bf3a94@bf3a90) (bf3a9b@lhs* bf3a93@bf3a8e)) (values bf3a9b@lhs* bf3a9a@rhs* (list->vector bf3a99@x*)))))) bf3a89@ls/false) (let ((bf3a9f@t bf3a87@t)) (let ((bf3aa1@ls/false (bf30b2@syntax-dispatch bf3a9f@t '_))) (if bf3aa1@ls/false (apply (lambda () (values '() '() bf39b9@p)) bf3aa1@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3a9f@t))))))))))))))))))))))))))))))) (lambda (bf399f@x) (let ((bf39a1@t bf399f@x)) (let ((bf39a3@ls/false (bf30b2@syntax-dispatch bf39a1@t '(_ any)))) (if bf39a3@ls/false (apply (lambda (bf39a5@e) (call-with-values (lambda () (bf399e@quasi bf39a5@e '0)) (lambda (bf39ad@bf39a8 bf39ae@bf39aa bf39af@bf39ac) (let ((bf39b3@v bf39af@bf39ac) (bf39b4@rhs* bf39ae@bf39aa) (bf39b5@lhs* bf39ad@bf39a8)) (bf3068@bless (list 'syntax-case (cons 'list bf39b4@rhs*) '() (list bf39b5@lhs* (list 'syntax bf39b3@v)))))))) bf39a3@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf39a1@t))))))) (set! bf4bb6@bf30a2@quasisyntax-macro bf30a2@quasisyntax-macro) (set! bf30a4@define-struct-macro (lambda (bf3aa3@stx) (bf3192@syntax-violation '#f '"define-struct not supported" bf3aa3@stx))) (set! bf4bb7@bf30a4@define-struct-macro bf30a4@define-struct-macro) (set! bf30a6@define-record-type-macro (lambda (bf3aa5@x) (letrec* ((bf3aa8@id (lambda (bf3c9b@ctxt . bf3c9d@str*) (bf3196@datum->syntax bf3c9b@ctxt (string->symbol (apply string-append (map (lambda (bf3c9f@x) (if (symbol? bf3c9f@x) (symbol->string bf3c9f@x) (if (string? bf3c9f@x) bf3c9f@x (assertion-violation 'define-record-type '"BUG")))) bf3c9d@str*)))))) (bf3aaa@get-record-name (lambda (bf3c89@spec) (let ((bf3c8b@t bf3c89@spec)) (let ((bf3c8d@ls/false (bf30b2@syntax-dispatch bf3c8b@t '(any any any)))) (if bf3c8d@ls/false (apply (lambda (bf3c8f@foo bf3c90@make-foo bf3c91@foo?) bf3c8f@foo) bf3c8d@ls/false) (let ((bf3c95@t bf3c8b@t)) (let ((bf3c97@ls/false (bf30b2@syntax-dispatch bf3c95@t 'any))) (if bf3c97@ls/false (apply (lambda (bf3c99@foo) bf3c99@foo) bf3c97@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3c95@t))))))))) (bf3aac@get-record-constructor-name (lambda (bf3c75@spec) (let ((bf3c77@t bf3c75@spec)) (let ((bf3c79@ls/false (bf30b2@syntax-dispatch bf3c77@t '(any any any)))) (if bf3c79@ls/false (apply (lambda (bf3c7b@foo bf3c7c@make-foo bf3c7d@foo?) bf3c7c@make-foo) bf3c79@ls/false) (let ((bf3c81@t bf3c77@t)) (let ((bf3c83@ls/false (bf30b2@syntax-dispatch bf3c81@t 'any))) (if (and bf3c83@ls/false (apply (lambda (bf3c85@foo) (bf2eab@id? bf3c85@foo)) bf3c83@ls/false)) (apply (lambda (bf3c87@foo) (bf3aa8@id bf3c87@foo '"make-" (bf2ebf@stx->datum bf3c87@foo))) bf3c83@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3c81@t))))))))) (bf3aae@get-record-predicate-name (lambda (bf3c61@spec) (let ((bf3c63@t bf3c61@spec)) (let ((bf3c65@ls/false (bf30b2@syntax-dispatch bf3c63@t '(any any any)))) (if bf3c65@ls/false (apply (lambda (bf3c67@foo bf3c68@make-foo bf3c69@foo?) bf3c69@foo?) bf3c65@ls/false) (let ((bf3c6d@t bf3c63@t)) (let ((bf3c6f@ls/false (bf30b2@syntax-dispatch bf3c6d@t 'any))) (if (and bf3c6f@ls/false (apply (lambda (bf3c71@foo) (bf2eab@id? bf3c71@foo)) bf3c6f@ls/false)) (apply (lambda (bf3c73@foo) (bf3aa8@id bf3c73@foo (bf2ebf@stx->datum bf3c73@foo) '"?")) bf3c6f@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3c6d@t))))))))) (bf3ab0@get-clause (lambda (bf3c4f@id bf3c50@ls) (let ((bf3c53@t bf3c50@ls)) (let ((bf3c55@ls/false (bf30b2@syntax-dispatch bf3c53@t '()))) (if bf3c55@ls/false (apply (lambda () '#f) bf3c55@ls/false) (let ((bf3c57@t bf3c53@t)) (let ((bf3c59@ls/false (bf30b2@syntax-dispatch bf3c57@t '((any . any) . any)))) (if bf3c59@ls/false (apply (lambda (bf3c5b@x bf3c5c@rest bf3c5d@ls) (if (bf2eb1@free-id=? (bf3068@bless bf3c4f@id) bf3c5b@x) (cons bf3c5b@x bf3c5c@rest) (bf3ab0@get-clause bf3c4f@id bf3c5d@ls))) bf3c59@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3c57@t))))))))) (bf3ab2@foo-rtd-code (lambda (bf3bfd@name bf3bfe@clause* bf3bff@parent-rtd-code) (letrec* ((bf3c04@convert-field-spec* (lambda (bf3c35@ls) (list->vector (map (lambda (bf3c37@x) (let ((bf3c39@t bf3c37@x)) (let ((bf3c3b@ls/false (bf30b2@syntax-dispatch bf3c39@t '(#(scheme-id mutable) any . any)))) (if bf3c3b@ls/false (apply (lambda (bf3c3d@name bf3c3e@rest) (list 'mutable bf3c3d@name)) bf3c3b@ls/false) (let ((bf3c41@t bf3c39@t)) (let ((bf3c43@ls/false (bf30b2@syntax-dispatch bf3c41@t '(#(scheme-id immutable) any . any)))) (if bf3c43@ls/false (apply (lambda (bf3c45@name bf3c46@rest) (list 'immutable bf3c45@name)) bf3c43@ls/false) (let ((bf3c49@t bf3c41@t)) (let ((bf3c4b@ls/false (bf30b2@syntax-dispatch bf3c49@t 'any))) (if bf3c4b@ls/false (apply (lambda (bf3c4d@name) (list 'immutable bf3c4d@name)) bf3c4b@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3c49@t))))))))))) bf3c35@ls))))) (let ((bf3c05@uid-code (let ((bf3c0d@t (bf3ab0@get-clause 'nongenerative bf3bfe@clause*))) (let ((bf3c0f@ls/false (bf30b2@syntax-dispatch bf3c0d@t '(_)))) (if bf3c0f@ls/false (apply (lambda () (list 'quote (gensym))) bf3c0f@ls/false) (let ((bf3c11@t bf3c0d@t)) (let ((bf3c13@ls/false (bf30b2@syntax-dispatch bf3c11@t '(_ any)))) (if bf3c13@ls/false (apply (lambda (bf3c15@uid) (list 'quote bf3c15@uid)) bf3c13@ls/false) (let ((bf3c17@t bf3c11@t)) (let ((bf3c19@ls/false (bf30b2@syntax-dispatch bf3c17@t '_))) (if bf3c19@ls/false (apply (lambda () '#f) bf3c19@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3c17@t))))))))))) (bf3c06@sealed? (let ((bf3c1b@t (bf3ab0@get-clause 'sealed bf3bfe@clause*))) (let ((bf3c1d@ls/false (bf30b2@syntax-dispatch bf3c1b@t '(_ #(atom #t))))) (if bf3c1d@ls/false (apply (lambda () '#t) bf3c1d@ls/false) (let ((bf3c1f@t bf3c1b@t)) (let ((bf3c21@ls/false (bf30b2@syntax-dispatch bf3c1f@t '_))) (if bf3c21@ls/false (apply (lambda () '#f) bf3c21@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3c1f@t)))))))) (bf3c07@opaque? (let ((bf3c23@t (bf3ab0@get-clause 'opaque bf3bfe@clause*))) (let ((bf3c25@ls/false (bf30b2@syntax-dispatch bf3c23@t '(_ #(atom #t))))) (if bf3c25@ls/false (apply (lambda () '#t) bf3c25@ls/false) (let ((bf3c27@t bf3c23@t)) (let ((bf3c29@ls/false (bf30b2@syntax-dispatch bf3c27@t '_))) (if bf3c29@ls/false (apply (lambda () '#f) bf3c29@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3c27@t)))))))) (bf3c08@fields (let ((bf3c2b@t (bf3ab0@get-clause 'fields bf3bfe@clause*))) (let ((bf3c2d@ls/false (bf30b2@syntax-dispatch bf3c2b@t '(_ . each-any)))) (if bf3c2d@ls/false (apply (lambda (bf3c2f@field-spec*) (list 'quote (bf3c04@convert-field-spec* bf3c2f@field-spec*))) bf3c2d@ls/false) (let ((bf3c31@t bf3c2b@t)) (let ((bf3c33@ls/false (bf30b2@syntax-dispatch bf3c31@t '_))) (if bf3c33@ls/false (apply (lambda () ''#()) bf3c33@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3c31@t))))))))) (bf3068@bless (list 'make-record-type-descriptor (list 'quote bf3bfd@name) bf3bff@parent-rtd-code bf3c05@uid-code bf3c06@sealed? bf3c07@opaque? bf3c08@fields)))))) (bf3ab4@parent-rtd-code (lambda (bf3be5@clause*) (let ((bf3be7@t (bf3ab0@get-clause 'parent bf3be5@clause*))) (let ((bf3be9@ls/false (bf30b2@syntax-dispatch bf3be7@t '(_ any)))) (if bf3be9@ls/false (apply (lambda (bf3beb@name) (list 'record-type-descriptor bf3beb@name)) bf3be9@ls/false) (let ((bf3bed@t bf3be7@t)) (let ((bf3bef@ls/false (bf30b2@syntax-dispatch bf3bed@t '#(atom #f)))) (if bf3bef@ls/false (apply (lambda () (let ((bf3bf1@t (bf3ab0@get-clause 'parent-rtd bf3be5@clause*))) (let ((bf3bf3@ls/false (bf30b2@syntax-dispatch bf3bf1@t '(_ any any)))) (if bf3bf3@ls/false (apply (lambda (bf3bf5@rtd bf3bf6@rcd) bf3bf5@rtd) bf3bf3@ls/false) (let ((bf3bf9@t bf3bf1@t)) (let ((bf3bfb@ls/false (bf30b2@syntax-dispatch bf3bf9@t '#(atom #f)))) (if bf3bfb@ls/false (apply (lambda () '#f) bf3bfb@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3bf9@t)))))))) bf3bef@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3bed@t))))))))) (bf3ab6@parent-rcd-code (lambda (bf3bcd@clause*) (let ((bf3bcf@t (bf3ab0@get-clause 'parent bf3bcd@clause*))) (let ((bf3bd1@ls/false (bf30b2@syntax-dispatch bf3bcf@t '(_ any)))) (if bf3bd1@ls/false (apply (lambda (bf3bd3@name) (list 'record-constructor-descriptor bf3bd3@name)) bf3bd1@ls/false) (let ((bf3bd5@t bf3bcf@t)) (let ((bf3bd7@ls/false (bf30b2@syntax-dispatch bf3bd5@t '#(atom #f)))) (if bf3bd7@ls/false (apply (lambda () (let ((bf3bd9@t (bf3ab0@get-clause 'parent-rtd bf3bcd@clause*))) (let ((bf3bdb@ls/false (bf30b2@syntax-dispatch bf3bd9@t '(_ any any)))) (if bf3bdb@ls/false (apply (lambda (bf3bdd@rtd bf3bde@rcd) bf3bde@rcd) bf3bdb@ls/false) (let ((bf3be1@t bf3bd9@t)) (let ((bf3be3@ls/false (bf30b2@syntax-dispatch bf3be1@t '#(atom #f)))) (if bf3be3@ls/false (apply (lambda () '#f) bf3be3@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3be1@t)))))))) bf3bd7@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3bd5@t))))))))) (bf3ab8@foo-rcd-code (lambda (bf3bc5@clause* bf3bc6@foo-rtd bf3bc7@protocol bf3bc8@parent-rcd-code) (list 'make-record-constructor-descriptor bf3bc6@foo-rtd bf3bc8@parent-rcd-code bf3bc7@protocol))) (bf3aba@get-protocol-code (lambda (bf3bb9@clause*) (let ((bf3bbb@t (bf3ab0@get-clause 'protocol bf3bb9@clause*))) (let ((bf3bbd@ls/false (bf30b2@syntax-dispatch bf3bbb@t '(_ any)))) (if bf3bbd@ls/false (apply (lambda (bf3bbf@expr) bf3bbf@expr) bf3bbd@ls/false) (let ((bf3bc1@t bf3bbb@t)) (let ((bf3bc3@ls/false (bf30b2@syntax-dispatch bf3bc1@t '_))) (if bf3bc3@ls/false (apply (lambda () '#f) bf3bc3@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3bc1@t))))))))) (bf3abc@get-fields (lambda (bf3ba7@clause*) (let ((bf3ba9@t bf3ba7@clause*)) (let ((bf3bab@ls/false (bf30b2@syntax-dispatch bf3ba9@t '()))) (if bf3bab@ls/false (apply (lambda () '()) bf3bab@ls/false) (let ((bf3bad@t bf3ba9@t)) (let ((bf3baf@ls/false (bf30b2@syntax-dispatch bf3bad@t '((#(scheme-id fields) . each-any) . _)))) (if bf3baf@ls/false (apply (lambda (bf3bb1@f*) bf3bb1@f*) bf3baf@ls/false) (let ((bf3bb3@t bf3bad@t)) (let ((bf3bb5@ls/false (bf30b2@syntax-dispatch bf3bb3@t '(_ . any)))) (if bf3bb5@ls/false (apply (lambda (bf3bb7@rest) (bf3abc@get-fields bf3bb7@rest)) bf3bb5@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3bb3@t)))))))))))) (bf3abe@get-mutator-indices (lambda (bf3b8f@fields) (let bf3b95@f ((bf3b91@fields bf3b8f@fields) (bf3b92@i '0)) (let ((bf3b97@t bf3b91@fields)) (let ((bf3b99@ls/false (bf30b2@syntax-dispatch bf3b97@t '()))) (if bf3b99@ls/false (apply (lambda () '()) bf3b99@ls/false) (let ((bf3b9b@t bf3b97@t)) (let ((bf3b9d@ls/false (bf30b2@syntax-dispatch bf3b9b@t '((#(scheme-id mutable) . _) . any)))) (if bf3b9d@ls/false (apply (lambda (bf3b9f@rest) (cons bf3b92@i (bf3b95@f bf3b9f@rest (+ bf3b92@i '1)))) bf3b9d@ls/false) (let ((bf3ba1@t bf3b9b@t)) (let ((bf3ba3@ls/false (bf30b2@syntax-dispatch bf3ba1@t '(_ . any)))) (if bf3ba3@ls/false (apply (lambda (bf3ba5@rest) (bf3b95@f bf3ba5@rest (+ bf3b92@i '1))) bf3ba3@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3ba1@t))))))))))))) (bf3ac0@get-mutators (lambda (bf3b65@foo bf3b66@fields) (letrec* ((bf3b6a@gen-name (lambda (bf3b8d@x) (bf3196@datum->syntax bf3b65@foo (string->symbol (string-append (symbol->string (bf3198@syntax->datum bf3b65@foo)) '"-" (symbol->string (bf3198@syntax->datum bf3b8d@x)) '"-set!")))))) (let bf3b6d@f ((bf3b6b@fields bf3b66@fields)) (let ((bf3b6f@t bf3b6b@fields)) (let ((bf3b71@ls/false (bf30b2@syntax-dispatch bf3b6f@t '()))) (if bf3b71@ls/false (apply (lambda () '()) bf3b71@ls/false) (let ((bf3b73@t bf3b6f@t)) (let ((bf3b75@ls/false (bf30b2@syntax-dispatch bf3b73@t '((#(scheme-id mutable) any any any) . any)))) (if bf3b75@ls/false (apply (lambda (bf3b77@name bf3b78@accessor bf3b79@mutator bf3b7a@rest) (cons bf3b79@mutator (bf3b6d@f bf3b7a@rest))) bf3b75@ls/false) (let ((bf3b7f@t bf3b73@t)) (let ((bf3b81@ls/false (bf30b2@syntax-dispatch bf3b7f@t '((#(scheme-id mutable) any) . any)))) (if bf3b81@ls/false (apply (lambda (bf3b83@name bf3b84@rest) (cons (bf3b6a@gen-name bf3b83@name) (bf3b6d@f bf3b84@rest))) bf3b81@ls/false) (let ((bf3b87@t bf3b7f@t)) (let ((bf3b89@ls/false (bf30b2@syntax-dispatch bf3b87@t '(_ . any)))) (if bf3b89@ls/false (apply (lambda (bf3b8b@rest) (bf3b6d@f bf3b8b@rest)) bf3b89@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3b87@t))))))))))))))))) (bf3ac2@get-accessors (lambda (bf3b21@foo bf3b22@fields) (letrec* ((bf3b26@gen-name (lambda (bf3b63@x) (bf3196@datum->syntax bf3b21@foo (string->symbol (string-append (symbol->string (bf3198@syntax->datum bf3b21@foo)) '"-" (symbol->string (bf3198@syntax->datum bf3b63@x)))))))) (map (lambda (bf3b27@field) (let ((bf3b29@t bf3b27@field)) (let ((bf3b2b@ls/false (bf30b2@syntax-dispatch bf3b29@t '(#(scheme-id mutable) any any any)))) (if (and bf3b2b@ls/false (apply (lambda (bf3b2d@name bf3b2e@accessor bf3b2f@mutator) (bf2eab@id? bf3b2e@accessor)) bf3b2b@ls/false)) (apply (lambda (bf3b33@name bf3b34@accessor bf3b35@mutator) bf3b34@accessor) bf3b2b@ls/false) (let ((bf3b39@t bf3b29@t)) (let ((bf3b3b@ls/false (bf30b2@syntax-dispatch bf3b39@t '(#(scheme-id immutable) any any)))) (if (and bf3b3b@ls/false (apply (lambda (bf3b3d@name bf3b3e@accessor) (bf2eab@id? bf3b3e@accessor)) bf3b3b@ls/false)) (apply (lambda (bf3b41@name bf3b42@accessor) bf3b42@accessor) bf3b3b@ls/false) (let ((bf3b45@t bf3b39@t)) (let ((bf3b47@ls/false (bf30b2@syntax-dispatch bf3b45@t '(#(scheme-id mutable) any)))) (if (and bf3b47@ls/false (apply (lambda (bf3b49@name) (bf2eab@id? bf3b49@name)) bf3b47@ls/false)) (apply (lambda (bf3b4b@name) (bf3b26@gen-name bf3b4b@name)) bf3b47@ls/false) (let ((bf3b4d@t bf3b45@t)) (let ((bf3b4f@ls/false (bf30b2@syntax-dispatch bf3b4d@t '(#(scheme-id immutable) any)))) (if (and bf3b4f@ls/false (apply (lambda (bf3b51@name) (bf2eab@id? bf3b51@name)) bf3b4f@ls/false)) (apply (lambda (bf3b53@name) (bf3b26@gen-name bf3b53@name)) bf3b4f@ls/false) (let ((bf3b55@t bf3b4d@t)) (let ((bf3b57@ls/false (bf30b2@syntax-dispatch bf3b55@t 'any))) (if (and bf3b57@ls/false (apply (lambda (bf3b59@name) (bf2eab@id? bf3b59@name)) bf3b57@ls/false)) (apply (lambda (bf3b5b@name) (bf3b26@gen-name bf3b5b@name)) bf3b57@ls/false) (let ((bf3b5d@t bf3b55@t)) (let ((bf3b5f@ls/false (bf30b2@syntax-dispatch bf3b5d@t 'any))) (if bf3b5f@ls/false (apply (lambda (bf3b61@others) (bf3192@syntax-violation '#f '"invalid field spec" bf3b27@field)) bf3b5f@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3b5d@t)))))))))))))))))))) bf3b22@fields)))) (bf3ac4@enumerate (lambda (bf3b19@ls) (let bf3b1f@f ((bf3b1b@ls bf3b19@ls) (bf3b1c@i '0)) (if (null? bf3b1b@ls) '() (cons bf3b1c@i (bf3b1f@f (cdr bf3b1b@ls) (+ bf3b1c@i '1))))))) (bf3ac6@do-define-record (lambda (bf3af1@namespec bf3af2@clause*) (let ((bf3af5@foo (bf3aaa@get-record-name bf3af1@namespec))) (let ((bf3af7@foo-rtd (gensym))) (let ((bf3af9@foo-rcd (gensym))) (let ((bf3afb@protocol (gensym))) (let ((bf3afd@make-foo (bf3aac@get-record-constructor-name bf3af1@namespec))) (let ((bf3aff@fields (bf3abc@get-fields bf3af2@clause*))) (let ((bf3b01@idx* (bf3ac4@enumerate bf3aff@fields))) (let ((bf3b03@foo-x* (bf3ac2@get-accessors bf3af5@foo bf3aff@fields))) (let ((bf3b05@set-foo-x!* (bf3ac0@get-mutators bf3af5@foo bf3aff@fields))) (let ((bf3b07@set-foo-idx* (bf3abe@get-mutator-indices bf3aff@fields))) (let ((bf3b09@foo? (bf3aae@get-record-predicate-name bf3af1@namespec))) (let ((bf3b0b@foo-rtd-code (bf3ab2@foo-rtd-code bf3af5@foo bf3af2@clause* (bf3ab4@parent-rtd-code bf3af2@clause*)))) (let ((bf3b0d@foo-rcd-code (bf3ab8@foo-rcd-code bf3af2@clause* bf3af7@foo-rtd bf3afb@protocol (bf3ab6@parent-rcd-code bf3af2@clause*)))) (let ((bf3b0f@protocol-code (bf3aba@get-protocol-code bf3af2@clause*))) (bf3068@bless (cons 'begin (cons (list 'define bf3af7@foo-rtd bf3b0b@foo-rtd-code) (cons (list 'define bf3afb@protocol bf3b0f@protocol-code) (cons (list 'define bf3af9@foo-rcd bf3b0d@foo-rcd-code) (cons (list 'define-syntax bf3af5@foo (list 'list ''$rtd (list 'syntax bf3af7@foo-rtd) (list 'syntax bf3af9@foo-rcd))) (cons (list 'define bf3b09@foo? (list 'record-predicate bf3af7@foo-rtd)) (cons (list 'define bf3afd@make-foo (list 'record-constructor bf3af9@foo-rcd)) (append (map (lambda (bf3b11@foo-x bf3b12@idx) (list 'define bf3b11@foo-x (list 'record-accessor bf3af7@foo-rtd bf3b12@idx))) bf3b03@foo-x* bf3b01@idx*) (map (lambda (bf3b15@set-foo-x! bf3b16@idx) (list 'define bf3b15@set-foo-x! (list 'record-mutator bf3af7@foo-rtd bf3b16@idx))) bf3b05@set-foo-x!* bf3b07@set-foo-idx*)))))))))))))))))))))))))) (bf3ac8@verify-clauses (lambda (bf3ad1@x bf3ad2@cls*) (letrec* ((bf3ad6@valid-kwds (map bf3068@bless '(fields parent parent-rtd protocol sealed opaque nongenerative))) (bf3ad8@free-id-member? (lambda (bf3aed@x bf3aee@ls) (and (pair? bf3aee@ls) (or (bf2eb1@free-id=? bf3aed@x (car bf3aee@ls)) (bf3ad8@free-id-member? bf3aed@x (cdr bf3aee@ls))))))) (let bf3add@f ((bf3ad9@cls* bf3ad2@cls*) (bf3ada@seen* '())) (if (not (null? bf3ad9@cls*)) (let ((bf3adf@t (car bf3ad9@cls*))) (let ((bf3ae1@ls/false (bf30b2@syntax-dispatch bf3adf@t '(any . any)))) (if bf3ae1@ls/false (apply (lambda (bf3ae3@kwd bf3ae4@rest) (if (or (not (bf2eab@id? bf3ae3@kwd)) (not (bf3ad8@free-id-member? bf3ae3@kwd bf3ad6@valid-kwds))) (bf3192@syntax-violation '#f '"not a valid define-record-type keyword" bf3ae3@kwd) (if (bf2eb7@bound-id-member? bf3ae3@kwd bf3ada@seen*) (bf3192@syntax-violation '#f '"duplicate use of keyword " bf3ad1@x bf3ae3@kwd) (bf3add@f (cdr bf3ad9@cls*) (cons bf3ae3@kwd bf3ada@seen*))))) bf3ae1@ls/false) (let ((bf3ae7@t bf3adf@t)) (let ((bf3ae9@ls/false (bf30b2@syntax-dispatch bf3ae7@t 'any))) (if bf3ae9@ls/false (apply (lambda (bf3aeb@cls) (bf3192@syntax-violation '#f '"malformed define-record-type clause" bf3aeb@cls)) bf3ae9@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3ae7@t))))))) (void))))))) (let ((bf3ac9@t bf3aa5@x)) (let ((bf3acb@ls/false (bf30b2@syntax-dispatch bf3ac9@t '(_ any . each-any)))) (if bf3acb@ls/false (apply (lambda (bf3acd@namespec bf3ace@clause*) (begin (bf3ac8@verify-clauses bf3aa5@x bf3ace@clause*) (bf3ac6@do-define-record bf3acd@namespec bf3ace@clause*))) bf3acb@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3ac9@t))))))) (set! bf4bb8@bf30a6@define-record-type-macro bf30a6@define-record-type-macro) (set! bf30a8@define-condition-type-macro (lambda (bf3ca1@x) (letrec* ((bf3ca4@mkname (lambda (bf3cd1@name bf3cd2@suffix) (bf3196@datum->syntax bf3cd1@name (string->symbol (string-append (symbol->string (bf3198@syntax->datum bf3cd1@name)) bf3cd2@suffix)))))) (let ((bf3ca5@t bf3ca1@x)) (let ((bf3ca7@ls/false (bf30b2@syntax-dispatch bf3ca5@t '(any any any any any . #(each (any any)))))) (if (and bf3ca7@ls/false (apply (lambda (bf3ca9@ctxt bf3caa@name bf3cab@super bf3cac@constructor bf3cad@predicate bf3cae@field* bf3caf@accessor*) (and (bf2eab@id? bf3caa@name) (bf2eab@id? bf3cab@super) (bf2eab@id? bf3cac@constructor) (bf2eab@id? bf3cad@predicate) (for-all bf2eab@id? bf3cae@field*) (for-all bf2eab@id? bf3caf@accessor*))) bf3ca7@ls/false)) (apply (lambda (bf3cb7@ctxt bf3cb8@name bf3cb9@super bf3cba@constructor bf3cbb@predicate bf3cbc@field* bf3cbd@accessor*) (let ((bf3cc5@aux-accessor* (map (lambda (bf3cc7@x) (gensym)) bf3cbd@accessor*))) (bf3068@bless (cons 'begin (cons (cons 'define-record-type (cons (list bf3cb8@name bf3cba@constructor (gensym)) (cons (list 'parent bf3cb9@super) (cons (cons 'fields (map (lambda (bf3cc9@field bf3cca@aux) (list 'immutable bf3cc9@field bf3cca@aux)) bf3cbc@field* bf3cc5@aux-accessor*)) '((nongenerative) (sealed #f) (opaque #f)))))) (cons (list 'define bf3cbb@predicate (list 'condition-predicate (list 'record-type-descriptor bf3cb8@name))) (map (lambda (bf3ccd@accessor bf3cce@aux) (list 'define bf3ccd@accessor (list 'condition-accessor (list 'record-type-descriptor bf3cb8@name) bf3cce@aux))) bf3cbd@accessor* bf3cc5@aux-accessor*))))))) bf3ca7@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3ca5@t))))))) (set! bf4bb9@bf30a8@define-condition-type-macro bf30a8@define-condition-type-macro) (set! bf30aa@incorrect-usage-macro (lambda (bf3cd5@e) (bf3192@syntax-violation '#f '"incorrect usage of auxiliary keyword" bf3cd5@e))) (set! bf4bba@bf30aa@incorrect-usage-macro bf30aa@incorrect-usage-macro) (set! bf30ac@parameterize-macro (lambda (bf3cd7@e) (let ((bf3cd9@t bf3cd7@e)) (let ((bf3cdb@ls/false (bf30b2@syntax-dispatch bf3cd9@t '(_ () any . each-any)))) (if bf3cdb@ls/false (apply (lambda (bf3cdd@b bf3cde@b*) (bf3068@bless (cons 'let (cons '() (cons bf3cdd@b bf3cde@b*))))) bf3cdb@ls/false) (let ((bf3ce1@t bf3cd9@t)) (let ((bf3ce3@ls/false (bf30b2@syntax-dispatch bf3ce1@t '(_ #(each (any any)) any . each-any)))) (if bf3ce3@ls/false (apply (lambda (bf3ce5@olhs* bf3ce6@orhs* bf3ce7@b bf3ce8@b*) (let ((bf3ced@lhs* (bf3180@generate-temporaries bf3ce5@olhs*)) (bf3cee@rhs* (bf3180@generate-temporaries bf3ce6@orhs*))) (bf3068@bless (cons (list 'lambda (append bf3ced@lhs* bf3cee@rhs*) (list 'let (list (list 'swap (cons 'lambda (cons '() (map (lambda (bf3cf1@lhs bf3cf2@rhs) (list 'let (list (list 't (list bf3cf1@lhs))) (list bf3cf1@lhs bf3cf2@rhs) (cons 'set! (cons bf3cf2@rhs '(t))))) bf3ced@lhs* bf3cee@rhs*))))) (cons 'dynamic-wind (cons 'swap (cons (cons 'lambda (cons '() (cons bf3ce7@b bf3ce8@b*))) '(swap)))))) (append bf3ce5@olhs* bf3ce6@orhs*))))) bf3ce3@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3ce1@t))))))))) (set! bf4bbb@bf30ac@parameterize-macro bf30ac@parameterize-macro) (set! bf30ae@foreign-call-transformer (lambda (bf3cf5@e bf3cf6@r bf3cf7@mr) (let ((bf3cfb@t bf3cf5@e)) (let ((bf3cfd@ls/false (bf30b2@syntax-dispatch bf3cfb@t '(_ any . each-any)))) (if bf3cfd@ls/false (apply (lambda (bf3cff@name bf3d00@arg*) (cons 'foreign-call (cons (bf30d4@chi-expr bf3cff@name bf3cf6@r bf3cf7@mr) (bf30d0@chi-expr* bf3d00@arg* bf3cf6@r bf3cf7@mr)))) bf3cfd@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3cfb@t)))))) (set! bf4bbc@bf30ae@foreign-call-transformer bf30ae@foreign-call-transformer) (set! bf30b0@convert-pattern (lambda (bf3d03@pattern bf3d04@keys) (letrec* ((bf3d08@cvt* (lambda (bf3da7@p* bf3da8@n bf3da9@ids) (if (null? bf3da7@p*) (values '() bf3da9@ids) (call-with-values (lambda () (bf3d08@cvt* (cdr bf3da7@p*) bf3da8@n bf3da9@ids)) (lambda (bf3db1@bf3dae bf3db2@bf3db0) (let ((bf3db5@ids bf3db2@bf3db0) (bf3db6@y bf3db1@bf3dae)) (call-with-values (lambda () (bf3d0a@cvt (car bf3da7@p*) bf3da8@n bf3db5@ids)) (lambda (bf3dbd@bf3dba bf3dbe@bf3dbc) (let ((bf3dc1@ids bf3dbe@bf3dbc) (bf3dc2@x bf3dbd@bf3dba)) (values (cons bf3dc2@x bf3db6@y) bf3dc1@ids)))))))))) (bf3d0a@cvt (lambda (bf3d0b@p bf3d0c@n bf3d0d@ids) (let ((bf3d11@t bf3d0b@p)) (let ((bf3d13@ls/false (bf30b2@syntax-dispatch bf3d11@t 'any))) (if (and bf3d13@ls/false (apply (lambda (bf3d15@id) (bf2eab@id? bf3d15@id)) bf3d13@ls/false)) (apply (lambda (bf3d17@id) (if (bf2eb7@bound-id-member? bf3d0b@p bf3d04@keys) (values (vector 'free-id bf3d0b@p) bf3d0d@ids) (if (bf2eb1@free-id=? bf3d0b@p (bf303a@scheme-stx '_)) (values '_ bf3d0d@ids) (values 'any (cons (cons bf3d0b@p bf3d0c@n) bf3d0d@ids))))) bf3d13@ls/false) (let ((bf3d19@t bf3d11@t)) (let ((bf3d1b@ls/false (bf30b2@syntax-dispatch bf3d19@t '(any any)))) (if (and bf3d1b@ls/false (apply (lambda (bf3d1d@p bf3d1e@dots) (bf30b4@ellipsis? bf3d1e@dots)) bf3d1b@ls/false)) (apply (lambda (bf3d21@p bf3d22@dots) (call-with-values (lambda () (bf3d0a@cvt bf3d21@p (+ bf3d0c@n '1) bf3d0d@ids)) (lambda (bf3d29@bf3d26 bf3d2a@bf3d28) (let ((bf3d2d@ids bf3d2a@bf3d28) (bf3d2e@p bf3d29@bf3d26)) (values (if (eq? bf3d2e@p 'any) 'each-any (vector 'each bf3d2e@p)) bf3d2d@ids))))) bf3d1b@ls/false) (let ((bf3d31@t bf3d19@t)) (let ((bf3d33@ls/false (bf30b2@syntax-dispatch bf3d31@t '(any any . #(each+ any () any))))) (if (and bf3d33@ls/false (apply (lambda (bf3d35@x bf3d36@dots bf3d37@ys bf3d38@z) (bf30b4@ellipsis? bf3d36@dots)) bf3d33@ls/false)) (apply (lambda (bf3d3d@x bf3d3e@dots bf3d3f@ys bf3d40@z) (call-with-values (lambda () (bf3d0a@cvt bf3d40@z bf3d0c@n bf3d0d@ids)) (lambda (bf3d49@bf3d46 bf3d4a@bf3d48) (let ((bf3d4d@ids bf3d4a@bf3d48) (bf3d4e@z bf3d49@bf3d46)) (call-with-values (lambda () (bf3d08@cvt* bf3d3f@ys bf3d0c@n bf3d4d@ids)) (lambda (bf3d55@bf3d52 bf3d56@bf3d54) (let ((bf3d59@ids bf3d56@bf3d54) (bf3d5a@ys bf3d55@bf3d52)) (call-with-values (lambda () (bf3d0a@cvt bf3d3d@x (+ bf3d0c@n '1) bf3d59@ids)) (lambda (bf3d61@bf3d5e bf3d62@bf3d60) (let ((bf3d65@ids bf3d62@bf3d60) (bf3d66@x bf3d61@bf3d5e)) (values (vector 'each+ bf3d66@x (reverse bf3d5a@ys) bf3d4e@z) bf3d65@ids))))))))))) bf3d33@ls/false) (let ((bf3d69@t bf3d31@t)) (let ((bf3d6b@ls/false (bf30b2@syntax-dispatch bf3d69@t '(any . any)))) (if bf3d6b@ls/false (apply (lambda (bf3d6d@x bf3d6e@y) (call-with-values (lambda () (bf3d0a@cvt bf3d6e@y bf3d0c@n bf3d0d@ids)) (lambda (bf3d75@bf3d72 bf3d76@bf3d74) (let ((bf3d79@ids bf3d76@bf3d74) (bf3d7a@y bf3d75@bf3d72)) (call-with-values (lambda () (bf3d0a@cvt bf3d6d@x bf3d0c@n bf3d79@ids)) (lambda (bf3d81@bf3d7e bf3d82@bf3d80) (let ((bf3d85@ids bf3d82@bf3d80) (bf3d86@x bf3d81@bf3d7e)) (values (cons bf3d86@x bf3d7a@y) bf3d85@ids)))))))) bf3d6b@ls/false) (let ((bf3d89@t bf3d69@t)) (let ((bf3d8b@ls/false (bf30b2@syntax-dispatch bf3d89@t '()))) (if bf3d8b@ls/false (apply (lambda () (values '() bf3d0d@ids)) bf3d8b@ls/false) (let ((bf3d8d@t bf3d89@t)) (let ((bf3d8f@ls/false (bf30b2@syntax-dispatch bf3d8d@t '#(vector each-any)))) (if (and bf3d8f@ls/false (apply (lambda (bf3d91@p) (not (bf2e77@stx? bf3d91@p))) bf3d8f@ls/false)) (apply (lambda (bf3d93@p) (call-with-values (lambda () (bf3d0a@cvt bf3d93@p bf3d0c@n bf3d0d@ids)) (lambda (bf3d99@bf3d96 bf3d9a@bf3d98) (let ((bf3d9d@ids bf3d9a@bf3d98) (bf3d9e@p bf3d99@bf3d96)) (values (vector 'vector bf3d9e@p) bf3d9d@ids))))) bf3d8f@ls/false) (let ((bf3da1@t bf3d8d@t)) (let ((bf3da3@ls/false (bf30b2@syntax-dispatch bf3da1@t 'any))) (if bf3da3@ls/false (apply (lambda (bf3da5@datum) (values (vector 'atom (bf2ebf@stx->datum bf3da5@datum)) bf3d0d@ids)) bf3da3@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3da1@t))))))))))))))))))))))))) (bf3d0a@cvt bf3d03@pattern '0 '())))) (set! bf4bbd@bf30b0@convert-pattern bf30b0@convert-pattern) (set! bf30b2@syntax-dispatch (letrec* ((bf3dc6@stx^ (lambda (bf3ea1@e bf3ea2@m* bf3ea3@s* bf3ea4@ae*) (if (and (null? bf3ea2@m*) (null? bf3ea3@s*) (null? bf3ea4@ae*)) bf3ea1@e (bf2e93@mkstx bf3ea1@e bf3ea2@m* bf3ea3@s* bf3ea4@ae*)))) (bf3dc8@match-each (lambda (bf3e81@e bf3e82@p bf3e83@m* bf3e84@s* bf3e85@ae*) (if (pair? bf3e81@e) (let ((bf3e8b@first (bf3dd4@match (car bf3e81@e) bf3e82@p bf3e83@m* bf3e84@s* bf3e85@ae* '()))) (and bf3e8b@first (let ((bf3e8d@rest (bf3dc8@match-each (cdr bf3e81@e) bf3e82@p bf3e83@m* bf3e84@s* bf3e85@ae*))) (and bf3e8d@rest (cons bf3e8b@first bf3e8d@rest))))) (if (null? bf3e81@e) '() (if (bf2e77@stx? bf3e81@e) (and (not (bf2e31@top-marked? bf3e83@m*)) (call-with-values (lambda () (join-wraps bf3e83@m* bf3e84@s* bf3e85@ae* bf3e81@e)) (lambda (bf3e95@bf3e90 bf3e96@bf3e92 bf3e97@bf3e94) (let ((bf3e9b@ae* bf3e97@bf3e94) (bf3e9c@s* bf3e96@bf3e92) (bf3e9d@m* bf3e95@bf3e90)) (bf3dc8@match-each (bf2e79@stx-expr bf3e81@e) bf3e82@p bf3e9d@m* bf3e9c@s* bf3e9b@ae*))))) (if (bf29ef@bf28c1@annotation? bf3e81@e) (bf3dc8@match-each (bf29f1@bf28c5@annotation-expression bf3e81@e) bf3e82@p bf3e83@m* bf3e84@s* bf3e85@ae*) '#f)))))) (bf3dca@match-each+ (lambda (bf3e41@e bf3e42@x-pat bf3e43@y-pat bf3e44@z-pat bf3e45@m* bf3e46@s* bf3e47@ae* bf3e48@r) (let bf3e59@f ((bf3e51@e bf3e41@e) (bf3e52@m* bf3e45@m*) (bf3e53@s* bf3e46@s*) (bf3e54@ae* bf3e47@ae*)) (if (pair? bf3e51@e) (call-with-values (lambda () (bf3e59@f (cdr bf3e51@e) bf3e52@m* bf3e53@s* bf3e54@ae*)) (lambda (bf3e61@bf3e5c bf3e62@bf3e5e bf3e63@bf3e60) (let ((bf3e67@r bf3e63@bf3e60) (bf3e68@y-pat bf3e62@bf3e5e) (bf3e69@xr* bf3e61@bf3e5c)) (if bf3e67@r (if (null? bf3e68@y-pat) (let ((bf3e6d@xr (bf3dd4@match (car bf3e51@e) bf3e42@x-pat bf3e52@m* bf3e53@s* bf3e54@ae* '()))) (if bf3e6d@xr (values (cons bf3e6d@xr bf3e69@xr*) bf3e68@y-pat bf3e67@r) (values '#f '#f '#f))) (values '() (cdr bf3e68@y-pat) (bf3dd4@match (car bf3e51@e) (car bf3e68@y-pat) bf3e52@m* bf3e53@s* bf3e54@ae* bf3e67@r))) (values '#f '#f '#f))))) (if (bf2e77@stx? bf3e51@e) (if (bf2e31@top-marked? bf3e52@m*) (values '() bf3e43@y-pat (bf3dd4@match bf3e51@e bf3e44@z-pat bf3e52@m* bf3e53@s* bf3e54@ae* bf3e48@r)) (call-with-values (lambda () (join-wraps bf3e52@m* bf3e53@s* bf3e54@ae* bf3e51@e)) (lambda (bf3e75@bf3e70 bf3e76@bf3e72 bf3e77@bf3e74) (let ((bf3e7b@ae* bf3e77@bf3e74) (bf3e7c@s* bf3e76@bf3e72) (bf3e7d@m* bf3e75@bf3e70)) (bf3e59@f (bf2e79@stx-expr bf3e51@e) bf3e7d@m* bf3e7c@s* bf3e7b@ae*))))) (if (bf29ef@bf28c1@annotation? bf3e51@e) (bf3e59@f (bf29f1@bf28c5@annotation-expression bf3e51@e) bf3e52@m* bf3e53@s* bf3e54@ae*) (values '() bf3e43@y-pat (bf3dd4@match bf3e51@e bf3e44@z-pat bf3e52@m* bf3e53@s* bf3e54@ae* bf3e48@r)))))))) (bf3dcc@match-each-any (lambda (bf3e25@e bf3e26@m* bf3e27@s* bf3e28@ae*) (if (pair? bf3e25@e) (let ((bf3e2d@l (bf3dcc@match-each-any (cdr bf3e25@e) bf3e26@m* bf3e27@s* bf3e28@ae*))) (and bf3e2d@l (cons (bf3dc6@stx^ (car bf3e25@e) bf3e26@m* bf3e27@s* bf3e28@ae*) bf3e2d@l))) (if (null? bf3e25@e) '() (if (bf2e77@stx? bf3e25@e) (and (not (bf2e31@top-marked? bf3e26@m*)) (call-with-values (lambda () (join-wraps bf3e26@m* bf3e27@s* bf3e28@ae* bf3e25@e)) (lambda (bf3e35@bf3e30 bf3e36@bf3e32 bf3e37@bf3e34) (let ((bf3e3b@ae* bf3e37@bf3e34) (bf3e3c@s* bf3e36@bf3e32) (bf3e3d@m* bf3e35@bf3e30)) (bf3dcc@match-each-any (bf2e79@stx-expr bf3e25@e) bf3e3d@m* bf3e3c@s* bf3e3b@ae*))))) (if (bf29ef@bf28c1@annotation? bf3e25@e) (bf3dcc@match-each-any (bf29f1@bf28c5@annotation-expression bf3e25@e) bf3e26@m* bf3e27@s* bf3e28@ae*) '#f)))))) (bf3dce@match-empty (lambda (bf3e1f@p bf3e20@r) (if (null? bf3e1f@p) bf3e20@r (if (eq? bf3e1f@p '_) bf3e20@r (if (eq? bf3e1f@p 'any) (cons '() bf3e20@r) (if (pair? bf3e1f@p) (bf3dce@match-empty (car bf3e1f@p) (bf3dce@match-empty (cdr bf3e1f@p) bf3e20@r)) (if (eq? bf3e1f@p 'each-any) (cons '() bf3e20@r) (let ((bf3e23@t (vector-ref bf3e1f@p '0))) (if (memv bf3e23@t '(each)) (bf3dce@match-empty (vector-ref bf3e1f@p '1) bf3e20@r) (if (memv bf3e23@t '(each+)) (bf3dce@match-empty (vector-ref bf3e1f@p '1) (bf3dce@match-empty (reverse (vector-ref bf3e1f@p '2)) (bf3dce@match-empty (vector-ref bf3e1f@p '3) bf3e20@r))) (if (memv bf3e23@t '(free-id atom)) bf3e20@r (if (memv bf3e23@t '(scheme-id atom)) bf3e20@r (if (memv bf3e23@t '(vector)) (bf3dce@match-empty (vector-ref bf3e1f@p '1) bf3e20@r) (assertion-violation 'syntax-dispatch '"invalid pattern" bf3e1f@p)))))))))))))) (bf3dd0@combine (lambda (bf3e1b@r* bf3e1c@r) (if (null? (car bf3e1b@r*)) bf3e1c@r (cons (map car bf3e1b@r*) (bf3dd0@combine (map cdr bf3e1b@r*) bf3e1c@r))))) (bf3dd2@match* (lambda (bf3df7@e bf3df8@p bf3df9@m* bf3dfa@s* bf3dfb@ae* bf3dfc@r) (if (null? bf3df8@p) (and (null? bf3df7@e) bf3dfc@r) (if (pair? bf3df8@p) (and (pair? bf3df7@e) (bf3dd4@match (car bf3df7@e) (car bf3df8@p) bf3df9@m* bf3dfa@s* bf3dfb@ae* (bf3dd4@match (cdr bf3df7@e) (cdr bf3df8@p) bf3df9@m* bf3dfa@s* bf3dfb@ae* bf3dfc@r))) (if (eq? bf3df8@p 'each-any) (let ((bf3e03@l (bf3dcc@match-each-any bf3df7@e bf3df9@m* bf3dfa@s* bf3dfb@ae*))) (and bf3e03@l (cons bf3e03@l bf3dfc@r))) (let ((bf3e05@t (vector-ref bf3df8@p '0))) (if (memv bf3e05@t '(each)) (if (null? bf3df7@e) (bf3dce@match-empty (vector-ref bf3df8@p '1) bf3dfc@r) (let ((bf3e07@r* (bf3dc8@match-each bf3df7@e (vector-ref bf3df8@p '1) bf3df9@m* bf3dfa@s* bf3dfb@ae*))) (and bf3e07@r* (bf3dd0@combine bf3e07@r* bf3dfc@r)))) (if (memv bf3e05@t '(free-id)) (and (symbol? bf3df7@e) (bf2e31@top-marked? bf3df9@m*) (bf2eb1@free-id=? (bf3dc6@stx^ bf3df7@e bf3df9@m* bf3dfa@s* bf3dfb@ae*) (vector-ref bf3df8@p '1)) bf3dfc@r) (if (memv bf3e05@t '(scheme-id)) (and (symbol? bf3df7@e) (bf2e31@top-marked? bf3df9@m*) (bf2eb1@free-id=? (bf3dc6@stx^ bf3df7@e bf3df9@m* bf3dfa@s* bf3dfb@ae*) (bf303a@scheme-stx (vector-ref bf3df8@p '1))) bf3dfc@r) (if (memv bf3e05@t '(each+)) (call-with-values (lambda () (bf3dca@match-each+ bf3df7@e (vector-ref bf3df8@p '1) (vector-ref bf3df8@p '2) (vector-ref bf3df8@p '3) bf3df9@m* bf3dfa@s* bf3dfb@ae* bf3dfc@r)) (lambda (bf3e0f@bf3e0a bf3e10@bf3e0c bf3e11@bf3e0e) (let ((bf3e15@r bf3e11@bf3e0e) (bf3e16@y-pat bf3e10@bf3e0c) (bf3e17@xr* bf3e0f@bf3e0a)) (and bf3e15@r (null? bf3e16@y-pat) (if (null? bf3e17@xr*) (bf3dce@match-empty (vector-ref bf3df8@p '1) bf3e15@r) (bf3dd0@combine bf3e17@xr* bf3e15@r)))))) (if (memv bf3e05@t '(atom)) (and (fast-equal? (vector-ref bf3df8@p '1) (bf2ebd@strip bf3df7@e bf3df9@m*)) bf3dfc@r) (if (memv bf3e05@t '(vector)) (and (vector? bf3df7@e) (bf3dd4@match (vector->list bf3df7@e) (vector-ref bf3df8@p '1) bf3df9@m* bf3dfa@s* bf3dfb@ae* bf3dfc@r)) (assertion-violation 'syntax-dispatch '"invalid pattern" bf3df8@p))))))))))))) (bf3dd4@match (lambda (bf3dd9@e bf3dda@p bf3ddb@m* bf3ddc@s* bf3ddd@ae* bf3dde@r) (if (not bf3dde@r) '#f (if (eq? bf3dda@p '_) bf3dde@r (if (eq? bf3dda@p 'any) (cons (bf3dc6@stx^ bf3dd9@e bf3ddb@m* bf3ddc@s* bf3ddd@ae*) bf3dde@r) (if (bf2e77@stx? bf3dd9@e) (and (not (bf2e31@top-marked? bf3ddb@m*)) (call-with-values (lambda () (join-wraps bf3ddb@m* bf3ddc@s* bf3ddd@ae* bf3dd9@e)) (lambda (bf3deb@bf3de6 bf3dec@bf3de8 bf3ded@bf3dea) (let ((bf3df1@ae* bf3ded@bf3dea) (bf3df2@s* bf3dec@bf3de8) (bf3df3@m* bf3deb@bf3de6)) (bf3dd4@match (bf2e79@stx-expr bf3dd9@e) bf3dda@p bf3df3@m* bf3df2@s* bf3df1@ae* bf3dde@r))))) (if (bf29ef@bf28c1@annotation? bf3dd9@e) (bf3dd4@match (bf29f1@bf28c5@annotation-expression bf3dd9@e) bf3dda@p bf3ddb@m* bf3ddc@s* bf3ddd@ae* bf3dde@r) (bf3dd2@match* bf3dd9@e bf3dda@p bf3ddb@m* bf3ddc@s* bf3ddd@ae* bf3dde@r))))))))) (lambda (bf3dd5@e bf3dd6@p) (bf3dd4@match bf3dd5@e bf3dd6@p '() '() '() '())))) (set! bf4bbe@bf30b2@syntax-dispatch bf30b2@syntax-dispatch) (set! bf30b4@ellipsis? (lambda (bf3ea9@x) (and (bf2eab@id? bf3ea9@x) (bf2eb1@free-id=? bf3ea9@x (bf303a@scheme-stx '...))))) (set! bf4bbf@bf30b4@ellipsis? bf30b4@ellipsis?) (set! bf30b6@underscore? (lambda (bf3eab@x) (and (bf2eab@id? bf3eab@x) (bf2eb1@free-id=? bf3eab@x (bf303a@scheme-stx '_))))) (set! bf4bc0@bf30b6@underscore? bf30b6@underscore?) (set! bf30b8@verify-literals (lambda (bf3ead@lits bf3eae@expr) (for-each (lambda (bf3eb1@x) (if (or (not (bf2eab@id? bf3eb1@x)) (bf30b4@ellipsis? bf3eb1@x) (bf30b6@underscore? bf3eb1@x)) (bf3192@syntax-violation '#f '"invalid literal" bf3eae@expr bf3eb1@x) (void))) bf3ead@lits))) (set! bf4bc1@bf30b8@verify-literals bf30b8@verify-literals) (set! bf30ba@syntax-case-transformer (letrec* ((bf3eb4@build-dispatch-call (lambda (bf3f25@pvars bf3f26@expr bf3f27@y bf3f28@r bf3f29@mr) (let ((bf3f2f@ids (map car bf3f25@pvars)) (bf3f30@levels (map cdr bf3f25@pvars))) (let ((bf3f33@labels (map bf2e37@gen-label bf3f2f@ids)) (bf3f34@new-vars (map bf2e33@gen-lexical bf3f2f@ids))) (let ((bf3f37@body (bf30d4@chi-expr (bf2e95@add-subst (bf2e6b@make-full-rib bf3f2f@ids bf3f33@labels) bf3f26@expr) (append (map (lambda (bf3f39@label bf3f3a@var bf3f3b@level) (cons bf3f39@label (bf2ec5@make-binding 'syntax (cons bf3f3a@var bf3f3b@level)))) bf3f33@labels bf3f34@new-vars (map cdr bf3f25@pvars)) bf3f28@r) bf3f29@mr))) (list '(primitive apply) (bf2e0e@bf2d40@build-lambda '#f bf3f34@new-vars bf3f37@body) bf3f27@y)))))) (bf3eb6@invalid-ids-error (lambda (bf3f19@id* bf3f1a@e bf3f1b@class) (let bf3f23@find ((bf3f1f@id* bf3f19@id*) (bf3f20@ok* '())) (if (null? bf3f1f@id*) (bf3192@syntax-violation '#f '"invalid syntax" bf3f1a@e) (if (bf2eab@id? (car bf3f1f@id*)) (if (bf2eb7@bound-id-member? (car bf3f1f@id*) bf3f20@ok*) (bf318e@syntax-error (car bf3f1f@id*) '"duplicate " bf3f1b@class) (bf3f23@find (cdr bf3f1f@id*) (cons (car bf3f1f@id*) bf3f20@ok*))) (bf318e@syntax-error (car bf3f1f@id*) '"invalid " bf3f1b@class)))))) (bf3eb8@gen-clause (lambda (bf3ef1@x bf3ef2@keys bf3ef3@clauses bf3ef4@r bf3ef5@mr bf3ef6@pat bf3ef7@fender bf3ef8@expr) (call-with-values (lambda () (bf30b0@convert-pattern bf3ef6@pat bf3ef2@keys)) (lambda (bf3f05@bf3f02 bf3f06@bf3f04) (let ((bf3f09@pvars bf3f06@bf3f04) (bf3f0a@p bf3f05@bf3f02)) (if (not (bf2eb5@distinct-bound-ids? (map car bf3f09@pvars))) (bf3eb6@invalid-ids-error (map car bf3f09@pvars) bf3ef6@pat '"pattern variable") (if (not (for-all (lambda (bf3f0d@x) (not (bf30b4@ellipsis? (car bf3f0d@x)))) bf3f09@pvars)) (bf3192@syntax-violation '#f '"misplaced ellipsis in syntax-case pattern" bf3ef6@pat) (let ((bf3f0f@y (bf2e33@gen-lexical 'tmp))) (let ((bf3f11@test (if (eq? bf3ef7@fender '#t) bf3f0f@y (let ((bf3f13@call (bf3eb4@build-dispatch-call bf3f09@pvars bf3ef7@fender bf3f0f@y bf3ef4@r bf3ef5@mr))) (list 'if bf3f0f@y bf3f13@call (list 'quote '#f)))))) (let ((bf3f15@conseq (bf3eb4@build-dispatch-call bf3f09@pvars bf3ef8@expr bf3f0f@y bf3ef4@r bf3ef5@mr))) (let ((bf3f17@altern (bf3eba@gen-syntax-case bf3ef1@x bf3ef2@keys bf3ef3@clauses bf3ef4@r bf3ef5@mr))) (list (bf2e0e@bf2d40@build-lambda '#f (list bf3f0f@y) (list 'if bf3f11@test bf3f15@conseq bf3f17@altern)) (list '(primitive syntax-dispatch) bf3ef1@x (list 'quote bf3f0a@p)))))))))))))) (bf3eba@gen-syntax-case (lambda (bf3ecf@x bf3ed0@keys bf3ed1@clauses bf3ed2@r bf3ed3@mr) (if (null? bf3ed1@clauses) (list '(primitive syntax-error) bf3ecf@x) (let ((bf3ed9@t (car bf3ed1@clauses))) (let ((bf3edb@ls/false (bf30b2@syntax-dispatch bf3ed9@t '(any any)))) (if bf3edb@ls/false (apply (lambda (bf3edd@pat bf3ede@expr) (if (and (bf2eab@id? bf3edd@pat) (not (bf2eb7@bound-id-member? bf3edd@pat bf3ed0@keys)) (not (bf30b4@ellipsis? bf3edd@pat))) (if (bf2eb1@free-id=? bf3edd@pat (bf303a@scheme-stx '_)) (bf30d4@chi-expr bf3ede@expr bf3ed2@r bf3ed3@mr) (let ((bf3ee1@lab (bf2e37@gen-label bf3edd@pat)) (bf3ee2@lex (bf2e33@gen-lexical bf3edd@pat))) (let ((bf3ee5@body (bf30d4@chi-expr (bf2e95@add-subst (bf2e6b@make-full-rib (list bf3edd@pat) (list bf3ee1@lab)) bf3ede@expr) (cons (cons bf3ee1@lab (bf2ec5@make-binding 'syntax (cons bf3ee2@lex '0))) bf3ed2@r) bf3ed3@mr))) (list (bf2e0e@bf2d40@build-lambda '#f (list bf3ee2@lex) bf3ee5@body) bf3ecf@x)))) (bf3eb8@gen-clause bf3ecf@x bf3ed0@keys (cdr bf3ed1@clauses) bf3ed2@r bf3ed3@mr bf3edd@pat '#t bf3ede@expr))) bf3edb@ls/false) (let ((bf3ee7@t bf3ed9@t)) (let ((bf3ee9@ls/false (bf30b2@syntax-dispatch bf3ee7@t '(any any any)))) (if bf3ee9@ls/false (apply (lambda (bf3eeb@pat bf3eec@fender bf3eed@expr) (bf3eb8@gen-clause bf3ecf@x bf3ed0@keys (cdr bf3ed1@clauses) bf3ed2@r bf3ed3@mr bf3eeb@pat bf3eec@fender bf3eed@expr)) bf3ee9@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3ee7@t))))))))))) (lambda (bf3ebb@e bf3ebc@r bf3ebd@mr) (let ((bf3ec1@t bf3ebb@e)) (let ((bf3ec3@ls/false (bf30b2@syntax-dispatch bf3ec1@t '(_ any each-any . each-any)))) (if bf3ec3@ls/false (apply (lambda (bf3ec5@expr bf3ec6@keys bf3ec7@clauses) (begin (bf30b8@verify-literals bf3ec6@keys bf3ebb@e) (let ((bf3ecb@x (bf2e33@gen-lexical 'tmp))) (let ((bf3ecd@body (bf3eba@gen-syntax-case bf3ecb@x bf3ec6@keys bf3ec7@clauses bf3ebc@r bf3ebd@mr))) (list (bf2e0e@bf2d40@build-lambda '#f (list bf3ecb@x) bf3ecd@body) (bf30d4@chi-expr bf3ec5@expr bf3ebc@r bf3ebd@mr)))))) bf3ec3@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3ec1@t))))))) (set! bf4bc2@bf30ba@syntax-case-transformer bf30ba@syntax-case-transformer) (set! bf30bc@ellipsis-map (lambda (bf3f3f@proc bf3f40@ls . bf3f43@ls*) (letrec* ((bf3f46@who '...)) (begin (if (not (list? bf3f40@ls)) (assertion-violation bf3f46@who '"not a list" bf3f40@ls) (void)) (if (not (null? bf3f43@ls*)) (let ((bf3f47@n (length bf3f40@ls))) (for-each (lambda (bf3f49@x) (begin (if (not (list? bf3f49@x)) (assertion-violation bf3f46@who '"not a list" bf3f49@x) (void)) (if (not (= (length bf3f49@x) bf3f47@n)) (assertion-violation bf3f46@who '"length mismatch" bf3f40@ls bf3f49@x) (void)))) bf3f43@ls*)) (void)) (apply map bf3f3f@proc bf3f40@ls bf3f43@ls*))))) (set! bf4bc3@bf30bc@ellipsis-map bf30bc@ellipsis-map) (set! bf30be@syntax-transformer (letrec* ((bf3f4c@gen-syntax (lambda (bf3fc3@src bf3fc4@e bf3fc5@r bf3fc6@maps bf3fc7@ellipsis? bf3fc8@vec?) (let ((bf3fcf@t bf3fc4@e)) (let ((bf3fd1@ls/false (bf30b2@syntax-dispatch bf3fcf@t 'any))) (if (and bf3fd1@ls/false (apply (lambda (bf3fd3@dots) (bf3fc7@ellipsis? bf3fd3@dots)) bf3fd1@ls/false)) (apply (lambda (bf3fd5@dots) (bf3192@syntax-violation '#f '"misplaced ellipsis in syntax form" bf3fc3@src)) bf3fd1@ls/false) (let ((bf3fd7@t bf3fcf@t)) (let ((bf3fd9@ls/false (bf30b2@syntax-dispatch bf3fd7@t 'any))) (if (and bf3fd9@ls/false (apply (lambda (bf3fdb@id) (bf2eab@id? bf3fdb@id)) bf3fd9@ls/false)) (apply (lambda (bf3fdd@id) (let ((bf3fdf@label (bf2ec1@id->label bf3fc4@e))) (let ((bf3fe1@b (bf2ec3@label->binding bf3fdf@label bf3fc5@r))) (if (eq? (bf2ec7@binding-type bf3fe1@b) 'syntax) (call-with-values (lambda () (let ((bf3fe7@var.lev (bf2ec9@binding-value bf3fe1@b))) (bf3f4e@gen-ref bf3fc3@src (car bf3fe7@var.lev) (cdr bf3fe7@var.lev) bf3fc6@maps))) (lambda (bf3fe9@bf3fe4 bf3fea@bf3fe6) (let ((bf3fed@maps bf3fea@bf3fe6) (bf3fee@var bf3fe9@bf3fe4)) (values (list 'ref bf3fee@var) bf3fed@maps)))) (values (list 'quote bf3fc4@e) bf3fc6@maps))))) bf3fd9@ls/false) (let ((bf3ff1@t bf3fd7@t)) (let ((bf3ff3@ls/false (bf30b2@syntax-dispatch bf3ff1@t '(any any)))) (if (and bf3ff3@ls/false (apply (lambda (bf3ff5@dots bf3ff6@e) (bf3fc7@ellipsis? bf3ff5@dots)) bf3ff3@ls/false)) (apply (lambda (bf3ff9@dots bf3ffa@e) (if bf3fc8@vec? (bf3192@syntax-violation '#f '"misplaced ellipsis in syntax form" bf3fc3@src) (bf3f4c@gen-syntax bf3fc3@src bf3ffa@e bf3fc5@r bf3fc6@maps (lambda (bf3ffd@x) '#f) '#f))) bf3ff3@ls/false) (let ((bf3fff@t bf3ff1@t)) (let ((bf4001@ls/false (bf30b2@syntax-dispatch bf3fff@t '(any any . any)))) (if (and bf4001@ls/false (apply (lambda (bf4003@x bf4004@dots bf4005@y) (bf3fc7@ellipsis? bf4004@dots)) bf4001@ls/false)) (apply (lambda (bf4009@x bf400a@dots bf400b@y) (let bf4021@f ((bf400f@y bf400b@y) (bf4010@k (lambda (bf4013@maps) (call-with-values (lambda () (bf3f4c@gen-syntax bf3fc3@src bf4009@x bf3fc5@r (cons '() bf4013@maps) bf3fc7@ellipsis? '#f)) (lambda (bf4019@bf4016 bf401a@bf4018) (let ((bf401d@maps bf401a@bf4018) (bf401e@x bf4019@bf4016)) (if (null? (car bf401d@maps)) (bf3192@syntax-violation '#f '"extra ellipsis in syntax form" bf3fc3@src) (values (bf3f54@gen-map bf401e@x (car bf401d@maps)) (cdr bf401d@maps))))))))) (let ((bf4023@t bf400f@y)) (let ((bf4025@ls/false (bf30b2@syntax-dispatch bf4023@t '()))) (if bf4025@ls/false (apply (lambda () (bf4010@k bf3fc6@maps)) bf4025@ls/false) (let ((bf4027@t bf4023@t)) (let ((bf4029@ls/false (bf30b2@syntax-dispatch bf4027@t '(any . any)))) (if (and bf4029@ls/false (apply (lambda (bf402b@dots bf402c@y) (bf3fc7@ellipsis? bf402b@dots)) bf4029@ls/false)) (apply (lambda (bf402f@dots bf4030@y) (bf4021@f bf4030@y (lambda (bf4033@maps) (call-with-values (lambda () (bf4010@k (cons '() bf4033@maps))) (lambda (bf4039@bf4036 bf403a@bf4038) (let ((bf403d@maps bf403a@bf4038) (bf403e@x bf4039@bf4036)) (if (null? (car bf403d@maps)) (bf3192@syntax-violation '#f '"extra ellipsis in syntax form" bf3fc3@src) (values (bf3f52@gen-mappend bf403e@x (car bf403d@maps)) (cdr bf403d@maps))))))))) bf4029@ls/false) (let ((bf4041@t bf4027@t)) (let ((bf4043@ls/false (bf30b2@syntax-dispatch bf4041@t '_))) (if bf4043@ls/false (apply (lambda () (call-with-values (lambda () (bf3f4c@gen-syntax bf3fc3@src bf400f@y bf3fc5@r bf3fc6@maps bf3fc7@ellipsis? bf3fc8@vec?)) (lambda (bf4049@bf4046 bf404a@bf4048) (let ((bf404d@maps bf404a@bf4048) (bf404e@y bf4049@bf4046)) (call-with-values (lambda () (bf4010@k bf404d@maps)) (lambda (bf4055@bf4052 bf4056@bf4054) (let ((bf4059@maps bf4056@bf4054) (bf405a@x bf4055@bf4052)) (values (bf3f50@gen-append bf405a@x bf404e@y) bf4059@maps)))))))) bf4043@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf4041@t)))))))))))) bf4001@ls/false) (let ((bf405d@t bf3fff@t)) (let ((bf405f@ls/false (bf30b2@syntax-dispatch bf405d@t '(any . any)))) (if bf405f@ls/false (apply (lambda (bf4061@x bf4062@y) (call-with-values (lambda () (bf3f4c@gen-syntax bf3fc3@src bf4061@x bf3fc5@r bf3fc6@maps bf3fc7@ellipsis? '#f)) (lambda (bf4069@bf4066 bf406a@bf4068) (let ((bf406d@maps bf406a@bf4068) (bf406e@xnew bf4069@bf4066)) (call-with-values (lambda () (bf3f4c@gen-syntax bf3fc3@src bf4062@y bf3fc5@r bf406d@maps bf3fc7@ellipsis? bf3fc8@vec?)) (lambda (bf4075@bf4072 bf4076@bf4074) (let ((bf4079@maps bf4076@bf4074) (bf407a@ynew bf4075@bf4072)) (values (bf3f56@gen-cons bf3fc4@e bf4061@x bf4062@y bf406e@xnew bf407a@ynew) bf4079@maps)))))))) bf405f@ls/false) (let ((bf407d@t bf405d@t)) (let ((bf407f@ls/false (bf30b2@syntax-dispatch bf407d@t '#(vector each-any)))) (if bf407f@ls/false (apply (lambda (bf4081@ls) (call-with-values (lambda () (bf3f4c@gen-syntax bf3fc3@src bf4081@ls bf3fc5@r bf3fc6@maps bf3fc7@ellipsis? '#t)) (lambda (bf4087@bf4084 bf4088@bf4086) (let ((bf408b@maps bf4088@bf4086) (bf408c@lsnew bf4087@bf4084)) (values (bf3f58@gen-vector bf3fc4@e bf4081@ls bf408c@lsnew) bf408b@maps))))) bf407f@ls/false) (let ((bf408f@t bf407d@t)) (let ((bf4091@ls/false (bf30b2@syntax-dispatch bf408f@t '_))) (if bf4091@ls/false (apply (lambda () (values (list 'quote bf3fc4@e) bf3fc6@maps)) bf4091@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf408f@t)))))))))))))))))))))))) (bf3f4e@gen-ref (lambda (bf3fa9@src bf3faa@var bf3fab@level bf3fac@maps) (if (= bf3fab@level '0) (values bf3faa@var bf3fac@maps) (if (null? bf3fac@maps) (bf3192@syntax-violation '#f '"missing ellipsis in syntax form" bf3fa9@src) (call-with-values (lambda () (bf3f4e@gen-ref bf3fa9@src bf3faa@var (- bf3fab@level '1) (cdr bf3fac@maps))) (lambda (bf3fb5@bf3fb2 bf3fb6@bf3fb4) (let ((bf3fb9@outer-maps bf3fb6@bf3fb4) (bf3fba@outer-var bf3fb5@bf3fb2)) (let ((bf3fbd@t (assq bf3fba@outer-var (car bf3fac@maps)))) (if bf3fbd@t ((lambda (bf3fbf@b) (values (cdr bf3fbf@b) bf3fac@maps)) bf3fbd@t) (let ((bf3fc1@inner-var (bf2e33@gen-lexical 'tmp))) (values bf3fc1@inner-var (cons (cons (cons bf3fba@outer-var bf3fc1@inner-var) (car bf3fac@maps)) bf3fb9@outer-maps)))))))))))) (bf3f50@gen-append (lambda (bf3fa5@x bf3fa6@y) (if (fast-equal? bf3fa6@y ''()) bf3fa5@x (list 'append bf3fa5@x bf3fa6@y)))) (bf3f52@gen-mappend (lambda (bf3fa1@e bf3fa2@map-env) (list 'apply '(primitive append) (bf3f54@gen-map bf3fa1@e bf3fa2@map-env)))) (bf3f54@gen-map (lambda (bf3f8f@e bf3f90@map-env) (let ((bf3f93@formals (map cdr bf3f90@map-env)) (bf3f94@actuals (map (lambda (bf3f97@x) (list 'ref (car bf3f97@x))) bf3f90@map-env))) (if (eq? (car bf3f8f@e) 'ref) (car bf3f94@actuals) (if (for-all (lambda (bf3f99@x) (and (eq? (car bf3f99@x) 'ref) (memq (cadr bf3f99@x) bf3f93@formals))) (cdr bf3f8f@e)) (let ((bf3f9b@args (map (let ((bf3f9d@r (map cons bf3f93@formals bf3f94@actuals))) (lambda (bf3f9f@x) (cdr (assq (cadr bf3f9f@x) bf3f9d@r)))) (cdr bf3f8f@e)))) (cons 'map (cons (list 'primitive (car bf3f8f@e)) bf3f9b@args))) (cons* 'map (list 'lambda bf3f93@formals bf3f8f@e) bf3f94@actuals)))))) (bf3f56@gen-cons (lambda (bf3f7f@e bf3f80@x bf3f81@y bf3f82@xnew bf3f83@ynew) (let ((bf3f89@t (car bf3f83@ynew))) (if (memv bf3f89@t '(quote)) (if (eq? (car bf3f82@xnew) 'quote) (let ((bf3f8b@xnew (cadr bf3f82@xnew)) (bf3f8c@ynew (cadr bf3f83@ynew))) (if (and (eq? bf3f8b@xnew bf3f80@x) (eq? bf3f8c@ynew bf3f81@y)) (list 'quote bf3f7f@e) (list 'quote (cons bf3f8b@xnew bf3f8c@ynew)))) (if (null? (cadr bf3f83@ynew)) (list 'list bf3f82@xnew) (list 'cons bf3f82@xnew bf3f83@ynew))) (if (memv bf3f89@t '(list)) (cons 'list (cons bf3f82@xnew (cdr bf3f83@ynew))) (list 'cons bf3f82@xnew bf3f83@ynew)))))) (bf3f58@gen-vector (lambda (bf3f79@e bf3f7a@ls bf3f7b@lsnew) (if (eq? (car bf3f7b@lsnew) 'quote) (if (eq? (cadr bf3f7b@lsnew) bf3f7a@ls) (list 'quote bf3f79@e) (list 'quote (list->vector (cadr bf3f7b@lsnew)))) (if (eq? (car bf3f7b@lsnew) 'list) (cons 'vector (cdr bf3f7b@lsnew)) (list 'list->vector bf3f7b@lsnew))))) (bf3f5a@regen (lambda (bf3f73@x) (let ((bf3f75@t (car bf3f73@x))) (if (memv bf3f75@t '(ref)) (cadr bf3f73@x) (if (memv bf3f75@t '(primitive)) (list 'primitive (cadr bf3f73@x)) (if (memv bf3f75@t '(quote)) (list 'quote (cadr bf3f73@x)) (if (memv bf3f75@t '(lambda)) (bf2e0e@bf2d40@build-lambda '#f (cadr bf3f73@x) (bf3f5a@regen (caddr bf3f73@x))) (if (memv bf3f75@t '(map)) (let ((bf3f77@ls (map bf3f5a@regen (cdr bf3f73@x)))) (cons '(primitive ellipsis-map) bf3f77@ls)) (cons (list 'primitive (car bf3f73@x)) (map bf3f5a@regen (cdr bf3f73@x)))))))))))) (lambda (bf3f5b@e bf3f5c@r bf3f5d@mr) (let ((bf3f61@t bf3f5b@e)) (let ((bf3f63@ls/false (bf30b2@syntax-dispatch bf3f61@t '(_ any)))) (if bf3f63@ls/false (apply (lambda (bf3f65@x) (call-with-values (lambda () (bf3f4c@gen-syntax bf3f5b@e bf3f65@x bf3f5c@r '() bf30b4@ellipsis? '#f)) (lambda (bf3f6b@bf3f68 bf3f6c@bf3f6a) (let ((bf3f6f@maps bf3f6c@bf3f6a) (bf3f70@e bf3f6b@bf3f68)) (bf3f5a@regen bf3f70@e))))) bf3f63@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf3f61@t))))))) (set! bf4bc4@bf30be@syntax-transformer bf30be@syntax-transformer) (set! bf30c0@core-macro-transformer (lambda (bf4093@name) (let ((bf4095@t bf4093@name)) (if (memv bf4095@t '(quote)) bf3062@quote-transformer (if (memv bf4095@t '(lambda)) bf3066@lambda-transformer (if (memv bf4095@t '(case-lambda)) bf3064@case-lambda-transformer (if (memv bf4095@t '(letrec)) bf304a@letrec-transformer (if (memv bf4095@t '(letrec*)) bf304c@letrec*-transformer (if (memv bf4095@t '(let)) bf3048@let-transformer (if (memv bf4095@t '(if)) bf305a@if-transformer (if (memv bf4095@t '(and)) bf305c@and-transformer (if (memv bf4095@t '(or)) bf305e@or-transformer (if (memv bf4095@t '(foreign-call)) bf30ae@foreign-call-transformer (if (memv bf4095@t '(syntax-case)) bf30ba@syntax-case-transformer (if (memv bf4095@t '(syntax)) bf30be@syntax-transformer (if (memv bf4095@t '(type-descriptor)) bf3050@type-descriptor-transformer (if (memv bf4095@t '(record-type-descriptor)) bf3052@record-type-descriptor-transformer (if (memv bf4095@t '(record-constructor-descriptor)) bf3054@record-constructor-descriptor-transformer (if (memv bf4095@t '(fluid-let-syntax)) bf304e@fluid-let-syntax-transformer (assertion-violation 'macro-transformer '"BUG: cannot find transformer" bf4093@name)))))))))))))))))))) (set! bf4bc5@bf30c0@core-macro-transformer bf30c0@core-macro-transformer) (set! bf30c2@symbol-macro (lambda (bf4097@x bf4098@set) (let ((bf409b@t bf4097@x)) (let ((bf409d@ls/false (bf30b2@syntax-dispatch bf409b@t '(_ any)))) (if (and bf409d@ls/false (apply (lambda (bf409f@name) (and (bf2eab@id? bf409f@name) (memq (bf2ead@id->sym bf409f@name) bf4098@set))) bf409d@ls/false)) (apply (lambda (bf40a1@name) (bf3068@bless (list 'quote bf40a1@name))) bf409d@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf409b@t)))))) (set! bf4bc6@bf30c2@symbol-macro bf30c2@symbol-macro) (set! bf30c4@macro-transformer (lambda (bf40a3@x) (if (procedure? bf40a3@x) bf40a3@x (if (symbol? bf40a3@x) (let ((bf40a5@t bf40a3@x)) (if (memv bf40a5@t '(define-record-type)) bf30a6@define-record-type-macro (if (memv bf40a5@t '(define-struct)) bf30a4@define-struct-macro (if (memv bf40a5@t '(include)) bf309a@include-macro (if (memv bf40a5@t '(cond)) bf3096@cond-macro (if (memv bf40a5@t '(let)) bf306e@let-macro (if (memv bf40a5@t '(do)) bf308e@do-macro (if (memv bf40a5@t '(or)) bf3092@or-macro (if (memv bf40a5@t '(and)) bf3094@and-macro (if (memv bf40a5@t '(let*)) bf3090@let*-macro (if (memv bf40a5@t '(let-values)) bf3070@let-values-macro (if (memv bf40a5@t '(let*-values)) bf3072@let*-values-macro (if (memv bf40a5@t '(syntax-rules)) bf309e@syntax-rules-macro (if (memv bf40a5@t '(quasiquote)) bf30a0@quasiquote-macro (if (memv bf40a5@t '(quasisyntax)) bf30a2@quasisyntax-macro (if (memv bf40a5@t '(with-syntax)) bf306a@with-syntax-macro (if (memv bf40a5@t '(when)) bf3056@when-macro (if (memv bf40a5@t '(unless)) bf3058@unless-macro (if (memv bf40a5@t '(case)) bf3060@case-macro (if (memv bf40a5@t '(identifier-syntax)) bf308c@identifier-syntax-macro (if (memv bf40a5@t '(time)) bf3084@time-macro (if (memv bf40a5@t '(delay)) bf3086@delay-macro (if (memv bf40a5@t '(assert)) bf3088@assert-macro (if (memv bf40a5@t '(endianness)) bf308a@endianness-macro (if (memv bf40a5@t '(guard)) bf3080@guard-macro (if (memv bf40a5@t '(define-enumeration)) bf3082@define-enumeration-macro (if (memv bf40a5@t '(trace-lambda)) bf3074@trace-lambda-macro (if (memv bf40a5@t '(trace-define)) bf3076@trace-define-macro (if (memv bf40a5@t '(trace-define-syntax)) bf3078@trace-define-syntax-macro (if (memv bf40a5@t '(trace-let-syntax)) bf307c@trace-let-syntax-macro (if (memv bf40a5@t '(trace-letrec-syntax)) bf307e@trace-letrec-syntax-macro (if (memv bf40a5@t '(define-condition-type)) bf30a8@define-condition-type-macro (if (memv bf40a5@t '(parameterize)) bf30ac@parameterize-macro (if (memv bf40a5@t '(include-into)) bf309c@include-into-macro (if (memv bf40a5@t '(eol-style)) (lambda (bf40a7@x) (bf30c2@symbol-macro bf40a7@x '(none lf cr crlf nel crnel ls))) (if (memv bf40a5@t '(error-handling-mode)) (lambda (bf40a9@x) (bf30c2@symbol-macro bf40a9@x '(ignore raise replace))) (if (memv bf40a5@t '(buffer-mode)) (lambda (bf40ab@x) (bf30c2@symbol-macro bf40ab@x '(none line block))) (if (memv bf40a5@t '(file-options)) bf2e26@file-options-macro (if (memv bf40a5@t '(... => _ else unquote unquote-splicing unsyntax unsyntax-splicing fields mutable immutable parent protocol sealed opaque nongenerative parent-rtd)) bf30aa@incorrect-usage-macro (error 'macro-transformer '"BUG: invalid macro" bf40a3@x)))))))))))))))))))))))))))))))))))))))) (error 'core-macro-transformer '"BUG: invalid macro" bf40a3@x))))) (set! bf4bc7@bf30c4@macro-transformer bf30c4@macro-transformer) (set! bf30c6@local-macro-transformer (lambda (bf40ad@x) (car bf40ad@x))) (set! bf4bc8@bf30c6@local-macro-transformer bf30c6@local-macro-transformer) (set! bf30c8@do-macro-call (lambda (bf40af@transformer bf40b0@expr bf40b1@rib) (let ((bf40b5@out (bf40af@transformer (bf2e97@add-mark bf2e8f@anti-mark '#f bf40b0@expr '#f)))) (begin (let bf40b9@f ((bf40b7@x bf40b5@out)) (if (not (bf2e77@stx? bf40b7@x)) (if (pair? bf40b7@x) (begin (bf40b9@f (car bf40b7@x)) (bf40b9@f (cdr bf40b7@x))) (if (vector? bf40b7@x) (vector-for-each bf40b9@f bf40b7@x) (if (symbol? bf40b7@x) (bf3192@syntax-violation '#f '"raw symbol encountered in output of macro" bf40b0@expr bf40b7@x) (void)))) (void))) (bf2e97@add-mark (bf2e8d@gen-mark) bf40b1@rib bf40b5@out bf40b0@expr))))) (set! bf4bc9@bf30c8@do-macro-call bf30c8@do-macro-call) (set! bf30ca@chi-macro (lambda (bf40bb@p bf40bc@e bf40bd@rib) (bf30c8@do-macro-call (bf30c4@macro-transformer bf40bb@p) bf40bc@e bf40bd@rib))) (set! bf4bca@bf30ca@chi-macro bf30ca@chi-macro) (set! bf30cc@chi-local-macro (lambda (bf40c1@p bf40c2@e bf40c3@rib) (bf30c8@do-macro-call (bf30c6@local-macro-transformer bf40c1@p) bf40c2@e bf40c3@rib))) (set! bf4bcb@bf30cc@chi-local-macro bf30cc@chi-local-macro) (set! bf30ce@chi-global-macro (lambda (bf40c7@p bf40c8@e bf40c9@rib) (let ((bf40cd@lib (car bf40c7@p)) (bf40ce@loc (cdr bf40c7@p))) (begin (bf2cc8@bf2b17@visit-library bf40cd@lib) (let ((bf40d1@x (symbol-value bf40ce@loc))) (let ((bf40d3@transformer (if (procedure? bf40d1@x) bf40d1@x (assertion-violation 'chi-global-macro '"BUG: not a procedure" bf40d1@x)))) (bf30c8@do-macro-call bf40d3@transformer bf40c8@e bf40c9@rib))))))) (set! bf4bcc@bf30ce@chi-global-macro bf30ce@chi-global-macro) (set! bf30d0@chi-expr* (lambda (bf40d5@e* bf40d6@r bf40d7@mr) (if (null? bf40d5@e*) '() (let ((bf40db@e (bf30d4@chi-expr (car bf40d5@e*) bf40d6@r bf40d7@mr))) (cons bf40db@e (bf30d0@chi-expr* (cdr bf40d5@e*) bf40d6@r bf40d7@mr)))))) (set! bf4bcd@bf30d0@chi-expr* bf30d0@chi-expr*) (set! bf30d2@chi-application (lambda (bf40dd@e bf40de@r bf40df@mr) (let ((bf40e3@t bf40dd@e)) (let ((bf40e5@ls/false (bf30b2@syntax-dispatch bf40e3@t '(any . each-any)))) (if bf40e5@ls/false (apply (lambda (bf40e7@rator bf40e8@rands) (let ((bf40eb@rator (bf30d4@chi-expr bf40e7@rator bf40de@r bf40df@mr))) (cons bf40eb@rator (bf30d0@chi-expr* bf40e8@rands bf40de@r bf40df@mr)))) bf40e5@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf40e3@t)))))) (set! bf4bce@bf30d2@chi-application bf30d2@chi-application) (set! bf30d4@chi-expr (lambda (bf40ed@e bf40ee@r bf40ef@mr) (call-with-values (lambda () (bf2ecd@syntax-type bf40ed@e bf40ee@r)) (lambda (bf40f9@bf40f4 bf40fa@bf40f6 bf40fb@bf40f8) (let ((bf40ff@kwd bf40fb@bf40f8) (bf4100@value bf40fa@bf40f6) (bf4101@type bf40f9@bf40f4)) (let ((bf4105@t bf4101@type)) (if (memv bf4105@t '(core-macro)) (let ((bf4107@transformer (bf30c0@core-macro-transformer bf4100@value))) (bf4107@transformer bf40ed@e bf40ee@r bf40ef@mr)) (if (memv bf4105@t '(global)) (let ((bf4109@lib (car bf4100@value))) (let ((bf410b@loc (cdr bf4100@value))) (begin ((bf311a@inv-collector) bf4109@lib) bf410b@loc))) (if (memv bf4105@t '(core-prim)) (let ((bf410d@name bf4100@value)) (list 'primitive bf410d@name)) (if (memv bf4105@t '(call)) (bf30d2@chi-application bf40ed@e bf40ee@r bf40ef@mr) (if (memv bf4105@t '(lexical)) (let ((bf410f@lex (bf303c@lexical-var bf4100@value))) bf410f@lex) (if (memv bf4105@t '(global-macro global-macro!)) (bf30d4@chi-expr (bf30ce@chi-global-macro bf4100@value bf40ed@e '#f) bf40ee@r bf40ef@mr) (if (memv bf4105@t '(local-macro local-macro!)) (bf30d4@chi-expr (bf30cc@chi-local-macro bf4100@value bf40ed@e '#f) bf40ee@r bf40ef@mr) (if (memv bf4105@t '(macro macro!)) (bf30d4@chi-expr (bf30ca@chi-macro bf4100@value bf40ed@e '#f) bf40ee@r bf40ef@mr) (if (memv bf4105@t '(constant)) (let ((bf4111@datum bf4100@value)) (list 'quote bf4111@datum)) (if (memv bf4105@t '(set!)) (bf30d6@chi-set! bf40ed@e bf40ee@r bf40ef@mr) (if (memv bf4105@t '(begin)) (let ((bf4113@t bf40ed@e)) (let ((bf4115@ls/false (bf30b2@syntax-dispatch bf4113@t '(_ any . each-any)))) (if bf4115@ls/false (apply (lambda (bf4117@x bf4118@x*) (bf2e10@bf2d70@build-sequence '#f (bf30d0@chi-expr* (cons bf4117@x bf4118@x*) bf40ee@r bf40ef@mr))) bf4115@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf4113@t)))) (if (memv bf4105@t '(let-syntax letrec-syntax)) (let ((bf411b@t bf40ed@e)) (let ((bf411d@ls/false (bf30b2@syntax-dispatch bf411b@t '(_ #(each (any any)) any . each-any)))) (if (and bf411d@ls/false (apply (lambda (bf411f@xlhs* bf4120@xrhs* bf4121@xbody bf4122@xbody*) (if (not (bf2eb3@valid-bound-ids? bf411f@xlhs*)) (bf3192@syntax-violation '#f '"invalid identifiers" bf40ed@e) (void))) bf411d@ls/false)) (apply (lambda (bf4127@xlhs* bf4128@xrhs* bf4129@xbody bf412a@xbody*) (let ((bf412f@xlab* (map bf2e37@gen-label bf4127@xlhs*))) (let ((bf4131@xrib (bf2e6b@make-full-rib bf4127@xlhs* bf412f@xlab*))) (let ((bf4133@xb* (map (lambda (bf4135@x) (bf2ee3@make-eval-transformer (bf310c@expand-transformer (if (eq? bf4101@type 'let-syntax) bf4135@x (bf2e95@add-subst bf4131@xrib bf4135@x)) bf40ef@mr))) bf4128@xrhs*))) (bf2e10@bf2d70@build-sequence '#f (bf30d0@chi-expr* (map (lambda (bf4137@x) (bf2e95@add-subst bf4131@xrib bf4137@x)) (cons bf4129@xbody bf412a@xbody*)) (append (map cons bf412f@xlab* bf4133@xb*) bf40ee@r) (append (map cons bf412f@xlab* bf4133@xb*) bf40ef@mr))))))) bf411d@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf411b@t)))) (if (memv bf4105@t '(displaced-lexical)) (bf3192@syntax-violation '#f '"identifier out of context" bf40ed@e) (if (memv bf4105@t '(syntax)) (bf3192@syntax-violation '#f '"reference to pattern variable outside a syntax form" bf40ed@e) (if (memv bf4105@t '(define define-syntax module import library)) (bf3192@syntax-violation '#f (string-append (let ((bf4139@t bf4101@type)) (if (memv bf4139@t '(define)) '"a definition" (if (memv bf4139@t '(define-syntax)) '"a define-syntax" (if (memv bf4139@t '(module)) '"a module definition" (if (memv bf4139@t '(library)) '"a library definition" (if (memv bf4139@t '(import)) '"an import declaration" (if (memv bf4139@t '(export)) '"an export declaration" '"a non-expression"))))))) '" was found where an expression was expected") bf40ed@e) (if (memv bf4105@t '(mutable)) (bf3192@syntax-violation '#f '"attempt to reference an unexportable variable" bf40ed@e) (bf3192@syntax-violation '#f '"invalid expression" bf40ed@e))))))))))))))))))))))) (set! bf4bcf@bf30d4@chi-expr bf30d4@chi-expr) (set! bf30d6@chi-set! (lambda (bf413b@e bf413c@r bf413d@mr) (let ((bf4141@t bf413b@e)) (let ((bf4143@ls/false (bf30b2@syntax-dispatch bf4141@t '(_ any any)))) (if (and bf4143@ls/false (apply (lambda (bf4145@x bf4146@v) (bf2eab@id? bf4145@x)) bf4143@ls/false)) (apply (lambda (bf4149@x bf414a@v) (call-with-values (lambda () (bf2ecd@syntax-type bf4149@x bf413c@r)) (lambda (bf4153@bf414e bf4154@bf4150 bf4155@bf4152) (let ((bf4159@kwd bf4155@bf4152) (bf415a@value bf4154@bf4150) (bf415b@type bf4153@bf414e)) (let ((bf415f@t bf415b@type)) (if (memv bf415f@t '(lexical)) (begin (bf3040@set-lexical-mutable! bf415a@value '#t) (list 'set! (bf303c@lexical-var bf415a@value) (bf30d4@chi-expr bf414a@v bf413c@r bf413d@mr))) (if (memv bf415f@t '(core-prim)) (bf3192@syntax-violation '#f '"cannot modify imported core primitive" bf413b@e) (if (memv bf415f@t '(global)) (bf3192@syntax-violation '#f '"attempt to modify imported binding" bf413b@e) (if (memv bf415f@t '(global-macro!)) (bf30d4@chi-expr (bf30ce@chi-global-macro bf415a@value bf413b@e '#f) bf413c@r bf413d@mr) (if (memv bf415f@t '(local-macro!)) (bf30d4@chi-expr (bf30cc@chi-local-macro bf415a@value bf413b@e '#f) bf413c@r bf413d@mr) (if (memv bf415f@t '(mutable)) (bf3192@syntax-violation '#f '"attempt to assign to an unexportable variable" bf413b@e) (bf3192@syntax-violation '#f '"invalid syntax" bf413b@e)))))))))))) bf4143@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf4141@t)))))) (set! bf4bd0@bf30d6@chi-set! bf30d6@chi-set!) (set! bf30d8@verify-formals (lambda (bf4161@fmls bf4162@stx) (let ((bf4165@t bf4161@fmls)) (let ((bf4167@ls/false (bf30b2@syntax-dispatch bf4165@t 'each-any))) (if bf4167@ls/false (apply (lambda (bf4169@x*) (if (not (bf2eb3@valid-bound-ids? bf4169@x*)) (bf306c@invalid-fmls-error bf4162@stx bf4161@fmls) (void))) bf4167@ls/false) (let ((bf416b@t bf4165@t)) (let ((bf416d@ls/false (bf30b2@syntax-dispatch bf416b@t '#(each+ any () any)))) (if bf416d@ls/false (apply (lambda (bf416f@x* bf4170@x) (if (not (bf2eb3@valid-bound-ids? (cons bf4170@x bf416f@x*))) (bf306c@invalid-fmls-error bf4162@stx bf4161@fmls) (void))) bf416d@ls/false) (let ((bf4173@t bf416b@t)) (let ((bf4175@ls/false (bf30b2@syntax-dispatch bf4173@t '_))) (if bf4175@ls/false (apply (lambda () (bf3192@syntax-violation '#f '"invalid syntax" bf4162@stx)) bf4175@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf4173@t)))))))))))) (set! bf4bd1@bf30d8@verify-formals bf30d8@verify-formals) (set! bf30da@chi-lambda-clause (lambda (bf4177@stx bf4178@fmls bf4179@body* bf417a@r bf417b@mr) (let ((bf4181@t bf4178@fmls)) (let ((bf4183@ls/false (bf30b2@syntax-dispatch bf4181@t 'each-any))) (if bf4183@ls/false (apply (lambda (bf4185@x*) (begin (bf30d8@verify-formals bf4178@fmls bf4177@stx) (let ((bf4187@lex* (map bf2e33@gen-lexical bf4185@x*)) (bf4188@lab* (map bf2e37@gen-label bf4185@x*))) (values bf4187@lex* (bf30ea@chi-internal (bf2e95@add-subst (bf2e6b@make-full-rib bf4185@x* bf4188@lab*) bf4179@body*) (bf3044@add-lexicals bf4188@lab* bf4187@lex* bf417a@r) bf417b@mr))))) bf4183@ls/false) (let ((bf418b@t bf4181@t)) (let ((bf418d@ls/false (bf30b2@syntax-dispatch bf418b@t '#(each+ any () any)))) (if bf418d@ls/false (apply (lambda (bf418f@x* bf4190@x) (begin (bf30d8@verify-formals bf4178@fmls bf4177@stx) (let ((bf4193@lex* (map bf2e33@gen-lexical bf418f@x*)) (bf4194@lab* (map bf2e37@gen-label bf418f@x*)) (bf4195@lex (bf2e33@gen-lexical bf4190@x)) (bf4196@lab (bf2e37@gen-label bf4190@x))) (values (append bf4193@lex* bf4195@lex) (bf30ea@chi-internal (bf2e95@add-subst (bf2e6b@make-full-rib (cons bf4190@x bf418f@x*) (cons bf4196@lab bf4194@lab*)) bf4179@body*) (bf3044@add-lexicals (cons bf4196@lab bf4194@lab*) (cons bf4195@lex bf4193@lex*) bf417a@r) bf417b@mr))))) bf418d@ls/false) (let ((bf419b@t bf418b@t)) (let ((bf419d@ls/false (bf30b2@syntax-dispatch bf419b@t '_))) (if bf419d@ls/false (apply (lambda () (bf3192@syntax-violation '#f '"invalid syntax" bf4178@fmls)) bf419d@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf419b@t)))))))))))) (set! bf4bd2@bf30da@chi-lambda-clause bf30da@chi-lambda-clause) (set! bf30dc@chi-lambda-clause* (lambda (bf419f@stx bf41a0@fmls* bf41a1@body** bf41a2@r bf41a3@mr) (if (null? bf41a0@fmls*) (values '() '()) (call-with-values (lambda () (bf30da@chi-lambda-clause bf419f@stx (car bf41a0@fmls*) (car bf41a1@body**) bf41a2@r bf41a3@mr)) (lambda (bf41ad@bf41aa bf41ae@bf41ac) (let ((bf41b1@b bf41ae@bf41ac) (bf41b2@a bf41ad@bf41aa)) (call-with-values (lambda () (bf30dc@chi-lambda-clause* bf419f@stx (cdr bf41a0@fmls*) (cdr bf41a1@body**) bf41a2@r bf41a3@mr)) (lambda (bf41b9@bf41b6 bf41ba@bf41b8) (let ((bf41bd@b* bf41ba@bf41b8) (bf41be@a* bf41b9@bf41b6)) (values (cons bf41b2@a bf41be@a*) (cons bf41b1@b bf41bd@b*))))))))))) (set! bf4bd3@bf30dc@chi-lambda-clause* bf30dc@chi-lambda-clause*) (set! bf30de@chi-defun (lambda (bf41c1@x bf41c2@r bf41c3@mr) (let ((bf41c7@fmls (car bf41c1@x)) (bf41c8@body* (cdr bf41c1@x))) (call-with-values (lambda () (bf30da@chi-lambda-clause bf41c7@fmls bf41c7@fmls bf41c8@body* bf41c2@r bf41c3@mr)) (lambda (bf41cf@bf41cc bf41d0@bf41ce) (let ((bf41d3@body bf41d0@bf41ce) (bf41d4@fmls bf41cf@bf41cc)) (bf2e0e@bf2d40@build-lambda '#f bf41d4@fmls bf41d3@body))))))) (set! bf4bd4@bf30de@chi-defun bf30de@chi-defun) (set! bf30e0@chi-rhs (lambda (bf41d7@rhs bf41d8@r bf41d9@mr) (let ((bf41dd@t (car bf41d7@rhs))) (if (memv bf41dd@t '(defun)) (bf30de@chi-defun (cdr bf41d7@rhs) bf41d8@r bf41d9@mr) (if (memv bf41dd@t '(expr)) (let ((bf41df@expr (cdr bf41d7@rhs))) (bf30d4@chi-expr bf41df@expr bf41d8@r bf41d9@mr)) (if (memv bf41dd@t '(top-expr)) (let ((bf41e1@expr (cdr bf41d7@rhs))) (bf2e10@bf2d70@build-sequence '#f (list (bf30d4@chi-expr bf41e1@expr bf41d8@r bf41d9@mr) (bf2e11@bf2d72@build-void)))) (assertion-violation 'chi-rhs '"BUG: invalid rhs" bf41d7@rhs))))))) (set! bf4bd5@bf30e0@chi-rhs bf30e0@chi-rhs) (set! bf30e2@expand-interaction-rhs*/init* (lambda (bf41e3@lhs* bf41e4@rhs* bf41e5@init* bf41e6@r bf41e7@mr) (let bf41f1@f ((bf41ed@lhs* bf41e3@lhs*) (bf41ee@rhs* bf41e4@rhs*)) (if (null? bf41ed@lhs*) (map (lambda (bf41f3@x) (bf30d4@chi-expr bf41f3@x bf41e6@r bf41e7@mr)) bf41e5@init*) (let ((bf41f5@lhs (car bf41ed@lhs*)) (bf41f6@rhs (car bf41ee@rhs*))) (let ((bf41f9@t (car bf41f6@rhs))) (if (memv bf41f9@t '(defun)) (let ((bf41fb@rhs (bf30de@chi-defun (cdr bf41f6@rhs) bf41e6@r bf41e7@mr))) (cons (list 'set! bf41f5@lhs bf41fb@rhs) (bf41f1@f (cdr bf41ed@lhs*) (cdr bf41ee@rhs*)))) (if (memv bf41f9@t '(expr)) (let ((bf41fd@rhs (bf30d4@chi-expr (cdr bf41f6@rhs) bf41e6@r bf41e7@mr))) (cons (list 'set! bf41f5@lhs bf41fd@rhs) (bf41f1@f (cdr bf41ed@lhs*) (cdr bf41ee@rhs*)))) (if (memv bf41f9@t '(top-expr)) (let ((bf41ff@e (bf30d4@chi-expr (cdr bf41f6@rhs) bf41e6@r bf41e7@mr))) (cons bf41ff@e (bf41f1@f (cdr bf41ed@lhs*) (cdr bf41ee@rhs*)))) (error 'expand-interaction '"invallid" bf41f6@rhs)))))))))) (set! bf4bd6@bf30e2@expand-interaction-rhs*/init* bf30e2@expand-interaction-rhs*/init*) (set! bf30e4@chi-rhs* (lambda (bf4201@rhs* bf4202@r bf4203@mr) (let bf4209@f ((bf4207@ls bf4201@rhs*)) (if (null? bf4207@ls) '() (let ((bf420b@a (bf30e0@chi-rhs (car bf4207@ls) bf4202@r bf4203@mr))) (cons bf420b@a (bf4209@f (cdr bf4207@ls)))))))) (set! bf4bd7@bf30e4@chi-rhs* bf30e4@chi-rhs*) (set! bf30e6@find-bound=? (lambda (bf420d@x bf420e@lhs* bf420f@rhs*) (if (null? bf420e@lhs*) '#f (if (bf2eaf@bound-id=? bf420d@x (car bf420e@lhs*)) (car bf420f@rhs*) (bf30e6@find-bound=? bf420d@x (cdr bf420e@lhs*) (cdr bf420f@rhs*)))))) (set! bf4bd8@bf30e6@find-bound=? bf30e6@find-bound=?) (set! bf30e8@find-dups (lambda (bf4213@ls) (let bf4219@f ((bf4215@ls bf4213@ls) (bf4216@dups '())) (if (null? bf4215@ls) bf4216@dups (let ((bf421b@t (bf30e6@find-bound=? (car bf4215@ls) (cdr bf4215@ls) (cdr bf4215@ls)))) (if bf421b@t ((lambda (bf421d@x) (bf4219@f (cdr bf4215@ls) (cons (list (car bf4215@ls) bf421d@x) bf4216@dups))) bf421b@t) (bf4219@f (cdr bf4215@ls) bf4216@dups))))))) (set! bf4bd9@bf30e8@find-dups bf30e8@find-dups) (set! bf30ea@chi-internal (lambda (bf421f@e* bf4220@r bf4221@mr) (let ((bf4225@rib (bf2e5f@make-empty-rib))) (call-with-values (lambda () (bf310a@chi-body* (map (lambda (bf4237@x) (bf2e95@add-subst bf4225@rib bf4237@x)) (bf2ea9@syntax->list bf421f@e*)) bf4220@r bf4221@mr '() '() '() '() '() bf4225@rib '#f)) (lambda (bf4239@bf4228 bf423a@bf422a bf423b@bf422c bf423c@bf422e bf423d@bf4230 bf423e@bf4232 bf423f@bf4234 bf4240@bf4236) (let ((bf4249@_exp* bf4240@bf4236) (bf424a@kwd* bf423f@bf4234) (bf424b@mod** bf423e@bf4232) (bf424c@rhs* bf423d@bf4230) (bf424d@lex* bf423c@bf422e) (bf424e@mr bf423b@bf422c) (bf424f@r bf423a@bf422a) (bf4250@e* bf4239@bf4228)) (begin (if (null? bf4250@e*) (bf3192@syntax-violation '#f '"no expression in body" bf4250@e*) (void)) (let ((bf4259@init* (bf30d0@chi-expr* (append (apply append (reverse bf424b@mod**)) bf4250@e*) bf424f@r bf424e@mr))) (let ((bf425b@rhs* (bf30e4@chi-rhs* bf424c@rhs* bf424f@r bf424e@mr))) (bf2e15@bf2d7a@build-letrec* '#f (reverse bf424d@lex*) (reverse bf425b@rhs*) (bf2e10@bf2d70@build-sequence '#f bf4259@init*))))))))))) (set! bf4bda@bf30ea@chi-internal bf30ea@chi-internal) (set! bf30ec@parse-module (lambda (bf425d@e) (let ((bf425f@t bf425d@e)) (let ((bf4261@ls/false (bf30b2@syntax-dispatch bf425f@t '(_ each-any . each-any)))) (if bf4261@ls/false (apply (lambda (bf4263@export* bf4264@b*) (begin (if (not (for-all bf2eab@id? bf4263@export*)) (bf3192@syntax-violation '#f '"module exports must be identifiers" bf425d@e) (void)) (values '#f (list->vector bf4263@export*) bf4264@b*))) bf4261@ls/false) (let ((bf4267@t bf425f@t)) (let ((bf4269@ls/false (bf30b2@syntax-dispatch bf4267@t '(_ any each-any . each-any)))) (if bf4269@ls/false (apply (lambda (bf426b@name bf426c@export* bf426d@b*) (begin (if (not (bf2eab@id? bf426b@name)) (bf3192@syntax-violation '#f '"module name must be an identifier" bf425d@e) (void)) (if (not (for-all bf2eab@id? bf426c@export*)) (bf3192@syntax-violation '#f '"module exports must be identifiers" bf425d@e) (void)) (values bf426b@name (list->vector bf426c@export*) bf426d@b*))) bf4269@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf4267@t))))))))) (set! bf4bdb@bf30ec@parse-module bf30ec@parse-module) (set! bf30f6@module-interface? (lambda (bf4271@x) (and (simple-struct? bf4271@x) (eq? (simple-struct-name bf4271@x) 'module-interface)))) (set! bf4bdc@bf30f6@module-interface? bf30f6@module-interface?) (set! bf30f8@module-interface-first-mark (lambda (bf4273@x) (simple-struct-ref bf4273@x '0))) (set! bf4bdd@bf30f8@module-interface-first-mark bf30f8@module-interface-first-mark) (set! bf30fa@set-module-interface-first-mark! (lambda (bf4275@x bf4276@val) (simple-struct-set! bf4275@x '0 bf4276@val))) (set! bf4bde@bf30fa@set-module-interface-first-mark! bf30fa@set-module-interface-first-mark!) (set! bf30fc@module-interface-exp-id-vec (lambda (bf4279@x) (simple-struct-ref bf4279@x '1))) (set! bf4bdf@bf30fc@module-interface-exp-id-vec bf30fc@module-interface-exp-id-vec) (set! bf30fe@set-module-interface-exp-id-vec! (lambda (bf427b@x bf427c@val) (simple-struct-set! bf427b@x '1 bf427c@val))) (set! bf4be0@bf30fe@set-module-interface-exp-id-vec! bf30fe@set-module-interface-exp-id-vec!) (set! bf3100@module-interface-exp-lab-vec (lambda (bf427f@x) (simple-struct-ref bf427f@x '2))) (set! bf4be1@bf3100@module-interface-exp-lab-vec bf3100@module-interface-exp-lab-vec) (set! bf3102@set-module-interface-exp-lab-vec! (lambda (bf4281@x bf4282@val) (simple-struct-set! bf4281@x '2 bf4282@val))) (set! bf4be2@bf3102@set-module-interface-exp-lab-vec! bf3102@set-module-interface-exp-lab-vec!) (set! bf3104@dummy '3) (set! bf4be3@bf3104@dummy bf3104@dummy) (set! bf3106@module-interface-exp-id* (lambda (bf4285@iface bf4286@id) (letrec* ((bf428a@diff-marks (lambda (bf4291@ls bf4292@x) (begin (if (null? bf4291@ls) (error 'diff-marks '"BUG: should not happen") (void)) (let ((bf4295@a (car bf4291@ls))) (if (eq? bf4295@a bf4292@x) '() (cons bf4295@a (bf428a@diff-marks (cdr bf4291@ls) bf4292@x)))))))) (let ((bf428b@diff (bf428a@diff-marks (bf2e7d@stx-mark* bf4286@id) (bf30f8@module-interface-first-mark bf4285@iface))) (bf428c@id-vec (bf30fc@module-interface-exp-id-vec bf4285@iface))) (if (null? bf428b@diff) bf428c@id-vec (vector-map (lambda (bf428f@x) (make-simple-struct 'stx '5 (list (bf2e79@stx-expr bf428f@x) (append bf428b@diff (bf2e7d@stx-mark* bf428f@x)) '() '()))) bf428c@id-vec)))))) (set! bf4be4@bf3106@module-interface-exp-id* bf3106@module-interface-exp-id*) (set! bf3108@chi-internal-module (lambda (bf4297@e bf4298@r bf4299@mr bf429a@lex* bf429b@rhs* bf429c@mod** bf429d@kwd*) (call-with-values (lambda () (bf30ec@parse-module bf4297@e)) (lambda (bf42ab@bf42a6 bf42ac@bf42a8 bf42ad@bf42aa) (let ((bf42b1@e* bf42ad@bf42aa) (bf42b2@exp-id* bf42ac@bf42a8) (bf42b3@name bf42ab@bf42a6)) (let ((bf42b7@rib (bf2e5f@make-empty-rib))) (let ((bf42b9@e* (map (lambda (bf42bb@x) (bf2e95@add-subst bf42b7@rib bf42bb@x)) (bf2ea9@syntax->list bf42b1@e*)))) (call-with-values (lambda () (bf310a@chi-body* bf42b9@e* bf4298@r bf4299@mr bf429a@lex* bf429b@rhs* bf429c@mod** bf429d@kwd* '() bf42b7@rib '#f)) (lambda (bf42cd@bf42be bf42ce@bf42c0 bf42cf@bf42c2 bf42d0@bf42c4 bf42d1@bf42c6 bf42d2@bf42c8 bf42d3@bf42ca bf42d4@bf42cc) (let ((bf42dd@_exp* bf42d4@bf42cc) (bf42de@kwd* bf42d3@bf42ca) (bf42df@mod** bf42d2@bf42c8) (bf42e0@rhs* bf42d1@bf42c6) (bf42e1@lex* bf42d0@bf42c4) (bf42e2@mr bf42cf@bf42c2) (bf42e3@r bf42ce@bf42c0) (bf42e4@e* bf42cd@bf42be)) (let ((bf42ed@exp-lab* (vector-map (lambda (bf42f1@x) (or (bf2ec1@id->label (make-simple-struct 'stx '5 (list (bf2ead@id->sym bf42f1@x) (bf2e7d@stx-mark* bf42f1@x) (list bf42b7@rib) '()))) (bf3192@syntax-violation '#f '"cannot find module export" bf42f1@x))) bf42b2@exp-id*)) (bf42ee@mod** (cons bf42e4@e* bf42df@mod**))) (if (not bf42b3@name) (values bf42e1@lex* bf42e0@rhs* bf42b2@exp-id* bf42ed@exp-lab* bf42e3@r bf42e2@mr bf42ee@mod** bf42de@kwd*) (let ((bf42f3@lab (bf2e37@gen-label 'module)) (bf42f4@iface (make-simple-struct 'module-interface '4 (list (car (bf2e7d@stx-mark* bf42b3@name)) (vector-map (lambda (bf42f7@x) (make-simple-struct 'stx '5 (list (bf2e79@stx-expr bf42f7@x) (bf2e7d@stx-mark* bf42f7@x) '() '()))) bf42b2@exp-id*) bf42ed@exp-lab*)))) (values bf42e1@lex* bf42e0@rhs* (vector bf42b3@name) (vector bf42f3@lab) (cons (cons bf42f3@lab (cons '$module bf42f4@iface)) bf42e3@r) (cons (cons bf42f3@lab (cons '$module bf42f4@iface)) bf42e2@mr) bf42ee@mod** bf42de@kwd*)))))))))))))) (set! bf4be5@bf3108@chi-internal-module bf3108@chi-internal-module) (set! bf310a@chi-body* (lambda (bf42f9@e* bf42fa@r bf42fb@mr bf42fc@lex* bf42fd@rhs* bf42fe@mod** bf42ff@kwd* bf4300@exp* bf4301@rib bf4302@top?) (if (null? bf42f9@e*) (values bf42f9@e* bf42fa@r bf42fb@mr bf42fc@lex* bf42fd@rhs* bf42fe@mod** bf42ff@kwd* bf4300@exp*) (let ((bf430d@e (car bf42f9@e*))) (call-with-values (lambda () (bf2ecd@syntax-type bf430d@e bf42fa@r)) (lambda (bf4315@bf4310 bf4316@bf4312 bf4317@bf4314) (let ((bf431b@kwd bf4317@bf4314) (bf431c@value bf4316@bf4312) (bf431d@type bf4315@bf4310)) (let ((bf4321@kwd* (if (bf2eab@id? bf431b@kwd) (cons bf431b@kwd bf42ff@kwd*) bf42ff@kwd*))) (let ((bf4323@t bf431d@type)) (if (memv bf4323@t '(define)) (call-with-values (lambda () (bf3034@parse-define bf430d@e)) (lambda (bf4329@bf4326 bf432a@bf4328) (let ((bf432d@rhs bf432a@bf4328) (bf432e@id bf4329@bf4326)) (begin (if (bf2eb7@bound-id-member? bf432e@id bf4321@kwd*) (bf3192@syntax-violation '#f '"cannot redefine keyword" bf430d@e) (void)) (call-with-values (lambda () (bf2e3b@gen-define-label+loc bf432e@id bf4301@rib)) (lambda (bf4335@bf4332 bf4336@bf4334) (let ((bf4339@lex bf4336@bf4334) (bf433a@lab bf4335@bf4332)) (begin (bf2e61@extend-rib! bf4301@rib bf432e@id bf433a@lab) (bf310a@chi-body* (cdr bf42f9@e*) (bf3042@add-lexical bf433a@lab bf4339@lex bf42fa@r) bf42fb@mr (cons bf4339@lex bf42fc@lex*) (cons bf432d@rhs bf42fd@rhs*) bf42fe@mod** bf4321@kwd* bf4300@exp* bf4301@rib bf4302@top?))))))))) (if (memv bf4323@t '(define-syntax)) (call-with-values (lambda () (bf3036@parse-define-syntax bf430d@e)) (lambda (bf4341@bf433e bf4342@bf4340) (let ((bf4345@rhs bf4342@bf4340) (bf4346@id bf4341@bf433e)) (begin (if (bf2eb7@bound-id-member? bf4346@id bf4321@kwd*) (bf3192@syntax-violation '#f '"cannot redefine keyword" bf430d@e) (void)) (let ((bf4349@lab (bf2e3d@gen-define-label bf4346@id bf4301@rib)) (bf434a@expanded-rhs (bf310c@expand-transformer bf4345@rhs bf42fb@mr))) (begin (bf2e61@extend-rib! bf4301@rib bf4346@id bf4349@lab) (let ((bf434d@b (bf2ee3@make-eval-transformer bf434a@expanded-rhs))) (bf310a@chi-body* (cdr bf42f9@e*) (cons (cons bf4349@lab bf434d@b) bf42fa@r) (cons (cons bf4349@lab bf434d@b) bf42fb@mr) bf42fc@lex* bf42fd@rhs* bf42fe@mod** bf4321@kwd* bf4300@exp* bf4301@rib bf4302@top?)))))))) (if (memv bf4323@t '(let-syntax letrec-syntax)) (let ((bf434f@t bf430d@e)) (let ((bf4351@ls/false (bf30b2@syntax-dispatch bf434f@t '(_ #(each (any any)) . each-any)))) (if (and bf4351@ls/false (apply (lambda (bf4353@xlhs* bf4354@xrhs* bf4355@xbody*) (if (not (bf2eb3@valid-bound-ids? bf4353@xlhs*)) (bf3192@syntax-violation '#f '"invalid identifiers" bf430d@e) (void))) bf4351@ls/false)) (apply (lambda (bf4359@xlhs* bf435a@xrhs* bf435b@xbody*) (let ((bf435f@xlab* (map bf2e37@gen-label bf4359@xlhs*))) (let ((bf4361@xrib (bf2e6b@make-full-rib bf4359@xlhs* bf435f@xlab*))) (let ((bf4363@xb* (map (lambda (bf4365@x) (bf2ee3@make-eval-transformer (bf310c@expand-transformer (if (eq? bf431d@type 'let-syntax) bf4365@x (bf2e95@add-subst bf4361@xrib bf4365@x)) bf42fb@mr))) bf435a@xrhs*))) (bf310a@chi-body* (append (map (lambda (bf4367@x) (bf2e95@add-subst bf4361@xrib bf4367@x)) bf435b@xbody*) (cdr bf42f9@e*)) (append (map cons bf435f@xlab* bf4363@xb*) bf42fa@r) (append (map cons bf435f@xlab* bf4363@xb*) bf42fb@mr) bf42fc@lex* bf42fd@rhs* bf42fe@mod** bf4321@kwd* bf4300@exp* bf4301@rib bf4302@top?))))) bf4351@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf434f@t)))) (if (memv bf4323@t '(begin)) (let ((bf4369@t bf430d@e)) (let ((bf436b@ls/false (bf30b2@syntax-dispatch bf4369@t '(_ . each-any)))) (if bf436b@ls/false (apply (lambda (bf436d@x*) (bf310a@chi-body* (append bf436d@x* (cdr bf42f9@e*)) bf42fa@r bf42fb@mr bf42fc@lex* bf42fd@rhs* bf42fe@mod** bf4321@kwd* bf4300@exp* bf4301@rib bf4302@top?)) bf436b@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf4369@t)))) (if (memv bf4323@t '(global-macro global-macro!)) (bf310a@chi-body* (cons (bf30ce@chi-global-macro bf431c@value bf430d@e bf4301@rib) (cdr bf42f9@e*)) bf42fa@r bf42fb@mr bf42fc@lex* bf42fd@rhs* bf42fe@mod** bf4321@kwd* bf4300@exp* bf4301@rib bf4302@top?) (if (memv bf4323@t '(local-macro local-macro!)) (bf310a@chi-body* (cons (bf30cc@chi-local-macro bf431c@value bf430d@e bf4301@rib) (cdr bf42f9@e*)) bf42fa@r bf42fb@mr bf42fc@lex* bf42fd@rhs* bf42fe@mod** bf4321@kwd* bf4300@exp* bf4301@rib bf4302@top?) (if (memv bf4323@t '(macro macro!)) (bf310a@chi-body* (cons (bf30ca@chi-macro bf431c@value bf430d@e bf4301@rib) (cdr bf42f9@e*)) bf42fa@r bf42fb@mr bf42fc@lex* bf42fd@rhs* bf42fe@mod** bf4321@kwd* bf4300@exp* bf4301@rib bf4302@top?) (if (memv bf4323@t '(module)) (call-with-values (lambda () (bf3108@chi-internal-module bf430d@e bf42fa@r bf42fb@mr bf42fc@lex* bf42fd@rhs* bf42fe@mod** bf4321@kwd*)) (lambda (bf437f@bf4370 bf4380@bf4372 bf4381@bf4374 bf4382@bf4376 bf4383@bf4378 bf4384@bf437a bf4385@bf437c bf4386@bf437e) (let ((bf438f@kwd* bf4386@bf437e) (bf4390@mod** bf4385@bf437c) (bf4391@mr bf4384@bf437a) (bf4392@r bf4383@bf4378) (bf4393@m-exp-lab* bf4382@bf4376) (bf4394@m-exp-id* bf4381@bf4374) (bf4395@rhs* bf4380@bf4372) (bf4396@lex* bf437f@bf4370)) (begin (vector-for-each (lambda (bf439f@id bf43a0@lab) (bf2e61@extend-rib! bf4301@rib bf439f@id bf43a0@lab)) bf4394@m-exp-id* bf4393@m-exp-lab*) (bf310a@chi-body* (cdr bf42f9@e*) bf4392@r bf4391@mr bf4396@lex* bf4395@rhs* bf4390@mod** bf438f@kwd* bf4300@exp* bf4301@rib bf4302@top?))))) (if (memv bf4323@t '(library)) (begin (bf3174@library-expander (bf2ebf@stx->datum bf430d@e)) (bf310a@chi-body* (cdr bf42f9@e*) bf42fa@r bf42fb@mr bf42fc@lex* bf42fd@rhs* bf42fe@mod** bf4321@kwd* bf4300@exp* bf4301@rib bf4302@top?)) (if (memv bf4323@t '(export)) (let ((bf43a3@t bf430d@e)) (let ((bf43a5@ls/false (bf30b2@syntax-dispatch bf43a3@t '(_ . each-any)))) (if bf43a5@ls/false (apply (lambda (bf43a7@exp-decl*) (bf310a@chi-body* (cdr bf42f9@e*) bf42fa@r bf42fb@mr bf42fc@lex* bf42fd@rhs* bf42fe@mod** bf4321@kwd* (append bf43a7@exp-decl* bf4300@exp*) bf4301@rib bf4302@top?)) bf43a5@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf43a3@t)))) (if (memv bf4323@t '(import)) (letrec* ((bf43aa@module-import? (lambda (bf43fd@e) (let ((bf43ff@t bf43fd@e)) (let ((bf4401@ls/false (bf30b2@syntax-dispatch bf43ff@t '(_ any)))) (if (and bf4401@ls/false (apply (lambda (bf4403@id) (bf2eab@id? bf4403@id)) bf4401@ls/false)) (apply (lambda (bf4405@id) '#t) bf4401@ls/false) (let ((bf4407@t bf43ff@t)) (let ((bf4409@ls/false (bf30b2@syntax-dispatch bf4407@t '(_ . each-any)))) (if bf4409@ls/false (apply (lambda (bf440b@imp*) '#f) bf4409@ls/false) (let ((bf440d@t bf4407@t)) (let ((bf440f@ls/false (bf30b2@syntax-dispatch bf440d@t '_))) (if bf440f@ls/false (apply (lambda () (bf3192@syntax-violation '#f '"malformed import form" bf43fd@e)) bf440f@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf440d@t)))))))))))) (bf43ac@module-import (lambda (bf43db@e bf43dc@r) (let ((bf43df@t bf43db@e)) (let ((bf43e1@ls/false (bf30b2@syntax-dispatch bf43df@t '(_ any)))) (if (and bf43e1@ls/false (apply (lambda (bf43e3@id) (bf2eab@id? bf43e3@id)) bf43e1@ls/false)) (apply (lambda (bf43e5@id) (call-with-values (lambda () (bf2ecd@syntax-type bf43e5@id bf43dc@r)) (lambda (bf43ed@bf43e8 bf43ee@bf43ea bf43ef@bf43ec) (let ((bf43f3@kwd bf43ef@bf43ec) (bf43f4@value bf43ee@bf43ea) (bf43f5@type bf43ed@bf43e8)) (let ((bf43f9@t bf43f5@type)) (if (memv bf43f9@t '($module)) (let ((bf43fb@iface bf43f4@value)) (values (bf3106@module-interface-exp-id* bf43fb@iface bf43e5@id) (bf3100@module-interface-exp-lab-vec bf43fb@iface))) (bf3192@syntax-violation '#f '"invalid import" bf43db@e))))))) bf43e1@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf43df@t)))))) (bf43ae@library-import (lambda (bf43bf@e) (let ((bf43c1@t bf43bf@e)) (let ((bf43c3@ls/false (bf30b2@syntax-dispatch bf43c1@t '(any . each-any)))) (if bf43c3@ls/false (apply (lambda (bf43c5@ctxt bf43c6@imp*) (call-with-values (lambda () (bf3114@parse-import-spec* (bf3198@syntax->datum bf43c6@imp*))) (lambda (bf43cd@bf43ca bf43ce@bf43cc) (let ((bf43d1@subst-labels bf43ce@bf43cc) (bf43d2@subst-names bf43cd@bf43ca)) (values (vector-map (lambda (bf43d5@name) (bf2e8b@datum->stx bf43c5@ctxt bf43d5@name)) bf43d2@subst-names) bf43d1@subst-labels))))) bf43c3@ls/false) (let ((bf43d7@t bf43c1@t)) (let ((bf43d9@ls/false (bf30b2@syntax-dispatch bf43d7@t '_))) (if bf43d9@ls/false (apply (lambda () (bf3192@syntax-violation '#f '"invalid import form" bf43bf@e)) bf43d9@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf43d7@t)))))))))) (begin (call-with-values (lambda () (if (bf43aa@module-import? bf430d@e) (bf43ac@module-import bf430d@e bf42fa@r) (bf43ae@library-import bf430d@e))) (lambda (bf43b3@bf43b0 bf43b4@bf43b2) (let ((bf43b7@lab* bf43b4@bf43b2) (bf43b8@id* bf43b3@bf43b0)) (vector-for-each (lambda (bf43bb@id bf43bc@lab) (bf2e61@extend-rib! bf4301@rib bf43bb@id bf43bc@lab)) bf43b8@id* bf43b7@lab*)))) (bf310a@chi-body* (cdr bf42f9@e*) bf42fa@r bf42fb@mr bf42fc@lex* bf42fd@rhs* bf42fe@mod** bf4321@kwd* bf4300@exp* bf4301@rib bf4302@top?))) (if bf4302@top? (bf310a@chi-body* (cdr bf42f9@e*) bf42fa@r bf42fb@mr (cons (bf2e33@gen-lexical 'dummy) bf42fc@lex*) (cons (cons 'top-expr bf430d@e) bf42fd@rhs*) bf42fe@mod** bf4321@kwd* bf4300@exp* bf4301@rib bf4302@top?) (values bf42f9@e* bf42fa@r bf42fb@mr bf42fc@lex* bf42fd@rhs* bf42fe@mod** bf4321@kwd* bf4300@exp*)))))))))))))))))))))) (set! bf4be6@bf310a@chi-body* bf310a@chi-body*) (set! bf310c@expand-transformer (lambda (bf4411@expr bf4412@r) (let ((bf4415@rtc (bf3118@make-collector))) (let ((bf4417@expanded-rhs (let ((bf4421@bf441a bf311a@inv-collector) (bf4422@bf441c bf311c@vis-collector) (bf4423@bf441e bf4415@rtc) (bf4424@bf4420 (lambda (bf4429@x) (values)))) (let ((bf442b@swap (lambda () (begin (let ((bf442d@t (bf4421@bf441a))) (begin (bf4421@bf441a bf4423@bf441e) (set! bf4423@bf441e bf442d@t))) (let ((bf442f@t (bf4422@bf441c))) (begin (bf4422@bf441c bf4424@bf4420) (set! bf4424@bf4420 bf442f@t))))))) (dynamic-wind bf442b@swap (lambda () (bf30d4@chi-expr bf4411@expr bf4412@r bf4412@r)) bf442b@swap))))) (begin (for-each (let ((bf4431@mark-visit (bf311c@vis-collector))) (lambda (bf4433@x) (begin (bf2cc7@bf2b15@invoke-library bf4433@x) (bf4431@mark-visit bf4433@x)))) (bf4415@rtc)) bf4417@expanded-rhs))))) (set! bf4be7@bf310c@expand-transformer bf310c@expand-transformer) (set! bf310e@parse-exports (lambda (bf4435@exp*) (let bf443d@f ((bf4437@exp* bf4435@exp*) (bf4438@int* '()) (bf4439@ext* '())) (if (null? bf4437@exp*) (begin (if (not (bf2eb3@valid-bound-ids? bf4439@ext*)) (bf3192@syntax-violation 'export '"invalid exports" (bf30e8@find-dups bf4439@ext*)) (void)) (values (map bf3198@syntax->datum bf4439@ext*) bf4438@int*)) (let ((bf443f@t (car bf4437@exp*))) (let ((bf4441@ls/false (bf30b2@syntax-dispatch bf443f@t '(any . #(each (any any)))))) (if bf4441@ls/false (apply (lambda (bf4443@rename bf4444@i* bf4445@e*) (begin (if (not (and (eq? (bf3198@syntax->datum bf4443@rename) 'rename) (for-all bf2eab@id? bf4444@i*) (for-all bf2eab@id? bf4445@e*))) (bf3192@syntax-violation 'export '"invalid export specifier" (car bf4437@exp*)) (void)) (bf443d@f (cdr bf4437@exp*) (append bf4444@i* bf4438@int*) (append bf4445@e* bf4439@ext*)))) bf4441@ls/false) (let ((bf4449@t bf443f@t)) (let ((bf444b@ls/false (bf30b2@syntax-dispatch bf4449@t 'any))) (if bf444b@ls/false (apply (lambda (bf444d@ie) (begin (if (not (bf2eab@id? bf444d@ie)) (bf3192@syntax-violation 'export '"invalid export" bf444d@ie) (void)) (bf443d@f (cdr bf4437@exp*) (cons bf444d@ie bf4438@int*) (cons bf444d@ie bf4439@ext*)))) bf444b@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf4449@t))))))))))) (set! bf4be8@bf310e@parse-exports bf310e@parse-exports) (set! bf3110@parse-library-name (lambda (bf444f@spec) (letrec* ((bf4452@parse (lambda (bf445f@x) (let ((bf4461@t bf445f@x)) (let ((bf4463@ls/false (bf30b2@syntax-dispatch bf4461@t '(each-any)))) (if (and bf4463@ls/false (apply (lambda (bf4465@v*) (for-all (lambda (bf4467@x) (let ((bf4469@x (bf3198@syntax->datum bf4467@x))) (and (integer? bf4469@x) (exact? bf4469@x)))) bf4465@v*)) bf4463@ls/false)) (apply (lambda (bf446b@v*) (values '() (map bf3198@syntax->datum bf446b@v*))) bf4463@ls/false) (let ((bf446d@t bf4461@t)) (let ((bf446f@ls/false (bf30b2@syntax-dispatch bf446d@t '(any . any)))) (if (and bf446f@ls/false (apply (lambda (bf4471@x bf4472@rest) (symbol? (bf3198@syntax->datum bf4471@x))) bf446f@ls/false)) (apply (lambda (bf4475@x bf4476@rest) (call-with-values (lambda () (bf4452@parse bf4476@rest)) (lambda (bf447d@bf447a bf447e@bf447c) (let ((bf4481@v* bf447e@bf447c) (bf4482@x* bf447d@bf447a)) (values (cons (bf3198@syntax->datum bf4475@x) bf4482@x*) bf4481@v*))))) bf446f@ls/false) (let ((bf4485@t bf446d@t)) (let ((bf4487@ls/false (bf30b2@syntax-dispatch bf4485@t '()))) (if bf4487@ls/false (apply (lambda () (values '() '())) bf4487@ls/false) (let ((bf4489@t bf4485@t)) (let ((bf448b@ls/false (bf30b2@syntax-dispatch bf4489@t '_))) (if bf448b@ls/false (apply (lambda () (bf3192@syntax-violation '#f '"invalid library name" bf444f@spec)) bf448b@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf4489@t)))))))))))))))) (call-with-values (lambda () (bf4452@parse bf444f@spec)) (lambda (bf4457@bf4454 bf4458@bf4456) (let ((bf445b@ver* bf4458@bf4456) (bf445c@name* bf4457@bf4454)) (begin (if (null? bf445c@name*) (bf3192@syntax-violation '#f '"empty library name" bf444f@spec) (void)) (values bf445c@name* bf445b@ver*)))))))) (set! bf4be9@bf3110@parse-library-name bf3110@parse-library-name) (set! bf3112@parse-library (lambda (bf448d@e) (let ((bf448f@t bf448d@e)) (let ((bf4491@ls/false (bf30b2@syntax-dispatch bf448f@t '(any each-any (any . each-any) (any . each-any) . each-any)))) (if (and bf4491@ls/false (apply (lambda (bf4493@library bf4494@name* bf4495@export bf4496@exp* bf4497@import bf4498@imp* bf4499@b*) (and (eq? (bf3198@syntax->datum bf4495@export) 'export) (eq? (bf3198@syntax->datum bf4497@import) 'import) (eq? (bf3198@syntax->datum bf4493@library) 'library))) bf4491@ls/false)) (apply (lambda (bf44a1@library bf44a2@name* bf44a3@export bf44a4@exp* bf44a5@import bf44a6@imp* bf44a7@b*) (values bf44a2@name* bf44a4@exp* bf44a6@imp* bf44a7@b*)) bf4491@ls/false) (let ((bf44af@t bf448f@t)) (let ((bf44b1@ls/false (bf30b2@syntax-dispatch bf44af@t '_))) (if bf44b1@ls/false (apply (lambda () (bf3192@syntax-violation '#f '"malformed library" bf448d@e)) bf44b1@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf44af@t))))))))) (set! bf4bea@bf3112@parse-library bf3112@parse-library) (set! bf3114@parse-import-spec* (letrec* ((bf44b4@idsyn? (lambda (bf46bd@x) (symbol? (bf3198@syntax->datum bf46bd@x)))) (bf44b6@dup-error (lambda (bf46bb@name) (bf3192@syntax-violation 'import '"two imports with different bindings" bf46bb@name))) (bf44b8@merge-substs (lambda (bf46a9@s bf46aa@subst) (letrec* ((bf46ae@insert-to-subst (lambda (bf46af@a bf46b0@subst) (let ((bf46b3@name (car bf46af@a)) (bf46b4@label (cdr bf46af@a))) (let ((bf46b7@t (assq bf46b3@name bf46b0@subst))) (if bf46b7@t ((lambda (bf46b9@x) (if (eq? (cdr bf46b9@x) bf46b4@label) bf46b0@subst (bf44b6@dup-error bf46b3@name))) bf46b7@t) (cons bf46af@a bf46b0@subst))))))) (if (null? bf46a9@s) bf46aa@subst (bf46ae@insert-to-subst (car bf46a9@s) (bf44b8@merge-substs (cdr bf46a9@s) bf46aa@subst)))))) (bf44ba@exclude* (lambda (bf4679@sym* bf467a@subst) (letrec* ((bf467e@exclude (lambda (bf4697@sym bf4698@subst) (if (null? bf4698@subst) (bf3192@syntax-violation 'import '"cannot rename unbound identifier" bf4697@sym) (if (eq? bf4697@sym (caar bf4698@subst)) (values (cdar bf4698@subst) (cdr bf4698@subst)) (let ((bf469b@a (car bf4698@subst))) (call-with-values (lambda () (bf467e@exclude bf4697@sym (cdr bf4698@subst))) (lambda (bf46a1@bf469e bf46a2@bf46a0) (let ((bf46a5@subst bf46a2@bf46a0) (bf46a6@old bf46a1@bf469e)) (values bf46a6@old (cons bf469b@a bf46a5@subst))))))))))) (if (null? bf4679@sym*) (values '() bf467a@subst) (call-with-values (lambda () (bf467e@exclude (car bf4679@sym*) bf467a@subst)) (lambda (bf4683@bf4680 bf4684@bf4682) (let ((bf4687@subst bf4684@bf4682) (bf4688@old bf4683@bf4680)) (call-with-values (lambda () (bf44ba@exclude* (cdr bf4679@sym*) bf4687@subst)) (lambda (bf468f@bf468c bf4690@bf468e) (let ((bf4693@subst bf4690@bf468e) (bf4694@old* bf468f@bf468c)) (values (cons bf4688@old bf4694@old*) bf4693@subst))))))))))) (bf44bc@find* (lambda (bf4671@sym* bf4672@subst) (map (lambda (bf4675@x) (let ((bf4677@t (assq bf4675@x bf4672@subst))) (if bf4677@t (cdr bf4677@t) (bf3192@syntax-violation 'import '"cannot find identifier" bf4675@x)))) bf4671@sym*))) (bf44be@rem* (lambda (bf4669@sym* bf466a@subst) (let bf466f@f ((bf466d@subst bf466a@subst)) (if (null? bf466d@subst) '() (if (memq (caar bf466d@subst) bf4669@sym*) (bf466f@f (cdr bf466d@subst)) (cons (car bf466d@subst) (bf466f@f (cdr bf466d@subst)))))))) (bf44c0@remove-dups (lambda (bf4667@ls) (if (null? bf4667@ls) '() (if (memq (car bf4667@ls) (cdr bf4667@ls)) (bf44c0@remove-dups (cdr bf4667@ls)) (cons (car bf4667@ls) (bf44c0@remove-dups (cdr bf4667@ls))))))) (bf44c2@parse-library-name (lambda (bf457f@spec) (letrec* ((bf4582@subversion? (lambda (bf4663@x) (let ((bf4665@x (bf3198@syntax->datum bf4663@x))) (and (integer? bf4665@x) (exact? bf4665@x) (>= bf4665@x '0))))) (bf4584@subversion-pred (lambda (bf4603@x*) (let ((bf4605@t bf4603@x*)) (let ((bf4607@ls/false (bf30b2@syntax-dispatch bf4605@t 'any))) (if (and bf4607@ls/false (apply (lambda (bf4609@n) (bf4582@subversion? bf4609@n)) bf4607@ls/false)) (apply (lambda (bf460b@n) (lambda (bf460d@x) (= bf460d@x (bf3198@syntax->datum bf460b@n)))) bf4607@ls/false) (let ((bf460f@t bf4605@t)) (let ((bf4611@ls/false (bf30b2@syntax-dispatch bf460f@t '(any . each-any)))) (if (and bf4611@ls/false (apply (lambda (bf4613@p? bf4614@sub*) (eq? (bf3198@syntax->datum bf4613@p?) 'and)) bf4611@ls/false)) (apply (lambda (bf4617@p? bf4618@sub*) (let ((bf461b@p* (map bf4584@subversion-pred bf4618@sub*))) (lambda (bf461d@x) (for-all (lambda (bf461f@p) (bf461f@p bf461d@x)) bf461b@p*)))) bf4611@ls/false) (let ((bf4621@t bf460f@t)) (let ((bf4623@ls/false (bf30b2@syntax-dispatch bf4621@t '(any . each-any)))) (if (and bf4623@ls/false (apply (lambda (bf4625@p? bf4626@sub*) (eq? (bf3198@syntax->datum bf4625@p?) 'or)) bf4623@ls/false)) (apply (lambda (bf4629@p? bf462a@sub*) (let ((bf462d@p* (map bf4584@subversion-pred bf462a@sub*))) (lambda (bf462f@x) (exists (lambda (bf4631@p) (bf4631@p bf462f@x)) bf462d@p*)))) bf4623@ls/false) (let ((bf4633@t bf4621@t)) (let ((bf4635@ls/false (bf30b2@syntax-dispatch bf4633@t '(any any)))) (if (and bf4635@ls/false (apply (lambda (bf4637@p? bf4638@sub) (eq? (bf3198@syntax->datum bf4637@p?) 'not)) bf4635@ls/false)) (apply (lambda (bf463b@p? bf463c@sub) (let ((bf463f@p (bf4584@subversion-pred bf463c@sub))) (lambda (bf4641@x) (not (bf463f@p bf4641@x))))) bf4635@ls/false) (let ((bf4643@t bf4633@t)) (let ((bf4645@ls/false (bf30b2@syntax-dispatch bf4643@t '(any any)))) (if (and bf4645@ls/false (apply (lambda (bf4647@p? bf4648@n) (and (eq? (bf3198@syntax->datum bf4647@p?) '<=) (bf4582@subversion? bf4648@n))) bf4645@ls/false)) (apply (lambda (bf464b@p? bf464c@n) (lambda (bf464f@x) (<= bf464f@x (bf3198@syntax->datum bf464c@n)))) bf4645@ls/false) (let ((bf4651@t bf4643@t)) (let ((bf4653@ls/false (bf30b2@syntax-dispatch bf4651@t '(any any)))) (if (and bf4653@ls/false (apply (lambda (bf4655@p? bf4656@n) (and (eq? (bf3198@syntax->datum bf4655@p?) '>=) (bf4582@subversion? bf4656@n))) bf4653@ls/false)) (apply (lambda (bf4659@p? bf465a@n) (lambda (bf465d@x) (>= bf465d@x (bf3198@syntax->datum bf465a@n)))) bf4653@ls/false) (let ((bf465f@t bf4651@t)) (let ((bf4661@ls/false (bf30b2@syntax-dispatch bf465f@t '_))) (if bf4661@ls/false (apply (lambda () (bf3192@syntax-violation 'import '"invalid sub-version spec" bf457f@spec bf4603@x*)) bf4661@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf465f@t)))))))))))))))))))))))) (bf4586@version-pred (lambda (bf45b3@x*) (let ((bf45b5@t bf45b3@x*)) (let ((bf45b7@ls/false (bf30b2@syntax-dispatch bf45b5@t '()))) (if bf45b7@ls/false (apply (lambda () (lambda (bf45b9@x) '#t)) bf45b7@ls/false) (let ((bf45bb@t bf45b5@t)) (let ((bf45bd@ls/false (bf30b2@syntax-dispatch bf45bb@t '(any . each-any)))) (if (and bf45bd@ls/false (apply (lambda (bf45bf@c bf45c0@ver*) (eq? (bf3198@syntax->datum bf45bf@c) 'and)) bf45bd@ls/false)) (apply (lambda (bf45c3@c bf45c4@ver*) (let ((bf45c7@p* (map bf4586@version-pred bf45c4@ver*))) (lambda (bf45c9@x) (for-all (lambda (bf45cb@p) (bf45cb@p bf45c9@x)) bf45c7@p*)))) bf45bd@ls/false) (let ((bf45cd@t bf45bb@t)) (let ((bf45cf@ls/false (bf30b2@syntax-dispatch bf45cd@t '(any . each-any)))) (if (and bf45cf@ls/false (apply (lambda (bf45d1@c bf45d2@ver*) (eq? (bf3198@syntax->datum bf45d1@c) 'or)) bf45cf@ls/false)) (apply (lambda (bf45d5@c bf45d6@ver*) (let ((bf45d9@p* (map bf4586@version-pred bf45d6@ver*))) (lambda (bf45db@x) (exists (lambda (bf45dd@p) (bf45dd@p bf45db@x)) bf45d9@p*)))) bf45cf@ls/false) (let ((bf45df@t bf45cd@t)) (let ((bf45e1@ls/false (bf30b2@syntax-dispatch bf45df@t '(any any)))) (if (and bf45e1@ls/false (apply (lambda (bf45e3@c bf45e4@ver) (eq? (bf3198@syntax->datum bf45e3@c) 'not)) bf45e1@ls/false)) (apply (lambda (bf45e7@c bf45e8@ver) (let ((bf45eb@p (bf4586@version-pred bf45e8@ver))) (lambda (bf45ed@x) (not (bf45eb@p bf45ed@x))))) bf45e1@ls/false) (let ((bf45ef@t bf45df@t)) (let ((bf45f1@ls/false (bf30b2@syntax-dispatch bf45ef@t 'each-any))) (if bf45f1@ls/false (apply (lambda (bf45f3@sub*) (let ((bf45f5@p* (map bf4584@subversion-pred bf45f3@sub*))) (lambda (bf45f7@x) (let bf45fd@f ((bf45f9@p* bf45f5@p*) (bf45fa@x bf45f7@x)) (if (null? bf45f9@p*) '#t (if (null? bf45fa@x) '#f (and ((car bf45f9@p*) (car bf45fa@x)) (bf45fd@f (cdr bf45f9@p*) (cdr bf45fa@x))))))))) bf45f1@ls/false) (let ((bf45ff@t bf45ef@t)) (let ((bf4601@ls/false (bf30b2@syntax-dispatch bf45ff@t '_))) (if bf4601@ls/false (apply (lambda () (bf3192@syntax-violation 'import '"invalid version spec" bf457f@spec bf45b3@x*)) bf4601@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf45ff@t)))))))))))))))))))))) (let bf4589@f ((bf4587@x bf457f@spec)) (let ((bf458b@t bf4587@x)) (let ((bf458d@ls/false (bf30b2@syntax-dispatch bf458b@t '(each-any)))) (if bf458d@ls/false (apply (lambda (bf458f@version-spec*) (values '() (bf4586@version-pred bf458f@version-spec*))) bf458d@ls/false) (let ((bf4591@t bf458b@t)) (let ((bf4593@ls/false (bf30b2@syntax-dispatch bf4591@t '(any . any)))) (if (and bf4593@ls/false (apply (lambda (bf4595@x bf4596@x*) (bf44b4@idsyn? bf4595@x)) bf4593@ls/false)) (apply (lambda (bf4599@x bf459a@x*) (call-with-values (lambda () (bf4589@f bf459a@x*)) (lambda (bf45a1@bf459e bf45a2@bf45a0) (let ((bf45a5@pred bf45a2@bf45a0) (bf45a6@name bf45a1@bf459e)) (values (cons (bf3198@syntax->datum bf4599@x) bf45a6@name) bf45a5@pred))))) bf4593@ls/false) (let ((bf45a9@t bf4591@t)) (let ((bf45ab@ls/false (bf30b2@syntax-dispatch bf45a9@t '()))) (if bf45ab@ls/false (apply (lambda () (values '() (lambda (bf45ad@x) '#t))) bf45ab@ls/false) (let ((bf45af@t bf45a9@t)) (let ((bf45b1@ls/false (bf30b2@syntax-dispatch bf45af@t '_))) (if bf45b1@ls/false (apply (lambda () (bf3192@syntax-violation '#f '"invalid import spec" bf457f@spec)) bf45b1@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf45af@t))))))))))))))))) (bf44c4@import-library (lambda (bf456f@spec*) (call-with-values (lambda () (bf44c2@parse-library-name bf456f@spec*)) (lambda (bf4575@bf4572 bf4576@bf4574) (let ((bf4579@pred bf4576@bf4574) (bf457a@name bf4575@bf4572)) (begin (if (null? bf457a@name) (bf3192@syntax-violation 'import '"empty library name" bf456f@spec*) (void)) (let ((bf457d@lib (bf2cc0@bf2b07@find-library-by-name bf457a@name))) (begin (if (not bf457d@lib) (bf3192@syntax-violation 'import '"cannot find library with required name" bf457a@name) (void)) (if (not (bf4579@pred (bf2c9a@bf2abb@library-version bf457d@lib))) (bf3192@syntax-violation 'import '"library does not satisfy version specification" bf456f@spec* bf457d@lib) (void)) ((bf311e@imp-collector) bf457d@lib) (bf2ca2@bf2acb@library-subst bf457d@lib))))))))) (bf44c6@get-import (lambda (bf44e1@spec) (let ((bf44e3@t bf44e1@spec)) (let ((bf44e5@ls/false (bf30b2@syntax-dispatch bf44e3@t '(any . each-any)))) (if (and bf44e5@ls/false (apply (lambda (bf44e7@x bf44e8@x*) (not (memq (bf3198@syntax->datum bf44e7@x) '(for rename except only prefix library)))) bf44e5@ls/false)) (apply (lambda (bf44eb@x bf44ec@x*) (bf44c4@import-library (cons bf44eb@x bf44ec@x*))) bf44e5@ls/false) (let ((bf44ef@t bf44e3@t)) (let ((bf44f1@ls/false (bf30b2@syntax-dispatch bf44ef@t '(any any . #(each (any any)))))) (if (and bf44f1@ls/false (apply (lambda (bf44f3@rename bf44f4@isp bf44f5@old* bf44f6@new*) (and (eq? (bf3198@syntax->datum bf44f3@rename) 'rename) (for-all bf44b4@idsyn? bf44f5@old*) (for-all bf44b4@idsyn? bf44f6@new*))) bf44f1@ls/false)) (apply (lambda (bf44fb@rename bf44fc@isp bf44fd@old* bf44fe@new*) (let ((bf4503@subst (bf44c6@get-import bf44fc@isp)) (bf4504@old* (map bf3198@syntax->datum bf44fd@old*)) (bf4505@new* (map bf3198@syntax->datum bf44fe@new*))) (let ((bf4509@old-label* (bf44bc@find* bf4504@old* bf4503@subst))) (let ((bf450b@subst (bf44be@rem* bf4504@old* bf4503@subst))) (bf44b8@merge-substs (map cons bf4505@new* bf4509@old-label*) bf450b@subst))))) bf44f1@ls/false) (let ((bf450d@t bf44ef@t)) (let ((bf450f@ls/false (bf30b2@syntax-dispatch bf450d@t '(any any . each-any)))) (if (and bf450f@ls/false (apply (lambda (bf4511@except bf4512@isp bf4513@sym*) (and (eq? (bf3198@syntax->datum bf4511@except) 'except) (for-all bf44b4@idsyn? bf4513@sym*))) bf450f@ls/false)) (apply (lambda (bf4517@except bf4518@isp bf4519@sym*) (let ((bf451d@subst (bf44c6@get-import bf4518@isp))) (bf44be@rem* (map bf3198@syntax->datum bf4519@sym*) bf451d@subst))) bf450f@ls/false) (let ((bf451f@t bf450d@t)) (let ((bf4521@ls/false (bf30b2@syntax-dispatch bf451f@t '(any any . each-any)))) (if (and bf4521@ls/false (apply (lambda (bf4523@only bf4524@isp bf4525@sym*) (and (eq? (bf3198@syntax->datum bf4523@only) 'only) (for-all bf44b4@idsyn? bf4525@sym*))) bf4521@ls/false)) (apply (lambda (bf4529@only bf452a@isp bf452b@sym*) (let ((bf452f@subst (bf44c6@get-import bf452a@isp)) (bf4530@sym* (map bf3198@syntax->datum bf452b@sym*))) (let ((bf4533@sym* (bf44c0@remove-dups bf4530@sym*))) (let ((bf4535@lab* (bf44bc@find* bf4533@sym* bf452f@subst))) (map cons bf4533@sym* bf4535@lab*))))) bf4521@ls/false) (let ((bf4537@t bf451f@t)) (let ((bf4539@ls/false (bf30b2@syntax-dispatch bf4537@t '(any any any)))) (if (and bf4539@ls/false (apply (lambda (bf453b@prefix bf453c@isp bf453d@p) (and (eq? (bf3198@syntax->datum bf453b@prefix) 'prefix) (bf44b4@idsyn? bf453d@p))) bf4539@ls/false)) (apply (lambda (bf4541@prefix bf4542@isp bf4543@p) (let ((bf4547@subst (bf44c6@get-import bf4542@isp)) (bf4548@prefix (symbol->string (bf3198@syntax->datum bf4543@p)))) (map (lambda (bf454b@x) (cons (string->symbol (string-append bf4548@prefix (symbol->string (car bf454b@x)))) (cdr bf454b@x))) bf4547@subst))) bf4539@ls/false) (let ((bf454d@t bf4537@t)) (let ((bf454f@ls/false (bf30b2@syntax-dispatch bf454d@t '(any each-any)))) (if (and bf454f@ls/false (apply (lambda (bf4551@library bf4552@spec*) (eq? (bf3198@syntax->datum bf4551@library) 'library)) bf454f@ls/false)) (apply (lambda (bf4555@library bf4556@spec*) (bf44c4@import-library bf4556@spec*)) bf454f@ls/false) (let ((bf4559@t bf454d@t)) (let ((bf455b@ls/false (bf30b2@syntax-dispatch bf4559@t '(any any . any)))) (if (and bf455b@ls/false (apply (lambda (bf455d@for bf455e@isp bf455f@rest) (eq? (bf3198@syntax->datum bf455d@for) 'for)) bf455b@ls/false)) (apply (lambda (bf4563@for bf4564@isp bf4565@rest) (bf44c6@get-import bf4564@isp)) bf455b@ls/false) (let ((bf4569@t bf4559@t)) (let ((bf456b@ls/false (bf30b2@syntax-dispatch bf4569@t 'any))) (if bf456b@ls/false (apply (lambda (bf456d@spec) (bf3192@syntax-violation 'import '"invalid import spec" bf456d@spec)) bf456b@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf4569@t))))))))))))))))))))))))))) (bf44c8@add-imports! (lambda (bf44d1@imp bf44d2@h) (let ((bf44d5@subst (bf44c6@get-import bf44d1@imp))) (for-each (lambda (bf44d7@x) (let ((bf44d9@name (car bf44d7@x)) (bf44da@label (cdr bf44d7@x))) (let ((bf44dd@t (hashtable-ref bf44d2@h bf44d9@name '#f))) (if bf44dd@t ((lambda (bf44df@l) (if (not (eq? bf44df@l bf44da@label)) (bf44b6@dup-error bf44d9@name) (void))) bf44dd@t) (hashtable-set! bf44d2@h bf44d9@name bf44da@label))))) bf44d5@subst))))) (lambda (bf44c9@imp*) (let bf44cf@f ((bf44cb@imp* bf44c9@imp*) (bf44cc@h (make-eq-hashtable))) (if (null? bf44cb@imp*) (hashtable-entries bf44cc@h) (begin (bf44c8@add-imports! (car bf44cb@imp*) bf44cc@h) (bf44cf@f (cdr bf44cb@imp*) bf44cc@h))))))) (set! bf4beb@bf3114@parse-import-spec* bf3114@parse-import-spec*) (set! bf3116@make-top-rib (lambda (bf46bf@names bf46c0@labels) (let ((bf46c3@rib (bf2e5f@make-empty-rib))) (begin (vector-for-each (lambda (bf46c5@name bf46c6@label) (begin (if (not (symbol? bf46c5@name)) (error 'make-top-rib '"BUG: not a symbol" bf46c5@name) (void)) (bf2e63@extend-rib/nc! bf46c3@rib (make-simple-struct 'stx '5 (list bf46c5@name bf2e2f@top-mark* '() '())) bf46c6@label))) bf46bf@names bf46c0@labels) bf46c3@rib)))) (set! bf4bec@bf3116@make-top-rib bf3116@make-top-rib) (set! bf3118@make-collector (lambda () (let ((bf46c9@ls '())) (lambda bf46cd (let ((bf46ce (length bf46cd))) (if (= bf46ce '0) (apply (lambda () bf46c9@ls) bf46cd) (if (= bf46ce '1) (apply (lambda (bf46cb@x) (set! bf46c9@ls (bf2e28@set-cons bf46cb@x bf46c9@ls))) bf46cd) (error 'apply '"invalid arg count")))))))) (set! bf4bed@bf3118@make-collector bf3118@make-collector) (set! bf311a@inv-collector (bf29fb@bf28d9@make-parameter (lambda bf46cf@args (assertion-violation 'inv-collector '"BUG: not initialized")) (lambda (bf46d1@x) (begin (if (not (procedure? bf46d1@x)) (assertion-violation 'inv-collector '"BUG: not a procedure" bf46d1@x) (void)) bf46d1@x)))) (set! bf4bee@bf311a@inv-collector bf311a@inv-collector) (set! bf311c@vis-collector (bf29fb@bf28d9@make-parameter (lambda bf46d3@args (assertion-violation 'vis-collector '"BUG: not initialized")) (lambda (bf46d5@x) (begin (if (not (procedure? bf46d5@x)) (assertion-violation 'vis-collector '"BUG: not a procedure" bf46d5@x) (void)) bf46d5@x)))) (set! bf4bef@bf311c@vis-collector bf311c@vis-collector) (set! bf311e@imp-collector (bf29fb@bf28d9@make-parameter (lambda bf46d7@args (assertion-violation 'imp-collector '"BUG: not initialized")) (lambda (bf46d9@x) (begin (if (not (procedure? bf46d9@x)) (assertion-violation 'imp-collector '"BUG: not a procedure" bf46d9@x) (void)) bf46d9@x)))) (set! bf4bf0@bf311e@imp-collector bf311e@imp-collector) (set! bf3120@chi-library-internal (lambda (bf46db@e* bf46dc@rib bf46dd@top?) (call-with-values (lambda () (bf310a@chi-body* bf46db@e* '() '() '() '() '() '() '() bf46dc@rib bf46dd@top?)) (lambda (bf46f1@bf46e2 bf46f2@bf46e4 bf46f3@bf46e6 bf46f4@bf46e8 bf46f5@bf46ea bf46f6@bf46ec bf46f7@bf46ee bf46f8@bf46f0) (let ((bf4701@exp* bf46f8@bf46f0) (bf4702@_kwd* bf46f7@bf46ee) (bf4703@mod** bf46f6@bf46ec) (bf4704@rhs* bf46f5@bf46ea) (bf4705@lex* bf46f4@bf46e8) (bf4706@mr bf46f3@bf46e6) (bf4707@r bf46f2@bf46e4) (bf4708@e* bf46f1@bf46e2)) (values (append (apply append (reverse bf4703@mod**)) bf4708@e*) bf4707@r bf4706@mr (reverse bf4705@lex*) (reverse bf4704@rhs*) bf4701@exp*)))))) (set! bf4bf1@bf3120@chi-library-internal bf3120@chi-library-internal) (set! bf3122@chi-interaction-expr (lambda (bf4711@e bf4712@rib bf4713@r) (call-with-values (lambda () (bf310a@chi-body* (list bf4711@e) bf4713@r bf4713@r '() '() '() '() '() bf4712@rib '#t)) (lambda (bf4727@bf4718 bf4728@bf471a bf4729@bf471c bf472a@bf471e bf472b@bf4720 bf472c@bf4722 bf472d@bf4724 bf472e@bf4726) (let ((bf4737@_exp* bf472e@bf4726) (bf4738@_kwd* bf472d@bf4724) (bf4739@mod** bf472c@bf4722) (bf473a@rhs* bf472b@bf4720) (bf473b@lex* bf472a@bf471e) (bf473c@mr bf4729@bf471c) (bf473d@r bf4728@bf471a) (bf473e@e* bf4727@bf4718)) (let ((bf4747@e* (bf30e2@expand-interaction-rhs*/init* (reverse bf473b@lex*) (reverse bf473a@rhs*) (append (apply append (reverse bf4739@mod**)) bf473e@e*) bf473d@r bf473c@mr))) (let ((bf4749@e (if (null? bf4747@e*) (bf2e11@bf2d72@build-void) (if (null? (cdr bf4747@e*)) (car bf4747@e*) (bf2e10@bf2d70@build-sequence '#f bf4747@e*))))) (values bf4749@e bf473d@r)))))))) (set! bf4bf2@bf3122@chi-interaction-expr bf3122@chi-interaction-expr) (set! bf3124@library-body-expander (lambda (bf474b@name bf474c@main-exp* bf474d@imp* bf474e@b* bf474f@top?) (letrec* ((bf4756@itc (bf3118@make-collector))) (let ((bf475f@bf4758 bf311e@imp-collector) (bf4760@bf475a bf31a2@top-level-context) (bf4761@bf475c bf4756@itc) (bf4762@bf475e '#f)) (let ((bf4767@swap (lambda () (begin (let ((bf4769@t (bf475f@bf4758))) (begin (bf475f@bf4758 bf4761@bf475c) (set! bf4761@bf475c bf4769@t))) (let ((bf476b@t (bf4760@bf475a))) (begin (bf4760@bf475a bf4762@bf475e) (set! bf4762@bf475e bf476b@t))))))) (dynamic-wind bf4767@swap (lambda () (call-with-values (lambda () (bf3114@parse-import-spec* bf474d@imp*)) (lambda (bf4771@bf476e bf4772@bf4770) (let ((bf4775@subst-labels bf4772@bf4770) (bf4776@subst-names bf4771@bf476e)) (let ((bf4779@rib (bf3116@make-top-rib bf4776@subst-names bf4775@subst-labels))) (letrec* ((bf477c@wrap (lambda (bf47f7@x) (make-simple-struct 'stx '5 (list bf47f7@x bf2e2f@top-mark* (list bf4779@rib) '()))))) (let ((bf477d@b* (map bf477c@wrap bf474e@b*)) (bf477e@main-exp* (map bf477c@wrap bf474c@main-exp*)) (bf477f@rtc (bf3118@make-collector)) (bf4780@vtc (bf3118@make-collector))) (let ((bf478d@bf4786 bf311a@inv-collector) (bf478e@bf4788 bf311c@vis-collector) (bf478f@bf478a bf477f@rtc) (bf4790@bf478c bf4780@vtc)) (let ((bf4795@swap (lambda () (begin (let ((bf4797@t (bf478d@bf4786))) (begin (bf478d@bf4786 bf478f@bf478a) (set! bf478f@bf478a bf4797@t))) (let ((bf4799@t (bf478e@bf4788))) (begin (bf478e@bf4788 bf4790@bf478c) (set! bf4790@bf478c bf4799@t))))))) (dynamic-wind bf4795@swap (lambda () (call-with-values (lambda () (bf3120@chi-library-internal bf477d@b* bf4779@rib bf474f@top?)) (lambda (bf47a7@bf479c bf47a8@bf479e bf47a9@bf47a0 bf47aa@bf47a2 bf47ab@bf47a4 bf47ac@bf47a6) (let ((bf47b3@internal-exp* bf47ac@bf47a6) (bf47b4@rhs* bf47ab@bf47a4) (bf47b5@lex* bf47aa@bf47a2) (bf47b6@mr bf47a9@bf47a0) (bf47b7@r bf47a8@bf479e) (bf47b8@init* bf47a7@bf479c)) (call-with-values (lambda () (bf310e@parse-exports (append bf477e@main-exp* bf47b3@internal-exp*))) (lambda (bf47c3@bf47c0 bf47c4@bf47c2) (let ((bf47c7@exp-id* bf47c4@bf47c2) (bf47c8@exp-name* bf47c3@bf47c0)) (begin (bf2e67@seal-rib! bf4779@rib) (let ((bf47cb@init* (bf30d0@chi-expr* bf47b8@init* bf47b7@r bf47b6@mr))) (let ((bf47cd@rhs* (bf30e4@chi-rhs* bf47b4@rhs* bf47b7@r bf47b6@mr))) (begin (bf2e69@unseal-rib! bf4779@rib) (let ((bf47cf@loc* (map bf2e35@gen-global bf47b5@lex*)) (bf47d0@export-subst (bf317c@make-export-subst bf47c8@exp-name* bf47c7@exp-id*))) (letrec* ((bf47d4@errstr '"attempt to export mutated variable")) (call-with-values (lambda () (bf317e@make-export-env/macros bf47b5@lex* bf47cf@loc* bf47b7@r)) (lambda (bf47db@bf47d6 bf47dc@bf47d8 bf47dd@bf47da) (let ((bf47e1@macro* bf47dd@bf47da) (bf47e2@global* bf47dc@bf47d8) (bf47e3@export-env bf47db@bf47d6)) (begin (for-each (lambda (bf47e7@s) (let ((bf47e9@name (car bf47e7@s)) (bf47ea@label (cdr bf47e7@s))) (let ((bf47ed@p (assq bf47ea@label bf47e3@export-env))) (if bf47ed@p (let ((bf47ef@b (cdr bf47ed@p))) (let ((bf47f1@type (car bf47ef@b))) (if (eq? bf47f1@type 'mutable) (bf3192@syntax-violation 'export bf47d4@errstr bf47e9@name) (void)))) (void))))) bf47d0@export-subst) (let ((bf47f3@invoke-body (bf2e16@bf2d7c@build-library-letrec* '#f bf474b@name bf47b5@lex* bf47cf@loc* bf47cd@rhs* (if (null? bf47cb@init*) (bf2e11@bf2d72@build-void) (bf2e10@bf2d70@build-sequence '#f bf47cb@init*)))) (bf47f4@invoke-definitions (map bf2e0d@bf2ccf@build-global-define (map cdr bf47e2@global*)))) (values (bf4756@itc) (bf477f@rtc) (bf4780@vtc) (bf2e10@bf2d70@build-sequence '#f (append bf47f4@invoke-definitions (list bf47f3@invoke-body))) bf47e1@macro* bf47d0@export-subst bf47e3@export-env))))))))))))))))))) bf4795@swap)))))))))) bf4767@swap)))))) (set! bf4bf3@bf3124@library-body-expander bf3124@library-body-expander) (set! bf3126@core-library-expander (lambda (bf47f9@e bf47fa@verify-name) (call-with-values (lambda () (bf3112@parse-library bf47f9@e)) (lambda (bf4805@bf47fe bf4806@bf4800 bf4807@bf4802 bf4808@bf4804) (let ((bf480d@b* bf4808@bf4804) (bf480e@imp* bf4807@bf4802) (bf480f@exp* bf4806@bf4800) (bf4810@name* bf4805@bf47fe)) (call-with-values (lambda () (bf3110@parse-library-name bf4810@name*)) (lambda (bf4819@bf4816 bf481a@bf4818) (let ((bf481d@ver bf481a@bf4818) (bf481e@name bf4819@bf4816)) (begin (bf47fa@verify-name bf481e@name) (call-with-values (lambda () (bf3124@library-body-expander bf481e@name bf480f@exp* bf480e@imp* bf480d@b* '#f)) (lambda (bf482f@bf4822 bf4830@bf4824 bf4831@bf4826 bf4832@bf4828 bf4833@bf482a bf4834@bf482c bf4835@bf482e) (let ((bf483d@export-env bf4835@bf482e) (bf483e@export-subst bf4834@bf482c) (bf483f@visit-code bf4833@bf482a) (bf4840@invoke-code bf4832@bf4828) (bf4841@visit-req* bf4831@bf4826) (bf4842@invoke-req* bf4830@bf4824) (bf4843@imp* bf482f@bf4822)) (values bf481e@name bf481d@ver bf4843@imp* bf4842@invoke-req* bf4841@visit-req* bf4840@invoke-code bf483f@visit-code bf483e@export-subst bf483d@export-env))))))))))))) (set! bf4bf4@bf3126@core-library-expander bf3126@core-library-expander) (set! bf3128@parse-top-level-program (lambda (bf484b@e*) (let ((bf484d@t bf484b@e*)) (let ((bf484f@ls/false (bf30b2@syntax-dispatch bf484d@t '((any . each-any) . each-any)))) (if (and bf484f@ls/false (apply (lambda (bf4851@import bf4852@imp* bf4853@b*) (eq? (bf3198@syntax->datum bf4851@import) 'import)) bf484f@ls/false)) (apply (lambda (bf4857@import bf4858@imp* bf4859@b*) (values bf4858@imp* bf4859@b*)) bf484f@ls/false) (let ((bf485d@t bf484d@t)) (let ((bf485f@ls/false (bf30b2@syntax-dispatch bf485d@t '((any . any) . any)))) (if (and bf485f@ls/false (apply (lambda (bf4861@import bf4862@x bf4863@y) (eq? (bf3198@syntax->datum bf4861@import) 'import)) bf485f@ls/false)) (apply (lambda (bf4867@import bf4868@x bf4869@y) (bf3192@syntax-violation 'expander '"invalid syntax of top-level program" (bf2ea5@syntax-car bf484b@e*))) bf485f@ls/false) (let ((bf486d@t bf485d@t)) (let ((bf486f@ls/false (bf30b2@syntax-dispatch bf486d@t '_))) (if bf486f@ls/false (apply (lambda () (assertion-violation 'expander '"top-level program is missing an (import ---) clause")) bf486f@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf486d@t)))))))))))) (set! bf4bf5@bf3128@parse-top-level-program bf3128@parse-top-level-program) (set! bf312a@top-level-expander (lambda (bf4871@e*) (call-with-values (lambda () (bf3128@parse-top-level-program bf4871@e*)) (lambda (bf4877@bf4874 bf4878@bf4876) (let ((bf487b@b* bf4878@bf4876) (bf487c@imp* bf4877@bf4874)) (call-with-values (lambda () (bf3124@library-body-expander '() '() bf487c@imp* bf487b@b* '#t)) (lambda (bf488d@bf4880 bf488e@bf4882 bf488f@bf4884 bf4890@bf4886 bf4891@bf4888 bf4892@bf488a bf4893@bf488c) (let ((bf489b@export-env bf4893@bf488c) (bf489c@export-subst bf4892@bf488a) (bf489d@visit-code bf4891@bf4888) (bf489e@invoke-code bf4890@bf4886) (bf489f@visit-req* bf488f@bf4884) (bf48a0@invoke-req* bf488e@bf4882) (bf48a1@imp* bf488d@bf4880)) (values bf48a0@invoke-req* bf489e@invoke-code))))))))) (set! bf4bf6@bf312a@top-level-expander bf312a@top-level-expander) (set! bf312c@rp (bf29f8@bf28d3@make-record-printer 'env (lambda (bf48a9@x bf48aa@p bf48ab@wr) (display '"#<environment>" bf48aa@p)))) (set! bf4bf7@bf312c@rp bf312c@rp) (set! bf3136@env? (lambda (bf48af@x) (and (simple-struct? bf48af@x) (eq? (simple-struct-name bf48af@x) 'env)))) (set! bf4bf8@bf3136@env? bf3136@env?) (set! bf3138@env-names (lambda (bf48b1@x) (simple-struct-ref bf48b1@x '0))) (set! bf4bf9@bf3138@env-names bf3138@env-names) (set! bf313a@set-env-names! (lambda (bf48b3@x bf48b4@val) (simple-struct-set! bf48b3@x '0 bf48b4@val))) (set! bf4bfa@bf313a@set-env-names! bf313a@set-env-names!) (set! bf313c@env-labels (lambda (bf48b7@x) (simple-struct-ref bf48b7@x '1))) (set! bf4bfb@bf313c@env-labels bf313c@env-labels) (set! bf313e@set-env-labels! (lambda (bf48b9@x bf48ba@val) (simple-struct-set! bf48b9@x '1 bf48ba@val))) (set! bf4bfc@bf313e@set-env-labels! bf313e@set-env-labels!) (set! bf3140@env-itc (lambda (bf48bd@x) (simple-struct-ref bf48bd@x '2))) (set! bf4bfd@bf3140@env-itc bf3140@env-itc) (set! bf3142@set-env-itc! (lambda (bf48bf@x bf48c0@val) (simple-struct-set! bf48bf@x '2 bf48c0@val))) (set! bf4bfe@bf3142@set-env-itc! bf3142@set-env-itc!) (set! bf3144@dummy '3) (set! bf4bff@bf3144@dummy bf3144@dummy) (set! bf3146@rp (bf29f8@bf28d3@make-record-printer 'interaction-env (lambda (bf48c3@x bf48c4@p bf48c5@wr) (display '"#<environment>" bf48c4@p)))) (set! bf4c00@bf3146@rp bf3146@rp) (set! bf3150@interaction-env? (lambda (bf48c9@x) (and (simple-struct? bf48c9@x) (eq? (simple-struct-name bf48c9@x) 'interaction-env)))) (set! bf4c01@bf3150@interaction-env? bf3150@interaction-env?) (set! bf3152@interaction-env-rib (lambda (bf48cb@x) (simple-struct-ref bf48cb@x '0))) (set! bf4c02@bf3152@interaction-env-rib bf3152@interaction-env-rib) (set! bf3154@set-interaction-env-rib! (lambda (bf48cd@x bf48ce@val) (simple-struct-set! bf48cd@x '0 bf48ce@val))) (set! bf4c03@bf3154@set-interaction-env-rib! bf3154@set-interaction-env-rib!) (set! bf3156@interaction-env-r (lambda (bf48d1@x) (simple-struct-ref bf48d1@x '1))) (set! bf4c04@bf3156@interaction-env-r bf3156@interaction-env-r) (set! bf3158@set-interaction-env-r! (lambda (bf48d3@x bf48d4@val) (simple-struct-set! bf48d3@x '1 bf48d4@val))) (set! bf4c05@bf3158@set-interaction-env-r! bf3158@set-interaction-env-r!) (set! bf315a@interaction-env-locs (lambda (bf48d7@x) (simple-struct-ref bf48d7@x '2))) (set! bf4c06@bf315a@interaction-env-locs bf315a@interaction-env-locs) (set! bf315c@set-interaction-env-locs! (lambda (bf48d9@x bf48da@val) (simple-struct-set! bf48d9@x '2 bf48da@val))) (set! bf4c07@bf315c@set-interaction-env-locs! bf315c@set-interaction-env-locs!) (set! bf315e@dummy '3) (set! bf4c08@bf315e@dummy bf315e@dummy) (set! bf3160@interaction-environment-symbols (lambda () (bf3168@environment-symbols (bf31a0@interaction-environment)))) (set! bf4c09@bf3160@interaction-environment-symbols bf3160@interaction-environment-symbols) (set! bf3162@environment-bindings (lambda (bf48dd@e) (vector->list (vector-map (lambda (bf48df@name bf48e0@label) (bf3164@parse-binding (cons bf48df@name (bf2cc6@bf2b13@imported-label->binding bf48e0@label)))) (bf3138@env-names bf48dd@e) (bf313c@env-labels bf48dd@e))))) (set! bf4c0a@bf3162@environment-bindings bf3162@environment-bindings) (set! bf3164@parse-binding (lambda (bf48e3@b) (cons (car bf48e3@b) (let ((bf48e5@t (cadr bf48e3@b))) (if (memv bf48e5@t '(core-prim global)) 'procedure (if (memv bf48e5@t '(core-macro macro global-macro)) 'syntax (if (memv bf48e5@t '($core-rtd)) 'record (if (eq? (car bf48e3@b) (cadr bf48e3@b)) 'syntax 'unknown)))))))) (set! bf4c0b@bf3164@parse-binding bf3164@parse-binding) (set! bf3166@environment? (lambda (bf48e7@x) (or (bf3136@env? bf48e7@x) (bf3150@interaction-env? bf48e7@x)))) (set! bf4c0c@bf3166@environment? bf3166@environment?) (set! bf3168@environment-symbols (lambda (bf48e9@x) (if (bf3136@env? bf48e9@x) (vector->list (bf3138@env-names bf48e9@x)) (if (bf3150@interaction-env? bf48e9@x) (map values (bf2e49@rib-sym* (bf3152@interaction-env-rib bf48e9@x))) (assertion-violation 'environment-symbols '"not an environment" bf48e9@x))))) (set! bf4c0d@bf3168@environment-symbols bf3168@environment-symbols) (set! bf316a@environment (lambda bf48eb@imp* (let ((bf48ed@itc (bf3118@make-collector))) (let ((bf48f3@bf48f0 bf311e@imp-collector) (bf48f4@bf48f2 bf48ed@itc)) (let ((bf48f7@swap (lambda () (let ((bf48f9@t (bf48f3@bf48f0))) (begin (bf48f3@bf48f0 bf48f4@bf48f2) (set! bf48f4@bf48f2 bf48f9@t)))))) (dynamic-wind bf48f7@swap (lambda () (call-with-values (lambda () (bf3114@parse-import-spec* bf48eb@imp*)) (lambda (bf48ff@bf48fc bf4900@bf48fe) (let ((bf4903@subst-labels bf4900@bf48fe) (bf4904@subst-names bf48ff@bf48fc)) (make-simple-struct 'env '4 (list bf4904@subst-names bf4903@subst-labels bf48ed@itc)))))) bf48f7@swap)))))) (set! bf4c0e@bf316a@environment bf316a@environment) (set! bf316c@null-environment (lambda (bf4907@n) (begin (if (not (eqv? bf4907@n '5)) (assertion-violation 'null-environment '"not 5" bf4907@n) (void)) (bf316a@environment '(psyntax null-environment-5))))) (set! bf4c0f@bf316c@null-environment bf316c@null-environment) (set! bf316e@scheme-report-environment (lambda (bf4909@n) (begin (if (not (eqv? bf4909@n '5)) (assertion-violation 'scheme-report-environment '"not 5" bf4909@n) (void)) (bf316a@environment '(psyntax scheme-report-environment-5))))) (set! bf4c10@bf316e@scheme-report-environment bf316e@scheme-report-environment) (set! bf3170@expand (lambda (bf490b@x bf490c@env) (if (bf3136@env? bf490c@env) (let ((bf490f@rib (bf3116@make-top-rib (bf3138@env-names bf490c@env) (bf313c@env-labels bf490c@env)))) (let ((bf4911@x (make-simple-struct 'stx '5 (list bf490b@x bf2e2f@top-mark* (list bf490f@rib) '()))) (bf4912@itc (bf3140@env-itc bf490c@env)) (bf4913@rtc (bf3118@make-collector)) (bf4914@vtc (bf3118@make-collector))) (let ((bf4919@x (let ((bf492b@bf491c bf31a2@top-level-context) (bf492c@bf491e bf311a@inv-collector) (bf492d@bf4920 bf311c@vis-collector) (bf492e@bf4922 bf311e@imp-collector) (bf492f@bf4924 '#f) (bf4930@bf4926 bf4913@rtc) (bf4931@bf4928 bf4914@vtc) (bf4932@bf492a bf4912@itc)) (let ((bf493b@swap (lambda () (begin (let ((bf493d@t (bf492b@bf491c))) (begin (bf492b@bf491c bf492f@bf4924) (set! bf492f@bf4924 bf493d@t))) (let ((bf493f@t (bf492c@bf491e))) (begin (bf492c@bf491e bf4930@bf4926) (set! bf4930@bf4926 bf493f@t))) (let ((bf4941@t (bf492d@bf4920))) (begin (bf492d@bf4920 bf4931@bf4928) (set! bf4931@bf4928 bf4941@t))) (let ((bf4943@t (bf492e@bf4922))) (begin (bf492e@bf4922 bf4932@bf492a) (set! bf4932@bf492a bf4943@t))))))) (dynamic-wind bf493b@swap (lambda () (bf30d4@chi-expr bf4911@x '() '())) bf493b@swap))))) (begin (bf2e67@seal-rib! bf490f@rib) (values bf4919@x (bf4913@rtc)))))) (if (bf3150@interaction-env? bf490c@env) (let ((bf4945@rib (bf3152@interaction-env-rib bf490c@env)) (bf4946@r (bf3156@interaction-env-r bf490c@env)) (bf4947@rtc (bf3118@make-collector))) (let ((bf494b@x (make-simple-struct 'stx '5 (list bf490b@x bf2e2f@top-mark* (list bf4945@rib) '())))) (call-with-values (lambda () (let ((bf4961@bf4952 bf31a2@top-level-context) (bf4962@bf4954 bf311a@inv-collector) (bf4963@bf4956 bf311c@vis-collector) (bf4964@bf4958 bf311e@imp-collector) (bf4965@bf495a bf490c@env) (bf4966@bf495c bf4947@rtc) (bf4967@bf495e (bf3118@make-collector)) (bf4968@bf4960 (bf3118@make-collector))) (let ((bf4971@swap (lambda () (begin (let ((bf4973@t (bf4961@bf4952))) (begin (bf4961@bf4952 bf4965@bf495a) (set! bf4965@bf495a bf4973@t))) (let ((bf4975@t (bf4962@bf4954))) (begin (bf4962@bf4954 bf4966@bf495c) (set! bf4966@bf495c bf4975@t))) (let ((bf4977@t (bf4963@bf4956))) (begin (bf4963@bf4956 bf4967@bf495e) (set! bf4967@bf495e bf4977@t))) (let ((bf4979@t (bf4964@bf4958))) (begin (bf4964@bf4958 bf4968@bf4960) (set! bf4968@bf4960 bf4979@t))))))) (dynamic-wind bf4971@swap (lambda () (bf3122@chi-interaction-expr bf494b@x bf4945@rib bf4946@r)) bf4971@swap)))) (lambda (bf497b@bf494e bf497c@bf4950) (let ((bf497f@r^ bf497c@bf4950) (bf4980@e bf497b@bf494e)) (begin (bf3158@set-interaction-env-r! bf490c@env bf497f@r^) (values bf4980@e (bf4947@rtc)))))))) (assertion-violation 'expand '"not an environment" bf490c@env))))) (set! bf4c11@bf3170@expand bf3170@expand) (set! bf3172@eval (lambda (bf4983@x bf4984@env) (begin (if (not (bf3166@environment? bf4984@env)) (error 'eval '"not an environment" bf4984@env) (void)) (call-with-values (lambda () (bf3170@expand bf4983@x bf4984@env)) (lambda (bf498b@bf4988 bf498c@bf498a) (let ((bf498f@invoke-req* bf498c@bf498a) (bf4990@x bf498b@bf4988)) (begin (for-each bf2cc7@bf2b15@invoke-library bf498f@invoke-req*) (eval-core (bf2a51@bf2a09@expanded->core bf4990@x))))))))) (set! bf4c12@bf3172@eval bf3172@eval) (set! bf3174@library-expander (lambda bf4a01 (let ((bf4a02 (length bf4a01))) (if (= bf4a02 '3) (apply (lambda (bf4993@x bf4994@filename bf4995@verify-name) (letrec* ((bf499a@build-visit-code (lambda (bf49ef@macro*) (if (null? bf49ef@macro*) (bf2e11@bf2d72@build-void) (bf2e10@bf2d70@build-sequence '#f (map (lambda (bf49f1@x) (let ((bf49f3@loc (car bf49f1@x)) (bf49f4@src (cddr bf49f1@x))) (list 'set! bf49f3@loc bf49f4@src))) bf49ef@macro*))))) (bf499c@visit! (lambda (bf49e7@macro*) (for-each (lambda (bf49e9@x) (let ((bf49eb@loc (car bf49e9@x)) (bf49ec@proc (cadr bf49e9@x))) (set-symbol-value! bf49eb@loc bf49ec@proc))) bf49e7@macro*)))) (call-with-values (lambda () (bf3126@core-library-expander bf4993@x bf4995@verify-name)) (lambda (bf49af@bf499e bf49b0@bf49a0 bf49b1@bf49a2 bf49b2@bf49a4 bf49b3@bf49a6 bf49b4@bf49a8 bf49b5@bf49aa bf49b6@bf49ac bf49b7@bf49ae) (let ((bf49c1@export-env bf49b7@bf49ae) (bf49c2@export-subst bf49b6@bf49ac) (bf49c3@macro* bf49b5@bf49aa) (bf49c4@invoke-code bf49b4@bf49a8) (bf49c5@vis* bf49b3@bf49a6) (bf49c6@inv* bf49b2@bf49a4) (bf49c7@imp* bf49b1@bf49a2) (bf49c8@ver bf49b0@bf49a0) (bf49c9@name bf49af@bf499e)) (let ((bf49d3@id (gensym)) (bf49d4@name bf49c9@name) (bf49d5@ver bf49c8@ver) (bf49d6@imp* (map bf2ccb@bf2b1d@library-spec bf49c7@imp*)) (bf49d7@vis* (map bf2ccb@bf2b1d@library-spec bf49c5@vis*)) (bf49d8@inv* (map bf2ccb@bf2b1d@library-spec bf49c6@inv*)) (bf49d9@visit-proc (lambda () (bf499c@visit! bf49c3@macro*))) (bf49da@invoke-proc (lambda () (eval-core (bf2a51@bf2a09@expanded->core bf49c4@invoke-code)))) (bf49db@visit-code (bf499a@build-visit-code bf49c3@macro*)) (bf49dc@invoke-code bf49c4@invoke-code)) (begin (bf2cc5@bf2b11@install-library bf49d3@id bf49d4@name bf49d5@ver bf49d6@imp* bf49d7@vis* bf49d8@inv* bf49c2@export-subst bf49c1@export-env bf49d9@visit-proc bf49da@invoke-proc bf49db@visit-code bf49dc@invoke-code '#t bf4994@filename) (values bf49d3@id bf49d4@name bf49d5@ver bf49d6@imp* bf49d7@vis* bf49d8@inv* bf49dc@invoke-code bf49db@visit-code bf49c2@export-subst bf49c1@export-env)))))))) bf4a01) (if (= bf4a02 '2) (apply (lambda (bf49f7@x bf49f8@filename) (bf3174@library-expander bf49f7@x bf49f8@filename (lambda (bf49fb@x) (values)))) bf4a01) (if (= bf4a02 '1) (apply (lambda (bf49fd@x) (bf3174@library-expander bf49fd@x '#f (lambda (bf49ff@x) (values)))) bf4a01) (error 'apply '"invalid arg count"))))))) (set! bf4c13@bf3174@library-expander bf3174@library-expander) (set! bf3176@boot-library-expand (lambda (bf4a03@x) (call-with-values (lambda () (bf3174@library-expander bf4a03@x)) (lambda (bf4a19@bf4a06 bf4a1a@bf4a08 bf4a1b@bf4a0a bf4a1c@bf4a0c bf4a1d@bf4a0e bf4a1e@bf4a10 bf4a1f@bf4a12 bf4a20@bf4a14 bf4a21@bf4a16 bf4a22@bf4a18) (let ((bf4a2d@export-env bf4a22@bf4a18) (bf4a2e@export-subst bf4a21@bf4a16) (bf4a2f@visit-code bf4a20@bf4a14) (bf4a30@invoke-code bf4a1f@bf4a12) (bf4a31@inv* bf4a1e@bf4a10) (bf4a32@vis* bf4a1d@bf4a0e) (bf4a33@imp* bf4a1c@bf4a0c) (bf4a34@ver bf4a1b@bf4a0a) (bf4a35@name bf4a1a@bf4a08) (bf4a36@id bf4a19@bf4a06)) (values bf4a35@name bf4a30@invoke-code bf4a2e@export-subst bf4a2d@export-env)))))) (set! bf4c14@bf3176@boot-library-expand bf3176@boot-library-expand) (set! bf3178@rev-map-append (lambda (bf4a41@f bf4a42@ls bf4a43@ac) (if (null? bf4a42@ls) bf4a43@ac (bf3178@rev-map-append bf4a41@f (cdr bf4a42@ls) (cons (bf4a41@f (car bf4a42@ls)) bf4a43@ac))))) (set! bf4c15@bf3178@rev-map-append bf3178@rev-map-append) (set! bf317a@build-exports (lambda (bf4a47@lex*+loc* bf4a48@init*) (bf2e10@bf2d70@build-sequence '#f (cons (bf2e11@bf2d72@build-void) (bf3178@rev-map-append (lambda (bf4a4b@x) (list 'set! (cdr bf4a4b@x) (car bf4a4b@x))) bf4a47@lex*+loc* bf4a48@init*))))) (set! bf4c16@bf317a@build-exports bf317a@build-exports) (set! bf317c@make-export-subst (lambda (bf4a4d@name* bf4a4e@id*) (map (lambda (bf4a51@name bf4a52@id) (let ((bf4a55@label (bf2ec1@id->label bf4a52@id))) (begin (if (not bf4a55@label) (bf3192@syntax-violation '#f '"cannot export unbound identifier" bf4a52@id) (void)) (cons bf4a51@name bf4a55@label)))) bf4a4d@name* bf4a4e@id*))) (set! bf4c17@bf317c@make-export-subst bf317c@make-export-subst) (set! bf317e@make-export-env/macros (lambda (bf4a57@lex* bf4a58@loc* bf4a59@r) (letrec* ((bf4a5e@lookup (lambda (bf4a7b@x) (let bf4a83@f ((bf4a7d@x bf4a7b@x) (bf4a7e@lex* bf4a57@lex*) (bf4a7f@loc* bf4a58@loc*)) (if (pair? bf4a7e@lex*) (if (eq? bf4a7d@x (car bf4a7e@lex*)) (car bf4a7f@loc*) (bf4a83@f bf4a7d@x (cdr bf4a7e@lex*) (cdr bf4a7f@loc*))) (assertion-violation 'lookup-make-export '"BUG")))))) (let bf4a67@f ((bf4a5f@r bf4a59@r) (bf4a60@env '()) (bf4a61@global* '()) (bf4a62@macro* '())) (if (null? bf4a5f@r) (values bf4a60@env bf4a61@global* bf4a62@macro*) (let ((bf4a69@x (car bf4a5f@r))) (let ((bf4a6b@label (car bf4a69@x)) (bf4a6c@b (cdr bf4a69@x))) (let ((bf4a6f@t (bf2ec7@binding-type bf4a6c@b))) (if (memv bf4a6f@t '(lexical)) (let ((bf4a71@v (bf2ec9@binding-value bf4a6c@b))) (let ((bf4a73@loc (bf4a5e@lookup (bf303c@lexical-var bf4a71@v))) (bf4a74@type (if (bf303e@lexical-mutable? bf4a71@v) 'mutable 'global))) (bf4a67@f (cdr bf4a5f@r) (cons (cons* bf4a6b@label bf4a74@type bf4a73@loc) bf4a60@env) (cons (cons (bf303c@lexical-var bf4a71@v) bf4a73@loc) bf4a61@global*) bf4a62@macro*))) (if (memv bf4a6f@t '(local-macro)) (let ((bf4a77@loc (gensym))) (bf4a67@f (cdr bf4a5f@r) (cons (cons* bf4a6b@label 'global-macro bf4a77@loc) bf4a60@env) bf4a61@global* (cons (cons bf4a77@loc (bf2ec9@binding-value bf4a6c@b)) bf4a62@macro*))) (if (memv bf4a6f@t '(local-macro!)) (let ((bf4a79@loc (gensym))) (bf4a67@f (cdr bf4a5f@r) (cons (cons* bf4a6b@label 'global-macro! bf4a79@loc) bf4a60@env) bf4a61@global* (cons (cons bf4a79@loc (bf2ec9@binding-value bf4a6c@b)) bf4a62@macro*))) (if (memv bf4a6f@t '($rtd $module)) (bf4a67@f (cdr bf4a5f@r) (cons bf4a69@x bf4a60@env) bf4a61@global* bf4a62@macro*) (assertion-violation 'expander '"BUG: do not know how to export" (bf2ec7@binding-type bf4a6c@b) (bf2ec9@binding-value bf4a6c@b)))))))))))))) (set! bf4c18@bf317e@make-export-env/macros bf317e@make-export-env/macros) (set! bf3180@generate-temporaries (lambda (bf4a85@ls) (let ((bf4a87@t bf4a85@ls)) (let ((bf4a89@ls/false (bf30b2@syntax-dispatch bf4a87@t 'each-any))) (if bf4a89@ls/false (apply (lambda (bf4a8b@ls) (map (lambda (bf4a8d@x) (make-simple-struct 'stx '5 (list (let ((bf4a8f@x (bf3198@syntax->datum bf4a8d@x))) (if (or (symbol? bf4a8f@x) (string? bf4a8f@x)) (gensym bf4a8f@x) (gensym 't))) bf2e2f@top-mark* '() '()))) bf4a8b@ls)) bf4a89@ls/false) (let ((bf4a91@t bf4a87@t)) (let ((bf4a93@ls/false (bf30b2@syntax-dispatch bf4a91@t '_))) (if bf4a93@ls/false (apply (lambda () (assertion-violation 'generate-temporaries '"not a list")) bf4a93@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf4a91@t))))))))) (set! bf4c19@bf3180@generate-temporaries bf3180@generate-temporaries) (set! bf3182@free-identifier=? (lambda (bf4a95@x bf4a96@y) (if (bf2eab@id? bf4a95@x) (if (bf2eab@id? bf4a96@y) (bf2eb1@free-id=? bf4a95@x bf4a96@y) (assertion-violation 'free-identifier=? '"not an identifier" bf4a96@y)) (assertion-violation 'free-identifier=? '"not an identifier" bf4a95@x)))) (set! bf4c1a@bf3182@free-identifier=? bf3182@free-identifier=?) (set! bf3184@bound-identifier=? (lambda (bf4a99@x bf4a9a@y) (if (bf2eab@id? bf4a99@x) (if (bf2eab@id? bf4a9a@y) (bf2eaf@bound-id=? bf4a99@x bf4a9a@y) (assertion-violation 'bound-identifier=? '"not an identifier" bf4a9a@y)) (assertion-violation 'bound-identifier=? '"not an identifier" bf4a99@x)))) (set! bf4c1b@bf3184@bound-identifier=? bf3184@bound-identifier=?) (set! bf3186@make-source-condition (lambda (bf4a9d@x) (letrec* ((bf4aa7@bf4aa2 (make-record-type-descriptor '&source-information &condition-rtd 'bf4aa5 '#f '#f '#((immutable file-name) (immutable line)))) (bf4aa9@bf4aa4 '#f) (bf4aab@bf4aa3 (make-record-constructor-descriptor bf4aa7@bf4aa2 &condition-rcd bf4aa9@bf4aa4)) (bf4aae@bf4aa1 (record-predicate bf4aa7@bf4aa2)) (bf4ab0@make-source-condition (record-constructor bf4aab@bf4aa3)) (bf4ab2@bf4a9f (record-accessor bf4aa7@bf4aa2 '0)) (bf4ab4@bf4aa0 (record-accessor bf4aa7@bf4aa2 '1)) (bf4ab6@source-condition? (condition-predicate bf4aa7@bf4aa2)) (bf4ab8@source-filename (condition-accessor bf4aa7@bf4aa2 bf4ab2@bf4a9f)) (bf4aba@source-character (condition-accessor bf4aa7@bf4aa2 bf4ab4@bf4aa0))) (if (and (pair? bf4a9d@x) (pair? (cdr bf4a9d@x))) (bf4ab0@make-source-condition (car bf4a9d@x) (cadr bf4a9d@x)) (condition))))) (set! bf4c1c@bf3186@make-source-condition bf3186@make-source-condition) (set! bf3188@extract-position-condition (lambda (bf4abb@x) (bf3186@make-source-condition (bf318a@expression-position bf4abb@x)))) (set! bf4c1d@bf3188@extract-position-condition bf3188@extract-position-condition) (set! bf318a@expression-position (lambda (bf4abd@x) (and (bf2e77@stx? bf4abd@x) (let ((bf4abf@x (bf2e79@stx-expr bf4abd@x))) (and (bf29ef@bf28c1@annotation? bf4abf@x) (bf29f0@bf28c3@annotation-source bf4abf@x)))))) (set! bf4c1e@bf318a@expression-position bf318a@expression-position) (set! bf318c@assertion-error (lambda (bf4ac1@expr bf4ac2@pos) (raise (condition (make-assertion-violation) (make-who-condition 'assert) (make-message-condition '"assertion failed") (make-irritants-condition (list bf4ac1@expr)) (bf3186@make-source-condition bf4ac2@pos))))) (set! bf4c1f@bf318c@assertion-error bf318c@assertion-error) (set! bf318e@syntax-error (lambda (bf4ac5@x . bf4ac7@args) (begin (if (not (for-all string? bf4ac7@args)) (assertion-violation 'syntax-error '"invalid argument" bf4ac7@args) (void)) (raise (condition (make-message-condition (if (null? bf4ac7@args) '"invalid syntax" (apply string-append bf4ac7@args))) (make-syntax-violation (bf3198@syntax->datum bf4ac5@x) '#f) (bf3188@extract-position-condition bf4ac5@x)))))) (set! bf4c20@bf318e@syntax-error bf318e@syntax-error) (set! bf3190@syntax-violation* (lambda (bf4ac9@who bf4aca@msg bf4acb@form bf4acc@condition-object) (begin (if (not (string? bf4aca@msg)) (assertion-violation 'syntax-violation '"message is not a string" bf4aca@msg) (void)) (let ((bf4ad1@who (if (or (string? bf4ac9@who) (symbol? bf4ac9@who)) bf4ac9@who (if (not bf4ac9@who) (let ((bf4ad3@t bf4acb@form)) (let ((bf4ad5@ls/false (bf30b2@syntax-dispatch bf4ad3@t 'any))) (if (and bf4ad5@ls/false (apply (lambda (bf4ad7@id) (bf2eab@id? bf4ad7@id)) bf4ad5@ls/false)) (apply (lambda (bf4ad9@id) (bf3198@syntax->datum bf4ad9@id)) bf4ad5@ls/false) (let ((bf4adb@t bf4ad3@t)) (let ((bf4add@ls/false (bf30b2@syntax-dispatch bf4adb@t '(any . any)))) (if (and bf4add@ls/false (apply (lambda (bf4adf@id bf4ae0@rest) (bf2eab@id? bf4adf@id)) bf4add@ls/false)) (apply (lambda (bf4ae3@id bf4ae4@rest) (bf3198@syntax->datum bf4ae3@id)) bf4add@ls/false) (let ((bf4ae7@t bf4adb@t)) (let ((bf4ae9@ls/false (bf30b2@syntax-dispatch bf4ae7@t '_))) (if bf4ae9@ls/false (apply (lambda () '#f) bf4ae9@ls/false) (bf3192@syntax-violation '#f '"invalid syntax" bf4ae7@t)))))))))) (assertion-violation 'syntax-violation '"invalid who argument" bf4ac9@who))))) (raise (condition (if bf4ad1@who (make-who-condition bf4ad1@who) (condition)) (make-message-condition bf4aca@msg) bf4acc@condition-object (bf3188@extract-position-condition bf4acb@form))))))) (set! bf4c21@bf3190@syntax-violation* bf3190@syntax-violation*) (set! bf3192@syntax-violation (lambda bf4af9 (let ((bf4afa (length bf4af9))) (if (= bf4afa '3) (apply (lambda (bf4aeb@who bf4aec@msg bf4aed@form) (bf3192@syntax-violation bf4aeb@who bf4aec@msg bf4aed@form '#f)) bf4af9) (if (= bf4afa '4) (apply (lambda (bf4af1@who bf4af2@msg bf4af3@form bf4af4@subform) (bf3190@syntax-violation* bf4af1@who bf4af2@msg bf4af3@form (make-syntax-violation (bf3198@syntax->datum bf4af3@form) (bf3198@syntax->datum bf4af4@subform)))) bf4af9) (error 'apply '"invalid arg count")))))) (set! bf4c22@bf3192@syntax-violation bf3192@syntax-violation) (set! bf3194@identifier? (lambda (bf4afb@x) (bf2eab@id? bf4afb@x))) (set! bf4c23@bf3194@identifier? bf3194@identifier?) (set! bf3196@datum->syntax (lambda (bf4afd@id bf4afe@datum) (if (bf2eab@id? bf4afd@id) (bf2e8b@datum->stx bf4afd@id bf4afe@datum) (assertion-violation 'datum->syntax '"not an identifier" bf4afd@id)))) (set! bf4c24@bf3196@datum->syntax bf3196@datum->syntax) (set! bf3198@syntax->datum (lambda (bf4b01@x) (bf2ebf@stx->datum bf4b01@x))) (set! bf4c25@bf3198@syntax->datum bf3198@syntax->datum) (set! bf319a@ungensym-all (lambda (bf4b03@code) (if (pair? bf4b03@code) (cons (bf319a@ungensym-all (car bf4b03@code)) (bf319a@ungensym-all (cdr bf4b03@code))) (if (symbol? bf4b03@code) (ungensym bf4b03@code) bf4b03@code)))) (set! bf4c26@bf319a@ungensym-all bf319a@ungensym-all) (set! bf319c@compile-r6rs-top-level (lambda (bf4b05@x*) (call-with-values (lambda () (bf312a@top-level-expander bf4b05@x*)) (lambda (bf4b0b@bf4b08 bf4b0c@bf4b0a) (let ((bf4b0f@invoke-code bf4b0c@bf4b0a) (bf4b10@lib* bf4b0b@bf4b08)) (lambda () (begin (for-each bf2cc7@bf2b15@invoke-library bf4b10@lib*) (let ((bf4b13@expanded (bf2a51@bf2a09@expanded->core bf4b0f@invoke-code))) (begin (if (symbol-value 'debug-expand) (format '#t '"psyntax expanded=~a\n" (bf319a@ungensym-all bf4b13@expanded)) (void)) (eval-core bf4b13@expanded)))))))))) (set! bf4c27@bf319c@compile-r6rs-top-level bf319c@compile-r6rs-top-level) (set! bf319e@pre-compile-r6rs-top-level (lambda (bf4b15@x*) (call-with-values (lambda () (bf312a@top-level-expander bf4b15@x*)) (lambda (bf4b1b@bf4b18 bf4b1c@bf4b1a) (let ((bf4b1f@invoke-code bf4b1c@bf4b1a) (bf4b20@lib* bf4b1b@bf4b18)) (begin (for-each bf2cc7@bf2b15@invoke-library bf4b20@lib*) (bf29f9@bf28d5@compile-core (bf2a51@bf2a09@expanded->core bf4b1f@invoke-code)))))))) (set! bf4c28@bf319e@pre-compile-r6rs-top-level bf319e@pre-compile-r6rs-top-level) (set! bf31a0@interaction-environment (let ((bf4b23@the-env '#f)) (lambda () (or bf4b23@the-env (let ((bf4b25@lib (bf2cc0@bf2b07@find-library-by-name '(mosh interaction))) (bf4b26@rib (bf2e5f@make-empty-rib))) (begin (let ((bf4b29@subst (bf2ca2@bf2acb@library-subst bf4b25@lib))) (begin (bf2e4b@set-rib-sym*! bf4b26@rib (map car bf4b29@subst)) (bf2e4f@set-rib-mark**! bf4b26@rib (map (lambda (bf4b2b@x) bf2e2f@top-mark*) bf4b29@subst)) (bf2e53@set-rib-label*! bf4b26@rib (map cdr bf4b29@subst)))) (let ((bf4b2d@env (make-simple-struct 'interaction-env '4 (list bf4b26@rib '() '())))) (begin (set! bf4b23@the-env bf4b2d@env) bf4b2d@env)))))))) (set! bf4c29@bf31a0@interaction-environment bf31a0@interaction-environment) (set! bf31a2@top-level-context (bf29fb@bf28d9@make-parameter '#f)) (set! bf4c2a@bf31a2@top-level-context bf31a2@top-level-context) (bf2cbd@bf2b01@current-library-expander bf3174@library-expander))
(begin (begin (bf2a4e@bf2a03@current-primitive-locations (lambda (bf5185@x) (let ((bf5187@t (assq bf5185@x '((syntax-error . bf4c20@bf318e@syntax-error) (syntax-dispatch . bf4bbe@bf30b2@syntax-dispatch) (load . bf4daa@bf4c51@load) (interaction-environment . bf4c29@bf31a0@interaction-environment) (library-path . bf2cb5@bf2af1@library-path) (mosh-cache-dir . bf29fc@bf28db@mosh-cache-dir) (make-parameter . bf29fb@bf28d9@make-parameter) (make-variable-transformer . bf4b7b@bf2edd@make-variable-transformer) (identifier? . bf4c23@bf3194@identifier?) (generate-temporaries . bf4c19@bf3180@generate-temporaries) (free-identifier=? . bf4c1a@bf3182@free-identifier=?) (syntax->datum . bf4c25@bf3198@syntax->datum) (datum->syntax . bf4c24@bf3196@datum->syntax) (bound-identifier=? . bf4c1b@bf3184@bound-identifier=?) (scheme-report-environment . bf4c10@bf316e@scheme-report-environment) (null-environment . bf4c0f@bf316c@null-environment) (command-line . bf4da7@bf4c4b@command-line) (eval . bf4c12@bf3172@eval) (environment . bf4c0e@bf316a@environment) (syntax-violation . bf4c22@bf3192@syntax-violation) (assertion-error . bf4c1f@bf318c@assertion-error))))) (if bf5187@t (cdr bf5187@t) '#f)))) (bf2cc5@bf2b11@install-library 'bf5162 '(mosh interaction) '() '() '() '() '((regexp? . bf5122) (alist->eq-hash-table . bf511e) (format . bf511b) (string-split . bf510b) (call-process . bf5104) (set-current-directory! . bf5100) (expand-path . bf50ff) (current-directory . bf50fe) (%getpid . bf50fd) (%spawn . bf50fc) (%waitpid . bf50fb) (simple-struct-name . bf50fa) (simple-struct-set! . bf50f9) (simple-struct-ref . bf50f8) (make-simple-struct . bf50f7) (simple-struct? . bf50f6) (pointer-ref-c-int64 . bf50f5) (pointer-ref-c-int32 . bf50f4) (pointer-ref-c-int16 . bf50f3) (pointer-ref-c-int8 . bf50f2) (pointer-ref-c-uint64 . bf50f1) (pointer-ref-c-uint32 . bf50f0) (pointer-ref-c-uint16 . bf50ef) (pointer-ref-c-uint8 . bf50ee) (pointer-set-c-uint64! . bf50ed) (pointer-set-c-uint32! . bf50ec) (pointer-set-c-uint16! . bf50eb) (pointer-set-c-uint8! . bf50ea) (pointer-set-c-int64! . bf50e9) (pointer-set-c-int32! . bf50e8) (pointer-set-c-int16! . bf50e7) (pointer-set-c-int8! . bf50e6) (pointer-set-c-pointer! . bf50e5) (pointer-set-c-double! . bf50e4) (pointer-set-c-float! . bf50e3) (pointer-set-c-long-long! . bf50e2) (pointer-set-c-long! . bf50e1) (pointer-set-c-int! . bf50e0) (pointer-set-c-short! . bf50df) (pointer-set-c-char! . bf50de) (pointer-ref-c-pointer . bf50dd) (pointer-ref-c-double . bf50dc) (pointer-ref-c-float . bf50db) (pointer-ref-c-unsigned-long-long . bf50da) (pointer-ref-c-signed-long-long . bf50d9) (pointer-ref-c-unsigned-long . bf50d8) (pointer-ref-c-signed-long . bf50d7) (pointer-ref-c-unsigned-int . bf50d6) (pointer-ref-c-signed-int . bf50d5) (pointer-ref-c-unsigned-short . bf50d4) (pointer-ref-c-signed-short . bf50d3) (pointer-ref-c-unsigned-char . bf50d2) (pointer-ref-c-signed-char . bf50d1) (pointer->integer . bf50d0) (integer->pointer . bf50cf) (pointer? . bf50ce) (shared-errno . bf50cd) (%ffi-supported? . bf50c8) (%ffi-pointer->string . bf50c7) (%ffi-call . bf50c6) (%ffi-lookup . bf50c5) (%ffi-open . bf50c4) (null-terminated-utf8->string . bf50c3) (null-terminated-bytevector->string . bf50c2) (%exec . bf50c1) (%fork . bf50c0) (%pipe . bf50bf) (p . bf50be) (whereis . bf50a2) (register . bf50a1) (vm-join! . bf50a0) (vm-set-value! . bf509f) (vm? . bf509e) (main-vm? . bf509d) (vm-eval . bf509c) (vm-self . bf509b) (vm-start! . bf509a) (make-vm . bf5099) (mutex-try-lock! . bf5098) (mutex-unlock! . bf5097) (mutex-lock! . bf5096) (mutex? . bf5095) (make-mutex . bf5094) (condition-variable-notify-all! . bf5093) (condition-variable-notify! . bf5092) (condition-variable-wait! . bf5091) (make-condition-variable . bf5090) (write/ss . bf508f) (string-upcase . bf5072) (string-titlecase . bf5071) (string-normalize-nfkd . bf5070) (string-normalize-nfkc . bf506f) (string-normalize-nfd . bf506e) (string-normalize-nfc . bf506d) (string-foldcase . bf506c) (string-downcase . bf506b) (string-ci>? . bf506a) (string-ci>=? . bf5069) (string-ci=? . bf5068) (string-ci<? . bf5067) (string-ci<=? . bf5066) (char-whitespace? . bf5065) (char-upper-case? . bf5064) (char-title-case? . bf5063) (char-numeric? . bf5062) (char-lower-case? . bf5061) (char-general-category . bf5060) (char-upcase . bf505f) (char-titlecase . bf505e) (char-foldcase . bf505d) (char-downcase . bf505c) (char-ci>? . bf505b) (char-ci>=? . bf505a) (char-ci=? . bf5059) (char-ci<? . bf5058) (char-ci<=? . bf5057) (char-alphabetic? . bf5056) (make-variable-transformer . bf2edc) (identifier? . bf3193) (generate-temporaries . bf317f) (free-identifier=? . bf3181) (syntax->datum . bf3197) (datum->syntax . bf3195) (bound-identifier=? . bf3183) (record-type-descriptor? . bf5055) (record-predicate . bf5054) (record-mutator . bf5053) (record-constructor . bf5052) (record-accessor . bf5051) (make-record-type-descriptor . bf5050) (make-record-constructor-descriptor . bf504f) (record? . bf504e) (record-type-uid . bf504d) (record-type-sealed? . bf504c) (record-type-parent . bf504b) (record-type-opaque? . bf504a) (record-type-name . bf5049) (record-type-generative? . bf5048) (record-type-field-names . bf5047) (record-rtd . bf5046) (record-field-mutable? . bf5045) (delete-file . bf5044) (file-exists? . bf5043) (vector-sort! . bf5042) (vector-sort . bf5041) (list-sort . bf5040) (symbol-hash . bf503f) (string-ci-hash . bf503e) (string-hash . bf503d) (equal-hash . bf503c) (hashtable-equivalence-function . bf503b) (make-hashtable . bf503a) (hashtable-hash-function . bf5039) (make-eqv-hashtable . bf5038) (make-eq-hashtable . bf5037) (hashtable? . bf5036) (hashtable-update! . bf5035) (hashtable-size . bf5034) (hashtable-set! . bf5033) (hashtable-ref . bf5032) (hashtable-mutable? . bf5031) (hashtable-keys . bf5030) (hashtable-entries . bf502f) (hashtable-delete! . bf502e) (hashtable-copy . bf502d) (hashtable-contains? . bf502c) (hashtable-clear! . bf502b) (call-with-output-file . bf502a) (call-with-input-file . bf5029) (write-char . bf5028) (write . bf5027) (with-output-to-file . bf5026) (with-input-from-file . bf5025) (read-char . bf5024) (read . bf5023) (peek-char . bf5022) (open-output-file . bf5021) (open-input-file . bf5020) (newline . bf501f) (display . bf501e) (close-output-port . bf501d) (close-input-port . bf501c) (eof-object? . bf501b) (eof-object . bf501a) (current-error-port . bf5019) (current-output-port . bf5018) (current-input-port . bf5017) (output-port? . bf5016) (input-port? . bf5015) (utf-8-codec . bf5014) (utf-16-codec . bf5013) (transcoder-error-handling-mode . bf5012) (transcoder-eol-style . bf5011) (transcoder-codec . bf5010) (transcoded-port . bf500f) (textual-port? . bf500e) (string->bytevector . bf500d) (standard-output-port . bf500c) (standard-input-port . bf500b) (standard-error-port . bf500a) (set-port-position! . bf5009) (put-u8 . bf5008) (put-string . bf5007) (put-datum . bf5006) (put-char . bf5005) (put-bytevector . bf5004) (port? . bf5003) (port-transcoder . bf5002) (port-position . bf5001) (port-has-set-port-position!? . bf5000) (port-has-port-position? . bf4fff) (port-eof? . bf4ffe) (output-port-buffer-mode . bf4ffd) (open-string-output-port . bf4ffc) (open-string-input-port . bf4ffb) (open-file-output-port . bf4ffa) (open-file-input/output-port . bf4ff9) (open-file-input-port . bf4ff8) (open-bytevector-output-port . bf4ff7) (open-bytevector-input-port . bf4ff6) (native-transcoder . bf4ff5) (native-eol-style . bf4ff4) (make-transcoder . bf4ff3) (latin-1-codec . bf4ff2) (make-i/o-write-error . bf4ff1) (make-i/o-read-error . bf4ff0) (make-i/o-port-error . bf4fef) (make-i/o-invalid-position-error . bf4fee) (make-i/o-filename-error . bf4fed) (make-i/o-file-protection-error . bf4fec) (make-i/o-file-is-read-only-error . bf4feb) (make-i/o-file-does-not-exist-error . bf4fea) (make-i/o-file-already-exists-error . bf4fe9) (make-i/o-error . bf4fe8) (make-i/o-encoding-error . bf4fe7) (make-i/o-decoding-error . bf4fe6) (make-custom-textual-output-port . bf4fe5) (make-custom-textual-input/output-port . bf4fe4) (make-custom-textual-input-port . bf4fe3) (make-custom-binary-output-port . bf4fe2) (make-custom-binary-input/output-port . bf4fe1) (make-custom-binary-input-port . bf4fe0) (make-bytevector . bf4fdf) (lookahead-u8 . bf4fde) (lookahead-char . bf4fdd) (i/o-write-error? . bf4fdc) (i/o-read-error? . bf4fdb) (i/o-port-error? . bf4fda) (i/o-invalid-position-error? . bf4fd9) (i/o-filename-error? . bf4fd8) (i/o-file-protection-error? . bf4fd7) (i/o-file-is-read-only-error? . bf4fd6) (i/o-file-does-not-exist-error? . bf4fd5) (i/o-file-already-exists-error? . bf4fd4) (i/o-error? . bf4fd3) (i/o-error-position . bf4fd2) (i/o-error-port . bf4fd1) (i/o-error-filename . bf4fd0) (i/o-encoding-error? . bf4fcf) (i/o-encoding-error-char . bf4fce) (i/o-decoding-error? . bf4fcd) (get-u8 . bf4fcc) (get-string-n! . bf4fcb) (get-string-n . bf4fca) (get-string-all . bf4fc9) (get-line . bf4fc8) (get-datum . bf4fc7) (get-char . bf4fc6) (get-bytevector-some . bf4fc5) (get-bytevector-n! . bf4fc4) (get-bytevector-n . bf4fc3) (get-bytevector-all . bf4fc2) (flush-output-port . bf4fc1) (close-port . bf4fc0) (exit . bf4fb8) (command-line . bf4c4a) (string-fill! . bf4fb7) (string-set! . bf4fb6) (set-cdr! . bf4fb5) (set-car! . bf4fb4) (remove . bf4fb3) (remv . bf4fb2) (remp . bf4fb1) (remq . bf4fb0) (partition . bf4faf) (memv . bf4fae) (memq . bf4fad) (memp . bf4fac) (member . bf4fab) (exists . bf4faa) (for-all . bf4fa9) (fold-right . bf4fa8) (fold-left . bf4fa7) (find . bf4fa6) (filter . bf4fa5) (cons* . bf4fa4) (assv . bf4fa3) (assq . bf4fa2) (assp . bf4fa1) (assoc . bf4fa0) (call-with-string-output-port . bf4f9f) (call-with-port . bf4f9e) (call-with-bytevector-output-port . bf4f9d) (bytevector->string . bf4f9c) (buffer-mode? . bf4f9b) (binary-port? . bf4f9a) (with-exception-handler . bf4f99) (raise-continuable . bf4f98) (raise . bf4f97) (eval . bf3171) (environment . bf3169) (make-enumeration . bf4f96) (enum-set=? . bf4f95) (enum-set-universe . bf4f94) (enum-set-union . bf4f93) (enum-set-subset? . bf4f92) (enum-set-projection . bf4f91) (enum-set-member? . bf4f90) (enum-set-intersection . bf4f8f) (enum-set-indexer . bf4f8e) (enum-set-difference . bf4f8d) (enum-set-constructor . bf4f8c) (enum-set-complement . bf4f8b) (enum-set->list . bf4f8a) (who-condition? . bf4f89) (warning? . bf4f88) (violation? . bf4f87) (undefined-violation? . bf4f86) (syntax-violation? . bf4f85) (syntax-violation-subform . bf4f84) (syntax-violation-form . bf4f83) (syntax-violation . bf3191) (simple-conditions . bf4f82) (serious-condition? . bf4f81) (non-continuable-violation? . bf4f80) (message-condition? . bf4f7f) (make-who-condition . bf4f7e) (make-warning . bf4f7d) (make-violation . bf4f7c) (make-undefined-violation . bf4f7b) (make-syntax-violation . bf4f7a) (make-serious-condition . bf4f79) (make-non-continuable-violation . bf4f78) (make-message-condition . bf4f77) (make-lexical-violation . bf4f76) (make-irritants-condition . bf4f75) (make-implementation-restriction-violation . bf4f74) (make-error . bf4f73) (make-assertion-violation . bf4f72) (lexical-violation? . bf4f71) (irritants-condition? . bf4f70) (implementation-restriction-violation? . bf4f6f) (error? . bf4f6e) (condition-who . bf4f6d) (condition-predicate . bf4f6c) (condition-message . bf4f6b) (condition-irritants . bf4f6a) (condition-accessor . bf4f69) (condition . bf4f68) (assertion-violation? . bf4f67) (condition? . bf4f66) (utf32->string . bf4f65) (utf16->string . bf4f64) (utf8->string . bf4f63) (uint-list->bytevector . bf4f62) (u8-list->bytevector . bf4f61) (string->utf8 . bf4f60) (string->utf32 . bf4f5f) (string->utf16 . bf4f5e) (sint-list->bytevector . bf4f5d) (native-endianness . bf4f5c) (bytevector? . bf4f5b) (bytevector=? . bf4f5a) (bytevector-uint-set! . bf4f59) (bytevector-uint-ref . bf4f58) (bytevector-u8-set! . bf4f57) (bytevector-u8-ref . bf4f56) (bytevector-u64-set! . bf4f55) (bytevector-u64-ref . bf4f54) (bytevector-u64-native-set! . bf4f53) (bytevector-u64-native-ref . bf4f52) (bytevector-u32-set! . bf4f51) (bytevector-u32-ref . bf4f50) (bytevector-u32-native-set! . bf4f4f) (bytevector-u32-native-ref . bf4f4e) (bytevector-u16-set! . bf4f4d) (bytevector-u16-ref . bf4f4c) (bytevector-u16-native-set! . bf4f4b) (bytevector-u16-native-ref . bf4f4a) (bytevector-sint-set! . bf4f49) (bytevector-sint-ref . bf4f48) (bytevector-s8-set! . bf4f47) (bytevector-s8-ref . bf4f46) (bytevector-s64-set! . bf4f45) (bytevector-s64-ref . bf4f44) (bytevector-s64-native-set! . bf4f43) (bytevector-s64-native-ref . bf4f42) (bytevector-s32-set! . bf4f41) (bytevector-s32-ref . bf4f40) (bytevector-s32-native-set! . bf4f3f) (bytevector-s32-native-ref . bf4f3e) (bytevector-s16-set! . bf4f3d) (bytevector-s16-ref . bf4f3c) (bytevector-s16-native-set! . bf4f3b) (bytevector-s16-native-ref . bf4f3a) (bytevector-length . bf4f39) (bytevector-ieee-single-ref . bf4f38) (bytevector-ieee-single-set! . bf4f37) (bytevector-ieee-single-native-set! . bf4f36) (bytevector-ieee-single-native-ref . bf4f35) (bytevector-ieee-double-set! . bf4f34) (bytevector-ieee-double-ref . bf4f33) (bytevector-ieee-double-native-set! . bf4f32) (bytevector-ieee-double-native-ref . bf4f31) (bytevector-fill! . bf4f30) (bytevector-copy! . bf4f2f) (bytevector-copy . bf4f2e) (bytevector->uint-list . bf4f2d) (bytevector->u8-list . bf4f2c) (bytevector->sint-list . bf4f2b) (no-nans-violation? . bf4f2a) (no-infinities-violation? . bf4f29) (make-no-nans-violation . bf4f28) (make-no-infinities-violation . bf4f27) (real->flonum . bf4f26) (flzero? . bf4f25) (fltruncate . bf4f24) (fltan . bf4f23) (flsqrt . bf4f22) (flsin . bf4f21) (flround . bf4f20) (flpositive? . bf4f1f) (flonum? . bf4f1e) (flodd? . bf4f1d) (flnumerator . bf4f1c) (flnegative? . bf4f1b) (flnan? . bf4f1a) (flmod0 . bf4f19) (flmod . bf4f18) (flmin . bf4f17) (flmax . bf4f16) (fllog . bf4f15) (flinteger? . bf4f14) (flinfinite? . bf4f13) (flfloor . bf4f12) (flfinite? . bf4f11) (flexpt . bf4f10) (flexp . bf4f0f) (fleven? . bf4f0e) (fldiv0-and-mod0 . bf4f0d) (fldiv0 . bf4f0c) (fldiv-and-mod . bf4f0b) (fldiv . bf4f0a) (fldenominator . bf4f09) (flcos . bf4f08) (flceiling . bf4f07) (flatan . bf4f06) (flasin . bf4f05) (flacos . bf4f04) (flabs . bf4f03) (fl>? . bf4f02) (fl>=? . bf4f01) (fl=? . bf4f00) (fl<? . bf4eff) (fl<=? . bf4efe) (fl/ . bf4efd) (fl- . bf4efc) (fl+ . bf4efb) (fl* . bf4efa) (fixnum->flonum . bf4ef9) (fxzero? . bf4ef8) (fxxor . bf4ef7) (fxrotate-bit-field . bf4ef6) (fxreverse-bit-field . bf4ef5) (fxpositive? . bf4ef4) (fxodd? . bf4ef3) (fxnot . bf4ef2) (fxnegative? . bf4ef1) (fxmod0 . bf4ef0) (fxmod . bf4eef) (fxmin . bf4eee) (fxmax . bf4eed) (fxlength . bf4eec) (fxior . bf4eeb) (fxif . bf4eea) (fxfirst-bit-set . bf4ee9) (fxeven? . bf4ee8) (fxdiv0-and-mod0 . bf4ee7) (fxdiv0 . bf4ee6) (fxdiv-and-mod . bf4ee5) (fxdiv . bf4ee4) (fxcopy-bit-field . bf4ee3) (fxcopy-bit . bf4ee2) (fxbit-set? . bf4ee1) (fxbit-field . bf4ee0) (fxbit-count . bf4edf) (fxarithmetic-shift-right . bf4ede) (fxarithmetic-shift-left . bf4edd) (fxarithmetic-shift . bf4edc) (fxand . bf4edb) (fx>? . bf4eda) (fx>=? . bf4ed9) (fx=? . bf4ed8) (fx<? . bf4ed7) (fx<=? . bf4ed6) (fx-/carry . bf4ed5) (fx- . bf4ed4) (fx+/carry . bf4ed3) (fx+ . bf4ed2) (fx*/carry . bf4ed1) (fx* . bf4ed0) (greatest-fixnum . bf4ecf) (least-fixnum . bf4ece) (fixnum-width . bf4ecd) (fixnum? . bf4ecc) (bitwise-rotate-bit-field . bf4ecb) (bitwise-reverse-bit-field . bf4eca) (bitwise-length . bf4ec9) (bitwise-if . bf4ec8) (bitwise-first-bit-set . bf4ec7) (bitwise-copy-bit-field . bf4ec6) (bitwise-copy-bit . bf4ec5) (bitwise-bit-set? . bf4ec4) (bitwise-bit-field . bf4ec3) (bitwise-bit-count . bf4ec2) (bitwise-xor . bf4ec1) (bitwise-ior . bf4ec0) (bitwise-and . bf4ebf) (bitwise-not . bf4ebe) (bitwise-arithmetic-shift-right . bf4ebd) (bitwise-arithmetic-shift-left . bf4ebc) (bitwise-arithmetic-shift . bf4ebb) (zero? . bf4eba) (vector? . bf4eb9) (vector-set! . bf4eb8) (vector-ref . bf4eb7) (vector-map . bf4eb6) (vector-length . bf4eb5) (vector-for-each . bf4eb4) (vector-fill! . bf4eb3) (vector->list . bf4eb2) (vector . bf4eb1) (values . bf4eb0) (truncate . bf4eaf) (tan . bf4eae) (symbol? . bf4ead) (symbol=? . bf4eac) (symbol->string . bf4eab) (substring . bf4eaa) (string? . bf4ea9) (string>? . bf4ea8) (string>=? . bf4ea7) (string=? . bf4ea6) (string<? . bf4ea5) (string<=? . bf4ea4) (string-ref . bf4ea3) (string-length . bf4ea2) (string-for-each . bf4ea1) (string-copy . bf4ea0) (string-append . bf4e9f) (string->symbol . bf4e9e) (string->number . bf4e9d) (string->list . bf4e9c) (string . bf4e9b) (sqrt . bf4e9a) (sin . bf4e99) (round . bf4e98) (reverse . bf4e97) (real? . bf4e96) (real-valued? . bf4e95) (real-part . bf4e94) (rationalize . bf4e93) (rational? . bf4e92) (rational-valued? . bf4e91) (procedure? . bf4e90) (positive? . bf4e8f) (pair? . bf4e8e) (odd? . bf4e8d) (numerator . bf4e8c) (number? . bf4e8b) (number->string . bf4e8a) (null? . bf4e89) (not . bf4e88) (negative? . bf4e87) (nan? . bf4e86) (min . bf4e85) (max . bf4e84) (map . bf4e83) (make-vector . bf4e82) (make-string . bf4e81) (make-rectangular . bf4e80) (make-polar . bf4e7f) (magnitude . bf4e7e) (log . bf4e7d) (list? . bf4e7c) (list-tail . bf4e7b) (list-ref . bf4e7a) (list->vector . bf4e79) (list->string . bf4e78) (list . bf4e77) (length . bf4e76) (lcm . bf4e75) (integer? . bf4e74) (integer-valued? . bf4e73) (integer->char . bf4e72) (infinite? . bf4e71) (inexact? . bf4e70) (inexact . bf4e6f) (imag-part . bf4e6e) (gcd . bf4e6d) (for-each . bf4e6c) (floor . bf4e6b) (finite? . bf4e6a) (expt . bf4e69) (exp . bf4e68) (exact? . bf4e67) (exact-integer-sqrt . bf4e66) (exact . bf4e65) (even? . bf4e64) (error . bf4e63) (eqv? . bf4e62) (equal? . bf4e61) (eq? . bf4e60) (dynamic-wind . bf4e5f) (div0-and-mod0 . bf4e5e) (mod0 . bf4e5d) (div0 . bf4e5c) (div-and-mod . bf4e5b) (mod . bf4e5a) (div . bf4e59) (denominator . bf4e58) (cos . bf4e57) (cons . bf4e56) (complex? . bf4e55) (char? . bf4e54) (char>? . bf4e53) (char>=? . bf4e52) (char=? . bf4e51) (char<? . bf4e50) (char<=? . bf4e4f) (char->integer . bf4e4e) (ceiling . bf4e4d) (call-with-values . bf4e4c) (call/cc . bf4e4b) (call-with-current-continuation . bf4e4a) (cddddr . bf4e49) (cdddar . bf4e48) (cddadr . bf4e47) (cddaar . bf4e46) (cdaddr . bf4e45) (cdadar . bf4e44) (cdaadr . bf4e43) (cdaaar . bf4e42) (cadddr . bf4e41) (caddar . bf4e40) (cadadr . bf4e3f) (cadaar . bf4e3e) (caaddr . bf4e3d) (caadar . bf4e3c) (caaadr . bf4e3b) (caaaar . bf4e3a) (cdddr . bf4e39) (cddar . bf4e38) (cdadr . bf4e37) (cdaar . bf4e36) (caddr . bf4e35) (cadar . bf4e34) (caadr . bf4e33) (caaar . bf4e32) (cddr . bf4e31) (cdar . bf4e30) (cadr . bf4e2f) (caar . bf4e2e) (cdr . bf4e2d) (car . bf4e2c) (boolean? . bf4e2b) (boolean=? . bf4e2a) (atan . bf4e29) (assertion-violation . bf4e28) (asin . bf4e27) (apply . bf4e26) (append . bf4e25) (angle . bf4e24) (acos . bf4e23) (abs . bf4e22) (/ . bf4e21) (* . bf4e20) (- . bf4e1f) (+ . bf4e1e) (>= . bf4e1d) (> . bf4e1c) (= . bf4e1b) (<= . bf4e1a) (< . bf4e19) (library . bf4e18) (&no-nans . bf4e17) (&no-infinities . bf4e16) (&i/o-encoding . bf4e15) (&i/o-decoding . bf4e14) (&i/o-port . bf4e13) (&i/o-file-does-not-exist . bf4e12) (&i/o-file-already-exists . bf4e11) (&i/o-file-is-read-only . bf4e10) (&i/o-file-protection . bf4e0f) (&i/o-filename . bf4e0e) (&i/o-invalid-position . bf4e0d) (&i/o-write . bf4e0c) (&i/o-read . bf4e0b) (&i/o . bf4e0a) (&undefined . bf4e09) (&syntax . bf4e08) (&lexical . bf4e07) (&implementation-restriction . bf4e06) (&non-continuable . bf4e05) (&who . bf4e04) (&irritants . bf4e03) (&assertion . bf4e02) (&violation . bf4e01) (&error . bf4e00) (&serious . bf4dff) (&warning . bf4dfe) (&message . bf4dfd) (&condition . bf4dfc) (define-condition-type . bf4dfb) (define-enumeration . bf4dfa) (define-record-type . bf4df9) (parent-rtd . bf4df8) (nongenerative . bf4df7) (opaque . bf4df6) (sealed . bf4df5) (protocol . bf4df4) (parent . bf4df3) (immutable . bf4df2) (mutable . bf4df1) (fields . bf4df0) (error-handling-mode . bf4def) (file-options . bf4dee) (buffer-mode . bf4ded) (eol-style . bf4dec) (guard . bf4deb) (unsyntax-splicing . bf4de8) (unsyntax . bf4de7) (unquote-splicing . bf4de6) (unquote . bf4de5) (_ . bf4de4) (else . bf4de3) (=> . bf4de2) (... . bf4de1) (assert . bf4de0) (endianness . bf4ddf) (time . bf4ddd) (do . bf4ddc) (cond . bf4ddb) (let* . bf4dda) (let*-values . bf4dd9) (let-values . bf4dd8) (identifier-syntax . bf4dd7) (with-syntax . bf4dd6) (quasisyntax . bf4dd5) (quasiquote . bf4dd4) (syntax-rules . bf4dd3) (include . bf4dd2) (record-constructor-descriptor . bf4dd0) (record-type-descriptor . bf4dcf) (case . bf4dce) (unless . bf4dcc) (when . bf4dcb) (or . bf4dca) (and . bf4dc9) (if . bf4dc8) (let . bf4dc7) (letrec* . bf4dc6) (letrec . bf4dc5) (case-lambda . bf4dc3) (lambda . bf4dc2) (syntax . bf4dc1) (syntax-case . bf4dc0) (quote . bf4dbf) (letrec-syntax . bf4dbd) (let-syntax . bf4dbc) (set! . bf4dbb) (import . bf4dba) (begin . bf4db9) (define-syntax . bf4db7) (define . bf4db6)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf5163 '(psyntax null-environment-5) '() '() '() '() '((make-promise . bf4fb9) (unquote-splicing . bf4de6) (unquote . bf4de5) (_ . bf4de4) (else . bf4de3) (=> . bf4de2) (... . bf4de1) (delay . bf4dde) (do . bf4ddc) (cond . bf4ddb) (let* . bf4dda) (quasiquote . bf4dd4) (syntax-rules . bf4dd3) (case . bf4dce) (or . bf4dca) (and . bf4dc9) (if . bf4dc8) (let . bf4dc7) (letrec . bf4dc5) (lambda . bf4dc2) (quote . bf4dbf) (letrec-syntax . bf4dbd) (let-syntax . bf4dbc) (set! . bf4dbb) (begin . bf4db9) (define-syntax . bf4db7) (define . bf4db6)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf5164 '(psyntax scheme-report-environment-5) '() '() '() '() '((string-ci>? . bf506a) (string-ci>=? . bf5069) (string-ci=? . bf5068) (string-ci<? . bf5067) (string-ci<=? . bf5066) (char-whitespace? . bf5065) (char-upper-case? . bf5064) (char-numeric? . bf5062) (char-lower-case? . bf5061) (char-upcase . bf505f) (char-downcase . bf505c) (char-ci>? . bf505b) (char-ci>=? . bf505a) (char-ci=? . bf5059) (char-ci<? . bf5058) (char-ci<=? . bf5057) (char-alphabetic? . bf5056) (call-with-output-file . bf502a) (call-with-input-file . bf5029) (write-char . bf5028) (write . bf5027) (with-output-to-file . bf5026) (with-input-from-file . bf5025) (read-char . bf5024) (read . bf5023) (peek-char . bf5022) (open-output-file . bf5021) (open-input-file . bf5020) (newline . bf501f) (display . bf501e) (close-output-port . bf501d) (close-input-port . bf501c) (eof-object . bf501a) (current-output-port . bf5018) (current-input-port . bf5017) (output-port? . bf5016) (input-port? . bf5015) (scheme-report-environment . bf316d) (quotient . bf4fbf) (null-environment . bf316b) (remainder . bf4fbe) (modulo . bf4fbd) (inexact->exact . bf4fbc) (force . bf4fbb) (exact->inexact . bf4fba) (make-promise . bf4fb9) (string-fill! . bf4fb7) (string-set! . bf4fb6) (set-cdr! . bf4fb5) (set-car! . bf4fb4) (memv . bf4fae) (memq . bf4fad) (member . bf4fab) (assv . bf4fa3) (assq . bf4fa2) (assoc . bf4fa0) (eval . bf3171) (zero? . bf4eba) (vector? . bf4eb9) (vector-set! . bf4eb8) (vector-ref . bf4eb7) (vector-length . bf4eb5) (vector-fill! . bf4eb3) (vector->list . bf4eb2) (vector . bf4eb1) (values . bf4eb0) (truncate . bf4eaf) (tan . bf4eae) (symbol? . bf4ead) (symbol->string . bf4eab) (substring . bf4eaa) (string? . bf4ea9) (string>? . bf4ea8) (string>=? . bf4ea7) (string=? . bf4ea6) (string<? . bf4ea5) (string<=? . bf4ea4) (string-ref . bf4ea3) (string-length . bf4ea2) (string-copy . bf4ea0) (string-append . bf4e9f) (string->symbol . bf4e9e) (string->number . bf4e9d) (string->list . bf4e9c) (string . bf4e9b) (sqrt . bf4e9a) (sin . bf4e99) (round . bf4e98) (reverse . bf4e97) (real? . bf4e96) (real-part . bf4e94) (rationalize . bf4e93) (rational? . bf4e92) (procedure? . bf4e90) (positive? . bf4e8f) (pair? . bf4e8e) (odd? . bf4e8d) (numerator . bf4e8c) (number? . bf4e8b) (number->string . bf4e8a) (not . bf4e88) (negative? . bf4e87) (min . bf4e85) (max . bf4e84) (map . bf4e83) (make-vector . bf4e82) (make-string . bf4e81) (make-rectangular . bf4e80) (make-polar . bf4e7f) (magnitude . bf4e7e) (log . bf4e7d) (list? . bf4e7c) (list-tail . bf4e7b) (list-ref . bf4e7a) (list->vector . bf4e79) (list->string . bf4e78) (list . bf4e77) (length . bf4e76) (lcm . bf4e75) (integer? . bf4e74) (integer->char . bf4e72) (inexact? . bf4e70) (imag-part . bf4e6e) (gcd . bf4e6d) (for-each . bf4e6c) (floor . bf4e6b) (expt . bf4e69) (exp . bf4e68) (exact? . bf4e67) (even? . bf4e64) (eqv? . bf4e62) (equal? . bf4e61) (eq? . bf4e60) (dynamic-wind . bf4e5f) (denominator . bf4e58) (cos . bf4e57) (cons . bf4e56) (complex? . bf4e55) (char? . bf4e54) (char>? . bf4e53) (char>=? . bf4e52) (char=? . bf4e51) (char<? . bf4e50) (char<=? . bf4e4f) (char->integer . bf4e4e) (ceiling . bf4e4d) (call-with-values . bf4e4c) (call-with-current-continuation . bf4e4a) (cddddr . bf4e49) (cdddar . bf4e48) (cddadr . bf4e47) (cddaar . bf4e46) (cdaddr . bf4e45) (cdadar . bf4e44) (cdaadr . bf4e43) (cdaaar . bf4e42) (cadddr . bf4e41) (caddar . bf4e40) (cadadr . bf4e3f) (cadaar . bf4e3e) (caaddr . bf4e3d) (caadar . bf4e3c) (caaadr . bf4e3b) (caaaar . bf4e3a) (cdddr . bf4e39) (cddar . bf4e38) (cdadr . bf4e37) (cdaar . bf4e36) (caddr . bf4e35) (cadar . bf4e34) (caadr . bf4e33) (caaar . bf4e32) (cddr . bf4e31) (cdar . bf4e30) (cadr . bf4e2f) (caar . bf4e2e) (cdr . bf4e2d) (car . bf4e2c) (boolean? . bf4e2b) (atan . bf4e29) (asin . bf4e27) (apply . bf4e26) (append . bf4e25) (angle . bf4e24) (acos . bf4e23) (abs . bf4e22) (/ . bf4e21) (* . bf4e20) (- . bf4e1f) (+ . bf4e1e) (>= . bf4e1d) (> . bf4e1c) (= . bf4e1b) (<= . bf4e1a) (< . bf4e19) (unquote-splicing . bf4de6) (unquote . bf4de5) (else . bf4de3) (=> . bf4de2) (... . bf4de1) (delay . bf4dde) (do . bf4ddc) (cond . bf4ddb) (let* . bf4dda) (quasiquote . bf4dd4) (syntax-rules . bf4dd3) (case . bf4dce) (or . bf4dca) (and . bf4dc9) (if . bf4dc8) (let . bf4dc7) (letrec . bf4dc5) (lambda . bf4dc2) (quote . bf4dbf) (letrec-syntax . bf4dbd) (let-syntax . bf4dbc) (set! . bf4dbb) (begin . bf4db9) (define-syntax . bf4db7) (define . bf4db6)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf5165 '(psyntax modules) '() '() '() '() '((module . bf4db8)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf5166 '(chez parameters) '() '() '() '() '() '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf5167 '(rnrs) '(6) '() '() '() '((regexp? . bf5122) (string-upcase . bf5072) (string-titlecase . bf5071) (string-normalize-nfkd . bf5070) (string-normalize-nfkc . bf506f) (string-normalize-nfd . bf506e) (string-normalize-nfc . bf506d) (string-foldcase . bf506c) (string-downcase . bf506b) (string-ci>? . bf506a) (string-ci>=? . bf5069) (string-ci=? . bf5068) (string-ci<? . bf5067) (string-ci<=? . bf5066) (char-whitespace? . bf5065) (char-upper-case? . bf5064) (char-title-case? . bf5063) (char-numeric? . bf5062) (char-lower-case? . bf5061) (char-general-category . bf5060) (char-upcase . bf505f) (char-titlecase . bf505e) (char-foldcase . bf505d) (char-downcase . bf505c) (char-ci>? . bf505b) (char-ci>=? . bf505a) (char-ci=? . bf5059) (char-ci<? . bf5058) (char-ci<=? . bf5057) (char-alphabetic? . bf5056) (make-variable-transformer . bf2edc) (identifier? . bf3193) (generate-temporaries . bf317f) (free-identifier=? . bf3181) (syntax->datum . bf3197) (datum->syntax . bf3195) (bound-identifier=? . bf3183) (record-type-descriptor? . bf5055) (record-predicate . bf5054) (record-mutator . bf5053) (record-constructor . bf5052) (record-accessor . bf5051) (make-record-type-descriptor . bf5050) (make-record-constructor-descriptor . bf504f) (record? . bf504e) (record-type-uid . bf504d) (record-type-sealed? . bf504c) (record-type-parent . bf504b) (record-type-opaque? . bf504a) (record-type-name . bf5049) (record-type-generative? . bf5048) (record-type-field-names . bf5047) (record-rtd . bf5046) (record-field-mutable? . bf5045) (delete-file . bf5044) (file-exists? . bf5043) (vector-sort! . bf5042) (vector-sort . bf5041) (list-sort . bf5040) (symbol-hash . bf503f) (string-ci-hash . bf503e) (string-hash . bf503d) (equal-hash . bf503c) (hashtable-equivalence-function . bf503b) (make-hashtable . bf503a) (hashtable-hash-function . bf5039) (make-eqv-hashtable . bf5038) (make-eq-hashtable . bf5037) (hashtable? . bf5036) (hashtable-update! . bf5035) (hashtable-size . bf5034) (hashtable-set! . bf5033) (hashtable-ref . bf5032) (hashtable-mutable? . bf5031) (hashtable-keys . bf5030) (hashtable-entries . bf502f) (hashtable-delete! . bf502e) (hashtable-copy . bf502d) (hashtable-contains? . bf502c) (hashtable-clear! . bf502b) (call-with-output-file . bf502a) (call-with-input-file . bf5029) (write-char . bf5028) (write . bf5027) (with-output-to-file . bf5026) (with-input-from-file . bf5025) (read-char . bf5024) (read . bf5023) (peek-char . bf5022) (open-output-file . bf5021) (open-input-file . bf5020) (newline . bf501f) (display . bf501e) (close-output-port . bf501d) (close-input-port . bf501c) (eof-object? . bf501b) (eof-object . bf501a) (current-error-port . bf5019) (current-output-port . bf5018) (current-input-port . bf5017) (output-port? . bf5016) (input-port? . bf5015) (utf-8-codec . bf5014) (utf-16-codec . bf5013) (transcoder-error-handling-mode . bf5012) (transcoder-eol-style . bf5011) (transcoder-codec . bf5010) (transcoded-port . bf500f) (textual-port? . bf500e) (string->bytevector . bf500d) (standard-output-port . bf500c) (standard-input-port . bf500b) (standard-error-port . bf500a) (set-port-position! . bf5009) (put-u8 . bf5008) (put-string . bf5007) (put-datum . bf5006) (put-char . bf5005) (put-bytevector . bf5004) (port? . bf5003) (port-transcoder . bf5002) (port-position . bf5001) (port-has-set-port-position!? . bf5000) (port-has-port-position? . bf4fff) (port-eof? . bf4ffe) (output-port-buffer-mode . bf4ffd) (open-string-output-port . bf4ffc) (open-string-input-port . bf4ffb) (open-file-output-port . bf4ffa) (open-file-input/output-port . bf4ff9) (open-file-input-port . bf4ff8) (open-bytevector-output-port . bf4ff7) (open-bytevector-input-port . bf4ff6) (native-transcoder . bf4ff5) (native-eol-style . bf4ff4) (make-transcoder . bf4ff3) (latin-1-codec . bf4ff2) (make-i/o-write-error . bf4ff1) (make-i/o-read-error . bf4ff0) (make-i/o-port-error . bf4fef) (make-i/o-invalid-position-error . bf4fee) (make-i/o-filename-error . bf4fed) (make-i/o-file-protection-error . bf4fec) (make-i/o-file-is-read-only-error . bf4feb) (make-i/o-file-does-not-exist-error . bf4fea) (make-i/o-file-already-exists-error . bf4fe9) (make-i/o-error . bf4fe8) (make-i/o-encoding-error . bf4fe7) (make-i/o-decoding-error . bf4fe6) (make-custom-textual-output-port . bf4fe5) (make-custom-textual-input/output-port . bf4fe4) (make-custom-textual-input-port . bf4fe3) (make-custom-binary-output-port . bf4fe2) (make-custom-binary-input/output-port . bf4fe1) (make-custom-binary-input-port . bf4fe0) (make-bytevector . bf4fdf) (lookahead-u8 . bf4fde) (lookahead-char . bf4fdd) (i/o-write-error? . bf4fdc) (i/o-read-error? . bf4fdb) (i/o-port-error? . bf4fda) (i/o-invalid-position-error? . bf4fd9) (i/o-filename-error? . bf4fd8) (i/o-file-protection-error? . bf4fd7) (i/o-file-is-read-only-error? . bf4fd6) (i/o-file-does-not-exist-error? . bf4fd5) (i/o-file-already-exists-error? . bf4fd4) (i/o-error? . bf4fd3) (i/o-error-position . bf4fd2) (i/o-error-port . bf4fd1) (i/o-error-filename . bf4fd0) (i/o-encoding-error? . bf4fcf) (i/o-encoding-error-char . bf4fce) (i/o-decoding-error? . bf4fcd) (get-u8 . bf4fcc) (get-string-n! . bf4fcb) (get-string-n . bf4fca) (get-string-all . bf4fc9) (get-line . bf4fc8) (get-datum . bf4fc7) (get-char . bf4fc6) (get-bytevector-some . bf4fc5) (get-bytevector-n! . bf4fc4) (get-bytevector-n . bf4fc3) (get-bytevector-all . bf4fc2) (flush-output-port . bf4fc1) (close-port . bf4fc0) (exit . bf4fb8) (command-line . bf4c4a) (remove . bf4fb3) (remv . bf4fb2) (remp . bf4fb1) (remq . bf4fb0) (partition . bf4faf) (memv . bf4fae) (memq . bf4fad) (memp . bf4fac) (member . bf4fab) (exists . bf4faa) (for-all . bf4fa9) (fold-right . bf4fa8) (fold-left . bf4fa7) (find . bf4fa6) (filter . bf4fa5) (cons* . bf4fa4) (assv . bf4fa3) (assq . bf4fa2) (assp . bf4fa1) (assoc . bf4fa0) (call-with-string-output-port . bf4f9f) (call-with-port . bf4f9e) (call-with-bytevector-output-port . bf4f9d) (bytevector->string . bf4f9c) (buffer-mode? . bf4f9b) (binary-port? . bf4f9a) (with-exception-handler . bf4f99) (raise-continuable . bf4f98) (raise . bf4f97) (make-enumeration . bf4f96) (enum-set=? . bf4f95) (enum-set-universe . bf4f94) (enum-set-union . bf4f93) (enum-set-subset? . bf4f92) (enum-set-projection . bf4f91) (enum-set-member? . bf4f90) (enum-set-intersection . bf4f8f) (enum-set-indexer . bf4f8e) (enum-set-difference . bf4f8d) (enum-set-constructor . bf4f8c) (enum-set-complement . bf4f8b) (enum-set->list . bf4f8a) (who-condition? . bf4f89) (warning? . bf4f88) (violation? . bf4f87) (undefined-violation? . bf4f86) (syntax-violation? . bf4f85) (syntax-violation-subform . bf4f84) (syntax-violation-form . bf4f83) (syntax-violation . bf3191) (simple-conditions . bf4f82) (serious-condition? . bf4f81) (non-continuable-violation? . bf4f80) (message-condition? . bf4f7f) (make-who-condition . bf4f7e) (make-warning . bf4f7d) (make-violation . bf4f7c) (make-undefined-violation . bf4f7b) (make-syntax-violation . bf4f7a) (make-serious-condition . bf4f79) (make-non-continuable-violation . bf4f78) (make-message-condition . bf4f77) (make-lexical-violation . bf4f76) (make-irritants-condition . bf4f75) (make-implementation-restriction-violation . bf4f74) (make-error . bf4f73) (make-assertion-violation . bf4f72) (lexical-violation? . bf4f71) (irritants-condition? . bf4f70) (implementation-restriction-violation? . bf4f6f) (error? . bf4f6e) (condition-who . bf4f6d) (condition-predicate . bf4f6c) (condition-message . bf4f6b) (condition-irritants . bf4f6a) (condition-accessor . bf4f69) (condition . bf4f68) (assertion-violation? . bf4f67) (condition? . bf4f66) (utf32->string . bf4f65) (utf16->string . bf4f64) (utf8->string . bf4f63) (uint-list->bytevector . bf4f62) (u8-list->bytevector . bf4f61) (string->utf8 . bf4f60) (string->utf32 . bf4f5f) (string->utf16 . bf4f5e) (sint-list->bytevector . bf4f5d) (native-endianness . bf4f5c) (bytevector? . bf4f5b) (bytevector=? . bf4f5a) (bytevector-uint-set! . bf4f59) (bytevector-uint-ref . bf4f58) (bytevector-u8-set! . bf4f57) (bytevector-u8-ref . bf4f56) (bytevector-u64-set! . bf4f55) (bytevector-u64-ref . bf4f54) (bytevector-u64-native-set! . bf4f53) (bytevector-u64-native-ref . bf4f52) (bytevector-u32-set! . bf4f51) (bytevector-u32-ref . bf4f50) (bytevector-u32-native-set! . bf4f4f) (bytevector-u32-native-ref . bf4f4e) (bytevector-u16-set! . bf4f4d) (bytevector-u16-ref . bf4f4c) (bytevector-u16-native-set! . bf4f4b) (bytevector-u16-native-ref . bf4f4a) (bytevector-sint-set! . bf4f49) (bytevector-sint-ref . bf4f48) (bytevector-s8-set! . bf4f47) (bytevector-s8-ref . bf4f46) (bytevector-s64-set! . bf4f45) (bytevector-s64-ref . bf4f44) (bytevector-s64-native-set! . bf4f43) (bytevector-s64-native-ref . bf4f42) (bytevector-s32-set! . bf4f41) (bytevector-s32-ref . bf4f40) (bytevector-s32-native-set! . bf4f3f) (bytevector-s32-native-ref . bf4f3e) (bytevector-s16-set! . bf4f3d) (bytevector-s16-ref . bf4f3c) (bytevector-s16-native-set! . bf4f3b) (bytevector-s16-native-ref . bf4f3a) (bytevector-length . bf4f39) (bytevector-ieee-single-ref . bf4f38) (bytevector-ieee-single-set! . bf4f37) (bytevector-ieee-single-native-set! . bf4f36) (bytevector-ieee-single-native-ref . bf4f35) (bytevector-ieee-double-set! . bf4f34) (bytevector-ieee-double-ref . bf4f33) (bytevector-ieee-double-native-set! . bf4f32) (bytevector-ieee-double-native-ref . bf4f31) (bytevector-fill! . bf4f30) (bytevector-copy! . bf4f2f) (bytevector-copy . bf4f2e) (bytevector->uint-list . bf4f2d) (bytevector->u8-list . bf4f2c) (bytevector->sint-list . bf4f2b) (no-nans-violation? . bf4f2a) (no-infinities-violation? . bf4f29) (make-no-nans-violation . bf4f28) (make-no-infinities-violation . bf4f27) (real->flonum . bf4f26) (flzero? . bf4f25) (fltruncate . bf4f24) (fltan . bf4f23) (flsqrt . bf4f22) (flsin . bf4f21) (flround . bf4f20) (flpositive? . bf4f1f) (flonum? . bf4f1e) (flodd? . bf4f1d) (flnumerator . bf4f1c) (flnegative? . bf4f1b) (flnan? . bf4f1a) (flmod0 . bf4f19) (flmod . bf4f18) (flmin . bf4f17) (flmax . bf4f16) (fllog . bf4f15) (flinteger? . bf4f14) (flinfinite? . bf4f13) (flfloor . bf4f12) (flfinite? . bf4f11) (flexpt . bf4f10) (flexp . bf4f0f) (fleven? . bf4f0e) (fldiv0-and-mod0 . bf4f0d) (fldiv0 . bf4f0c) (fldiv-and-mod . bf4f0b) (fldiv . bf4f0a) (fldenominator . bf4f09) (flcos . bf4f08) (flceiling . bf4f07) (flatan . bf4f06) (flasin . bf4f05) (flacos . bf4f04) (flabs . bf4f03) (fl>? . bf4f02) (fl>=? . bf4f01) (fl=? . bf4f00) (fl<? . bf4eff) (fl<=? . bf4efe) (fl/ . bf4efd) (fl- . bf4efc) (fl+ . bf4efb) (fl* . bf4efa) (fixnum->flonum . bf4ef9) (fxzero? . bf4ef8) (fxxor . bf4ef7) (fxrotate-bit-field . bf4ef6) (fxreverse-bit-field . bf4ef5) (fxpositive? . bf4ef4) (fxodd? . bf4ef3) (fxnot . bf4ef2) (fxnegative? . bf4ef1) (fxmod0 . bf4ef0) (fxmod . bf4eef) (fxmin . bf4eee) (fxmax . bf4eed) (fxlength . bf4eec) (fxior . bf4eeb) (fxif . bf4eea) (fxfirst-bit-set . bf4ee9) (fxeven? . bf4ee8) (fxdiv0-and-mod0 . bf4ee7) (fxdiv0 . bf4ee6) (fxdiv-and-mod . bf4ee5) (fxdiv . bf4ee4) (fxcopy-bit-field . bf4ee3) (fxcopy-bit . bf4ee2) (fxbit-set? . bf4ee1) (fxbit-field . bf4ee0) (fxbit-count . bf4edf) (fxarithmetic-shift-right . bf4ede) (fxarithmetic-shift-left . bf4edd) (fxarithmetic-shift . bf4edc) (fxand . bf4edb) (fx>? . bf4eda) (fx>=? . bf4ed9) (fx=? . bf4ed8) (fx<? . bf4ed7) (fx<=? . bf4ed6) (fx-/carry . bf4ed5) (fx- . bf4ed4) (fx+/carry . bf4ed3) (fx+ . bf4ed2) (fx*/carry . bf4ed1) (fx* . bf4ed0) (greatest-fixnum . bf4ecf) (least-fixnum . bf4ece) (fixnum-width . bf4ecd) (fixnum? . bf4ecc) (bitwise-rotate-bit-field . bf4ecb) (bitwise-reverse-bit-field . bf4eca) (bitwise-length . bf4ec9) (bitwise-if . bf4ec8) (bitwise-first-bit-set . bf4ec7) (bitwise-copy-bit-field . bf4ec6) (bitwise-copy-bit . bf4ec5) (bitwise-bit-set? . bf4ec4) (bitwise-bit-field . bf4ec3) (bitwise-bit-count . bf4ec2) (bitwise-xor . bf4ec1) (bitwise-ior . bf4ec0) (bitwise-and . bf4ebf) (bitwise-not . bf4ebe) (bitwise-arithmetic-shift-right . bf4ebd) (bitwise-arithmetic-shift-left . bf4ebc) (bitwise-arithmetic-shift . bf4ebb) (zero? . bf4eba) (vector? . bf4eb9) (vector-set! . bf4eb8) (vector-ref . bf4eb7) (vector-map . bf4eb6) (vector-length . bf4eb5) (vector-for-each . bf4eb4) (vector-fill! . bf4eb3) (vector->list . bf4eb2) (vector . bf4eb1) (values . bf4eb0) (truncate . bf4eaf) (tan . bf4eae) (symbol? . bf4ead) (symbol=? . bf4eac) (symbol->string . bf4eab) (substring . bf4eaa) (string? . bf4ea9) (string>? . bf4ea8) (string>=? . bf4ea7) (string=? . bf4ea6) (string<? . bf4ea5) (string<=? . bf4ea4) (string-ref . bf4ea3) (string-length . bf4ea2) (string-for-each . bf4ea1) (string-copy . bf4ea0) (string-append . bf4e9f) (string->symbol . bf4e9e) (string->number . bf4e9d) (string->list . bf4e9c) (string . bf4e9b) (sqrt . bf4e9a) (sin . bf4e99) (round . bf4e98) (reverse . bf4e97) (real? . bf4e96) (real-valued? . bf4e95) (real-part . bf4e94) (rationalize . bf4e93) (rational? . bf4e92) (rational-valued? . bf4e91) (procedure? . bf4e90) (positive? . bf4e8f) (pair? . bf4e8e) (odd? . bf4e8d) (numerator . bf4e8c) (number? . bf4e8b) (number->string . bf4e8a) (null? . bf4e89) (not . bf4e88) (negative? . bf4e87) (nan? . bf4e86) (min . bf4e85) (max . bf4e84) (map . bf4e83) (make-vector . bf4e82) (make-string . bf4e81) (make-rectangular . bf4e80) (make-polar . bf4e7f) (magnitude . bf4e7e) (log . bf4e7d) (list? . bf4e7c) (list-tail . bf4e7b) (list-ref . bf4e7a) (list->vector . bf4e79) (list->string . bf4e78) (list . bf4e77) (length . bf4e76) (lcm . bf4e75) (integer? . bf4e74) (integer-valued? . bf4e73) (integer->char . bf4e72) (infinite? . bf4e71) (inexact? . bf4e70) (inexact . bf4e6f) (imag-part . bf4e6e) (gcd . bf4e6d) (for-each . bf4e6c) (floor . bf4e6b) (finite? . bf4e6a) (expt . bf4e69) (exp . bf4e68) (exact? . bf4e67) (exact-integer-sqrt . bf4e66) (exact . bf4e65) (even? . bf4e64) (error . bf4e63) (eqv? . bf4e62) (equal? . bf4e61) (eq? . bf4e60) (dynamic-wind . bf4e5f) (div0-and-mod0 . bf4e5e) (mod0 . bf4e5d) (div0 . bf4e5c) (div-and-mod . bf4e5b) (mod . bf4e5a) (div . bf4e59) (denominator . bf4e58) (cos . bf4e57) (cons . bf4e56) (complex? . bf4e55) (char? . bf4e54) (char>? . bf4e53) (char>=? . bf4e52) (char=? . bf4e51) (char<? . bf4e50) (char<=? . bf4e4f) (char->integer . bf4e4e) (ceiling . bf4e4d) (call-with-values . bf4e4c) (call/cc . bf4e4b) (call-with-current-continuation . bf4e4a) (cddddr . bf4e49) (cdddar . bf4e48) (cddadr . bf4e47) (cddaar . bf4e46) (cdaddr . bf4e45) (cdadar . bf4e44) (cdaadr . bf4e43) (cdaaar . bf4e42) (cadddr . bf4e41) (caddar . bf4e40) (cadadr . bf4e3f) (cadaar . bf4e3e) (caaddr . bf4e3d) (caadar . bf4e3c) (caaadr . bf4e3b) (caaaar . bf4e3a) (cdddr . bf4e39) (cddar . bf4e38) (cdadr . bf4e37) (cdaar . bf4e36) (caddr . bf4e35) (cadar . bf4e34) (caadr . bf4e33) (caaar . bf4e32) (cddr . bf4e31) (cdar . bf4e30) (cadr . bf4e2f) (caar . bf4e2e) (cdr . bf4e2d) (car . bf4e2c) (boolean? . bf4e2b) (boolean=? . bf4e2a) (atan . bf4e29) (assertion-violation . bf4e28) (asin . bf4e27) (apply . bf4e26) (append . bf4e25) (angle . bf4e24) (acos . bf4e23) (abs . bf4e22) (/ . bf4e21) (* . bf4e20) (- . bf4e1f) (+ . bf4e1e) (>= . bf4e1d) (> . bf4e1c) (= . bf4e1b) (<= . bf4e1a) (< . bf4e19) (&no-nans . bf4e17) (&no-infinities . bf4e16) (&i/o-encoding . bf4e15) (&i/o-decoding . bf4e14) (&i/o-port . bf4e13) (&i/o-file-does-not-exist . bf4e12) (&i/o-file-already-exists . bf4e11) (&i/o-file-is-read-only . bf4e10) (&i/o-file-protection . bf4e0f) (&i/o-filename . bf4e0e) (&i/o-invalid-position . bf4e0d) (&i/o-write . bf4e0c) (&i/o-read . bf4e0b) (&i/o . bf4e0a) (&undefined . bf4e09) (&syntax . bf4e08) (&lexical . bf4e07) (&implementation-restriction . bf4e06) (&non-continuable . bf4e05) (&who . bf4e04) (&irritants . bf4e03) (&assertion . bf4e02) (&violation . bf4e01) (&error . bf4e00) (&serious . bf4dff) (&warning . bf4dfe) (&message . bf4dfd) (&condition . bf4dfc) (define-condition-type . bf4dfb) (define-enumeration . bf4dfa) (define-record-type . bf4df9) (parent-rtd . bf4df8) (nongenerative . bf4df7) (opaque . bf4df6) (sealed . bf4df5) (protocol . bf4df4) (parent . bf4df3) (immutable . bf4df2) (mutable . bf4df1) (fields . bf4df0) (error-handling-mode . bf4def) (file-options . bf4dee) (buffer-mode . bf4ded) (eol-style . bf4dec) (guard . bf4deb) (unsyntax-splicing . bf4de8) (unsyntax . bf4de7) (unquote-splicing . bf4de6) (unquote . bf4de5) (_ . bf4de4) (else . bf4de3) (=> . bf4de2) (... . bf4de1) (assert . bf4de0) (endianness . bf4ddf) (do . bf4ddc) (cond . bf4ddb) (let* . bf4dda) (let*-values . bf4dd9) (let-values . bf4dd8) (identifier-syntax . bf4dd7) (with-syntax . bf4dd6) (quasisyntax . bf4dd5) (quasiquote . bf4dd4) (syntax-rules . bf4dd3) (record-constructor-descriptor . bf4dd0) (record-type-descriptor . bf4dcf) (case . bf4dce) (unless . bf4dcc) (when . bf4dcb) (or . bf4dca) (and . bf4dc9) (if . bf4dc8) (let . bf4dc7) (letrec* . bf4dc6) (letrec . bf4dc5) (case-lambda . bf4dc3) (lambda . bf4dc2) (syntax . bf4dc1) (syntax-case . bf4dc0) (quote . bf4dbf) (letrec-syntax . bf4dbd) (let-syntax . bf4dbc) (set! . bf4dbb) (begin . bf4db9) (define-syntax . bf4db7) (define . bf4db6)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf5168 '(rnrs r5rs) '(6) '() '() '() '((scheme-report-environment . bf316d) (quotient . bf4fbf) (null-environment . bf316b) (remainder . bf4fbe) (modulo . bf4fbd) (inexact->exact . bf4fbc) (force . bf4fbb) (exact->inexact . bf4fba) (make-promise . bf4fb9) (delay . bf4dde)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf5169 '(rnrs control) '(6) '() '() '() '((do . bf4ddc) (unless . bf4dcc) (when . bf4dcb) (case-lambda . bf4dc3)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf516a '(rnrs eval) '(6) '() '() '() '((eval . bf3171) (environment . bf3169)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf516b '(rnrs mutable-pairs) '(6) '() '() '() '((set-cdr! . bf4fb5) (set-car! . bf4fb4)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf516c '(rnrs mutable-strings) '(6) '() '() '() '((string-fill! . bf4fb7) (string-set! . bf4fb6)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf516d '(rnrs programs) '(6) '() '() '() '((exit . bf4fb8) (command-line . bf4c4a)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf516e '(rnrs syntax-case) '(6) '() '() '() '((make-variable-transformer . bf2edc) (identifier? . bf3193) (generate-temporaries . bf317f) (free-identifier=? . bf3181) (syntax->datum . bf3197) (datum->syntax . bf3195) (bound-identifier=? . bf3183) (syntax-violation . bf3191) (unsyntax-splicing . bf4de8) (unsyntax . bf4de7) (_ . bf4de4) (... . bf4de1) (with-syntax . bf4dd6) (quasisyntax . bf4dd5) (syntax . bf4dc1) (syntax-case . bf4dc0)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf516f '(rnrs files) '(6) '() '() '() '((delete-file . bf5044) (file-exists? . bf5043) (make-i/o-write-error . bf4ff1) (make-i/o-read-error . bf4ff0) (make-i/o-port-error . bf4fef) (make-i/o-invalid-position-error . bf4fee) (make-i/o-filename-error . bf4fed) (make-i/o-file-protection-error . bf4fec) (make-i/o-file-is-read-only-error . bf4feb) (make-i/o-file-does-not-exist-error . bf4fea) (make-i/o-file-already-exists-error . bf4fe9) (make-i/o-error . bf4fe8) (i/o-write-error? . bf4fdc) (i/o-read-error? . bf4fdb) (i/o-port-error? . bf4fda) (i/o-invalid-position-error? . bf4fd9) (i/o-filename-error? . bf4fd8) (i/o-file-protection-error? . bf4fd7) (i/o-file-is-read-only-error? . bf4fd6) (i/o-file-does-not-exist-error? . bf4fd5) (i/o-file-already-exists-error? . bf4fd4) (i/o-error? . bf4fd3) (i/o-error-position . bf4fd2) (i/o-error-port . bf4fd1) (i/o-error-filename . bf4fd0) (&i/o-port . bf4e13) (&i/o-file-does-not-exist . bf4e12) (&i/o-file-already-exists . bf4e11) (&i/o-file-is-read-only . bf4e10) (&i/o-file-protection . bf4e0f) (&i/o-filename . bf4e0e) (&i/o-invalid-position . bf4e0d) (&i/o-write . bf4e0c) (&i/o-read . bf4e0b) (&i/o . bf4e0a)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf5170 '(rnrs sorting) '(6) '() '() '() '((vector-sort! . bf5042) (vector-sort . bf5041) (list-sort . bf5040)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf5171 '(rnrs base) '(6) '() '() '() '((zero? . bf4eba) (vector? . bf4eb9) (vector-set! . bf4eb8) (vector-ref . bf4eb7) (vector-map . bf4eb6) (vector-length . bf4eb5) (vector-for-each . bf4eb4) (vector-fill! . bf4eb3) (vector->list . bf4eb2) (vector . bf4eb1) (values . bf4eb0) (truncate . bf4eaf) (tan . bf4eae) (symbol? . bf4ead) (symbol=? . bf4eac) (symbol->string . bf4eab) (substring . bf4eaa) (string? . bf4ea9) (string>? . bf4ea8) (string>=? . bf4ea7) (string=? . bf4ea6) (string<? . bf4ea5) (string<=? . bf4ea4) (string-ref . bf4ea3) (string-length . bf4ea2) (string-for-each . bf4ea1) (string-copy . bf4ea0) (string-append . bf4e9f) (string->symbol . bf4e9e) (string->number . bf4e9d) (string->list . bf4e9c) (string . bf4e9b) (sqrt . bf4e9a) (sin . bf4e99) (round . bf4e98) (reverse . bf4e97) (real? . bf4e96) (real-valued? . bf4e95) (real-part . bf4e94) (rationalize . bf4e93) (rational? . bf4e92) (rational-valued? . bf4e91) (procedure? . bf4e90) (positive? . bf4e8f) (pair? . bf4e8e) (odd? . bf4e8d) (numerator . bf4e8c) (number? . bf4e8b) (number->string . bf4e8a) (null? . bf4e89) (not . bf4e88) (negative? . bf4e87) (nan? . bf4e86) (min . bf4e85) (max . bf4e84) (map . bf4e83) (make-vector . bf4e82) (make-string . bf4e81) (make-rectangular . bf4e80) (make-polar . bf4e7f) (magnitude . bf4e7e) (log . bf4e7d) (list? . bf4e7c) (list-tail . bf4e7b) (list-ref . bf4e7a) (list->vector . bf4e79) (list->string . bf4e78) (list . bf4e77) (length . bf4e76) (lcm . bf4e75) (integer? . bf4e74) (integer-valued? . bf4e73) (integer->char . bf4e72) (infinite? . bf4e71) (inexact? . bf4e70) (inexact . bf4e6f) (imag-part . bf4e6e) (gcd . bf4e6d) (for-each . bf4e6c) (floor . bf4e6b) (finite? . bf4e6a) (expt . bf4e69) (exp . bf4e68) (exact? . bf4e67) (exact-integer-sqrt . bf4e66) (exact . bf4e65) (even? . bf4e64) (error . bf4e63) (eqv? . bf4e62) (equal? . bf4e61) (eq? . bf4e60) (dynamic-wind . bf4e5f) (div0-and-mod0 . bf4e5e) (mod0 . bf4e5d) (div0 . bf4e5c) (div-and-mod . bf4e5b) (mod . bf4e5a) (div . bf4e59) (denominator . bf4e58) (cos . bf4e57) (cons . bf4e56) (complex? . bf4e55) (char? . bf4e54) (char>? . bf4e53) (char>=? . bf4e52) (char=? . bf4e51) (char<? . bf4e50) (char<=? . bf4e4f) (char->integer . bf4e4e) (ceiling . bf4e4d) (call-with-values . bf4e4c) (call/cc . bf4e4b) (call-with-current-continuation . bf4e4a) (cddddr . bf4e49) (cdddar . bf4e48) (cddadr . bf4e47) (cddaar . bf4e46) (cdaddr . bf4e45) (cdadar . bf4e44) (cdaadr . bf4e43) (cdaaar . bf4e42) (cadddr . bf4e41) (caddar . bf4e40) (cadadr . bf4e3f) (cadaar . bf4e3e) (caaddr . bf4e3d) (caadar . bf4e3c) (caaadr . bf4e3b) (caaaar . bf4e3a) (cdddr . bf4e39) (cddar . bf4e38) (cdadr . bf4e37) (cdaar . bf4e36) (caddr . bf4e35) (cadar . bf4e34) (caadr . bf4e33) (caaar . bf4e32) (cddr . bf4e31) (cdar . bf4e30) (cadr . bf4e2f) (caar . bf4e2e) (cdr . bf4e2d) (car . bf4e2c) (boolean? . bf4e2b) (boolean=? . bf4e2a) (atan . bf4e29) (assertion-violation . bf4e28) (asin . bf4e27) (apply . bf4e26) (append . bf4e25) (angle . bf4e24) (acos . bf4e23) (abs . bf4e22) (/ . bf4e21) (* . bf4e20) (- . bf4e1f) (+ . bf4e1e) (>= . bf4e1d) (> . bf4e1c) (= . bf4e1b) (<= . bf4e1a) (< . bf4e19) (unquote-splicing . bf4de6) (unquote . bf4de5) (_ . bf4de4) (else . bf4de3) (=> . bf4de2) (... . bf4de1) (assert . bf4de0) (cond . bf4ddb) (let* . bf4dda) (let*-values . bf4dd9) (let-values . bf4dd8) (identifier-syntax . bf4dd7) (quasiquote . bf4dd4) (syntax-rules . bf4dd3) (case . bf4dce) (or . bf4dca) (and . bf4dc9) (if . bf4dc8) (let . bf4dc7) (letrec* . bf4dc6) (letrec . bf4dc5) (lambda . bf4dc2) (quote . bf4dbf) (letrec-syntax . bf4dbd) (let-syntax . bf4dbc) (set! . bf4dbb) (begin . bf4db9) (define-syntax . bf4db7) (define . bf4db6)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf5172 '(rnrs lists) '(6) '() '() '() '((remove . bf4fb3) (remv . bf4fb2) (remp . bf4fb1) (remq . bf4fb0) (partition . bf4faf) (memv . bf4fae) (memq . bf4fad) (memp . bf4fac) (member . bf4fab) (exists . bf4faa) (for-all . bf4fa9) (fold-right . bf4fa8) (fold-left . bf4fa7) (find . bf4fa6) (filter . bf4fa5) (cons* . bf4fa4) (assv . bf4fa3) (assq . bf4fa2) (assp . bf4fa1) (assoc . bf4fa0)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf5173 '(rnrs io simple) '(6) '() '() '() '((call-with-output-file . bf502a) (call-with-input-file . bf5029) (write-char . bf5028) (write . bf5027) (with-output-to-file . bf5026) (with-input-from-file . bf5025) (read-char . bf5024) (read . bf5023) (peek-char . bf5022) (open-output-file . bf5021) (open-input-file . bf5020) (newline . bf501f) (display . bf501e) (close-output-port . bf501d) (close-input-port . bf501c) (eof-object? . bf501b) (eof-object . bf501a) (current-error-port . bf5019) (current-output-port . bf5018) (current-input-port . bf5017) (output-port? . bf5016) (input-port? . bf5015) (make-i/o-write-error . bf4ff1) (make-i/o-read-error . bf4ff0) (make-i/o-port-error . bf4fef) (make-i/o-invalid-position-error . bf4fee) (make-i/o-filename-error . bf4fed) (make-i/o-file-protection-error . bf4fec) (make-i/o-file-is-read-only-error . bf4feb) (make-i/o-file-does-not-exist-error . bf4fea) (make-i/o-file-already-exists-error . bf4fe9) (make-i/o-error . bf4fe8) (i/o-write-error? . bf4fdc) (i/o-read-error? . bf4fdb) (i/o-port-error? . bf4fda) (i/o-invalid-position-error? . bf4fd9) (i/o-filename-error? . bf4fd8) (i/o-file-protection-error? . bf4fd7) (i/o-file-is-read-only-error? . bf4fd6) (i/o-file-does-not-exist-error? . bf4fd5) (i/o-file-already-exists-error? . bf4fd4) (i/o-error? . bf4fd3) (i/o-error-position . bf4fd2) (i/o-error-port . bf4fd1) (i/o-error-filename . bf4fd0) (&i/o-port . bf4e13) (&i/o-file-does-not-exist . bf4e12) (&i/o-file-already-exists . bf4e11) (&i/o-file-is-read-only . bf4e10) (&i/o-file-protection . bf4e0f) (&i/o-filename . bf4e0e) (&i/o-invalid-position . bf4e0d) (&i/o-write . bf4e0c) (&i/o-read . bf4e0b) (&i/o . bf4e0a)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf5174 '(rnrs bytevectors) '(6) '() '() '() '((make-bytevector . bf4fdf) (utf32->string . bf4f65) (utf16->string . bf4f64) (utf8->string . bf4f63) (uint-list->bytevector . bf4f62) (u8-list->bytevector . bf4f61) (string->utf8 . bf4f60) (string->utf32 . bf4f5f) (string->utf16 . bf4f5e) (sint-list->bytevector . bf4f5d) (native-endianness . bf4f5c) (bytevector? . bf4f5b) (bytevector=? . bf4f5a) (bytevector-uint-set! . bf4f59) (bytevector-uint-ref . bf4f58) (bytevector-u8-set! . bf4f57) (bytevector-u8-ref . bf4f56) (bytevector-u64-set! . bf4f55) (bytevector-u64-ref . bf4f54) (bytevector-u64-native-set! . bf4f53) (bytevector-u64-native-ref . bf4f52) (bytevector-u32-set! . bf4f51) (bytevector-u32-ref . bf4f50) (bytevector-u32-native-set! . bf4f4f) (bytevector-u32-native-ref . bf4f4e) (bytevector-u16-set! . bf4f4d) (bytevector-u16-ref . bf4f4c) (bytevector-u16-native-set! . bf4f4b) (bytevector-u16-native-ref . bf4f4a) (bytevector-sint-set! . bf4f49) (bytevector-sint-ref . bf4f48) (bytevector-s8-set! . bf4f47) (bytevector-s8-ref . bf4f46) (bytevector-s64-set! . bf4f45) (bytevector-s64-ref . bf4f44) (bytevector-s64-native-set! . bf4f43) (bytevector-s64-native-ref . bf4f42) (bytevector-s32-set! . bf4f41) (bytevector-s32-ref . bf4f40) (bytevector-s32-native-set! . bf4f3f) (bytevector-s32-native-ref . bf4f3e) (bytevector-s16-set! . bf4f3d) (bytevector-s16-ref . bf4f3c) (bytevector-s16-native-set! . bf4f3b) (bytevector-s16-native-ref . bf4f3a) (bytevector-length . bf4f39) (bytevector-ieee-single-ref . bf4f38) (bytevector-ieee-single-set! . bf4f37) (bytevector-ieee-single-native-set! . bf4f36) (bytevector-ieee-single-native-ref . bf4f35) (bytevector-ieee-double-set! . bf4f34) (bytevector-ieee-double-ref . bf4f33) (bytevector-ieee-double-native-set! . bf4f32) (bytevector-ieee-double-native-ref . bf4f31) (bytevector-fill! . bf4f30) (bytevector-copy! . bf4f2f) (bytevector-copy . bf4f2e) (bytevector->uint-list . bf4f2d) (bytevector->u8-list . bf4f2c) (bytevector->sint-list . bf4f2b) (endianness . bf4ddf)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf5175 '(rnrs unicode) '(6) '() '() '() '((string-upcase . bf5072) (string-titlecase . bf5071) (string-normalize-nfkd . bf5070) (string-normalize-nfkc . bf506f) (string-normalize-nfd . bf506e) (string-normalize-nfc . bf506d) (string-foldcase . bf506c) (string-downcase . bf506b) (string-ci>? . bf506a) (string-ci>=? . bf5069) (string-ci=? . bf5068) (string-ci<? . bf5067) (string-ci<=? . bf5066) (char-whitespace? . bf5065) (char-upper-case? . bf5064) (char-title-case? . bf5063) (char-numeric? . bf5062) (char-lower-case? . bf5061) (char-general-category . bf5060) (char-upcase . bf505f) (char-titlecase . bf505e) (char-foldcase . bf505d) (char-downcase . bf505c) (char-ci>? . bf505b) (char-ci>=? . bf505a) (char-ci=? . bf5059) (char-ci<? . bf5058) (char-ci<=? . bf5057) (char-alphabetic? . bf5056)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf5176 '(rnrs exceptions) '(6) '() '() '() '((with-exception-handler . bf4f99) (raise-continuable . bf4f98) (raise . bf4f97) (guard . bf4deb) (else . bf4de3) (=> . bf4de2)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf5177 '(rnrs arithmetic bitwise) '(6) '() '() '() '((bitwise-rotate-bit-field . bf4ecb) (bitwise-reverse-bit-field . bf4eca) (bitwise-length . bf4ec9) (bitwise-if . bf4ec8) (bitwise-first-bit-set . bf4ec7) (bitwise-copy-bit-field . bf4ec6) (bitwise-copy-bit . bf4ec5) (bitwise-bit-set? . bf4ec4) (bitwise-bit-field . bf4ec3) (bitwise-bit-count . bf4ec2) (bitwise-xor . bf4ec1) (bitwise-ior . bf4ec0) (bitwise-and . bf4ebf) (bitwise-not . bf4ebe) (bitwise-arithmetic-shift-right . bf4ebd) (bitwise-arithmetic-shift-left . bf4ebc) (bitwise-arithmetic-shift . bf4ebb)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf5178 '(rnrs arithmetic fixnums) '(6) '() '() '() '((fxzero? . bf4ef8) (fxxor . bf4ef7) (fxrotate-bit-field . bf4ef6) (fxreverse-bit-field . bf4ef5) (fxpositive? . bf4ef4) (fxodd? . bf4ef3) (fxnot . bf4ef2) (fxnegative? . bf4ef1) (fxmod0 . bf4ef0) (fxmod . bf4eef) (fxmin . bf4eee) (fxmax . bf4eed) (fxlength . bf4eec) (fxior . bf4eeb) (fxif . bf4eea) (fxfirst-bit-set . bf4ee9) (fxeven? . bf4ee8) (fxdiv0-and-mod0 . bf4ee7) (fxdiv0 . bf4ee6) (fxdiv-and-mod . bf4ee5) (fxdiv . bf4ee4) (fxcopy-bit-field . bf4ee3) (fxcopy-bit . bf4ee2) (fxbit-set? . bf4ee1) (fxbit-field . bf4ee0) (fxbit-count . bf4edf) (fxarithmetic-shift-right . bf4ede) (fxarithmetic-shift-left . bf4edd) (fxarithmetic-shift . bf4edc) (fxand . bf4edb) (fx>? . bf4eda) (fx>=? . bf4ed9) (fx=? . bf4ed8) (fx<? . bf4ed7) (fx<=? . bf4ed6) (fx-/carry . bf4ed5) (fx- . bf4ed4) (fx+/carry . bf4ed3) (fx+ . bf4ed2) (fx*/carry . bf4ed1) (fx* . bf4ed0) (greatest-fixnum . bf4ecf) (least-fixnum . bf4ece) (fixnum-width . bf4ecd) (fixnum? . bf4ecc)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf5179 '(rnrs arithmetic flonums) '(6) '() '() '() '((no-nans-violation? . bf4f2a) (no-infinities-violation? . bf4f29) (make-no-nans-violation . bf4f28) (make-no-infinities-violation . bf4f27) (real->flonum . bf4f26) (flzero? . bf4f25) (fltruncate . bf4f24) (fltan . bf4f23) (flsqrt . bf4f22) (flsin . bf4f21) (flround . bf4f20) (flpositive? . bf4f1f) (flonum? . bf4f1e) (flodd? . bf4f1d) (flnumerator . bf4f1c) (flnegative? . bf4f1b) (flnan? . bf4f1a) (flmod0 . bf4f19) (flmod . bf4f18) (flmin . bf4f17) (flmax . bf4f16) (fllog . bf4f15) (flinteger? . bf4f14) (flinfinite? . bf4f13) (flfloor . bf4f12) (flfinite? . bf4f11) (flexpt . bf4f10) (flexp . bf4f0f) (fleven? . bf4f0e) (fldiv0-and-mod0 . bf4f0d) (fldiv0 . bf4f0c) (fldiv-and-mod . bf4f0b) (fldiv . bf4f0a) (fldenominator . bf4f09) (flcos . bf4f08) (flceiling . bf4f07) (flatan . bf4f06) (flasin . bf4f05) (flacos . bf4f04) (flabs . bf4f03) (fl>? . bf4f02) (fl>=? . bf4f01) (fl=? . bf4f00) (fl<? . bf4eff) (fl<=? . bf4efe) (fl/ . bf4efd) (fl- . bf4efc) (fl+ . bf4efb) (fl* . bf4efa) (fixnum->flonum . bf4ef9) (&no-nans . bf4e17) (&no-infinities . bf4e16)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf517a '(rnrs hashtables) '(6) '() '() '() '((symbol-hash . bf503f) (string-ci-hash . bf503e) (string-hash . bf503d) (equal-hash . bf503c) (hashtable-equivalence-function . bf503b) (make-hashtable . bf503a) (hashtable-hash-function . bf5039) (make-eqv-hashtable . bf5038) (make-eq-hashtable . bf5037) (hashtable? . bf5036) (hashtable-update! . bf5035) (hashtable-size . bf5034) (hashtable-set! . bf5033) (hashtable-ref . bf5032) (hashtable-mutable? . bf5031) (hashtable-keys . bf5030) (hashtable-entries . bf502f) (hashtable-delete! . bf502e) (hashtable-copy . bf502d) (hashtable-contains? . bf502c) (hashtable-clear! . bf502b)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf517b '(rnrs io ports) '(6) '() '() '() '((eof-object? . bf501b) (eof-object . bf501a) (current-error-port . bf5019) (current-output-port . bf5018) (current-input-port . bf5017) (output-port? . bf5016) (input-port? . bf5015) (utf-8-codec . bf5014) (utf-16-codec . bf5013) (transcoder-error-handling-mode . bf5012) (transcoder-eol-style . bf5011) (transcoder-codec . bf5010) (transcoded-port . bf500f) (textual-port? . bf500e) (string->bytevector . bf500d) (standard-output-port . bf500c) (standard-input-port . bf500b) (standard-error-port . bf500a) (set-port-position! . bf5009) (put-u8 . bf5008) (put-string . bf5007) (put-datum . bf5006) (put-char . bf5005) (put-bytevector . bf5004) (port? . bf5003) (port-transcoder . bf5002) (port-position . bf5001) (port-has-set-port-position!? . bf5000) (port-has-port-position? . bf4fff) (port-eof? . bf4ffe) (output-port-buffer-mode . bf4ffd) (open-string-output-port . bf4ffc) (open-string-input-port . bf4ffb) (open-file-output-port . bf4ffa) (open-file-input/output-port . bf4ff9) (open-file-input-port . bf4ff8) (open-bytevector-output-port . bf4ff7) (open-bytevector-input-port . bf4ff6) (native-transcoder . bf4ff5) (native-eol-style . bf4ff4) (make-transcoder . bf4ff3) (latin-1-codec . bf4ff2) (make-i/o-write-error . bf4ff1) (make-i/o-read-error . bf4ff0) (make-i/o-port-error . bf4fef) (make-i/o-invalid-position-error . bf4fee) (make-i/o-filename-error . bf4fed) (make-i/o-file-protection-error . bf4fec) (make-i/o-file-is-read-only-error . bf4feb) (make-i/o-file-does-not-exist-error . bf4fea) (make-i/o-file-already-exists-error . bf4fe9) (make-i/o-error . bf4fe8) (make-i/o-encoding-error . bf4fe7) (make-i/o-decoding-error . bf4fe6) (make-custom-textual-output-port . bf4fe5) (make-custom-textual-input/output-port . bf4fe4) (make-custom-textual-input-port . bf4fe3) (make-custom-binary-output-port . bf4fe2) (make-custom-binary-input/output-port . bf4fe1) (make-custom-binary-input-port . bf4fe0) (lookahead-u8 . bf4fde) (lookahead-char . bf4fdd) (i/o-write-error? . bf4fdc) (i/o-read-error? . bf4fdb) (i/o-port-error? . bf4fda) (i/o-invalid-position-error? . bf4fd9) (i/o-filename-error? . bf4fd8) (i/o-file-protection-error? . bf4fd7) (i/o-file-is-read-only-error? . bf4fd6) (i/o-file-does-not-exist-error? . bf4fd5) (i/o-file-already-exists-error? . bf4fd4) (i/o-error? . bf4fd3) (i/o-error-position . bf4fd2) (i/o-error-port . bf4fd1) (i/o-error-filename . bf4fd0) (i/o-encoding-error? . bf4fcf) (i/o-encoding-error-char . bf4fce) (i/o-decoding-error? . bf4fcd) (get-u8 . bf4fcc) (get-string-n! . bf4fcb) (get-string-n . bf4fca) (get-string-all . bf4fc9) (get-line . bf4fc8) (get-datum . bf4fc7) (get-char . bf4fc6) (get-bytevector-some . bf4fc5) (get-bytevector-n! . bf4fc4) (get-bytevector-n . bf4fc3) (get-bytevector-all . bf4fc2) (flush-output-port . bf4fc1) (close-port . bf4fc0) (call-with-string-output-port . bf4f9f) (call-with-port . bf4f9e) (call-with-bytevector-output-port . bf4f9d) (bytevector->string . bf4f9c) (buffer-mode? . bf4f9b) (binary-port? . bf4f9a) (&i/o-encoding . bf4e15) (&i/o-decoding . bf4e14) (&i/o-port . bf4e13) (&i/o-file-does-not-exist . bf4e12) (&i/o-file-already-exists . bf4e11) (&i/o-file-is-read-only . bf4e10) (&i/o-file-protection . bf4e0f) (&i/o-filename . bf4e0e) (&i/o-invalid-position . bf4e0d) (&i/o-write . bf4e0c) (&i/o-read . bf4e0b) (&i/o . bf4e0a) (error-handling-mode . bf4def) (file-options . bf4dee) (buffer-mode . bf4ded) (eol-style . bf4dec)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf517c '(rnrs enums) '(6) '() '() '() '((make-enumeration . bf4f96) (enum-set=? . bf4f95) (enum-set-universe . bf4f94) (enum-set-union . bf4f93) (enum-set-subset? . bf4f92) (enum-set-projection . bf4f91) (enum-set-member? . bf4f90) (enum-set-intersection . bf4f8f) (enum-set-indexer . bf4f8e) (enum-set-difference . bf4f8d) (enum-set-constructor . bf4f8c) (enum-set-complement . bf4f8b) (enum-set->list . bf4f8a) (define-enumeration . bf4dfa)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf517d '(rnrs conditions) '(6) '() '() '() '((who-condition? . bf4f89) (warning? . bf4f88) (violation? . bf4f87) (undefined-violation? . bf4f86) (syntax-violation? . bf4f85) (syntax-violation-subform . bf4f84) (syntax-violation-form . bf4f83) (syntax-violation . bf3191) (simple-conditions . bf4f82) (serious-condition? . bf4f81) (non-continuable-violation? . bf4f80) (message-condition? . bf4f7f) (make-who-condition . bf4f7e) (make-warning . bf4f7d) (make-violation . bf4f7c) (make-undefined-violation . bf4f7b) (make-syntax-violation . bf4f7a) (make-serious-condition . bf4f79) (make-non-continuable-violation . bf4f78) (make-message-condition . bf4f77) (make-lexical-violation . bf4f76) (make-irritants-condition . bf4f75) (make-implementation-restriction-violation . bf4f74) (make-error . bf4f73) (make-assertion-violation . bf4f72) (lexical-violation? . bf4f71) (irritants-condition? . bf4f70) (implementation-restriction-violation? . bf4f6f) (error? . bf4f6e) (condition-who . bf4f6d) (condition-predicate . bf4f6c) (condition-message . bf4f6b) (condition-irritants . bf4f6a) (condition-accessor . bf4f69) (condition . bf4f68) (assertion-violation? . bf4f67) (condition? . bf4f66) (&undefined . bf4e09) (&syntax . bf4e08) (&lexical . bf4e07) (&implementation-restriction . bf4e06) (&non-continuable . bf4e05) (&who . bf4e04) (&irritants . bf4e03) (&assertion . bf4e02) (&violation . bf4e01) (&error . bf4e00) (&serious . bf4dff) (&warning . bf4dfe) (&message . bf4dfd) (&condition . bf4dfc) (define-condition-type . bf4dfb)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf517e '(rnrs records inspection) '(6) '() '() '() '((record? . bf504e) (record-type-uid . bf504d) (record-type-sealed? . bf504c) (record-type-parent . bf504b) (record-type-opaque? . bf504a) (record-type-name . bf5049) (record-type-generative? . bf5048) (record-type-field-names . bf5047) (record-rtd . bf5046) (record-field-mutable? . bf5045)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf517f '(rnrs records procedural) '(6) '() '() '() '((record-type-descriptor? . bf5055) (record-predicate . bf5054) (record-mutator . bf5053) (record-constructor . bf5052) (record-accessor . bf5051) (make-record-type-descriptor . bf5050) (make-record-constructor-descriptor . bf504f)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf5180 '(rnrs records syntactic) '(6) '() '() '() '((define-record-type . bf4df9) (parent-rtd . bf4df8) (nongenerative . bf4df7) (opaque . bf4df6) (sealed . bf4df5) (protocol . bf4df4) (parent . bf4df3) (immutable . bf4df2) (mutable . bf4df1) (fields . bf4df0) (record-constructor-descriptor . bf4dd0) (record-type-descriptor . bf4dcf)) '() values values '#f '#f '#t '#f) (bf2cc5@bf2b11@install-library 'bf5181 '(psyntax system $all) '() '() '() '() '((&no-nans-rcd . bf5161) (&no-nans-rtd . bf5160) (&no-infinities-rcd . bf515f) (&no-infinities-rtd . bf515e) (&i/o-encoding-rcd . bf515d) (&i/o-encoding-rtd . bf515c) (&i/o-decoding-rcd . bf515b) (&i/o-decoding-rtd . bf515a) (&i/o-port-rcd . bf5159) (&i/o-port-rtd . bf5158) (&i/o-file-does-not-exist-rcd . bf5157) (&i/o-file-does-not-exist-rtd . bf5156) (&i/o-file-already-exists-rcd . bf5155) (&i/o-file-already-exists-rtd . bf5154) (&i/o-file-is-read-only-rcd . bf5153) (&i/o-file-is-read-only-rtd . bf5152) (&i/o-file-protection-rcd . bf5151) (&i/o-file-protection-rtd . bf5150) (&i/o-filename-rcd . bf514f) (&i/o-filename-rtd . bf514e) (&i/o-invalid-position-rcd . bf514d) (&i/o-invalid-position-rtd . bf514c) (&i/o-write-rcd . bf514b) (&i/o-write-rtd . bf514a) (&i/o-read-rcd . bf5149) (&i/o-read-rtd . bf5148) (&i/o-rcd . bf5147) (&i/o-rtd . bf5146) (&undefined-rcd . bf5145) (&undefined-rtd . bf5144) (&syntax-rcd . bf5143) (&syntax-rtd . bf5142) (&lexical-rcd . bf5141) (&lexical-rtd . bf5140) (&implementation-restriction-rcd . bf513f) (&implementation-restriction-rtd . bf513e) (&non-continuable-rcd . bf513d) (&non-continuable-rtd . bf513c) (&who-rcd . bf513b) (&who-rtd . bf513a) (&irritants-rcd . bf5139) (&irritants-rtd . bf5138) (&assertion-rcd . bf5137) (&assertion-rtd . bf5136) (&violation-rcd . bf5135) (&violation-rtd . bf5134) (&error-rcd . bf5133) (&error-rtd . bf5132) (&serious-rcd . bf5131) (&serious-rtd . bf5130) (&warning-rcd . bf512f) (&warning-rtd . bf512e) (&message-rcd . bf512d) (&message-rtd . bf512c) (&condition-rcd . bf512b) (&condition-rtd . bf512a) (syntax-error . bf318d) (syntax-dispatch . bf30b1) (pretty-print . bf5129) (eval-core . bf5128) (set-symbol-value! . bf5127) (symbol-value . bf5126) (gensym . bf5125) (void . bf5124) (load . bf4c50) (interaction-environment . bf319f) (char-ready? . bf5123) (regexp? . bf5122) (read-line . bf5121) (gensym-prefix-set! . bf5120) (ungensym . bf511f) (alist->eq-hash-table . bf511e) (assoc-ref . bf511d) (print . bf511c) (format . bf511b) (host-os . bf511a) (library-path . bf2af0) (standard-library-path . bf5119) (ssl-supported? . bf5118) (ssl-socket? . bf5117) (socket-sslize! . bf5116) (%monapi-name-whereis . bf5115) (%monapi-message-send . bf5114) (file-newer? . bf5113) (stat-mtime . bf5112) (write-to-file . bf5111) (file->list . bf5110) (file->string . bf510f) (digit->integer . bf510e) (call-with-string-input-port . bf510d) (call-with-string-io . bf510c) (string-split . bf510b) (bytevector-for-each . bf510a) (string->regexp . bf5109) (rxmatch . bf5108) (regexp-replace-all . bf5107) (hashtable-fold-left . bf5106) (hashtable-for-each . bf5105) (mosh-cache-dir . bf28da) (call-process . bf5104) (local-tz-offset . bf5103) (microseconds . bf5102) (directory-list . bf5101) (set-current-directory! . bf5100) (expand-path . bf50ff) (current-directory . bf50fe) (%getpid . bf50fd) (%spawn . bf50fc) (%waitpid . bf50fb) (simple-struct-name . bf50fa) (simple-struct-set! . bf50f9) (simple-struct-ref . bf50f8) (make-simple-struct . bf50f7) (simple-struct? . bf50f6) (pointer-ref-c-int64 . bf50f5) (pointer-ref-c-int32 . bf50f4) (pointer-ref-c-int16 . bf50f3) (pointer-ref-c-int8 . bf50f2) (pointer-ref-c-uint64 . bf50f1) (pointer-ref-c-uint32 . bf50f0) (pointer-ref-c-uint16 . bf50ef) (pointer-ref-c-uint8 . bf50ee) (pointer-set-c-uint64! . bf50ed) (pointer-set-c-uint32! . bf50ec) (pointer-set-c-uint16! . bf50eb) (pointer-set-c-uint8! . bf50ea) (pointer-set-c-int64! . bf50e9) (pointer-set-c-int32! . bf50e8) (pointer-set-c-int16! . bf50e7) (pointer-set-c-int8! . bf50e6) (pointer-set-c-pointer! . bf50e5) (pointer-set-c-double! . bf50e4) (pointer-set-c-float! . bf50e3) (pointer-set-c-long-long! . bf50e2) (pointer-set-c-long! . bf50e1) (pointer-set-c-int! . bf50e0) (pointer-set-c-short! . bf50df) (pointer-set-c-char! . bf50de) (pointer-ref-c-pointer . bf50dd) (pointer-ref-c-double . bf50dc) (pointer-ref-c-float . bf50db) (pointer-ref-c-unsigned-long-long . bf50da) (pointer-ref-c-signed-long-long . bf50d9) (pointer-ref-c-unsigned-long . bf50d8) (pointer-ref-c-signed-long . bf50d7) (pointer-ref-c-unsigned-int . bf50d6) (pointer-ref-c-signed-int . bf50d5) (pointer-ref-c-unsigned-short . bf50d4) (pointer-ref-c-signed-short . bf50d3) (pointer-ref-c-unsigned-char . bf50d2) (pointer-ref-c-signed-char . bf50d1) (pointer->integer . bf50d0) (integer->pointer . bf50cf) (pointer? . bf50ce) (shared-errno . bf50cd) (%ffi-free-c-callback-trampoline . bf50cc) (%ffi-make-c-callback-trampoline . bf50cb) (%ffi-free . bf50ca) (%ffi-malloc . bf50c9) (%ffi-supported? . bf50c8) (%ffi-pointer->string . bf50c7) (%ffi-call . bf50c6) (%ffi-lookup . bf50c5) (%ffi-open . bf50c4) (null-terminated-utf8->string . bf50c3) (null-terminated-bytevector->string . bf50c2) (%exec . bf50c1) (%fork . bf50c0) (%pipe . bf50bf) (p . bf50be) (open-output-string . bf50bd) (get-output-string . bf50bc) (file-stat-ctime . bf50bb) (file-stat-atime . bf50ba) (file-stat-mtime . bf50b9) (file-size-in-bytes . bf50b8) (file-writable? . bf50b7) (file-executable? . bf50b6) (file-readable? . bf50b5) (file-regular? . bf50b4) (file-symbolic-link? . bf50b3) (file-directory? . bf50b2) (create-symbolic-link . bf50b1) (rename-file . bf50b0) (delete-directory . bf50af) (create-directory . bf50ae) (create-mosh-cache-dir . bf50ad) (get-environment-variables . bf50ac) (current-exception-handler . bf50ab) (get-environment-variable . bf50aa) (join-wraps . bf50a9) (id->real-label . bf50a8) (same-marks? . bf50a7) (same-marks*? . bf50a6) (get-timeofday . bf50a5) (get-command-line . bf50a4) (sys-display . bf50a3) (whereis . bf50a2) (register . bf50a1) (vm-join! . bf50a0) (vm-set-value! . bf509f) (vm? . bf509e) (main-vm? . bf509d) (vm-eval . bf509c) (vm-self . bf509b) (vm-start! . bf509a) (make-vm . bf5099) (mutex-try-lock! . bf5098) (mutex-unlock! . bf5097) (mutex-lock! . bf5096) (mutex? . bf5095) (make-mutex . bf5094) (condition-variable-notify-all! . bf5093) (condition-variable-notify! . bf5092) (condition-variable-wait! . bf5091) (make-condition-variable . bf5090) (write/ss . bf508f) (mosh-executable-path . bf508e) (make-file-options . bf508d) (source-info . bf508c) (make-compiler-instruction . bf508b) (make-instruction . bf508a) (set-annotation! . bf5089) (get-annotation . bf5088) (annotated-pair? . bf5087) (annotated-cons . bf5086) (set-source-info! . bf5085) (bignum? . bf5084) (fast-equal? . bf5083) (fasl-read . bf5082) (fasl-write . bf5081) (time-usage . bf5080) (os-constant . bf507f) (condition-printer . bf507e) (disasm . bf507d) (make-parameter . bf28d8) (socket-port . bf507c) (socket-shutdown . bf507b) (socket-close . bf507a) (socket-send . bf5079) (socket-recv! . bf5078) (socket-recv . bf5077) (make-server-socket . bf5076) (make-client-socket . bf5075) (socket-accept . bf5074) (socket? . bf5073) (string-upcase . bf5072) (string-titlecase . bf5071) (string-normalize-nfkd . bf5070) (string-normalize-nfkc . bf506f) (string-normalize-nfd . bf506e) (string-normalize-nfc . bf506d) (string-foldcase . bf506c) (string-downcase . bf506b) (string-ci>? . bf506a) (string-ci>=? . bf5069) (string-ci=? . bf5068) (string-ci<? . bf5067) (string-ci<=? . bf5066) (char-whitespace? . bf5065) (char-upper-case? . bf5064) (char-title-case? . bf5063) (char-numeric? . bf5062) (char-lower-case? . bf5061) (char-general-category . bf5060) (char-upcase . bf505f) (char-titlecase . bf505e) (char-foldcase . bf505d) (char-downcase . bf505c) (char-ci>? . bf505b) (char-ci>=? . bf505a) (char-ci=? . bf5059) (char-ci<? . bf5058) (char-ci<=? . bf5057) (char-alphabetic? . bf5056) (make-variable-transformer . bf2edc) (identifier? . bf3193) (generate-temporaries . bf317f) (free-identifier=? . bf3181) (syntax->datum . bf3197) (datum->syntax . bf3195) (bound-identifier=? . bf3183) (record-type-descriptor? . bf5055) (record-predicate . bf5054) (record-mutator . bf5053) (record-constructor . bf5052) (record-accessor . bf5051) (make-record-type-descriptor . bf5050) (make-record-constructor-descriptor . bf504f) (record? . bf504e) (record-type-uid . bf504d) (record-type-sealed? . bf504c) (record-type-parent . bf504b) (record-type-opaque? . bf504a) (record-type-name . bf5049) (record-type-generative? . bf5048) (record-type-field-names . bf5047) (record-rtd . bf5046) (record-field-mutable? . bf5045) (delete-file . bf5044) (file-exists? . bf5043) (vector-sort! . bf5042) (vector-sort . bf5041) (list-sort . bf5040) (symbol-hash . bf503f) (string-ci-hash . bf503e) (string-hash . bf503d) (equal-hash . bf503c) (hashtable-equivalence-function . bf503b) (make-hashtable . bf503a) (hashtable-hash-function . bf5039) (make-eqv-hashtable . bf5038) (make-eq-hashtable . bf5037) (hashtable? . bf5036) (hashtable-update! . bf5035) (hashtable-size . bf5034) (hashtable-set! . bf5033) (hashtable-ref . bf5032) (hashtable-mutable? . bf5031) (hashtable-keys . bf5030) (hashtable-entries . bf502f) (hashtable-delete! . bf502e) (hashtable-copy . bf502d) (hashtable-contains? . bf502c) (hashtable-clear! . bf502b) (call-with-output-file . bf502a) (call-with-input-file . bf5029) (write-char . bf5028) (write . bf5027) (with-output-to-file . bf5026) (with-input-from-file . bf5025) (read-char . bf5024) (read . bf5023) (peek-char . bf5022) (open-output-file . bf5021) (open-input-file . bf5020) (newline . bf501f) (display . bf501e) (close-output-port . bf501d) (close-input-port . bf501c) (eof-object? . bf501b) (eof-object . bf501a) (current-error-port . bf5019) (current-output-port . bf5018) (current-input-port . bf5017) (output-port? . bf5016) (input-port? . bf5015) (utf-8-codec . bf5014) (utf-16-codec . bf5013) (transcoder-error-handling-mode . bf5012) (transcoder-eol-style . bf5011) (transcoder-codec . bf5010) (transcoded-port . bf500f) (textual-port? . bf500e) (string->bytevector . bf500d) (standard-output-port . bf500c) (standard-input-port . bf500b) (standard-error-port . bf500a) (set-port-position! . bf5009) (put-u8 . bf5008) (put-string . bf5007) (put-datum . bf5006) (put-char . bf5005) (put-bytevector . bf5004) (port? . bf5003) (port-transcoder . bf5002) (port-position . bf5001) (port-has-set-port-position!? . bf5000) (port-has-port-position? . bf4fff) (port-eof? . bf4ffe) (output-port-buffer-mode . bf4ffd) (open-string-output-port . bf4ffc) (open-string-input-port . bf4ffb) (open-file-output-port . bf4ffa) (open-file-input/output-port . bf4ff9) (open-file-input-port . bf4ff8) (open-bytevector-output-port . bf4ff7) (open-bytevector-input-port . bf4ff6) (native-transcoder . bf4ff5) (native-eol-style . bf4ff4) (make-transcoder . bf4ff3) (latin-1-codec . bf4ff2) (make-i/o-write-error . bf4ff1) (make-i/o-read-error . bf4ff0) (make-i/o-port-error . bf4fef) (make-i/o-invalid-position-error . bf4fee) (make-i/o-filename-error . bf4fed) (make-i/o-file-protection-error . bf4fec) (make-i/o-file-is-read-only-error . bf4feb) (make-i/o-file-does-not-exist-error . bf4fea) (make-i/o-file-already-exists-error . bf4fe9) (make-i/o-error . bf4fe8) (make-i/o-encoding-error . bf4fe7) (make-i/o-decoding-error . bf4fe6) (make-custom-textual-output-port . bf4fe5) (make-custom-textual-input/output-port . bf4fe4) (make-custom-textual-input-port . bf4fe3) (make-custom-binary-output-port . bf4fe2) (make-custom-binary-input/output-port . bf4fe1) (make-custom-binary-input-port . bf4fe0) (make-bytevector . bf4fdf) (lookahead-u8 . bf4fde) (lookahead-char . bf4fdd) (i/o-write-error? . bf4fdc) (i/o-read-error? . bf4fdb) (i/o-port-error? . bf4fda) (i/o-invalid-position-error? . bf4fd9) (i/o-filename-error? . bf4fd8) (i/o-file-protection-error? . bf4fd7) (i/o-file-is-read-only-error? . bf4fd6) (i/o-file-does-not-exist-error? . bf4fd5) (i/o-file-already-exists-error? . bf4fd4) (i/o-error? . bf4fd3) (i/o-error-position . bf4fd2) (i/o-error-port . bf4fd1) (i/o-error-filename . bf4fd0) (i/o-encoding-error? . bf4fcf) (i/o-encoding-error-char . bf4fce) (i/o-decoding-error? . bf4fcd) (get-u8 . bf4fcc) (get-string-n! . bf4fcb) (get-string-n . bf4fca) (get-string-all . bf4fc9) (get-line . bf4fc8) (get-datum . bf4fc7) (get-char . bf4fc6) (get-bytevector-some . bf4fc5) (get-bytevector-n! . bf4fc4) (get-bytevector-n . bf4fc3) (get-bytevector-all . bf4fc2) (flush-output-port . bf4fc1) (close-port . bf4fc0) (scheme-report-environment . bf316d) (quotient . bf4fbf) (null-environment . bf316b) (remainder . bf4fbe) (modulo . bf4fbd) (inexact->exact . bf4fbc) (force . bf4fbb) (exact->inexact . bf4fba) (make-promise . bf4fb9) (exit . bf4fb8) (command-line . bf4c4a) (string-fill! . bf4fb7) (string-set! . bf4fb6) (set-cdr! . bf4fb5) (set-car! . bf4fb4) (remove . bf4fb3) (remv . bf4fb2) (remp . bf4fb1) (remq . bf4fb0) (partition . bf4faf) (memv . bf4fae) (memq . bf4fad) (memp . bf4fac) (member . bf4fab) (exists . bf4faa) (for-all . bf4fa9) (fold-right . bf4fa8) (fold-left . bf4fa7) (find . bf4fa6) (filter . bf4fa5) (cons* . bf4fa4) (assv . bf4fa3) (assq . bf4fa2) (assp . bf4fa1) (assoc . bf4fa0) (call-with-string-output-port . bf4f9f) (call-with-port . bf4f9e) (call-with-bytevector-output-port . bf4f9d) (bytevector->string . bf4f9c) (buffer-mode? . bf4f9b) (binary-port? . bf4f9a) (with-exception-handler . bf4f99) (raise-continuable . bf4f98) (raise . bf4f97) (eval . bf3171) (environment . bf3169) (make-enumeration . bf4f96) (enum-set=? . bf4f95) (enum-set-universe . bf4f94) (enum-set-union . bf4f93) (enum-set-subset? . bf4f92) (enum-set-projection . bf4f91) (enum-set-member? . bf4f90) (enum-set-intersection . bf4f8f) (enum-set-indexer . bf4f8e) (enum-set-difference . bf4f8d) (enum-set-constructor . bf4f8c) (enum-set-complement . bf4f8b) (enum-set->list . bf4f8a) (who-condition? . bf4f89) (warning? . bf4f88) (violation? . bf4f87) (undefined-violation? . bf4f86) (syntax-violation? . bf4f85) (syntax-violation-subform . bf4f84) (syntax-violation-form . bf4f83) (syntax-violation . bf3191) (simple-conditions . bf4f82) (serious-condition? . bf4f81) (non-continuable-violation? . bf4f80) (message-condition? . bf4f7f) (make-who-condition . bf4f7e) (make-warning . bf4f7d) (make-violation . bf4f7c) (make-undefined-violation . bf4f7b) (make-syntax-violation . bf4f7a) (make-serious-condition . bf4f79) (make-non-continuable-violation . bf4f78) (make-message-condition . bf4f77) (make-lexical-violation . bf4f76) (make-irritants-condition . bf4f75) (make-implementation-restriction-violation . bf4f74) (make-error . bf4f73) (make-assertion-violation . bf4f72) (lexical-violation? . bf4f71) (irritants-condition? . bf4f70) (implementation-restriction-violation? . bf4f6f) (error? . bf4f6e) (condition-who . bf4f6d) (condition-predicate . bf4f6c) (condition-message . bf4f6b) (condition-irritants . bf4f6a) (condition-accessor . bf4f69) (condition . bf4f68) (assertion-violation? . bf4f67) (condition? . bf4f66) (utf32->string . bf4f65) (utf16->string . bf4f64) (utf8->string . bf4f63) (uint-list->bytevector . bf4f62) (u8-list->bytevector . bf4f61) (string->utf8 . bf4f60) (string->utf32 . bf4f5f) (string->utf16 . bf4f5e) (sint-list->bytevector . bf4f5d) (native-endianness . bf4f5c) (bytevector? . bf4f5b) (bytevector=? . bf4f5a) (bytevector-uint-set! . bf4f59) (bytevector-uint-ref . bf4f58) (bytevector-u8-set! . bf4f57) (bytevector-u8-ref . bf4f56) (bytevector-u64-set! . bf4f55) (bytevector-u64-ref . bf4f54) (bytevector-u64-native-set! . bf4f53) (bytevector-u64-native-ref . bf4f52) (bytevector-u32-set! . bf4f51) (bytevector-u32-ref . bf4f50) (bytevector-u32-native-set! . bf4f4f) (bytevector-u32-native-ref . bf4f4e) (bytevector-u16-set! . bf4f4d) (bytevector-u16-ref . bf4f4c) (bytevector-u16-native-set! . bf4f4b) (bytevector-u16-native-ref . bf4f4a) (bytevector-sint-set! . bf4f49) (bytevector-sint-ref . bf4f48) (bytevector-s8-set! . bf4f47) (bytevector-s8-ref . bf4f46) (bytevector-s64-set! . bf4f45) (bytevector-s64-ref . bf4f44) (bytevector-s64-native-set! . bf4f43) (bytevector-s64-native-ref . bf4f42) (bytevector-s32-set! . bf4f41) (bytevector-s32-ref . bf4f40) (bytevector-s32-native-set! . bf4f3f) (bytevector-s32-native-ref . bf4f3e) (bytevector-s16-set! . bf4f3d) (bytevector-s16-ref . bf4f3c) (bytevector-s16-native-set! . bf4f3b) (bytevector-s16-native-ref . bf4f3a) (bytevector-length . bf4f39) (bytevector-ieee-single-ref . bf4f38) (bytevector-ieee-single-set! . bf4f37) (bytevector-ieee-single-native-set! . bf4f36) (bytevector-ieee-single-native-ref . bf4f35) (bytevector-ieee-double-set! . bf4f34) (bytevector-ieee-double-ref . bf4f33) (bytevector-ieee-double-native-set! . bf4f32) (bytevector-ieee-double-native-ref . bf4f31) (bytevector-fill! . bf4f30) (bytevector-copy! . bf4f2f) (bytevector-copy . bf4f2e) (bytevector->uint-list . bf4f2d) (bytevector->u8-list . bf4f2c) (bytevector->sint-list . bf4f2b) (no-nans-violation? . bf4f2a) (no-infinities-violation? . bf4f29) (make-no-nans-violation . bf4f28) (make-no-infinities-violation . bf4f27) (real->flonum . bf4f26) (flzero? . bf4f25) (fltruncate . bf4f24) (fltan . bf4f23) (flsqrt . bf4f22) (flsin . bf4f21) (flround . bf4f20) (flpositive? . bf4f1f) (flonum? . bf4f1e) (flodd? . bf4f1d) (flnumerator . bf4f1c) (flnegative? . bf4f1b) (flnan? . bf4f1a) (flmod0 . bf4f19) (flmod . bf4f18) (flmin . bf4f17) (flmax . bf4f16) (fllog . bf4f15) (flinteger? . bf4f14) (flinfinite? . bf4f13) (flfloor . bf4f12) (flfinite? . bf4f11) (flexpt . bf4f10) (flexp . bf4f0f) (fleven? . bf4f0e) (fldiv0-and-mod0 . bf4f0d) (fldiv0 . bf4f0c) (fldiv-and-mod . bf4f0b) (fldiv . bf4f0a) (fldenominator . bf4f09) (flcos . bf4f08) (flceiling . bf4f07) (flatan . bf4f06) (flasin . bf4f05) (flacos . bf4f04) (flabs . bf4f03) (fl>? . bf4f02) (fl>=? . bf4f01) (fl=? . bf4f00) (fl<? . bf4eff) (fl<=? . bf4efe) (fl/ . bf4efd) (fl- . bf4efc) (fl+ . bf4efb) (fl* . bf4efa) (fixnum->flonum . bf4ef9) (fxzero? . bf4ef8) (fxxor . bf4ef7) (fxrotate-bit-field . bf4ef6) (fxreverse-bit-field . bf4ef5) (fxpositive? . bf4ef4) (fxodd? . bf4ef3) (fxnot . bf4ef2) (fxnegative? . bf4ef1) (fxmod0 . bf4ef0) (fxmod . bf4eef) (fxmin . bf4eee) (fxmax . bf4eed) (fxlength . bf4eec) (fxior . bf4eeb) (fxif . bf4eea) (fxfirst-bit-set . bf4ee9) (fxeven? . bf4ee8) (fxdiv0-and-mod0 . bf4ee7) (fxdiv0 . bf4ee6) (fxdiv-and-mod . bf4ee5) (fxdiv . bf4ee4) (fxcopy-bit-field . bf4ee3) (fxcopy-bit . bf4ee2) (fxbit-set? . bf4ee1) (fxbit-field . bf4ee0) (fxbit-count . bf4edf) (fxarithmetic-shift-right . bf4ede) (fxarithmetic-shift-left . bf4edd) (fxarithmetic-shift . bf4edc) (fxand . bf4edb) (fx>? . bf4eda) (fx>=? . bf4ed9) (fx=? . bf4ed8) (fx<? . bf4ed7) (fx<=? . bf4ed6) (fx-/carry . bf4ed5) (fx- . bf4ed4) (fx+/carry . bf4ed3) (fx+ . bf4ed2) (fx*/carry . bf4ed1) (fx* . bf4ed0) (greatest-fixnum . bf4ecf) (least-fixnum . bf4ece) (fixnum-width . bf4ecd) (fixnum? . bf4ecc) (bitwise-rotate-bit-field . bf4ecb) (bitwise-reverse-bit-field . bf4eca) (bitwise-length . bf4ec9) (bitwise-if . bf4ec8) (bitwise-first-bit-set . bf4ec7) (bitwise-copy-bit-field . bf4ec6) (bitwise-copy-bit . bf4ec5) (bitwise-bit-set? . bf4ec4) (bitwise-bit-field . bf4ec3) (bitwise-bit-count . bf4ec2) (bitwise-xor . bf4ec1) (bitwise-ior . bf4ec0) (bitwise-and . bf4ebf) (bitwise-not . bf4ebe) (bitwise-arithmetic-shift-right . bf4ebd) (bitwise-arithmetic-shift-left . bf4ebc) (bitwise-arithmetic-shift . bf4ebb) (zero? . bf4eba) (vector? . bf4eb9) (vector-set! . bf4eb8) (vector-ref . bf4eb7) (vector-map . bf4eb6) (vector-length . bf4eb5) (vector-for-each . bf4eb4) (vector-fill! . bf4eb3) (vector->list . bf4eb2) (vector . bf4eb1) (values . bf4eb0) (truncate . bf4eaf) (tan . bf4eae) (symbol? . bf4ead) (symbol=? . bf4eac) (symbol->string . bf4eab) (substring . bf4eaa) (string? . bf4ea9) (string>? . bf4ea8) (string>=? . bf4ea7) (string=? . bf4ea6) (string<? . bf4ea5) (string<=? . bf4ea4) (string-ref . bf4ea3) (string-length . bf4ea2) (string-for-each . bf4ea1) (string-copy . bf4ea0) (string-append . bf4e9f) (string->symbol . bf4e9e) (string->number . bf4e9d) (string->list . bf4e9c) (string . bf4e9b) (sqrt . bf4e9a) (sin . bf4e99) (round . bf4e98) (reverse . bf4e97) (real? . bf4e96) (real-valued? . bf4e95) (real-part . bf4e94) (rationalize . bf4e93) (rational? . bf4e92) (rational-valued? . bf4e91) (procedure? . bf4e90) (positive? . bf4e8f) (pair? . bf4e8e) (odd? . bf4e8d) (numerator . bf4e8c) (number? . bf4e8b) (number->string . bf4e8a) (null? . bf4e89) (not . bf4e88) (negative? . bf4e87) (nan? . bf4e86) (min . bf4e85) (max . bf4e84) (map . bf4e83) (make-vector . bf4e82) (make-string . bf4e81) (make-rectangular . bf4e80) (make-polar . bf4e7f) (magnitude . bf4e7e) (log . bf4e7d) (list? . bf4e7c) (list-tail . bf4e7b) (list-ref . bf4e7a) (list->vector . bf4e79) (list->string . bf4e78) (list . bf4e77) (length . bf4e76) (lcm . bf4e75) (integer? . bf4e74) (integer-valued? . bf4e73) (integer->char . bf4e72) (infinite? . bf4e71) (inexact? . bf4e70) (inexact . bf4e6f) (imag-part . bf4e6e) (gcd . bf4e6d) (for-each . bf4e6c) (floor . bf4e6b) (finite? . bf4e6a) (expt . bf4e69) (exp . bf4e68) (exact? . bf4e67) (exact-integer-sqrt . bf4e66) (exact . bf4e65) (even? . bf4e64) (error . bf4e63) (eqv? . bf4e62) (equal? . bf4e61) (eq? . bf4e60) (dynamic-wind . bf4e5f) (div0-and-mod0 . bf4e5e) (mod0 . bf4e5d) (div0 . bf4e5c) (div-and-mod . bf4e5b) (mod . bf4e5a) (div . bf4e59) (denominator . bf4e58) (cos . bf4e57) (cons . bf4e56) (complex? . bf4e55) (char? . bf4e54) (char>? . bf4e53) (char>=? . bf4e52) (char=? . bf4e51) (char<? . bf4e50) (char<=? . bf4e4f) (char->integer . bf4e4e) (ceiling . bf4e4d) (call-with-values . bf4e4c) (call/cc . bf4e4b) (call-with-current-continuation . bf4e4a) (cddddr . bf4e49) (cdddar . bf4e48) (cddadr . bf4e47) (cddaar . bf4e46) (cdaddr . bf4e45) (cdadar . bf4e44) (cdaadr . bf4e43) (cdaaar . bf4e42) (cadddr . bf4e41) (caddar . bf4e40) (cadadr . bf4e3f) (cadaar . bf4e3e) (caaddr . bf4e3d) (caadar . bf4e3c) (caaadr . bf4e3b) (caaaar . bf4e3a) (cdddr . bf4e39) (cddar . bf4e38) (cdadr . bf4e37) (cdaar . bf4e36) (caddr . bf4e35) (cadar . bf4e34) (caadr . bf4e33) (caaar . bf4e32) (cddr . bf4e31) (cdar . bf4e30) (cadr . bf4e2f) (caar . bf4e2e) (cdr . bf4e2d) (car . bf4e2c) (boolean? . bf4e2b) (boolean=? . bf4e2a) (atan . bf4e29) (assertion-violation . bf4e28) (assertion-error . bf318b) (asin . bf4e27) (apply . bf4e26) (append . bf4e25) (angle . bf4e24) (acos . bf4e23) (abs . bf4e22) (/ . bf4e21) (* . bf4e20) (- . bf4e1f) (+ . bf4e1e) (>= . bf4e1d) (> . bf4e1c) (= . bf4e1b) (<= . bf4e1a) (< . bf4e19) (library . bf4e18) (&no-nans . bf4e17) (&no-infinities . bf4e16) (&i/o-encoding . bf4e15) (&i/o-decoding . bf4e14) (&i/o-port . bf4e13) (&i/o-file-does-not-exist . bf4e12) (&i/o-file-already-exists . bf4e11) (&i/o-file-is-read-only . bf4e10) (&i/o-file-protection . bf4e0f) (&i/o-filename . bf4e0e) (&i/o-invalid-position . bf4e0d) (&i/o-write . bf4e0c) (&i/o-read . bf4e0b) (&i/o . bf4e0a) (&undefined . bf4e09) (&syntax . bf4e08) (&lexical . bf4e07) (&implementation-restriction . bf4e06) (&non-continuable . bf4e05) (&who . bf4e04) (&irritants . bf4e03) (&assertion . bf4e02) (&violation . bf4e01) (&error . bf4e00) (&serious . bf4dff) (&warning . bf4dfe) (&message . bf4dfd) (&condition . bf4dfc) (define-condition-type . bf4dfb) (define-enumeration . bf4dfa) (define-record-type . bf4df9) (parent-rtd . bf4df8) (nongenerative . bf4df7) (opaque . bf4df6) (sealed . bf4df5) (protocol . bf4df4) (parent . bf4df3) (immutable . bf4df2) (mutable . bf4df1) (fields . bf4df0) (error-handling-mode . bf4def) (file-options . bf4dee) (buffer-mode . bf4ded) (eol-style . bf4dec) (guard . bf4deb) (trace-define . bf4dea) (trace-lambda . bf4de9) (unsyntax-splicing . bf4de8) (unsyntax . bf4de7) (unquote-splicing . bf4de6) (unquote . bf4de5) (_ . bf4de4) (else . bf4de3) (=> . bf4de2) (... . bf4de1) (assert . bf4de0) (endianness . bf4ddf) (delay . bf4dde) (time . bf4ddd) (do . bf4ddc) (cond . bf4ddb) (let* . bf4dda) (let*-values . bf4dd9) (let-values . bf4dd8) (identifier-syntax . bf4dd7) (with-syntax . bf4dd6) (quasisyntax . bf4dd5) (quasiquote . bf4dd4) (syntax-rules . bf4dd3) (include . bf4dd2) (define-struct . bf4dd1) (record-constructor-descriptor . bf4dd0) (record-type-descriptor . bf4dcf) (case . bf4dce) (parameterize . bf4dcd) (unless . bf4dcc) (when . bf4dcb) (or . bf4dca) (and . bf4dc9) (if . bf4dc8) (let . bf4dc7) (letrec* . bf4dc6) (letrec . bf4dc5) (type-descriptor . bf4dc4) (case-lambda . bf4dc3) (lambda . bf4dc2) (syntax . bf4dc1) (syntax-case . bf4dc0) (quote . bf4dbf) (foreign-call . bf4dbe) (letrec-syntax . bf4dbd) (let-syntax . bf4dbc) (set! . bf4dbb) (import . bf4dba) (begin . bf4db9) (module . bf4db8) (define-syntax . bf4db7) (define . bf4db6)) '((bf5161 core-prim . &no-nans-rcd) (bf5160 core-prim . &no-nans-rtd) (bf515f core-prim . &no-infinities-rcd) (bf515e core-prim . &no-infinities-rtd) (bf515d core-prim . &i/o-encoding-rcd) (bf515c core-prim . &i/o-encoding-rtd) (bf515b core-prim . &i/o-decoding-rcd) (bf515a core-prim . &i/o-decoding-rtd) (bf5159 core-prim . &i/o-port-rcd) (bf5158 core-prim . &i/o-port-rtd) (bf5157 core-prim . &i/o-file-does-not-exist-rcd) (bf5156 core-prim . &i/o-file-does-not-exist-rtd) (bf5155 core-prim . &i/o-file-already-exists-rcd) (bf5154 core-prim . &i/o-file-already-exists-rtd) (bf5153 core-prim . &i/o-file-is-read-only-rcd) (bf5152 core-prim . &i/o-file-is-read-only-rtd) (bf5151 core-prim . &i/o-file-protection-rcd) (bf5150 core-prim . &i/o-file-protection-rtd) (bf514f core-prim . &i/o-filename-rcd) (bf514e core-prim . &i/o-filename-rtd) (bf514d core-prim . &i/o-invalid-position-rcd) (bf514c core-prim . &i/o-invalid-position-rtd) (bf514b core-prim . &i/o-write-rcd) (bf514a core-prim . &i/o-write-rtd) (bf5149 core-prim . &i/o-read-rcd) (bf5148 core-prim . &i/o-read-rtd) (bf5147 core-prim . &i/o-rcd) (bf5146 core-prim . &i/o-rtd) (bf5145 core-prim . &undefined-rcd) (bf5144 core-prim . &undefined-rtd) (bf5143 core-prim . &syntax-rcd) (bf5142 core-prim . &syntax-rtd) (bf5141 core-prim . &lexical-rcd) (bf5140 core-prim . &lexical-rtd) (bf513f core-prim . &implementation-restriction-rcd) (bf513e core-prim . &implementation-restriction-rtd) (bf513d core-prim . &non-continuable-rcd) (bf513c core-prim . &non-continuable-rtd) (bf513b core-prim . &who-rcd) (bf513a core-prim . &who-rtd) (bf5139 core-prim . &irritants-rcd) (bf5138 core-prim . &irritants-rtd) (bf5137 core-prim . &assertion-rcd) (bf5136 core-prim . &assertion-rtd) (bf5135 core-prim . &violation-rcd) (bf5134 core-prim . &violation-rtd) (bf5133 core-prim . &error-rcd) (bf5132 core-prim . &error-rtd) (bf5131 core-prim . &serious-rcd) (bf5130 core-prim . &serious-rtd) (bf512f core-prim . &warning-rcd) (bf512e core-prim . &warning-rtd) (bf512d core-prim . &message-rcd) (bf512c core-prim . &message-rtd) (bf512b core-prim . &condition-rcd) (bf512a core-prim . &condition-rtd) (bf318d core-prim . syntax-error) (bf30b1 core-prim . syntax-dispatch) (bf5129 core-prim . pretty-print) (bf5128 core-prim . eval-core) (bf5127 core-prim . set-symbol-value!) (bf5126 core-prim . symbol-value) (bf5125 core-prim . gensym) (bf5124 core-prim . void) (bf4c50 core-prim . load) (bf319f core-prim . interaction-environment) (bf5123 core-prim . char-ready?) (bf5122 core-prim . regexp?) (bf5121 core-prim . read-line) (bf5120 core-prim . gensym-prefix-set!) (bf511f core-prim . ungensym) (bf511e core-prim . alist->eq-hash-table) (bf511d core-prim . assoc-ref) (bf511c core-prim . print) (bf511b core-prim . format) (bf511a core-prim . host-os) (bf2af0 core-prim . library-path) (bf5119 core-prim . standard-library-path) (bf5118 core-prim . ssl-supported?) (bf5117 core-prim . ssl-socket?) (bf5116 core-prim . socket-sslize!) (bf5115 core-prim . %monapi-name-whereis) (bf5114 core-prim . %monapi-message-send) (bf5113 core-prim . file-newer?) (bf5112 core-prim . stat-mtime) (bf5111 core-prim . write-to-file) (bf5110 core-prim . file->list) (bf510f core-prim . file->string) (bf510e core-prim . digit->integer) (bf510d core-prim . call-with-string-input-port) (bf510c core-prim . call-with-string-io) (bf510b core-prim . string-split) (bf510a core-prim . bytevector-for-each) (bf5109 core-prim . string->regexp) (bf5108 core-prim . rxmatch) (bf5107 core-prim . regexp-replace-all) (bf5106 core-prim . hashtable-fold-left) (bf5105 core-prim . hashtable-for-each) (bf28da core-prim . mosh-cache-dir) (bf5104 core-prim . call-process) (bf5103 core-prim . local-tz-offset) (bf5102 core-prim . microseconds) (bf5101 core-prim . directory-list) (bf5100 core-prim . set-current-directory!) (bf50ff core-prim . expand-path) (bf50fe core-prim . current-directory) (bf50fd core-prim . %getpid) (bf50fc core-prim . %spawn) (bf50fb core-prim . %waitpid) (bf50fa core-prim . simple-struct-name) (bf50f9 core-prim . simple-struct-set!) (bf50f8 core-prim . simple-struct-ref) (bf50f7 core-prim . make-simple-struct) (bf50f6 core-prim . simple-struct?) (bf50f5 core-prim . pointer-ref-c-int64) (bf50f4 core-prim . pointer-ref-c-int32) (bf50f3 core-prim . pointer-ref-c-int16) (bf50f2 core-prim . pointer-ref-c-int8) (bf50f1 core-prim . pointer-ref-c-uint64) (bf50f0 core-prim . pointer-ref-c-uint32) (bf50ef core-prim . pointer-ref-c-uint16) (bf50ee core-prim . pointer-ref-c-uint8) (bf50ed core-prim . pointer-set-c-uint64!) (bf50ec core-prim . pointer-set-c-uint32!) (bf50eb core-prim . pointer-set-c-uint16!) (bf50ea core-prim . pointer-set-c-uint8!) (bf50e9 core-prim . pointer-set-c-int64!) (bf50e8 core-prim . pointer-set-c-int32!) (bf50e7 core-prim . pointer-set-c-int16!) (bf50e6 core-prim . pointer-set-c-int8!) (bf50e5 core-prim . pointer-set-c-pointer!) (bf50e4 core-prim . pointer-set-c-double!) (bf50e3 core-prim . pointer-set-c-float!) (bf50e2 core-prim . pointer-set-c-long-long!) (bf50e1 core-prim . pointer-set-c-long!) (bf50e0 core-prim . pointer-set-c-int!) (bf50df core-prim . pointer-set-c-short!) (bf50de core-prim . pointer-set-c-char!) (bf50dd core-prim . pointer-ref-c-pointer) (bf50dc core-prim . pointer-ref-c-double) (bf50db core-prim . pointer-ref-c-float) (bf50da core-prim . pointer-ref-c-unsigned-long-long) (bf50d9 core-prim . pointer-ref-c-signed-long-long) (bf50d8 core-prim . pointer-ref-c-unsigned-long) (bf50d7 core-prim . pointer-ref-c-signed-long) (bf50d6 core-prim . pointer-ref-c-unsigned-int) (bf50d5 core-prim . pointer-ref-c-signed-int) (bf50d4 core-prim . pointer-ref-c-unsigned-short) (bf50d3 core-prim . pointer-ref-c-signed-short) (bf50d2 core-prim . pointer-ref-c-unsigned-char) (bf50d1 core-prim . pointer-ref-c-signed-char) (bf50d0 core-prim . pointer->integer) (bf50cf core-prim . integer->pointer) (bf50ce core-prim . pointer?) (bf50cd core-prim . shared-errno) (bf50cc core-prim . %ffi-free-c-callback-trampoline) (bf50cb core-prim . %ffi-make-c-callback-trampoline) (bf50ca core-prim . %ffi-free) (bf50c9 core-prim . %ffi-malloc) (bf50c8 core-prim . %ffi-supported?) (bf50c7 core-prim . %ffi-pointer->string) (bf50c6 core-prim . %ffi-call) (bf50c5 core-prim . %ffi-lookup) (bf50c4 core-prim . %ffi-open) (bf50c3 core-prim . null-terminated-utf8->string) (bf50c2 core-prim . null-terminated-bytevector->string) (bf50c1 core-prim . %exec) (bf50c0 core-prim . %fork) (bf50bf core-prim . %pipe) (bf50be core-prim . p) (bf50bd core-prim . open-output-string) (bf50bc core-prim . get-output-string) (bf50bb core-prim . file-stat-ctime) (bf50ba core-prim . file-stat-atime) (bf50b9 core-prim . file-stat-mtime) (bf50b8 core-prim . file-size-in-bytes) (bf50b7 core-prim . file-writable?) (bf50b6 core-prim . file-executable?) (bf50b5 core-prim . file-readable?) (bf50b4 core-prim . file-regular?) (bf50b3 core-prim . file-symbolic-link?) (bf50b2 core-prim . file-directory?) (bf50b1 core-prim . create-symbolic-link) (bf50b0 core-prim . rename-file) (bf50af core-prim . delete-directory) (bf50ae core-prim . create-directory) (bf50ad core-prim . create-mosh-cache-dir) (bf50ac core-prim . get-environment-variables) (bf50ab core-prim . current-exception-handler) (bf50aa core-prim . get-environment-variable) (bf50a9 core-prim . join-wraps) (bf50a8 core-prim . id->real-label) (bf50a7 core-prim . same-marks?) (bf50a6 core-prim . same-marks*?) (bf50a5 core-prim . get-timeofday) (bf50a4 core-prim . get-command-line) (bf50a3 core-prim . sys-display) (bf50a2 core-prim . whereis) (bf50a1 core-prim . register) (bf50a0 core-prim . vm-join!) (bf509f core-prim . vm-set-value!) (bf509e core-prim . vm?) (bf509d core-prim . main-vm?) (bf509c core-prim . vm-eval) (bf509b core-prim . vm-self) (bf509a core-prim . vm-start!) (bf5099 core-prim . make-vm) (bf5098 core-prim . mutex-try-lock!) (bf5097 core-prim . mutex-unlock!) (bf5096 core-prim . mutex-lock!) (bf5095 core-prim . mutex?) (bf5094 core-prim . make-mutex) (bf5093 core-prim . condition-variable-notify-all!) (bf5092 core-prim . condition-variable-notify!) (bf5091 core-prim . condition-variable-wait!) (bf5090 core-prim . make-condition-variable) (bf508f core-prim . write/ss) (bf508e core-prim . mosh-executable-path) (bf508d core-prim . make-file-options) (bf508c core-prim . source-info) (bf508b core-prim . make-compiler-instruction) (bf508a core-prim . make-instruction) (bf5089 core-prim . set-annotation!) (bf5088 core-prim . get-annotation) (bf5087 core-prim . annotated-pair?) (bf5086 core-prim . annotated-cons) (bf5085 core-prim . set-source-info!) (bf5084 core-prim . bignum?) (bf5083 core-prim . fast-equal?) (bf5082 core-prim . fasl-read) (bf5081 core-prim . fasl-write) (bf5080 core-prim . time-usage) (bf507f core-prim . os-constant) (bf507e core-prim . condition-printer) (bf507d core-prim . disasm) (bf28d8 core-prim . make-parameter) (bf507c core-prim . socket-port) (bf507b core-prim . socket-shutdown) (bf507a core-prim . socket-close) (bf5079 core-prim . socket-send) (bf5078 core-prim . socket-recv!) (bf5077 core-prim . socket-recv) (bf5076 core-prim . make-server-socket) (bf5075 core-prim . make-client-socket) (bf5074 core-prim . socket-accept) (bf5073 core-prim . socket?) (bf5072 core-prim . string-upcase) (bf5071 core-prim . string-titlecase) (bf5070 core-prim . string-normalize-nfkd) (bf506f core-prim . string-normalize-nfkc) (bf506e core-prim . string-normalize-nfd) (bf506d core-prim . string-normalize-nfc) (bf506c core-prim . string-foldcase) (bf506b core-prim . string-downcase) (bf506a core-prim . string-ci>?) (bf5069 core-prim . string-ci>=?) (bf5068 core-prim . string-ci=?) (bf5067 core-prim . string-ci<?) (bf5066 core-prim . string-ci<=?) (bf5065 core-prim . char-whitespace?) (bf5064 core-prim . char-upper-case?) (bf5063 core-prim . char-title-case?) (bf5062 core-prim . char-numeric?) (bf5061 core-prim . char-lower-case?) (bf5060 core-prim . char-general-category) (bf505f core-prim . char-upcase) (bf505e core-prim . char-titlecase) (bf505d core-prim . char-foldcase) (bf505c core-prim . char-downcase) (bf505b core-prim . char-ci>?) (bf505a core-prim . char-ci>=?) (bf5059 core-prim . char-ci=?) (bf5058 core-prim . char-ci<?) (bf5057 core-prim . char-ci<=?) (bf5056 core-prim . char-alphabetic?) (bf2edc core-prim . make-variable-transformer) (bf3193 core-prim . identifier?) (bf317f core-prim . generate-temporaries) (bf3181 core-prim . free-identifier=?) (bf3197 core-prim . syntax->datum) (bf3195 core-prim . datum->syntax) (bf3183 core-prim . bound-identifier=?) (bf5055 core-prim . record-type-descriptor?) (bf5054 core-prim . record-predicate) (bf5053 core-prim . record-mutator) (bf5052 core-prim . record-constructor) (bf5051 core-prim . record-accessor) (bf5050 core-prim . make-record-type-descriptor) (bf504f core-prim . make-record-constructor-descriptor) (bf504e core-prim . record?) (bf504d core-prim . record-type-uid) (bf504c core-prim . record-type-sealed?) (bf504b core-prim . record-type-parent) (bf504a core-prim . record-type-opaque?) (bf5049 core-prim . record-type-name) (bf5048 core-prim . record-type-generative?) (bf5047 core-prim . record-type-field-names) (bf5046 core-prim . record-rtd) (bf5045 core-prim . record-field-mutable?) (bf5044 core-prim . delete-file) (bf5043 core-prim . file-exists?) (bf5042 core-prim . vector-sort!) (bf5041 core-prim . vector-sort) (bf5040 core-prim . list-sort) (bf503f core-prim . symbol-hash) (bf503e core-prim . string-ci-hash) (bf503d core-prim . string-hash) (bf503c core-prim . equal-hash) (bf503b core-prim . hashtable-equivalence-function) (bf503a core-prim . make-hashtable) (bf5039 core-prim . hashtable-hash-function) (bf5038 core-prim . make-eqv-hashtable) (bf5037 core-prim . make-eq-hashtable) (bf5036 core-prim . hashtable?) (bf5035 core-prim . hashtable-update!) (bf5034 core-prim . hashtable-size) (bf5033 core-prim . hashtable-set!) (bf5032 core-prim . hashtable-ref) (bf5031 core-prim . hashtable-mutable?) (bf5030 core-prim . hashtable-keys) (bf502f core-prim . hashtable-entries) (bf502e core-prim . hashtable-delete!) (bf502d core-prim . hashtable-copy) (bf502c core-prim . hashtable-contains?) (bf502b core-prim . hashtable-clear!) (bf502a core-prim . call-with-output-file) (bf5029 core-prim . call-with-input-file) (bf5028 core-prim . write-char) (bf5027 core-prim . write) (bf5026 core-prim . with-output-to-file) (bf5025 core-prim . with-input-from-file) (bf5024 core-prim . read-char) (bf5023 core-prim . read) (bf5022 core-prim . peek-char) (bf5021 core-prim . open-output-file) (bf5020 core-prim . open-input-file) (bf501f core-prim . newline) (bf501e core-prim . display) (bf501d core-prim . close-output-port) (bf501c core-prim . close-input-port) (bf501b core-prim . eof-object?) (bf501a core-prim . eof-object) (bf5019 core-prim . current-error-port) (bf5018 core-prim . current-output-port) (bf5017 core-prim . current-input-port) (bf5016 core-prim . output-port?) (bf5015 core-prim . input-port?) (bf5014 core-prim . utf-8-codec) (bf5013 core-prim . utf-16-codec) (bf5012 core-prim . transcoder-error-handling-mode) (bf5011 core-prim . transcoder-eol-style) (bf5010 core-prim . transcoder-codec) (bf500f core-prim . transcoded-port) (bf500e core-prim . textual-port?) (bf500d core-prim . string->bytevector) (bf500c core-prim . standard-output-port) (bf500b core-prim . standard-input-port) (bf500a core-prim . standard-error-port) (bf5009 core-prim . set-port-position!) (bf5008 core-prim . put-u8) (bf5007 core-prim . put-string) (bf5006 core-prim . put-datum) (bf5005 core-prim . put-char) (bf5004 core-prim . put-bytevector) (bf5003 core-prim . port?) (bf5002 core-prim . port-transcoder) (bf5001 core-prim . port-position) (bf5000 core-prim . port-has-set-port-position!?) (bf4fff core-prim . port-has-port-position?) (bf4ffe core-prim . port-eof?) (bf4ffd core-prim . output-port-buffer-mode) (bf4ffc core-prim . open-string-output-port) (bf4ffb core-prim . open-string-input-port) (bf4ffa core-prim . open-file-output-port) (bf4ff9 core-prim . open-file-input/output-port) (bf4ff8 core-prim . open-file-input-port) (bf4ff7 core-prim . open-bytevector-output-port) (bf4ff6 core-prim . open-bytevector-input-port) (bf4ff5 core-prim . native-transcoder) (bf4ff4 core-prim . native-eol-style) (bf4ff3 core-prim . make-transcoder) (bf4ff2 core-prim . latin-1-codec) (bf4ff1 core-prim . make-i/o-write-error) (bf4ff0 core-prim . make-i/o-read-error) (bf4fef core-prim . make-i/o-port-error) (bf4fee core-prim . make-i/o-invalid-position-error) (bf4fed core-prim . make-i/o-filename-error) (bf4fec core-prim . make-i/o-file-protection-error) (bf4feb core-prim . make-i/o-file-is-read-only-error) (bf4fea core-prim . make-i/o-file-does-not-exist-error) (bf4fe9 core-prim . make-i/o-file-already-exists-error) (bf4fe8 core-prim . make-i/o-error) (bf4fe7 core-prim . make-i/o-encoding-error) (bf4fe6 core-prim . make-i/o-decoding-error) (bf4fe5 core-prim . make-custom-textual-output-port) (bf4fe4 core-prim . make-custom-textual-input/output-port) (bf4fe3 core-prim . make-custom-textual-input-port) (bf4fe2 core-prim . make-custom-binary-output-port) (bf4fe1 core-prim . make-custom-binary-input/output-port) (bf4fe0 core-prim . make-custom-binary-input-port) (bf4fdf core-prim . make-bytevector) (bf4fde core-prim . lookahead-u8) (bf4fdd core-prim . lookahead-char) (bf4fdc core-prim . i/o-write-error?) (bf4fdb core-prim . i/o-read-error?) (bf4fda core-prim . i/o-port-error?) (bf4fd9 core-prim . i/o-invalid-position-error?) (bf4fd8 core-prim . i/o-filename-error?) (bf4fd7 core-prim . i/o-file-protection-error?) (bf4fd6 core-prim . i/o-file-is-read-only-error?) (bf4fd5 core-prim . i/o-file-does-not-exist-error?) (bf4fd4 core-prim . i/o-file-already-exists-error?) (bf4fd3 core-prim . i/o-error?) (bf4fd2 core-prim . i/o-error-position) (bf4fd1 core-prim . i/o-error-port) (bf4fd0 core-prim . i/o-error-filename) (bf4fcf core-prim . i/o-encoding-error?) (bf4fce core-prim . i/o-encoding-error-char) (bf4fcd core-prim . i/o-decoding-error?) (bf4fcc core-prim . get-u8) (bf4fcb core-prim . get-string-n!) (bf4fca core-prim . get-string-n) (bf4fc9 core-prim . get-string-all) (bf4fc8 core-prim . get-line) (bf4fc7 core-prim . get-datum) (bf4fc6 core-prim . get-char) (bf4fc5 core-prim . get-bytevector-some) (bf4fc4 core-prim . get-bytevector-n!) (bf4fc3 core-prim . get-bytevector-n) (bf4fc2 core-prim . get-bytevector-all) (bf4fc1 core-prim . flush-output-port) (bf4fc0 core-prim . close-port) (bf316d core-prim . scheme-report-environment) (bf4fbf core-prim . quotient) (bf316b core-prim . null-environment) (bf4fbe core-prim . remainder) (bf4fbd core-prim . modulo) (bf4fbc core-prim . inexact->exact) (bf4fbb core-prim . force) (bf4fba core-prim . exact->inexact) (bf4fb9 core-prim . make-promise) (bf4fb8 core-prim . exit) (bf4c4a core-prim . command-line) (bf4fb7 core-prim . string-fill!) (bf4fb6 core-prim . string-set!) (bf4fb5 core-prim . set-cdr!) (bf4fb4 core-prim . set-car!) (bf4fb3 core-prim . remove) (bf4fb2 core-prim . remv) (bf4fb1 core-prim . remp) (bf4fb0 core-prim . remq) (bf4faf core-prim . partition) (bf4fae core-prim . memv) (bf4fad core-prim . memq) (bf4fac core-prim . memp) (bf4fab core-prim . member) (bf4faa core-prim . exists) (bf4fa9 core-prim . for-all) (bf4fa8 core-prim . fold-right) (bf4fa7 core-prim . fold-left) (bf4fa6 core-prim . find) (bf4fa5 core-prim . filter) (bf4fa4 core-prim . cons*) (bf4fa3 core-prim . assv) (bf4fa2 core-prim . assq) (bf4fa1 core-prim . assp) (bf4fa0 core-prim . assoc) (bf4f9f core-prim . call-with-string-output-port) (bf4f9e core-prim . call-with-port) (bf4f9d core-prim . call-with-bytevector-output-port) (bf4f9c core-prim . bytevector->string) (bf4f9b core-prim . buffer-mode?) (bf4f9a core-prim . binary-port?) (bf4f99 core-prim . with-exception-handler) (bf4f98 core-prim . raise-continuable) (bf4f97 core-prim . raise) (bf3171 core-prim . eval) (bf3169 core-prim . environment) (bf4f96 core-prim . make-enumeration) (bf4f95 core-prim . enum-set=?) (bf4f94 core-prim . enum-set-universe) (bf4f93 core-prim . enum-set-union) (bf4f92 core-prim . enum-set-subset?) (bf4f91 core-prim . enum-set-projection) (bf4f90 core-prim . enum-set-member?) (bf4f8f core-prim . enum-set-intersection) (bf4f8e core-prim . enum-set-indexer) (bf4f8d core-prim . enum-set-difference) (bf4f8c core-prim . enum-set-constructor) (bf4f8b core-prim . enum-set-complement) (bf4f8a core-prim . enum-set->list) (bf4f89 core-prim . who-condition?) (bf4f88 core-prim . warning?) (bf4f87 core-prim . violation?) (bf4f86 core-prim . undefined-violation?) (bf4f85 core-prim . syntax-violation?) (bf4f84 core-prim . syntax-violation-subform) (bf4f83 core-prim . syntax-violation-form) (bf3191 core-prim . syntax-violation) (bf4f82 core-prim . simple-conditions) (bf4f81 core-prim . serious-condition?) (bf4f80 core-prim . non-continuable-violation?) (bf4f7f core-prim . message-condition?) (bf4f7e core-prim . make-who-condition) (bf4f7d core-prim . make-warning) (bf4f7c core-prim . make-violation) (bf4f7b core-prim . make-undefined-violation) (bf4f7a core-prim . make-syntax-violation) (bf4f79 core-prim . make-serious-condition) (bf4f78 core-prim . make-non-continuable-violation) (bf4f77 core-prim . make-message-condition) (bf4f76 core-prim . make-lexical-violation) (bf4f75 core-prim . make-irritants-condition) (bf4f74 core-prim . make-implementation-restriction-violation) (bf4f73 core-prim . make-error) (bf4f72 core-prim . make-assertion-violation) (bf4f71 core-prim . lexical-violation?) (bf4f70 core-prim . irritants-condition?) (bf4f6f core-prim . implementation-restriction-violation?) (bf4f6e core-prim . error?) (bf4f6d core-prim . condition-who) (bf4f6c core-prim . condition-predicate) (bf4f6b core-prim . condition-message) (bf4f6a core-prim . condition-irritants) (bf4f69 core-prim . condition-accessor) (bf4f68 core-prim . condition) (bf4f67 core-prim . assertion-violation?) (bf4f66 core-prim . condition?) (bf4f65 core-prim . utf32->string) (bf4f64 core-prim . utf16->string) (bf4f63 core-prim . utf8->string) (bf4f62 core-prim . uint-list->bytevector) (bf4f61 core-prim . u8-list->bytevector) (bf4f60 core-prim . string->utf8) (bf4f5f core-prim . string->utf32) (bf4f5e core-prim . string->utf16) (bf4f5d core-prim . sint-list->bytevector) (bf4f5c core-prim . native-endianness) (bf4f5b core-prim . bytevector?) (bf4f5a core-prim . bytevector=?) (bf4f59 core-prim . bytevector-uint-set!) (bf4f58 core-prim . bytevector-uint-ref) (bf4f57 core-prim . bytevector-u8-set!) (bf4f56 core-prim . bytevector-u8-ref) (bf4f55 core-prim . bytevector-u64-set!) (bf4f54 core-prim . bytevector-u64-ref) (bf4f53 core-prim . bytevector-u64-native-set!) (bf4f52 core-prim . bytevector-u64-native-ref) (bf4f51 core-prim . bytevector-u32-set!) (bf4f50 core-prim . bytevector-u32-ref) (bf4f4f core-prim . bytevector-u32-native-set!) (bf4f4e core-prim . bytevector-u32-native-ref) (bf4f4d core-prim . bytevector-u16-set!) (bf4f4c core-prim . bytevector-u16-ref) (bf4f4b core-prim . bytevector-u16-native-set!) (bf4f4a core-prim . bytevector-u16-native-ref) (bf4f49 core-prim . bytevector-sint-set!) (bf4f48 core-prim . bytevector-sint-ref) (bf4f47 core-prim . bytevector-s8-set!) (bf4f46 core-prim . bytevector-s8-ref) (bf4f45 core-prim . bytevector-s64-set!) (bf4f44 core-prim . bytevector-s64-ref) (bf4f43 core-prim . bytevector-s64-native-set!) (bf4f42 core-prim . bytevector-s64-native-ref) (bf4f41 core-prim . bytevector-s32-set!) (bf4f40 core-prim . bytevector-s32-ref) (bf4f3f core-prim . bytevector-s32-native-set!) (bf4f3e core-prim . bytevector-s32-native-ref) (bf4f3d core-prim . bytevector-s16-set!) (bf4f3c core-prim . bytevector-s16-ref) (bf4f3b core-prim . bytevector-s16-native-set!) (bf4f3a core-prim . bytevector-s16-native-ref) (bf4f39 core-prim . bytevector-length) (bf4f38 core-prim . bytevector-ieee-single-ref) (bf4f37 core-prim . bytevector-ieee-single-set!) (bf4f36 core-prim . bytevector-ieee-single-native-set!) (bf4f35 core-prim . bytevector-ieee-single-native-ref) (bf4f34 core-prim . bytevector-ieee-double-set!) (bf4f33 core-prim . bytevector-ieee-double-ref) (bf4f32 core-prim . bytevector-ieee-double-native-set!) (bf4f31 core-prim . bytevector-ieee-double-native-ref) (bf4f30 core-prim . bytevector-fill!) (bf4f2f core-prim . bytevector-copy!) (bf4f2e core-prim . bytevector-copy) (bf4f2d core-prim . bytevector->uint-list) (bf4f2c core-prim . bytevector->u8-list) (bf4f2b core-prim . bytevector->sint-list) (bf4f2a core-prim . no-nans-violation?) (bf4f29 core-prim . no-infinities-violation?) (bf4f28 core-prim . make-no-nans-violation) (bf4f27 core-prim . make-no-infinities-violation) (bf4f26 core-prim . real->flonum) (bf4f25 core-prim . flzero?) (bf4f24 core-prim . fltruncate) (bf4f23 core-prim . fltan) (bf4f22 core-prim . flsqrt) (bf4f21 core-prim . flsin) (bf4f20 core-prim . flround) (bf4f1f core-prim . flpositive?) (bf4f1e core-prim . flonum?) (bf4f1d core-prim . flodd?) (bf4f1c core-prim . flnumerator) (bf4f1b core-prim . flnegative?) (bf4f1a core-prim . flnan?) (bf4f19 core-prim . flmod0) (bf4f18 core-prim . flmod) (bf4f17 core-prim . flmin) (bf4f16 core-prim . flmax) (bf4f15 core-prim . fllog) (bf4f14 core-prim . flinteger?) (bf4f13 core-prim . flinfinite?) (bf4f12 core-prim . flfloor) (bf4f11 core-prim . flfinite?) (bf4f10 core-prim . flexpt) (bf4f0f core-prim . flexp) (bf4f0e core-prim . fleven?) (bf4f0d core-prim . fldiv0-and-mod0) (bf4f0c core-prim . fldiv0) (bf4f0b core-prim . fldiv-and-mod) (bf4f0a core-prim . fldiv) (bf4f09 core-prim . fldenominator) (bf4f08 core-prim . flcos) (bf4f07 core-prim . flceiling) (bf4f06 core-prim . flatan) (bf4f05 core-prim . flasin) (bf4f04 core-prim . flacos) (bf4f03 core-prim . flabs) (bf4f02 core-prim . fl>?) (bf4f01 core-prim . fl>=?) (bf4f00 core-prim . fl=?) (bf4eff core-prim . fl<?) (bf4efe core-prim . fl<=?) (bf4efd core-prim . fl/) (bf4efc core-prim . fl-) (bf4efb core-prim . fl+) (bf4efa core-prim . fl*) (bf4ef9 core-prim . fixnum->flonum) (bf4ef8 core-prim . fxzero?) (bf4ef7 core-prim . fxxor) (bf4ef6 core-prim . fxrotate-bit-field) (bf4ef5 core-prim . fxreverse-bit-field) (bf4ef4 core-prim . fxpositive?) (bf4ef3 core-prim . fxodd?) (bf4ef2 core-prim . fxnot) (bf4ef1 core-prim . fxnegative?) (bf4ef0 core-prim . fxmod0) (bf4eef core-prim . fxmod) (bf4eee core-prim . fxmin) (bf4eed core-prim . fxmax) (bf4eec core-prim . fxlength) (bf4eeb core-prim . fxior) (bf4eea core-prim . fxif) (bf4ee9 core-prim . fxfirst-bit-set) (bf4ee8 core-prim . fxeven?) (bf4ee7 core-prim . fxdiv0-and-mod0) (bf4ee6 core-prim . fxdiv0) (bf4ee5 core-prim . fxdiv-and-mod) (bf4ee4 core-prim . fxdiv) (bf4ee3 core-prim . fxcopy-bit-field) (bf4ee2 core-prim . fxcopy-bit) (bf4ee1 core-prim . fxbit-set?) (bf4ee0 core-prim . fxbit-field) (bf4edf core-prim . fxbit-count) (bf4ede core-prim . fxarithmetic-shift-right) (bf4edd core-prim . fxarithmetic-shift-left) (bf4edc core-prim . fxarithmetic-shift) (bf4edb core-prim . fxand) (bf4eda core-prim . fx>?) (bf4ed9 core-prim . fx>=?) (bf4ed8 core-prim . fx=?) (bf4ed7 core-prim . fx<?) (bf4ed6 core-prim . fx<=?) (bf4ed5 core-prim . fx-/carry) (bf4ed4 core-prim . fx-) (bf4ed3 core-prim . fx+/carry) (bf4ed2 core-prim . fx+) (bf4ed1 core-prim . fx*/carry) (bf4ed0 core-prim . fx*) (bf4ecf core-prim . greatest-fixnum) (bf4ece core-prim . least-fixnum) (bf4ecd core-prim . fixnum-width) (bf4ecc core-prim . fixnum?) (bf4ecb core-prim . bitwise-rotate-bit-field) (bf4eca core-prim . bitwise-reverse-bit-field) (bf4ec9 core-prim . bitwise-length) (bf4ec8 core-prim . bitwise-if) (bf4ec7 core-prim . bitwise-first-bit-set) (bf4ec6 core-prim . bitwise-copy-bit-field) (bf4ec5 core-prim . bitwise-copy-bit) (bf4ec4 core-prim . bitwise-bit-set?) (bf4ec3 core-prim . bitwise-bit-field) (bf4ec2 core-prim . bitwise-bit-count) (bf4ec1 core-prim . bitwise-xor) (bf4ec0 core-prim . bitwise-ior) (bf4ebf core-prim . bitwise-and) (bf4ebe core-prim . bitwise-not) (bf4ebd core-prim . bitwise-arithmetic-shift-right) (bf4ebc core-prim . bitwise-arithmetic-shift-left) (bf4ebb core-prim . bitwise-arithmetic-shift) (bf4eba core-prim . zero?) (bf4eb9 core-prim . vector?) (bf4eb8 core-prim . vector-set!) (bf4eb7 core-prim . vector-ref) (bf4eb6 core-prim . vector-map) (bf4eb5 core-prim . vector-length) (bf4eb4 core-prim . vector-for-each) (bf4eb3 core-prim . vector-fill!) (bf4eb2 core-prim . vector->list) (bf4eb1 core-prim . vector) (bf4eb0 core-prim . values) (bf4eaf core-prim . truncate) (bf4eae core-prim . tan) (bf4ead core-prim . symbol?) (bf4eac core-prim . symbol=?) (bf4eab core-prim . symbol->string) (bf4eaa core-prim . substring) (bf4ea9 core-prim . string?) (bf4ea8 core-prim . string>?) (bf4ea7 core-prim . string>=?) (bf4ea6 core-prim . string=?) (bf4ea5 core-prim . string<?) (bf4ea4 core-prim . string<=?) (bf4ea3 core-prim . string-ref) (bf4ea2 core-prim . string-length) (bf4ea1 core-prim . string-for-each) (bf4ea0 core-prim . string-copy) (bf4e9f core-prim . string-append) (bf4e9e core-prim . string->symbol) (bf4e9d core-prim . string->number) (bf4e9c core-prim . string->list) (bf4e9b core-prim . string) (bf4e9a core-prim . sqrt) (bf4e99 core-prim . sin) (bf4e98 core-prim . round) (bf4e97 core-prim . reverse) (bf4e96 core-prim . real?) (bf4e95 core-prim . real-valued?) (bf4e94 core-prim . real-part) (bf4e93 core-prim . rationalize) (bf4e92 core-prim . rational?) (bf4e91 core-prim . rational-valued?) (bf4e90 core-prim . procedure?) (bf4e8f core-prim . positive?) (bf4e8e core-prim . pair?) (bf4e8d core-prim . odd?) (bf4e8c core-prim . numerator) (bf4e8b core-prim . number?) (bf4e8a core-prim . number->string) (bf4e89 core-prim . null?) (bf4e88 core-prim . not) (bf4e87 core-prim . negative?) (bf4e86 core-prim . nan?) (bf4e85 core-prim . min) (bf4e84 core-prim . max) (bf4e83 core-prim . map) (bf4e82 core-prim . make-vector) (bf4e81 core-prim . make-string) (bf4e80 core-prim . make-rectangular) (bf4e7f core-prim . make-polar) (bf4e7e core-prim . magnitude) (bf4e7d core-prim . log) (bf4e7c core-prim . list?) (bf4e7b core-prim . list-tail) (bf4e7a core-prim . list-ref) (bf4e79 core-prim . list->vector) (bf4e78 core-prim . list->string) (bf4e77 core-prim . list) (bf4e76 core-prim . length) (bf4e75 core-prim . lcm) (bf4e74 core-prim . integer?) (bf4e73 core-prim . integer-valued?) (bf4e72 core-prim . integer->char) (bf4e71 core-prim . infinite?) (bf4e70 core-prim . inexact?) (bf4e6f core-prim . inexact) (bf4e6e core-prim . imag-part) (bf4e6d core-prim . gcd) (bf4e6c core-prim . for-each) (bf4e6b core-prim . floor) (bf4e6a core-prim . finite?) (bf4e69 core-prim . expt) (bf4e68 core-prim . exp) (bf4e67 core-prim . exact?) (bf4e66 core-prim . exact-integer-sqrt) (bf4e65 core-prim . exact) (bf4e64 core-prim . even?) (bf4e63 core-prim . error) (bf4e62 core-prim . eqv?) (bf4e61 core-prim . equal?) (bf4e60 core-prim . eq?) (bf4e5f core-prim . dynamic-wind) (bf4e5e core-prim . div0-and-mod0) (bf4e5d core-prim . mod0) (bf4e5c core-prim . div0) (bf4e5b core-prim . div-and-mod) (bf4e5a core-prim . mod) (bf4e59 core-prim . div) (bf4e58 core-prim . denominator) (bf4e57 core-prim . cos) (bf4e56 core-prim . cons) (bf4e55 core-prim . complex?) (bf4e54 core-prim . char?) (bf4e53 core-prim . char>?) (bf4e52 core-prim . char>=?) (bf4e51 core-prim . char=?) (bf4e50 core-prim . char<?) (bf4e4f core-prim . char<=?) (bf4e4e core-prim . char->integer) (bf4e4d core-prim . ceiling) (bf4e4c core-prim . call-with-values) (bf4e4b core-prim . call/cc) (bf4e4a core-prim . call-with-current-continuation) (bf4e49 core-prim . cddddr) (bf4e48 core-prim . cdddar) (bf4e47 core-prim . cddadr) (bf4e46 core-prim . cddaar) (bf4e45 core-prim . cdaddr) (bf4e44 core-prim . cdadar) (bf4e43 core-prim . cdaadr) (bf4e42 core-prim . cdaaar) (bf4e41 core-prim . cadddr) (bf4e40 core-prim . caddar) (bf4e3f core-prim . cadadr) (bf4e3e core-prim . cadaar) (bf4e3d core-prim . caaddr) (bf4e3c core-prim . caadar) (bf4e3b core-prim . caaadr) (bf4e3a core-prim . caaaar) (bf4e39 core-prim . cdddr) (bf4e38 core-prim . cddar) (bf4e37 core-prim . cdadr) (bf4e36 core-prim . cdaar) (bf4e35 core-prim . caddr) (bf4e34 core-prim . cadar) (bf4e33 core-prim . caadr) (bf4e32 core-prim . caaar) (bf4e31 core-prim . cddr) (bf4e30 core-prim . cdar) (bf4e2f core-prim . cadr) (bf4e2e core-prim . caar) (bf4e2d core-prim . cdr) (bf4e2c core-prim . car) (bf4e2b core-prim . boolean?) (bf4e2a core-prim . boolean=?) (bf4e29 core-prim . atan) (bf4e28 core-prim . assertion-violation) (bf318b core-prim . assertion-error) (bf4e27 core-prim . asin) (bf4e26 core-prim . apply) (bf4e25 core-prim . append) (bf4e24 core-prim . angle) (bf4e23 core-prim . acos) (bf4e22 core-prim . abs) (bf4e21 core-prim . /) (bf4e20 core-prim . *) (bf4e1f core-prim . -) (bf4e1e core-prim . +) (bf4e1d core-prim . >=) (bf4e1c core-prim . >) (bf4e1b core-prim . =) (bf4e1a core-prim . <=) (bf4e19 core-prim . <) (bf4e18 core-prim . library) (bf4e17 $core-rtd &no-nans-rtd &no-nans-rcd) (bf4e16 $core-rtd &no-infinities-rtd &no-infinities-rcd) (bf4e15 $core-rtd &i/o-encoding-rtd &i/o-encoding-rcd) (bf4e14 $core-rtd &i/o-decoding-rtd &i/o-decoding-rcd) (bf4e13 $core-rtd &i/o-port-rtd &i/o-port-rcd) (bf4e12 $core-rtd &i/o-file-does-not-exist-rtd &i/o-file-does-not-exist-rcd) (bf4e11 $core-rtd &i/o-file-already-exists-rtd &i/o-file-already-exists-rcd) (bf4e10 $core-rtd &i/o-file-is-read-only-rtd &i/o-fie-is-read-only-rcd) (bf4e0f $core-rtd &i/o-file-protection-rtd &i/o-file-protection-rcd) (bf4e0e $core-rtd &i/o-filename-rtd &i/o-filename-rcd) (bf4e0d $core-rtd &i/o-invalid-position-rtd &i/o-invalid-position-rcd) (bf4e0c $core-rtd &i/o-write-rtd &i/o-write-rcd) (bf4e0b $core-rtd &i/o-read-rtd &i/o-read-rcd) (bf4e0a $core-rtd &i/o-rtd &i/o-rcd) (bf4e09 $core-rtd &undefined-rtd &undefined-rcd) (bf4e08 $core-rtd &syntax-rtd &syntax-rcd) (bf4e07 $core-rtd &lexical-rtd &lexical-rcd) (bf4e06 $core-rtd &implementation-restriction-rtd &implementation-restriction-rcd) (bf4e05 $core-rtd &non-continuable-rtd &non-continuable-rcd) (bf4e04 $core-rtd &who-rtd &who-rcd) (bf4e03 $core-rtd &irritants-rtd &irritants-rcd) (bf4e02 $core-rtd &assertion-rtd &assertion-rcd) (bf4e01 $core-rtd &violation-rtd &violation-rcd) (bf4e00 $core-rtd &error-rtd &error-rcd) (bf4dff $core-rtd &serious-rtd &serious-rcd) (bf4dfe $core-rtd &warning-rtd &warning-rcd) (bf4dfd $core-rtd &message-rtd &message-rcd) (bf4dfc $core-rtd &condition-rtd &condition-rcd) (bf4dfb macro . define-condition-type) (bf4dfa macro . define-enumeration) (bf4df9 macro . define-record-type) (bf4df8 macro . parent-rtd) (bf4df7 macro . nongenerative) (bf4df6 macro . opaque) (bf4df5 macro . sealed) (bf4df4 macro . protocol) (bf4df3 macro . parent) (bf4df2 macro . immutable) (bf4df1 macro . mutable) (bf4df0 macro . fields) (bf4def macro . error-handling-mode) (bf4dee macro . file-options) (bf4ded macro . buffer-mode) (bf4dec macro . eol-style) (bf4deb macro . guard) (bf4dea macro . trace-define) (bf4de9 macro . trace-lambda) (bf4de8 macro . unsyntax-splicing) (bf4de7 macro . unsyntax) (bf4de6 macro . unquote-splicing) (bf4de5 macro . unquote) (bf4de4 macro . _) (bf4de3 macro . else) (bf4de2 macro . =>) (bf4de1 macro . ...) (bf4de0 macro . assert) (bf4ddf macro . endianness) (bf4dde macro . delay) (bf4ddd macro . time) (bf4ddc macro . do) (bf4ddb macro . cond) (bf4dda macro . let*) (bf4dd9 macro . let*-values) (bf4dd8 macro . let-values) (bf4dd7 macro . identifier-syntax) (bf4dd6 macro . with-syntax) (bf4dd5 macro . quasisyntax) (bf4dd4 macro . quasiquote) (bf4dd3 macro . syntax-rules) (bf4dd2 macro . include) (bf4dd1 macro . define-struct) (bf4dd0 core-macro . record-constructor-descriptor) (bf4dcf core-macro . record-type-descriptor) (bf4dce macro . case) (bf4dcd macro . parameterize) (bf4dcc macro . unless) (bf4dcb macro . when) (bf4dca core-macro . or) (bf4dc9 core-macro . and) (bf4dc8 core-macro . if) (bf4dc7 core-macro . let) (bf4dc6 core-macro . letrec*) (bf4dc5 core-macro . letrec) (bf4dc4 core-macro . type-descriptor) (bf4dc3 core-macro . case-lambda) (bf4dc2 core-macro . lambda) (bf4dc1 core-macro . syntax) (bf4dc0 core-macro . syntax-case) (bf4dbf core-macro . quote) (bf4dbe core-macro . foreign-call) (bf4dbd letrec-syntax) (bf4dbc let-syntax) (bf4dbb set!) (bf4dba import) (bf4db9 begin) (bf4db8 module) (bf4db7 define-syntax) (bf4db6 define)) values values '#f '#f '#f '#f) (bf2cc5@bf2b11@install-library 'bf5182 '(psyntax system $bootstrap) '() '() '() '() '((pretty-print . bf5129) (eval-core . bf5128) (set-symbol-value! . bf5127) (symbol-value . bf5126) (gensym . bf5125) (void . bf5124)) '() values values '#f '#f '#f '#f) (bf2cc5@bf2b11@install-library 'bf5183 '(mosh) '() '() '() '() '((set-symbol-value! . bf5127) (symbol-value . bf5126) (regexp? . bf5122) (read-line . bf5121) (ungensym . bf511f) (alist->eq-hash-table . bf511e) (assoc-ref . bf511d) (print . bf511c) (format . bf511b) (host-os . bf511a) (library-path . bf2af0) (standard-library-path . bf5119) (file-newer? . bf5113) (stat-mtime . bf5112) (digit->integer . bf510e) (call-with-string-input-port . bf510d) (call-with-string-io . bf510c) (string-split . bf510b) (bytevector-for-each . bf510a) (string->regexp . bf5109) (rxmatch . bf5108) (regexp-replace-all . bf5107) (hashtable-fold-left . bf5106) (hashtable-for-each . bf5105) (set-current-directory! . bf5100) (expand-path . bf50ff) (current-directory . bf50fe) (p . bf50be) (get-timeofday . bf50a5) (get-command-line . bf50a4) (sys-display . bf50a3) (whereis . bf50a2) (register . bf50a1) (vm-join! . bf50a0) (vm-set-value! . bf509f) (vm? . bf509e) (main-vm? . bf509d) (vm-eval . bf509c) (vm-self . bf509b) (vm-start! . bf509a) (make-vm . bf5099) (mutex-try-lock! . bf5098) (mutex-unlock! . bf5097) (mutex-lock! . bf5096) (mutex? . bf5095) (make-mutex . bf5094) (condition-variable-notify-all! . bf5093) (condition-variable-notify! . bf5092) (condition-variable-wait! . bf5091) (make-condition-variable . bf5090) (write/ss . bf508f) (mosh-executable-path . bf508e) (make-file-options . bf508d) (source-info . bf508c) (make-compiler-instruction . bf508b) (make-instruction . bf508a) (set-annotation! . bf5089) (get-annotation . bf5088) (annotated-pair? . bf5087) (annotated-cons . bf5086) (set-source-info! . bf5085) (bignum? . bf5084) (fast-equal? . bf5083) (fasl-read . bf5082) (fasl-write . bf5081) (time-usage . bf5080) (os-constant . bf507f) (condition-printer . bf507e) (time . bf4ddd) (include . bf4dd2)) '() values values '#f '#f '#f '#f) (bf2cc5@bf2b11@install-library 'bf5184 '(system) '() '() '() '() '((gensym-prefix-set! . bf5120) (ssl-supported? . bf5118) (ssl-socket? . bf5117) (socket-sslize! . bf5116) (%monapi-name-whereis . bf5115) (%monapi-message-send . bf5114) (write-to-file . bf5111) (file->list . bf5110) (file->string . bf510f) (mosh-cache-dir . bf28da) (call-process . bf5104) (local-tz-offset . bf5103) (microseconds . bf5102) (directory-list . bf5101) (expand-path . bf50ff) (%getpid . bf50fd) (%spawn . bf50fc) (%waitpid . bf50fb) (simple-struct-name . bf50fa) (simple-struct-set! . bf50f9) (simple-struct-ref . bf50f8) (make-simple-struct . bf50f7) (simple-struct? . bf50f6) (pointer-ref-c-int64 . bf50f5) (pointer-ref-c-int32 . bf50f4) (pointer-ref-c-int16 . bf50f3) (pointer-ref-c-int8 . bf50f2) (pointer-ref-c-uint64 . bf50f1) (pointer-ref-c-uint32 . bf50f0) (pointer-ref-c-uint16 . bf50ef) (pointer-ref-c-uint8 . bf50ee) (pointer-set-c-uint64! . bf50ed) (pointer-set-c-uint32! . bf50ec) (pointer-set-c-uint16! . bf50eb) (pointer-set-c-uint8! . bf50ea) (pointer-set-c-int64! . bf50e9) (pointer-set-c-int32! . bf50e8) (pointer-set-c-int16! . bf50e7) (pointer-set-c-int8! . bf50e6) (pointer-set-c-pointer! . bf50e5) (pointer-set-c-double! . bf50e4) (pointer-set-c-float! . bf50e3) (pointer-set-c-long-long! . bf50e2) (pointer-set-c-long! . bf50e1) (pointer-set-c-int! . bf50e0) (pointer-set-c-short! . bf50df) (pointer-set-c-char! . bf50de) (pointer-ref-c-pointer . bf50dd) (pointer-ref-c-double . bf50dc) (pointer-ref-c-float . bf50db) (pointer-ref-c-unsigned-long-long . bf50da) (pointer-ref-c-signed-long-long . bf50d9) (pointer-ref-c-unsigned-long . bf50d8) (pointer-ref-c-signed-long . bf50d7) (pointer-ref-c-unsigned-int . bf50d6) (pointer-ref-c-signed-int . bf50d5) (pointer-ref-c-unsigned-short . bf50d4) (pointer-ref-c-signed-short . bf50d3) (pointer-ref-c-unsigned-char . bf50d2) (pointer-ref-c-signed-char . bf50d1) (pointer->integer . bf50d0) (integer->pointer . bf50cf) (pointer? . bf50ce) (shared-errno . bf50cd) (%ffi-free-c-callback-trampoline . bf50cc) (%ffi-make-c-callback-trampoline . bf50cb) (%ffi-free . bf50ca) (%ffi-malloc . bf50c9) (%ffi-supported? . bf50c8) (%ffi-pointer->string . bf50c7) (%ffi-call . bf50c6) (%ffi-lookup . bf50c5) (%ffi-open . bf50c4) (null-terminated-utf8->string . bf50c3) (null-terminated-bytevector->string . bf50c2) (%exec . bf50c1) (%fork . bf50c0) (%pipe . bf50bf) (open-output-string . bf50bd) (get-output-string . bf50bc) (file-stat-ctime . bf50bb) (file-stat-atime . bf50ba) (file-stat-mtime . bf50b9) (file-size-in-bytes . bf50b8) (file-writable? . bf50b7) (file-executable? . bf50b6) (file-readable? . bf50b5) (file-regular? . bf50b4) (file-symbolic-link? . bf50b3) (file-directory? . bf50b2) (create-symbolic-link . bf50b1) (rename-file . bf50b0) (delete-directory . bf50af) (create-directory . bf50ae) (create-mosh-cache-dir . bf50ad) (get-environment-variables . bf50ac) (current-exception-handler . bf50ab) (get-environment-variable . bf50aa) (join-wraps . bf50a9) (id->real-label . bf50a8) (same-marks? . bf50a7) (same-marks*? . bf50a6) (disasm . bf507d) (make-parameter . bf28d8) (socket-port . bf507c) (socket-shutdown . bf507b) (socket-close . bf507a) (socket-send . bf5079) (socket-recv! . bf5078) (socket-recv . bf5077) (make-server-socket . bf5076) (make-client-socket . bf5075) (socket-accept . bf5074) (socket? . bf5073) (parameterize . bf4dcd)) '() values values '#f '#f '#f '#f)))
(begin (set! bf4c35@ref (unspecified)) (set! bf4c37@x* (unspecified)) (set! bf4c39@add-library-path! (unspecified)) (set! bf4c3b@parse-and-add-library-path (unspecified)) (set! bf4c3d@for-each-with-index (unspecified)) (set! bf4c3f@rpad (unspecified)) (set! bf4c41@condition-printer/p (unspecified)) (set! bf4c43@record->field-alist (unspecified)) (set! bf4c45@map-with-index (unspecified)) (set! bf4c47@repl (unspecified)) (set! bf4c49@trace-printer (unspecified)) (set! bf4c4b@command-line (unspecified)) (set! bf4c4d@local-library-path (unspecified)) (set! bf4c4f@load/args (unspecified)) (set! bf4c51@load (unspecified)) (set! bf4c53@ironscheme-build (unspecified)) (set! bf4c55@eval-top-level (unspecified)) (set! bf4c57@compile-system-libraries (unspecified)) (set! bf4c59@compile (unspecified)) (set! bf4c5b@compile->closure (unspecified)) (set! bf4c5d@pre-compile-r6rs-file (unspecified)) (set! bf4c5f@load-r6rs-top-level (unspecified)) (set! bf4c61@load-r6rs-top-level-sexp (unspecified)) (set! bf4c63@prefix-inc (unspecified)) (set! bf4c65@prefix-inc! (unspecified)) (set! bf4c35@ref (lambda (bf4ca0@rtd bf4ca1@i bf4ca2@x) (let ((bf4ca6@val ((record-accessor bf4ca0@rtd bf4ca1@i) bf4ca2@x))) (if (symbol? bf4ca6@val) (ungensym bf4ca6@val) bf4ca6@val)))) (set! bf4d9c@bf4c35@ref bf4c35@ref) (set! bf4c37@x* '()) (set! bf4d9d@bf4c37@x* bf4c37@x*) (set! bf4c39@add-library-path! (lambda (bf4ca8@path) (bf2cb5@bf2af1@library-path (append (bf2cb5@bf2af1@library-path) (list bf4ca8@path))))) (set! bf4d9e@bf4c39@add-library-path! bf4c39@add-library-path!) (set! bf4c3b@parse-and-add-library-path (lambda (bf4caa@paths bf4cab@message) (letrec* ((bf4caf@separator (if (string=? (host-os) '"win32") '#\; '#\:))) (let ((bf4cb0@t bf4caa@paths)) (if bf4cb0@t ((lambda (bf4cb2@paths) (for-each (lambda (bf4cb4@path) (if (file-exists? bf4cb4@path) (bf4c39@add-library-path! (expand-path bf4cb4@path)) (format (current-error-port) bf4cab@message bf4cb4@path))) (string-split bf4cb2@paths bf4caf@separator))) bf4cb0@t) (void)))))) (set! bf4d9f@bf4c3b@parse-and-add-library-path bf4c3b@parse-and-add-library-path) (set! bf4c3d@for-each-with-index (lambda (bf4cb6@proc bf4cb7@lst) (letrec ((bf4cba@loop (lambda (bf4cbc@i bf4cbd@lst) (if (null? bf4cbd@lst) (if '#f '#f (void)) (begin (bf4cb6@proc bf4cbc@i (car bf4cbd@lst)) (bf4cba@loop (+ bf4cbc@i '1) (cdr bf4cbd@lst))))))) (bf4cba@loop '1 bf4cb7@lst)))) (set! bf4da0@bf4c3d@for-each-with-index bf4c3d@for-each-with-index) (set! bf4c3f@rpad (lambda (bf4cc0@str bf4cc1@pad bf4cc2@n) (let ((bf4cc6@rest (- bf4cc2@n (string-length (format '"~a" bf4cc0@str))))) (let bf4ccc@loop ((bf4cc8@rest bf4cc6@rest) (bf4cc9@ret (format '"~a" bf4cc0@str))) (if (<= bf4cc8@rest '0) bf4cc9@ret (bf4ccc@loop (- bf4cc8@rest '1) (string-append bf4cc9@ret bf4cc1@pad))))))) (set! bf4da1@bf4c3f@rpad bf4c3f@rpad) (set! bf4c41@condition-printer/p (lambda (bf4cce@e bf4ccf@port) (letrec* ((bf4cd3@max-condition-len (apply max (map (lambda (bf4ce4@c) (string-length (symbol->string (record-type-name (record-rtd bf4ce4@c))))) (simple-conditions bf4cce@e))))) (begin (display '" Condition components:\n" bf4ccf@port) (bf4c3d@for-each-with-index (lambda (bf4cd4@i bf4cd5@x) (let ((bf4cd8@rtd (record-rtd bf4cd5@x)) (bf4cd9@fields-alist (bf4c43@record->field-alist bf4cd5@x))) (begin (format bf4ccf@port '" ~d. ~a" bf4cd4@i (bf4c3f@rpad (symbol->string (record-type-name bf4cd8@rtd)) '" " bf4cd3@max-condition-len)) (if (null? bf4cd9@fields-alist) (newline bf4ccf@port) (void)) (let bf4ce0@loop ((bf4cdc@first '#t) (bf4cdd@fields-alist bf4cd9@fields-alist)) (if (null? bf4cdd@fields-alist) '() (let ((bf4ce2@field (car bf4cdd@fields-alist))) (begin (if (not bf4cdc@first) (display (bf4c3f@rpad '"" '" " (+ '4 bf4cd3@max-condition-len)) bf4ccf@port) (void)) (display '"       " bf4ccf@port) (display (car bf4ce2@field) bf4ccf@port) (display '": " bf4ccf@port) (write (cdr bf4ce2@field) bf4ccf@port) (newline bf4ccf@port) (bf4ce0@loop '#f (cdr bf4cdd@fields-alist))))))))) (simple-conditions bf4cce@e)))))) (set! bf4da2@bf4c41@condition-printer/p bf4c41@condition-printer/p) (set! bf4c43@record->field-alist (lambda (bf4ce6@r) (letrec* ((bf4ce9@ref (lambda (bf4cf4@rtd bf4cf5@i bf4cf6@x) (let ((bf4cfa@val ((record-accessor bf4cf4@rtd bf4cf5@i) bf4cf6@x))) (if (symbol? bf4cfa@val) (ungensym bf4cfa@val) bf4cfa@val))))) (let bf4cee@loop ((bf4cea@ret '()) (bf4ceb@rtd (record-rtd bf4ce6@r))) (if bf4ceb@rtd (bf4cee@loop (append bf4cea@ret (bf4c45@map-with-index (lambda (bf4cf0@i bf4cf1@field) (cons bf4cf1@field (bf4ce9@ref bf4ceb@rtd bf4cf0@i bf4ce6@r))) (vector->list (record-type-field-names bf4ceb@rtd)))) (record-type-parent bf4ceb@rtd)) bf4cea@ret))))) (set! bf4da3@bf4c43@record->field-alist bf4c43@record->field-alist) (set! bf4c45@map-with-index (lambda (bf4cfc@proc bf4cfd@lst) (let bf4d06@loop ((bf4d00@i '0) (bf4d01@lst bf4cfd@lst) (bf4d02@ret '())) (if (null? bf4d01@lst) (reverse bf4d02@ret) (bf4d06@loop (+ bf4d00@i '1) (cdr bf4d01@lst) (cons (bf4cfc@proc bf4d00@i (car bf4d01@lst)) bf4d02@ret)))))) (set! bf4da4@bf4c45@map-with-index bf4c45@map-with-index) (set! bf4c47@repl (lambda bf4d08@x (letrec* ((bf4d0b@rec (lambda () (begin (display '"mosh> ") ((call/cc (lambda (bf4d0e@bf4d0c) (lambda () (with-exception-handler (lambda (bf4d10@e) ((call/cc (lambda (bf4d12@bf4d0d) (bf4d0e@bf4d0c (lambda () (if '#t (begin (display '"\nUnhandled exception:\n\n" (current-error-port)) (if (condition? bf4d10@e) (bf4c41@condition-printer/p bf4d10@e (current-error-port)) (format (current-error-port) '"  Non-condition object:\n     ~a\n" bf4d10@e))) (bf4d12@bf4d0d (lambda () (raise-continuable bf4d10@e)))))))))) (lambda () (let bf4d18@loop ((bf4d14@line (get-line (current-input-port))) (bf4d15@accum '"")) (letrec* ((bf4d1b@parentheses-ok? (lambda (bf4d26@text) (let bf4d2e@loop ((bf4d28@chars (string->list bf4d26@text)) (bf4d29@p0 '0) (bf4d2a@p1 '0)) (if (null? bf4d28@chars) (= '0 bf4d29@p0 bf4d2a@p1) (let ((bf4d30@t (car bf4d28@chars))) (if (memv bf4d30@t '(#\()) (bf4d2e@loop (cdr bf4d28@chars) (+ bf4d29@p0 '1) bf4d2a@p1) (if (memv bf4d30@t '(#\))) (bf4d2e@loop (cdr bf4d28@chars) (- bf4d29@p0 '1) bf4d2a@p1) (if (memv bf4d30@t '(#\[)) (bf4d2e@loop (cdr bf4d28@chars) bf4d29@p0 (+ bf4d2a@p1 '1)) (if (memv bf4d30@t '(#\])) (bf4d2e@loop (cdr bf4d28@chars) bf4d29@p0 (- bf4d2a@p1 '1)) (bf4d2e@loop (cdr bf4d28@chars) bf4d29@p0 bf4d2a@p1)))))))))) (bf4d1d@eval-string-print (lambda (bf4d20@text) (if (not (or (string=? '"\n" bf4d20@text) (= '0 (string-length bf4d20@text)))) (call-with-values (lambda () (bf4c55@eval-top-level (call-with-port (open-string-input-port bf4d20@text) read))) (lambda bf4d22@out* (for-each (lambda (bf4d24@out) (begin (write/ss bf4d24@out) (newline))) bf4d22@out*))) (void))))) (if (eof-object? bf4d14@line) (begin (bf4d1d@eval-string-print bf4d15@accum) (exit)) (let ((bf4d1e@current (string-append bf4d15@accum bf4d14@line))) (if (bf4d1b@parentheses-ok? bf4d1e@current) (bf4d1d@eval-string-print bf4d1e@current) (bf4d18@loop (get-line (current-input-port)) bf4d1e@current)))))))))))) (newline) (bf4d0b@rec))))) (bf4d0b@rec)))) (set! bf4da5@bf4c47@repl bf4c47@repl) (set! bf4c49@trace-printer (bf29fb@bf28d9@make-parameter write)) (set! bf4da6@bf4c49@trace-printer bf4c49@trace-printer) (set! bf4c4b@command-line (bf29fb@bf28d9@make-parameter (get-command-line))) (set! bf4da7@bf4c4b@command-line bf4c4b@command-line) (set! bf4c4d@local-library-path (lambda (bf4d32@filename) (bf2cb5@bf2af1@library-path))) (set! bf4da8@bf4c4d@local-library-path bf4c4d@local-library-path) (set! bf4c4f@load/args (lambda (bf4d34@filename . bf4d36@args) (begin (apply bf4c5f@load-r6rs-top-level bf4d34@filename 'load bf4d36@args) (void)))) (set! bf4da9@bf4c4f@load/args bf4c4f@load/args) (set! bf4c51@load (lambda (bf4d38@filename) (begin (apply bf4c5f@load-r6rs-top-level bf4d38@filename 'load (bf4c4b@command-line)) (void)))) (set! bf4daa@bf4c51@load bf4c51@load) (set! bf4c53@ironscheme-build (lambda () (bf4c51@load '"ironscheme-buildscript.ss"))) (set! bf4dab@bf4c53@ironscheme-build bf4c53@ironscheme-build) (set! bf4c55@eval-top-level (lambda (bf4d3a@x) (bf4c12@bf3172@eval bf4d3a@x (bf4c29@bf31a0@interaction-environment)))) (set! bf4dac@bf4c55@eval-top-level bf4c55@eval-top-level) (set! bf4c57@compile-system-libraries (lambda () (bf4c55@eval-top-level '(begin (include "system-libraries.ss") (compile "system-libraries.ss"))))) (set! bf4dad@bf4c57@compile-system-libraries bf4c57@compile-system-libraries) (set! bf4c59@compile (lambda (bf4d3c@filename) (bf4c5f@load-r6rs-top-level bf4d3c@filename 'compile))) (set! bf4dae@bf4c59@compile bf4c59@compile) (set! bf4c5b@compile->closure (lambda (bf4d3e@filename) (bf4c5f@load-r6rs-top-level bf4d3e@filename 'closure))) (set! bf4daf@bf4c5b@compile->closure bf4c5b@compile->closure) (set! bf4c5d@pre-compile-r6rs-file (lambda (bf4d40@filename) (bf4c5f@load-r6rs-top-level bf4d40@filename 'compile))) (set! bf4db0@bf4c5d@pre-compile-r6rs-file bf4c5d@pre-compile-r6rs-file) (set! bf4c5f@load-r6rs-top-level (lambda (bf4d42@filename bf4d43@how . bf4d46@args) (begin (bf2cb5@bf2af1@library-path (bf4c4d@local-library-path bf4d42@filename)) (let ((bf4d48@x* (with-input-from-file bf4d42@filename (lambda () (let bf4d4a@f () (let ((bf4d4c@x (bf29ed@bf28bd@read-annotated))) (if (eof-object? bf4d4c@x) '() (cons bf4d4c@x (bf4d4a@f))))))))) (let ((bf4d4e@t bf4d43@how)) (if (memv bf4d4e@t '(closure)) (bf4c28@bf319e@pre-compile-r6rs-top-level bf4d48@x*) (if (memv bf4d4e@t '(load)) (begin (bf4c4b@command-line (cons bf4d42@filename (car bf4d46@args))) (bf29fc@bf28db@mosh-cache-dir (create-mosh-cache-dir)) (if (bf29fc@bf28db@mosh-cache-dir) (gensym-prefix-set! (bf4c65@prefix-inc! (string-append (bf29fc@bf28db@mosh-cache-dir) '"/prefix.txt"))) (void)) (if (symbol-value '%clean-acc) (for-each (lambda (bf4d50@file) ((call/cc (lambda (bf4d54@bf4d52) (lambda () (with-exception-handler (lambda (bf4d56@c) ((call/cc (lambda (bf4d58@bf4d53) (bf4d54@bf4d52 (lambda () (if '#t '#t (bf4d58@bf4d53 (lambda () (raise-continuable bf4d56@c)))))))))) (lambda () (delete-file (string-append (bf29fc@bf28db@mosh-cache-dir) '"/" bf4d50@file))))))))) (directory-list (bf29fc@bf28db@mosh-cache-dir))) (void)) (let ((bf4d5a@compiled (bf4c27@bf319c@compile-r6rs-top-level bf4d48@x*))) (begin (if (and (bf29fc@bf28db@mosh-cache-dir) (not (symbol-value '%disable-acc))) (bf2cb9@bf2af9@serialize-all bf29f6@bf28cf@serialize-library bf2a52@bf2a0b@compile-core-expr) (void)) (bf4d5a@compiled)))) (if (memv bf4d4e@t '(compile)) (begin (bf4c27@bf319c@compile-r6rs-top-level bf4d48@x*) (bf2cb9@bf2af9@serialize-all bf29f6@bf28cf@serialize-library bf2a52@bf2a0b@compile-core-expr)) (if '#f '#f (void)))))))))) (set! bf4db1@bf4c5f@load-r6rs-top-level bf4c5f@load-r6rs-top-level) (set! bf4c61@load-r6rs-top-level-sexp (lambda (bf4d5c@import-spec bf4d5d@thunk) (let ((bf4d68@bf4d61 bf2cb5@bf2af1@library-path) (bf4d69@bf4d63 bf29fc@bf28db@mosh-cache-dir) (bf4d6a@bf4d65 (bf4c4d@local-library-path '"")) (bf4d6b@bf4d67 (create-mosh-cache-dir))) (let ((bf4d70@swap (lambda () (begin (let ((bf4d72@t (bf4d68@bf4d61))) (begin (bf4d68@bf4d61 bf4d6a@bf4d65) (set! bf4d6a@bf4d65 bf4d72@t))) (let ((bf4d74@t (bf4d69@bf4d63))) (begin (bf4d69@bf4d63 bf4d6b@bf4d67) (set! bf4d6b@bf4d67 bf4d74@t))))))) (dynamic-wind bf4d70@swap (lambda () (begin (if (bf29fc@bf28db@mosh-cache-dir) (gensym-prefix-set! (bf4c65@prefix-inc! (string-append (bf29fc@bf28db@mosh-cache-dir) '"/prefix.txt"))) (void)) (let ((bf4d7a@bf4d77 bf4c4b@command-line) (bf4d7b@bf4d79 '())) (let ((bf4d7e@swap (lambda () (let ((bf4d80@t (bf4d7a@bf4d77))) (begin (bf4d7a@bf4d77 bf4d7b@bf4d79) (set! bf4d7b@bf4d79 bf4d80@t)))))) (dynamic-wind bf4d7e@swap (lambda () ((bf4c27@bf319c@compile-r6rs-top-level (list (cons 'import bf4d5c@import-spec) (list bf4d5d@thunk))))) bf4d7e@swap))))) bf4d70@swap))))) (set! bf4db2@bf4c61@load-r6rs-top-level-sexp bf4c61@load-r6rs-top-level-sexp) (set! bf4c63@prefix-inc (lambda (bf4d82@prefix-string) (let ((bf4d84@prefix (symbol->string bf4d82@prefix-string))) (let ((bf4d86@len (string-length bf4d84@prefix))) (let bf4d8e@loop ((bf4d88@i (- bf4d86@len '1)) (bf4d89@carry? '#t) (bf4d8a@accum '())) (if (< bf4d88@i '0) (string->symbol (list->string (if bf4d89@carry? (cons '#\a bf4d8a@accum) bf4d8a@accum))) (if bf4d89@carry? (let ((bf4d90@next-integer (+ '1 (char->integer (string-ref bf4d84@prefix bf4d88@i))))) (if (= bf4d90@next-integer '123) (bf4d8e@loop (- bf4d88@i '1) '#f (cons '#\A bf4d8a@accum)) (if (= bf4d90@next-integer '91) (bf4d8e@loop (- bf4d88@i '1) '#t (cons '#\a bf4d8a@accum)) (bf4d8e@loop (- bf4d88@i '1) '#f (cons (integer->char bf4d90@next-integer) bf4d8a@accum))))) (bf4d8e@loop (- bf4d88@i '1) '#f (cons (string-ref bf4d84@prefix bf4d88@i) bf4d8a@accum))))))))) (set! bf4db3@bf4c63@prefix-inc bf4c63@prefix-inc) (set! bf4c65@prefix-inc! (lambda (bf4d92@file) (begin (if (not (file-exists? bf4d92@file)) (call-with-output-file bf4d92@file (lambda (bf4d94@port) (write 'd bf4d94@port))) (void)) (let ((bf4d96@prefix (call-with-input-file bf4d92@file read))) (if (main-vm?) (let ((bf4d98@next-prefix (bf4c63@prefix-inc bf4d96@prefix))) (begin (call-with-port (open-file-output-port bf4d92@file (make-file-options '(no-fail)) 'block (native-transcoder)) (lambda (bf4d9a@port) (write bf4d98@next-prefix bf4d9a@port))) bf4d96@prefix)) bf4d96@prefix))))) (set! bf4db4@bf4c65@prefix-inc! bf4c65@prefix-inc!) (begin (bf2cba@bf2afb@current-precompiled-library-loader bf29f7@bf28d1@load-serialized-library) (set-symbol-value! 'load bf4c51@load) (set-symbol-value! 'pre-compile-r6rs-file bf4c5d@pre-compile-r6rs-file) (set-symbol-value! 'eval-r6rs bf4c55@eval-top-level) (set-symbol-value! 'int-env-syms bf4c09@bf3160@interaction-environment-symbols) (set-symbol-value! 'expanded2core bf2a51@bf2a09@expanded->core) (set-symbol-value! 'trace-printer bf4c49@trace-printer) (set-symbol-value! 'compile-r6rs-top-level 'compile-r6rs-top-level) (set-symbol-value! 'create-non-continuable-violation (lambda (bf4c66@c) (condition (make-non-continuable-violation) (make-who-condition 'raise) (make-message-condition '"returned from non-continuable exception") (make-irritants-condition (list bf4c66@c))))) (bf4c3b@parse-and-add-library-path (get-environment-variable '"MOSH_LOADPATH") '"** WARN in environment variable 'MOSH_LOADPATH': directory ~s not exist\n") (bf4c3b@parse-and-add-library-path (symbol-value '%loadpath) '"** WARN in command-line option '--loadpath': directory ~s not exist\n") (if (mosh-executable-path) (if (file-exists? (string-append (mosh-executable-path) '"/lib")) (bf4c39@add-library-path! (string-append (mosh-executable-path) '"/lib")) (void)) (if (file-exists? (string-append (current-directory) '"/lib")) (bf4c39@add-library-path! (string-append (current-directory) '"/lib")) (void))) (if (file-exists? (string-append (standard-library-path) '"/lib")) (bf4c39@add-library-path! (string-append (standard-library-path) '"/lib")) (void)) (let ((bf4c68@prefix (lambda (bf4c6a@ext bf4c6b@ls) (append (map (lambda (bf4c6e@x) (string-append bf4c6a@ext bf4c6e@x)) bf4c6b@ls) bf4c6b@ls)))) (bf2cb6@bf2af3@library-extensions (bf4c68@prefix '".mosh" (bf2cb6@bf2af3@library-extensions)))) (current-exception-handler (lambda (bf4c70@c) (begin (if (condition? bf4c70@c) (bf4c41@condition-printer/p bf4c70@c (current-error-port)) (format (current-error-port) '"\n Non-condition object:\n     ~a\n" bf4c70@c)) bf4c70@c))) (if ((call/cc (lambda (bf4c74@bf4c72) (lambda () (with-exception-handler (lambda (bf4c76@c) ((call/cc (lambda (bf4c78@bf4c73) (bf4c74@bf4c72 (lambda () (if '#t '#f (bf4c78@bf4c73 (lambda () (raise-continuable bf4c76@c)))))))))) (lambda () (symbol-value '%vm-import-spec))))))) (bf4c61@load-r6rs-top-level-sexp (symbol-value '%vm-import-spec) (symbol-value '%vm-thunk)) (if (null? (bf4c4b@command-line)) (let ((bf4c82@bf4c7b bf4c4b@command-line) (bf4c83@bf4c7d bf29fc@bf28db@mosh-cache-dir) (bf4c84@bf4c7f '()) (bf4c85@bf4c81 (create-mosh-cache-dir))) (let ((bf4c8a@swap (lambda () (begin (let ((bf4c8c@t (bf4c82@bf4c7b))) (begin (bf4c82@bf4c7b bf4c84@bf4c7f) (set! bf4c84@bf4c7f bf4c8c@t))) (let ((bf4c8e@t (bf4c83@bf4c7d))) (begin (bf4c83@bf4c7d bf4c85@bf4c81) (set! bf4c85@bf4c81 bf4c8e@t))))))) (dynamic-wind bf4c8a@swap (lambda () (begin (if (bf29fc@bf28db@mosh-cache-dir) (gensym-prefix-set! (bf4c65@prefix-inc! (string-append (bf29fc@bf28db@mosh-cache-dir) '"/prefix.txt"))) (void)) (bf4c47@repl))) bf4c8a@swap))) (begin (bf2cb5@bf2af1@library-path (bf4c4d@local-library-path (car (bf4c4b@command-line)))) (set! bf4c37@x* (with-input-from-file (car (bf4c4b@command-line)) (lambda () (let bf4c90@f () (let ((bf4c92@x (bf29ed@bf28bd@read-annotated))) (if (eof-object? bf4c92@x) '() (cons bf4c92@x (bf4c90@f)))))))) (bf4c4b@command-line (cons (car (bf4c4b@command-line)) (cdr (bf4c4b@command-line)))) (bf29fc@bf28db@mosh-cache-dir (create-mosh-cache-dir)) (if (bf29fc@bf28db@mosh-cache-dir) (gensym-prefix-set! (bf4c65@prefix-inc! (string-append (bf29fc@bf28db@mosh-cache-dir) '"/prefix.txt"))) (void)) (if (symbol-value '%clean-acc) (for-each (lambda (bf4c94@file) ((call/cc (lambda (bf4c98@bf4c96) (lambda () (with-exception-handler (lambda (bf4c9a@c) ((call/cc (lambda (bf4c9c@bf4c97) (bf4c98@bf4c96 (lambda () (if '#t '#t (bf4c9c@bf4c97 (lambda () (raise-continuable bf4c9a@c)))))))))) (lambda () (delete-file (string-append (bf29fc@bf28db@mosh-cache-dir) '"/" bf4c94@file))))))))) (directory-list (bf29fc@bf28db@mosh-cache-dir))) (void)) (let ((bf4c9e@compiled (bf4c27@bf319c@compile-r6rs-top-level bf4c37@x*))) (begin (if (and (bf29fc@bf28db@mosh-cache-dir) (not (symbol-value '%disable-acc))) (bf2cb9@bf2af9@serialize-all bf29f6@bf28cf@serialize-library bf2a52@bf2a0b@compile-core-expr) (void)) (bf4c9e@compiled))))))))
