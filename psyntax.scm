;;; Copyright (c) 2006, 2007 Abdulaziz Ghuloum and Kent Dybvig
;;; automatically generated from psyntax sources
;;; for copyright details, see psyntax/main.ss

(begin (set! f2926@library-file-path->cache-path (unspecified)) (set! f2928@read-annotated (unspecified)) (set! f292a@annotation-stripped (unspecified)) (set! f292c@annotation? (unspecified)) (set! f292e@annotation-source (unspecified)) (set! f2930@annotation-expression (unspecified)) (set! f2932@scm->fasl (unspecified)) (set! f2934@fasl-save (unspecified)) (set! f2936@fasl-load (unspecified)) (set! f2938@verbose? (unspecified)) (set! f293a@serialize-library (unspecified)) (set! f293c@load-serialized-library (unspecified)) (set! f293e@make-record-printer (unspecified)) (set! f2940@compile-core (unspecified)) (set! f2942@read-library-source-file (unspecified)) (set! f2944@make-parameter (unspecified)) (set! f2946@mosh-cache-dir (unspecified)) (set! f29dc@file-options-spec (unspecified)) (set! f2926@library-file-path->cache-path (lambda (f29dd@x) (call-with-values (lambda () (open-string-output-port)) (lambda (f29e3@f29e0 f29e4@f29e2) (let ((f29e7@extract f29e4@f29e2) (f29e8@p f29e3@f29e0)) (letrec* ((f29ec@display-hex (lambda (f29f5@n) (if (<= '0 f29f5@n '9) (display f29f5@n f29e8@p) (display (integer->char (+ (char->integer '#\a) (- f29f5@n '10))) f29e8@p))))) (begin (let f29ef@f ((f29ed@ls (string-split f29dd@x '#\/))) (if (not (null? f29ed@ls)) (begin (display '"_" f29e8@p) (for-each (lambda (f29f1@c) (if (or (char<=? '#\a f29f1@c '#\z) (char<=? '#\A f29f1@c '#\Z) (char<=? '#\0 f29f1@c '#\9) (memv f29f1@c '(#\- #\. #\_ #\~))) (display f29f1@c f29e8@p) (begin (display '"%" f29e8@p) (let ((f29f3@n (char->integer f29f1@c))) (begin (f29ec@display-hex (quotient f29f3@n '16)) (f29ec@display-hex (remainder f29f3@n '16))))))) (string->list (car f29ed@ls))) (f29ef@f (cdr f29ed@ls))) (void))) (f29e7@extract)))))))) (set! f2a57@f2926@library-file-path->cache-path f2926@library-file-path->cache-path) (set! f2928@read-annotated read) (set! f2a58@f2928@read-annotated f2928@read-annotated) (set! f292a@annotation-stripped (lambda (f29f7@x) (f2930@annotation-expression f29f7@x))) (set! f2a59@f292a@annotation-stripped f292a@annotation-stripped) (set! f292c@annotation? (lambda (f29f9@x) (source-info f29f9@x))) (set! f2a5a@f292c@annotation? f292c@annotation?) (set! f292e@annotation-source (lambda (f29fb@x) (source-info f29fb@x))) (set! f2a5b@f292e@annotation-source f292e@annotation-source) (set! f2930@annotation-expression (lambda (f29fd@x) (if (pair? f29fd@x) (cons (car f29fd@x) (cdr f29fd@x)) (if (procedure? f29fd@x) (set-source-info! f29fd@x '#f) f29fd@x)))) (set! f2a5c@f2930@annotation-expression f2930@annotation-expression) (set! f2932@scm->fasl (lambda (f29ff@filename) (string-append (f2946@mosh-cache-dir) '"/" (f2926@library-file-path->cache-path f29ff@filename) '".mosh-fasl"))) (set! f2a5d@f2932@scm->fasl f2932@scm->fasl) (set! f2934@fasl-save (lambda (f2a01@filename f2a02@obj) (call-with-port (open-file-output-port f2a01@filename) (lambda (f2a05@port) ((symbol-value 'fasl-write!) f2a02@obj f2a05@port))))) (set! f2a5e@f2934@fasl-save f2934@fasl-save) (set! f2936@fasl-load (lambda (f2a07@filename) (call-with-port (open-file-input-port f2a07@filename) (symbol-value 'fasl-read!)))) (set! f2a5f@f2936@fasl-load f2936@fasl-load) (set! f2938@verbose? (symbol-value '%verbose)) (set! f2a60@f2938@verbose? f2938@verbose?) (set! f293a@serialize-library (lambda (f2a09@filename f2a0a@obj) (begin (if f2938@verbose? (format (current-error-port) '"serialize-library ~a\n..." f2a09@filename) (void)) (let ((f2a0d@expanded2core (symbol-value 'expanded2core))) (let ((f2a0f@compile (symbol-value 'compile-w/o-halt))) (let ((f2a11@code f2a0a@obj)) (let ((f2a13@pivot (cddddr (cddddr f2a11@code)))) (let ((f2a15@visit (f2a0f@compile (f2a0d@expanded2core (car f2a13@pivot))))) (begin (set-car! f2a13@pivot f2a15@visit) (let ((f2a17@pivot (cdr f2a13@pivot))) (let ((f2a19@invoke (f2a0f@compile (f2a0d@expanded2core (car f2a17@pivot))))) (set-car! f2a17@pivot f2a19@invoke))))))))) (let ((f2a1b@fasl-file (f2932@scm->fasl f2a09@filename))) (begin (if (file-exists? f2a1b@fasl-file) (delete-file f2a1b@fasl-file) (void)) ((call/cc (lambda (f2a1f@f2a1d) (lambda () (with-exception-handler (lambda (f2a21@c) ((call/cc (lambda (f2a23@f2a1e) (f2a1f@f2a1d (lambda () (if '#t (begin (if f2938@verbose? (format (current-error-port) '"Warning:serialize-library failed ~a\n" f2a09@filename) (void)) (if (file-exists? f2a1b@fasl-file) (delete-file f2a1b@fasl-file) (void)) '#f) (f2a23@f2a1e (lambda () (raise-continuable f2a21@c)))))))))) (lambda () (f2934@fasl-save f2a1b@fasl-file f2a0a@obj)))))))))))) (set! f2a61@f293a@serialize-library f293a@serialize-library) (set! f293c@load-serialized-library (lambda (f2a25@filename f2a26@obj) (and (f2946@mosh-cache-dir) (let ((f2a29@fasl-file (f2932@scm->fasl f2a25@filename))) (if (and (file-exists? f2a29@fasl-file) ((symbol-value 'file-newer?) f2a29@fasl-file f2a25@filename)) (let ((f2a2b@expanded2core (symbol-value 'expanded2core))) (let ((f2a2d@eval-compiled-core (symbol-value 'eval-compiled!))) (let ((f2a2f@code (f2936@fasl-load f2a29@fasl-file))) (let ((f2a31@pivot (cddddr (cddddr f2a2f@code)))) (let ((f2a33@visit (car f2a31@pivot))) (let ((f2a35@visit-proc (lambda () (f2a2d@eval-compiled-core f2a33@visit)))) (begin (set-car! f2a31@pivot f2a35@visit-proc) (let ((f2a37@pivot (cdr f2a31@pivot))) (let ((f2a39@invoke (car f2a37@pivot))) (begin (set-car! f2a37@pivot (lambda () (f2a2d@eval-compiled-core f2a39@invoke))) (apply f2a26@obj f2a2f@code))))))))))) '#f))))) (set! f2a62@f293c@load-serialized-library f293c@load-serialized-library) (set! f293e@make-record-printer (lambda (f2a3b@name f2a3c@printer) (lambda f2a3f@x (begin (display '"record printer") (for-each display f2a3f@x))))) (set! f2a63@f293e@make-record-printer f293e@make-record-printer) (set! f2940@compile-core (lambda f2a41@x (apply error 'comile-core '"not implementated" f2a41@x))) (set! f2a64@f2940@compile-core f2940@compile-core) (set! f2942@read-library-source-file (lambda (f2a43@file-name) (with-input-from-file f2a43@file-name f2928@read-annotated))) (set! f2a65@f2942@read-library-source-file f2942@read-library-source-file) (set! f2944@make-parameter (lambda f2a53 (let ((f2a54 (length f2a53))) (if (= f2a54 '1) (apply (lambda (f2a45@x) (f2944@make-parameter f2a45@x (lambda (f2a47@x) f2a47@x))) f2a53) (if (= f2a54 '2) (apply (lambda (f2a49@x f2a4a@fender) (let ((f2a4d@x (f2a4a@fender f2a49@x))) (lambda f2a51 (let ((f2a52 (length f2a51))) (if (= f2a52 '0) (apply (lambda () f2a4d@x) f2a51) (if (= f2a52 '1) (apply (lambda (f2a4f@v) (set! f2a4d@x (f2a4a@fender f2a4f@v))) f2a51) (error 'apply '"invalid arg count"))))))) f2a53) (error 'apply '"invalid arg count")))))) (set! f2a66@f2944@make-parameter f2944@make-parameter) (set! f2946@mosh-cache-dir (f2944@make-parameter '#f)) (set! f2a67@f2946@mosh-cache-dir f2946@mosh-cache-dir) (set! f29dc@file-options-spec (lambda (f2a55@x) f2a55@x)) (set! f2a68@f29dc@file-options-spec f29dc@file-options-spec) (void))
(begin (set! f2a6e@current-primitive-locations (unspecified)) (set! f2a70@mutable? (unspecified)) (set! f2a72@rewriter (unspecified)) (set! f2a74@expanded->core (unspecified)) (set! f2a76@compile-core-expr (unspecified)) (set! f2a78@pretty-print (unspecified)) (set! f2a7a@compile-core-expr-to-port (unspecified)) (set! f2a6e@current-primitive-locations (f2a66@f2944@make-parameter (lambda (f2a7b@x) '#f) (lambda (f2a7d@p) f2a7d@p))) (set! f2ab9@f2a6e@current-primitive-locations f2a6e@current-primitive-locations) (set! f2a70@mutable? (lambda (f2a7f@x) (or (pair? f2a7f@x) (vector? f2a7f@x) (hashtable? f2a7f@x)))) (set! f2aba@f2a70@mutable? f2a70@mutable?) (set! f2a72@rewriter (lambda (f2a81@quote-hack?) (letrec* ((f2a84@f (lambda (f2a85@x) (if (pair? f2a85@x) (let ((f2a87@t (car f2a85@x))) (if (memv f2a87@t '(quote)) (if (and f2a81@quote-hack? (f2a70@mutable? (cadr f2a85@x))) (let ((f2a89@g (gensym))) (begin (set-symbol-value! f2a89@g (cadr f2a85@x)) f2a89@g)) f2a85@x) (if (memv f2a87@t '(case-lambda)) (cons 'case-lambda (map (lambda (f2a8b@x) (cons (car f2a8b@x) (map f2a84@f (cdr f2a8b@x)))) (cdr f2a85@x))) (if (memv f2a87@t '(lambda)) (cons* 'lambda (cadr f2a85@x) (map f2a84@f (cddr f2a85@x))) (if (memv f2a87@t '(letrec)) (let ((f2a8d@bindings (cadr f2a85@x)) (f2a8e@body* (cddr f2a85@x))) (let ((f2a91@lhs* (map car f2a8d@bindings)) (f2a92@rhs* (map cadr f2a8d@bindings))) (cons* 'letrec (map list f2a91@lhs* (map f2a84@f f2a92@rhs*)) (map f2a84@f f2a8e@body*)))) (if (memv f2a87@t '(letrec*)) (let ((f2a95@bindings (cadr f2a85@x)) (f2a96@body* (cddr f2a85@x))) (let ((f2a99@lhs* (map car f2a95@bindings)) (f2a9a@rhs* (map cadr f2a95@bindings))) (cons* 'letrec* (map list f2a99@lhs* (map f2a84@f f2a9a@rhs*)) (map f2a84@f f2a96@body*)))) (if (memv f2a87@t '(library-letrec*)) (let ((f2a9d@name (cadr f2a85@x)) (f2a9e@x (cdr f2a85@x))) (let ((f2aa1@bindings (cadr f2a9e@x)) (f2aa2@body* (cddr f2a9e@x))) (let ((f2aa5@lhs* (map car f2aa1@bindings)) (f2aa6@lhs** (map cadr f2aa1@bindings)) (f2aa7@rhs* (map caddr f2aa1@bindings))) (cons* 'library-letrec* f2a9d@name (map list f2aa5@lhs* f2aa6@lhs** (map f2a84@f f2aa7@rhs*)) (map f2a84@f f2aa2@body*))))) (if (memv f2a87@t '(begin)) (cons 'begin (map f2a84@f (cdr f2a85@x))) (if (memv f2a87@t '(set!)) (list 'set! (cadr f2a85@x) (f2a84@f (caddr f2a85@x))) (if (memv f2a87@t '(primitive)) (let ((f2aab@op (cadr f2a85@x))) (let ((f2aad@t ((f2a6e@current-primitive-locations) f2aab@op))) (if f2aad@t ((lambda (f2aaf@loc) f2aaf@loc) f2aad@t) f2aab@op))) (if (memv f2a87@t '(define)) f2a85@x (if (list? f2a85@x) (map f2a84@f f2a85@x) (error 'rewrite '"invalid form ~s ~s" f2a85@x (list? f2a85@x)))))))))))))) f2a85@x)))) f2a84@f))) (set! f2abb@f2a72@rewriter f2a72@rewriter) (set! f2a74@expanded->core (lambda (f2ab1@x) ((f2a72@rewriter '#f) f2ab1@x))) (set! f2abc@f2a74@expanded->core f2a74@expanded->core) (set! f2a76@compile-core-expr (lambda (f2ab3@x) ((f2a72@rewriter '#f) f2ab3@x))) (set! f2abd@f2a76@compile-core-expr f2a76@compile-core-expr) (set! f2a78@pretty-print write) (set! f2abe@f2a78@pretty-print f2a78@pretty-print) (set! f2a7a@compile-core-expr-to-port (lambda (f2ab5@x f2ab6@p) (f2a78@pretty-print ((f2a72@rewriter '#f) f2ab5@x) f2ab6@p))) (set! f2abf@f2a7a@compile-core-expr-to-port f2a7a@compile-core-expr-to-port) (void))
(begin (void))
(begin (set! f2b0e@make-collection (unspecified)) (set! f2b10@current-library-collection (unspecified)) (set! f2b12@rp (unspecified)) (set! f2b1c@library? (unspecified)) (set! f2b1e@library-id (unspecified)) (set! f2b20@set-library-id! (unspecified)) (set! f2b22@library-name (unspecified)) (set! f2b24@set-library-name! (unspecified)) (set! f2b26@library-version (unspecified)) (set! f2b28@set-library-version! (unspecified)) (set! f2b2a@library-imp* (unspecified)) (set! f2b2c@set-library-imp*! (unspecified)) (set! f2b2e@library-vis* (unspecified)) (set! f2b30@set-library-vis*! (unspecified)) (set! f2b32@library-inv* (unspecified)) (set! f2b34@set-library-inv*! (unspecified)) (set! f2b36@library-subst (unspecified)) (set! f2b38@set-library-subst! (unspecified)) (set! f2b3a@library-env (unspecified)) (set! f2b3c@set-library-env! (unspecified)) (set! f2b3e@library-visit-state (unspecified)) (set! f2b40@set-library-visit-state! (unspecified)) (set! f2b42@library-invoke-state (unspecified)) (set! f2b44@set-library-invoke-state! (unspecified)) (set! f2b46@library-visit-code (unspecified)) (set! f2b48@set-library-visit-code! (unspecified)) (set! f2b4a@library-invoke-code (unspecified)) (set! f2b4c@set-library-invoke-code! (unspecified)) (set! f2b4e@library-visible? (unspecified)) (set! f2b50@set-library-visible?! (unspecified)) (set! f2b52@library-source-file-name (unspecified)) (set! f2b54@set-library-source-file-name! (unspecified)) (set! f2b56@dummy (unspecified)) (set! f2b58@find-dependencies (unspecified)) (set! f2b5a@find-library-by (unspecified)) (set! f2b5c@library-path (unspecified)) (set! f2b5e@library-extensions (unspecified)) (set! f2b60@library-name->file-name (unspecified)) (set! f2b62@file-locator (unspecified)) (set! f2b64@serialize-all (unspecified)) (set! f2b66@current-precompiled-library-loader (unspecified)) (set! f2b68@try-load-from-file (unspecified)) (set! f2b6a@library-loader (unspecified)) (set! f2b6c@current-library-expander (unspecified)) (set! f2b6e@external-pending-libraries (unspecified)) (set! f2b70@find-external-library (unspecified)) (set! f2b72@find-library-by-name (unspecified)) (set! f2b74@library-exists? (unspecified)) (set! f2b76@find-library-by-spec/die (unspecified)) (set! f2b78@label->binding-table (unspecified)) (set! f2b7a@install-library-record (unspecified)) (set! f2b7c@install-library (unspecified)) (set! f2b7e@imported-label->binding (unspecified)) (set! f2b80@invoke-library (unspecified)) (set! f2b82@visit-library (unspecified)) (set! f2b84@invoke-library-by-spec (unspecified)) (set! f2b86@installed-libraries (unspecified)) (set! f2b88@library-spec (unspecified)) (set! f2b0e@make-collection (lambda () (let ((f2b89@set '())) (letrec* ((f2b8c@set-cons (lambda (f2b91@x f2b92@ls) (if (memq f2b91@x f2b92@ls) f2b92@ls (cons f2b91@x f2b92@ls))))) (lambda f2b8f (let ((f2b90 (length f2b8f))) (if (= f2b90 '0) (apply (lambda () f2b89@set) f2b8f) (if (= f2b90 '1) (apply (lambda (f2b8d@x) (set! f2b89@set (f2b8c@set-cons f2b8d@x f2b89@set))) f2b8f) (error 'apply '"invalid arg count"))))))))) (set! f2cfd@f2b0e@make-collection f2b0e@make-collection) (set! f2b10@current-library-collection (f2a66@f2944@make-parameter (f2b0e@make-collection) (lambda (f2b95@x) (begin (if (not (procedure? f2b95@x)) (assertion-violation 'current-library-collection '"not a procedure" f2b95@x) (void)) f2b95@x)))) (set! f2cfe@f2b10@current-library-collection f2b10@current-library-collection) (set! f2b12@rp (f2a63@f293e@make-record-printer 'library (lambda (f2b97@x f2b98@p f2b99@wr) (begin (if (not (f2b1c@library? f2b97@x)) (assertion-violation 'record-type-printer '"not a library") (void)) (display (format '"#<library ~s>" (if (null? (f2b26@library-version f2b97@x)) (f2b22@library-name f2b97@x) (append (f2b22@library-name f2b97@x) (list (f2b26@library-version f2b97@x))))) f2b98@p))))) (set! f2cff@f2b12@rp f2b12@rp) (set! f2b1c@library? (lambda (f2b9d@x) (and (simple-struct? f2b9d@x) (eq? (simple-struct-name f2b9d@x) 'library)))) (set! f2d00@f2b1c@library? f2b1c@library?) (set! f2b1e@library-id (lambda (f2b9f@x) (simple-struct-ref f2b9f@x '0))) (set! f2d01@f2b1e@library-id f2b1e@library-id) (set! f2b20@set-library-id! (lambda (f2ba1@x f2ba2@val) (simple-struct-set! f2ba1@x '0 f2ba2@val))) (set! f2d02@f2b20@set-library-id! f2b20@set-library-id!) (set! f2b22@library-name (lambda (f2ba5@x) (simple-struct-ref f2ba5@x '1))) (set! f2d03@f2b22@library-name f2b22@library-name) (set! f2b24@set-library-name! (lambda (f2ba7@x f2ba8@val) (simple-struct-set! f2ba7@x '1 f2ba8@val))) (set! f2d04@f2b24@set-library-name! f2b24@set-library-name!) (set! f2b26@library-version (lambda (f2bab@x) (simple-struct-ref f2bab@x '2))) (set! f2d05@f2b26@library-version f2b26@library-version) (set! f2b28@set-library-version! (lambda (f2bad@x f2bae@val) (simple-struct-set! f2bad@x '2 f2bae@val))) (set! f2d06@f2b28@set-library-version! f2b28@set-library-version!) (set! f2b2a@library-imp* (lambda (f2bb1@x) (simple-struct-ref f2bb1@x '3))) (set! f2d07@f2b2a@library-imp* f2b2a@library-imp*) (set! f2b2c@set-library-imp*! (lambda (f2bb3@x f2bb4@val) (simple-struct-set! f2bb3@x '3 f2bb4@val))) (set! f2d08@f2b2c@set-library-imp*! f2b2c@set-library-imp*!) (set! f2b2e@library-vis* (lambda (f2bb7@x) (simple-struct-ref f2bb7@x '4))) (set! f2d09@f2b2e@library-vis* f2b2e@library-vis*) (set! f2b30@set-library-vis*! (lambda (f2bb9@x f2bba@val) (simple-struct-set! f2bb9@x '4 f2bba@val))) (set! f2d0a@f2b30@set-library-vis*! f2b30@set-library-vis*!) (set! f2b32@library-inv* (lambda (f2bbd@x) (simple-struct-ref f2bbd@x '5))) (set! f2d0b@f2b32@library-inv* f2b32@library-inv*) (set! f2b34@set-library-inv*! (lambda (f2bbf@x f2bc0@val) (simple-struct-set! f2bbf@x '5 f2bc0@val))) (set! f2d0c@f2b34@set-library-inv*! f2b34@set-library-inv*!) (set! f2b36@library-subst (lambda (f2bc3@x) (simple-struct-ref f2bc3@x '6))) (set! f2d0d@f2b36@library-subst f2b36@library-subst) (set! f2b38@set-library-subst! (lambda (f2bc5@x f2bc6@val) (simple-struct-set! f2bc5@x '6 f2bc6@val))) (set! f2d0e@f2b38@set-library-subst! f2b38@set-library-subst!) (set! f2b3a@library-env (lambda (f2bc9@x) (simple-struct-ref f2bc9@x '7))) (set! f2d0f@f2b3a@library-env f2b3a@library-env) (set! f2b3c@set-library-env! (lambda (f2bcb@x f2bcc@val) (simple-struct-set! f2bcb@x '7 f2bcc@val))) (set! f2d10@f2b3c@set-library-env! f2b3c@set-library-env!) (set! f2b3e@library-visit-state (lambda (f2bcf@x) (simple-struct-ref f2bcf@x '8))) (set! f2d11@f2b3e@library-visit-state f2b3e@library-visit-state) (set! f2b40@set-library-visit-state! (lambda (f2bd1@x f2bd2@val) (simple-struct-set! f2bd1@x '8 f2bd2@val))) (set! f2d12@f2b40@set-library-visit-state! f2b40@set-library-visit-state!) (set! f2b42@library-invoke-state (lambda (f2bd5@x) (simple-struct-ref f2bd5@x '9))) (set! f2d13@f2b42@library-invoke-state f2b42@library-invoke-state) (set! f2b44@set-library-invoke-state! (lambda (f2bd7@x f2bd8@val) (simple-struct-set! f2bd7@x '9 f2bd8@val))) (set! f2d14@f2b44@set-library-invoke-state! f2b44@set-library-invoke-state!) (set! f2b46@library-visit-code (lambda (f2bdb@x) (simple-struct-ref f2bdb@x '10))) (set! f2d15@f2b46@library-visit-code f2b46@library-visit-code) (set! f2b48@set-library-visit-code! (lambda (f2bdd@x f2bde@val) (simple-struct-set! f2bdd@x '10 f2bde@val))) (set! f2d16@f2b48@set-library-visit-code! f2b48@set-library-visit-code!) (set! f2b4a@library-invoke-code (lambda (f2be1@x) (simple-struct-ref f2be1@x '11))) (set! f2d17@f2b4a@library-invoke-code f2b4a@library-invoke-code) (set! f2b4c@set-library-invoke-code! (lambda (f2be3@x f2be4@val) (simple-struct-set! f2be3@x '11 f2be4@val))) (set! f2d18@f2b4c@set-library-invoke-code! f2b4c@set-library-invoke-code!) (set! f2b4e@library-visible? (lambda (f2be7@x) (simple-struct-ref f2be7@x '12))) (set! f2d19@f2b4e@library-visible? f2b4e@library-visible?) (set! f2b50@set-library-visible?! (lambda (f2be9@x f2bea@val) (simple-struct-set! f2be9@x '12 f2bea@val))) (set! f2d1a@f2b50@set-library-visible?! f2b50@set-library-visible?!) (set! f2b52@library-source-file-name (lambda (f2bed@x) (simple-struct-ref f2bed@x '13))) (set! f2d1b@f2b52@library-source-file-name f2b52@library-source-file-name) (set! f2b54@set-library-source-file-name! (lambda (f2bef@x f2bf0@val) (simple-struct-set! f2bef@x '13 f2bf0@val))) (set! f2d1c@f2b54@set-library-source-file-name! f2b54@set-library-source-file-name!) (set! f2b56@dummy '3) (set! f2d1d@f2b56@dummy f2b56@dummy) (set! f2b58@find-dependencies (lambda (f2bf3@ls) (if (null? f2bf3@ls) '() (assertion-violation 'find-dependencies '"cannot handle deps yet")))) (set! f2d1e@f2b58@find-dependencies f2b58@find-dependencies) (set! f2b5a@find-library-by (lambda (f2bf5@pred) (let f2bf9@f ((f2bf7@ls ((f2b10@current-library-collection)))) (if (null? f2bf7@ls) '#f (if (f2bf5@pred (car f2bf7@ls)) (car f2bf7@ls) (f2bf9@f (cdr f2bf7@ls))))))) (set! f2d1f@f2b5a@find-library-by f2b5a@find-library-by) (set! f2b5c@library-path (f2a66@f2944@make-parameter '(".") (lambda (f2bfb@x) (if (and (list? f2bfb@x) (for-all string? f2bfb@x)) (map (lambda (f2bfd@x) f2bfd@x) f2bfb@x) (assertion-violation 'library-path '"not a list of strings" f2bfb@x))))) (set! f2d20@f2b5c@library-path f2b5c@library-path) (set! f2b5e@library-extensions (f2a66@f2944@make-parameter '(".sls" ".ss" ".scm") (lambda (f2bff@x) (if (and (list? f2bff@x) (for-all string? f2bff@x)) (map (lambda (f2c01@x) f2c01@x) f2bff@x) (assertion-violation 'library-extensions '"not a list of strings" f2bff@x))))) (set! f2d21@f2b5e@library-extensions f2b5e@library-extensions) (set! f2b60@library-name->file-name (lambda (f2c03@x) (call-with-values (lambda () (open-string-output-port)) (lambda (f2c09@f2c06 f2c0a@f2c08) (let ((f2c0d@extract f2c0a@f2c08) (f2c0e@p f2c09@f2c06)) (letrec* ((f2c12@display-hex (lambda (f2c1b@n) (if (<= '0 f2c1b@n '9) (display f2c1b@n f2c0e@p) (display (integer->char (+ (char->integer '#\a) (- f2c1b@n '10))) f2c0e@p))))) (begin (let f2c15@f ((f2c13@ls f2c03@x)) (if (not (null? f2c13@ls)) (begin (display '"/" f2c0e@p) (for-each (lambda (f2c17@c) (if (or (char<=? '#\a f2c17@c '#\z) (char<=? '#\A f2c17@c '#\Z) (char<=? '#\0 f2c17@c '#\9) (memv f2c17@c '(#\- #\. #\_ #\~))) (display f2c17@c f2c0e@p) (begin (display '"%" f2c0e@p) (let ((f2c19@n (char->integer f2c17@c))) (begin (f2c12@display-hex (quotient f2c19@n '16)) (f2c12@display-hex (remainder f2c19@n '16))))))) (string->list (symbol->string (car f2c13@ls)))) (f2c15@f (cdr f2c13@ls))) (void))) (f2c0d@extract)))))))) (set! f2d22@f2b60@library-name->file-name f2b60@library-name->file-name) (set! f2b62@file-locator (f2a66@f2944@make-parameter (lambda (f2c1d@x) (let ((f2c1f@str (f2b60@library-name->file-name f2c1d@x))) (let f2c27@f ((f2c21@ls (f2b5c@library-path)) (f2c22@exts (f2b5e@library-extensions)) (f2c23@failed-list '())) (if (null? f2c21@ls) (letrec* ((f2c31@f2c2c (make-record-type-descriptor '&library-resolution &condition-rtd 'f2c2f '#f '#f '#((immutable library) (immutable files)))) (f2c33@f2c2e '#f) (f2c35@f2c2d (make-record-constructor-descriptor f2c31@f2c2c &condition-rcd f2c33@f2c2e)) (f2c38@f2c2b (record-predicate f2c31@f2c2c)) (f2c3a@make-library-resolution-condition (record-constructor f2c35@f2c2d)) (f2c3c@f2c29 (record-accessor f2c31@f2c2c '0)) (f2c3e@f2c2a (record-accessor f2c31@f2c2c '1)) (f2c40@library-resolution-condition? (condition-predicate f2c31@f2c2c)) (f2c42@condition-library (condition-accessor f2c31@f2c2c f2c3c@f2c29)) (f2c44@condition-files (condition-accessor f2c31@f2c2c f2c3e@f2c2a))) (raise (condition (make-error) (make-who-condition 'expander) (make-message-condition '"cannot locate library in library-path") (f2c3a@make-library-resolution-condition f2c1d@x (reverse f2c23@failed-list))))) (if (null? f2c22@exts) (f2c27@f (cdr f2c21@ls) (f2b5e@library-extensions) f2c23@failed-list) (let ((f2c45@name (string-append (car f2c21@ls) f2c1f@str (car f2c22@exts)))) (if (file-exists? f2c45@name) f2c45@name (f2c27@f f2c21@ls (cdr f2c22@exts) (cons f2c45@name f2c23@failed-list))))))))) (lambda (f2c47@f) (if (procedure? f2c47@f) f2c47@f (assertion-violation 'file-locator '"not a procedure" f2c47@f))))) (set! f2d23@f2b62@file-locator f2b62@file-locator) (set! f2b64@serialize-all (lambda (f2c49@serialize f2c4a@compile) (letrec* ((f2c4e@library-desc (lambda (f2c51@x) (list (f2b1e@library-id f2c51@x) (f2b22@library-name f2c51@x))))) (for-each (lambda (f2c4f@x) (if (f2b52@library-source-file-name f2c4f@x) (f2c49@serialize (f2b52@library-source-file-name f2c4f@x) (list (f2b1e@library-id f2c4f@x) (f2b22@library-name f2c4f@x) (f2b26@library-version f2c4f@x) (map f2c4e@library-desc (f2b2a@library-imp* f2c4f@x)) (map f2c4e@library-desc (f2b2e@library-vis* f2c4f@x)) (map f2c4e@library-desc (f2b32@library-inv* f2c4f@x)) (f2b36@library-subst f2c4f@x) (f2b3a@library-env f2c4f@x) (f2c4a@compile (f2b46@library-visit-code f2c4f@x)) (f2c4a@compile (f2b4a@library-invoke-code f2c4f@x)) (f2b4e@library-visible? f2c4f@x))) (void))) ((f2b10@current-library-collection)))))) (set! f2d24@f2b64@serialize-all f2b64@serialize-all) (set! f2b66@current-precompiled-library-loader (f2a66@f2944@make-parameter (lambda (f2c53@filename f2c54@sk) '#f))) (set! f2d25@f2b66@current-precompiled-library-loader f2b66@current-precompiled-library-loader) (set! f2b68@try-load-from-file (lambda (f2c57@filename) ((f2b66@current-precompiled-library-loader) f2c57@filename (lambda f2c7d (let ((f2c7e (length f2c7d))) (if (= f2c7e '11) (apply (lambda (f2c59@id f2c5a@name f2c5b@ver f2c5c@imp* f2c5d@vis* f2c5e@inv* f2c5f@exp-subst f2c60@exp-env f2c61@visit-proc f2c62@invoke-proc f2c63@visible?) (let f2c71@f ((f2c6f@deps (append f2c5c@imp* f2c5d@vis* f2c5e@inv*))) (if (null? f2c6f@deps) (begin (f2b7c@install-library f2c59@id f2c5a@name f2c5b@ver f2c5c@imp* f2c5d@vis* f2c5e@inv* f2c5f@exp-subst f2c60@exp-env f2c61@visit-proc f2c62@invoke-proc '#f '#f f2c63@visible? '#f) '#t) (let ((f2c73@d (car f2c6f@deps))) (let ((f2c75@label (car f2c73@d)) (f2c76@dname (cadr f2c73@d))) (let ((f2c79@l (f2b72@find-library-by-name f2c76@dname))) (if (and (f2b1c@library? f2c79@l) (eq? f2c75@label (f2b1e@library-id f2c79@l))) (f2c71@f (cdr f2c6f@deps)) (begin (if f2a60@f2938@verbose? (format (current-error-port) '"WARNING: library ~e has an inconsistent dependency on library ~e; file ~e will be recompiled from source. \n" f2c5a@name f2c76@dname f2c57@filename) (void)) '#f)))))))) f2c7d) (if (>= f2c7e '0) (apply (lambda f2c7b@others '#f) f2c7d) (error 'apply '"invalid arg count")))))))) (set! f2d26@f2b68@try-load-from-file f2b68@try-load-from-file) (set! f2b6a@library-loader (f2a66@f2944@make-parameter (lambda (f2c7f@x) (let ((f2c81@file-name ((f2b62@file-locator) f2c7f@x))) (if (not f2c81@file-name) (assertion-violation '#f '"cannot file library" f2c7f@x) (or (f2b68@try-load-from-file f2c81@file-name) ((f2b6c@current-library-expander) (f2a65@f2942@read-library-source-file f2c81@file-name) f2c81@file-name (lambda (f2c83@name) (if (not (fast-equal? f2c83@name f2c7f@x)) (assertion-violation 'import (call-with-values (lambda () (open-string-output-port)) (lambda (f2c89@f2c86 f2c8a@f2c88) (let ((f2c8d@e f2c8a@f2c88) (f2c8e@p f2c89@f2c86)) (begin (display '"expected to find library " f2c8e@p) (write f2c7f@x f2c8e@p) (display '" in file " f2c8e@p) (display f2c81@file-name f2c8e@p) (display '", found " f2c8e@p) (write f2c83@name f2c8e@p) (display '" instead" f2c8e@p) (f2c8d@e)))))) (void)))))))) (lambda (f2c91@f) (if (procedure? f2c91@f) f2c91@f (assertion-violation 'library-locator '"not a procedure" f2c91@f))))) (set! f2d27@f2b6a@library-loader f2b6a@library-loader) (set! f2b6c@current-library-expander (f2a66@f2944@make-parameter (lambda (f2c93@x) (assertion-violation 'library-expander '"not initialized")) (lambda (f2c95@f) (if (procedure? f2c95@f) f2c95@f (assertion-violation 'library-expander '"not a procedure" f2c95@f))))) (set! f2d28@f2b6c@current-library-expander f2b6c@current-library-expander) (set! f2b6e@external-pending-libraries (f2a66@f2944@make-parameter '())) (set! f2d29@f2b6e@external-pending-libraries f2b6e@external-pending-libraries) (set! f2b70@find-external-library (lambda (f2c97@name) (begin (if (member f2c97@name (f2b6e@external-pending-libraries)) (assertion-violation '#f '"circular attempt to import library was detected" f2c97@name) (void)) (let ((f2c9d@f2c9a f2b6e@external-pending-libraries) (f2c9e@f2c9c (cons f2c97@name (f2b6e@external-pending-libraries)))) (let ((f2ca1@swap (lambda () (let ((f2ca3@t (f2c9d@f2c9a))) (begin (f2c9d@f2c9a f2c9e@f2c9c) (set! f2c9e@f2c9c f2ca3@t)))))) (dynamic-wind f2ca1@swap (lambda () (begin ((f2b6a@library-loader) f2c97@name) (or (f2b5a@find-library-by (lambda (f2ca5@x) (fast-equal? (f2b22@library-name f2ca5@x) f2c97@name))) (assertion-violation '#f '"handling external library did not yield the correct library" f2c97@name)))) f2ca1@swap)))))) (set! f2d2a@f2b70@find-external-library f2b70@find-external-library) (set! f2b72@find-library-by-name (lambda (f2ca7@name) (or (f2b5a@find-library-by (lambda (f2ca9@x) (fast-equal? (f2b22@library-name f2ca9@x) f2ca7@name))) (f2b70@find-external-library f2ca7@name)))) (set! f2d2b@f2b72@find-library-by-name f2b72@find-library-by-name) (set! f2b74@library-exists? (lambda (f2cab@name) (and (f2b5a@find-library-by (lambda (f2cad@x) (fast-equal? (f2b22@library-name f2cad@x) f2cab@name))) '#t))) (set! f2d2c@f2b74@library-exists? f2b74@library-exists?) (set! f2b76@find-library-by-spec/die (lambda (f2caf@spec) (let ((f2cb1@id (car f2caf@spec))) (or (f2b5a@find-library-by (lambda (f2cb3@x) (eq? f2cb1@id (f2b1e@library-id f2cb3@x)))) (assertion-violation '#f '"cannot find library with required spec" f2caf@spec))))) (set! f2d2d@f2b76@find-library-by-spec/die f2b76@find-library-by-spec/die) (set! f2b78@label->binding-table (make-eq-hashtable)) (set! f2d2e@f2b78@label->binding-table f2b78@label->binding-table) (set! f2b7a@install-library-record (lambda (f2cb5@lib) (begin (let ((f2cb7@exp-env (f2b3a@library-env f2cb5@lib))) (for-each (lambda (f2cb9@x) (let ((f2cbb@label (car f2cb9@x)) (f2cbc@binding (cdr f2cb9@x))) (let ((f2cbf@binding (let ((f2cc1@t (car f2cbc@binding))) (if (memv f2cc1@t '(global)) (cons 'global (cons f2cb5@lib (cdr f2cbc@binding))) (if (memv f2cc1@t '(global-macro)) (cons 'global-macro (cons f2cb5@lib (cdr f2cbc@binding))) (if (memv f2cc1@t '(global-macro!)) (cons 'global-macro! (cons f2cb5@lib (cdr f2cbc@binding))) f2cbc@binding)))))) (begin (if (hashtable-ref f2b78@label->binding-table f2cbb@label '#f) (begin (format (current-error-port) '"FATAL overwrite !! key=~a value=~a to ~a\n" f2cbb@label (hashtable-ref f2b78@label->binding-table f2cbb@label '#f) f2cbf@binding) (exit)) (void)) (hashtable-set! f2b78@label->binding-table f2cbb@label f2cbf@binding))))) f2cb7@exp-env)) ((f2b10@current-library-collection) f2cb5@lib)))) (set! f2d2f@f2b7a@install-library-record f2b7a@install-library-record) (set! f2b7c@install-library (lambda (f2cc3@id f2cc4@name f2cc5@ver f2cc6@imp* f2cc7@vis* f2cc8@inv* f2cc9@exp-subst f2cca@exp-env f2ccb@visit-proc f2ccc@invoke-proc f2ccd@visit-code f2cce@invoke-code f2ccf@visible? f2cd0@source-file-name) (let ((f2cdf@imp-lib* (map f2b76@find-library-by-spec/die f2cc6@imp*)) (f2ce0@vis-lib* (map f2b76@find-library-by-spec/die f2cc7@vis*)) (f2ce1@inv-lib* (map f2b76@find-library-by-spec/die f2cc8@inv*))) (begin (if (not (and (symbol? f2cc3@id) (list? f2cc4@name) (list? f2cc5@ver))) (assertion-violation 'install-library '"invalid spec with id/name/ver" f2cc3@id f2cc4@name f2cc5@ver) (void)) (if (f2b74@library-exists? f2cc4@name) (assertion-violation 'install-library '"library is already installed" f2cc4@name) (void)) (let ((f2ce5@lib (make-simple-struct 'library '15 (list f2cc3@id f2cc4@name f2cc5@ver f2cdf@imp-lib* f2ce0@vis-lib* f2ce1@inv-lib* f2cc9@exp-subst f2cca@exp-env f2ccb@visit-proc f2ccc@invoke-proc f2ccd@visit-code f2cce@invoke-code f2ccf@visible? f2cd0@source-file-name)))) (f2b7a@install-library-record f2ce5@lib)))))) (set! f2d30@f2b7c@install-library f2b7c@install-library) (set! f2b7e@imported-label->binding (lambda (f2ce7@lab) (hashtable-ref f2b78@label->binding-table f2ce7@lab '#f))) (set! f2d31@f2b7e@imported-label->binding f2b7e@imported-label->binding) (set! f2b80@invoke-library (lambda (f2ce9@lib) (let ((f2ceb@invoke (f2b42@library-invoke-state f2ce9@lib))) (if (procedure? f2ceb@invoke) (begin (f2b44@set-library-invoke-state! f2ce9@lib (lambda () (assertion-violation 'invoke '"circularity detected" f2ce9@lib))) (for-each f2b80@invoke-library (f2b32@library-inv* f2ce9@lib)) (f2b44@set-library-invoke-state! f2ce9@lib (lambda () (assertion-violation 'invoke '"first invoke did not return" f2ce9@lib))) (f2ceb@invoke) (f2b44@set-library-invoke-state! f2ce9@lib '#t)) (void))))) (set! f2d32@f2b80@invoke-library f2b80@invoke-library) (set! f2b82@visit-library (lambda (f2ced@lib) (let ((f2cef@visit (f2b3e@library-visit-state f2ced@lib))) (if (procedure? f2cef@visit) (begin (f2b40@set-library-visit-state! f2ced@lib (lambda () (assertion-violation 'visit '"circularity detected" f2ced@lib))) (for-each f2b80@invoke-library (f2b2e@library-vis* f2ced@lib)) (f2b40@set-library-visit-state! f2ced@lib (lambda () (assertion-violation 'invoke '"first visit did not return" f2ced@lib))) (f2cef@visit) (f2b40@set-library-visit-state! f2ced@lib '#t)) (void))))) (set! f2d33@f2b82@visit-library f2b82@visit-library) (set! f2b84@invoke-library-by-spec (lambda (f2cf1@spec) (f2b80@invoke-library (f2b76@find-library-by-spec/die f2cf1@spec)))) (set! f2d34@f2b84@invoke-library-by-spec f2b84@invoke-library-by-spec) (set! f2b86@installed-libraries (lambda f2cf9 (let ((f2cfa (length f2cf9))) (if (= f2cfa '1) (apply (lambda (f2cf3@all?) (let f2cf7@f ((f2cf5@ls ((f2b10@current-library-collection)))) (if (null? f2cf5@ls) '() (if (or f2cf3@all? (f2b4e@library-visible? (car f2cf5@ls))) (cons (car f2cf5@ls) (f2cf7@f (cdr f2cf5@ls))) (f2cf7@f (cdr f2cf5@ls)))))) f2cf9) (if (= f2cfa '0) (apply (lambda () (f2b86@installed-libraries '#f)) f2cf9) (error 'apply '"invalid arg count")))))) (set! f2d35@f2b86@installed-libraries f2b86@installed-libraries) (set! f2b88@library-spec (lambda (f2cfb@x) (begin (if (not (f2b1c@library? f2cfb@x)) (assertion-violation 'library-spec '"not a library" f2cfb@x) (void)) (list (f2b1e@library-id f2cfb@x) (f2b22@library-name f2cfb@x) (f2b26@library-version f2cfb@x))))) (set! f2d36@f2b88@library-spec f2b88@library-spec) (void))
(begin (set! f2d3a@build-global-define (unspecified)) (set! f2dab@build-lambda (unspecified)) (set! f2dad@build-case-lambda (unspecified)) (set! f2ddb@build-sequence (unspecified)) (set! f2ddd@build-void (unspecified)) (set! f2ddf@build-letrec (unspecified)) (set! f2de1@build-let (unspecified)) (set! f2de3@build-named-let (unspecified)) (set! f2de5@build-letrec* (unspecified)) (set! f2de7@build-library-letrec* (unspecified)) (set! f2de9@build-receive (unspecified)) (set! f2d3a@build-global-define (lambda (f2dea@x) (f2ddd@build-void))) (set! f2e78@f2d3a@build-global-define f2d3a@build-global-define) (set! f2dab@build-lambda (lambda (f2dec@ae f2ded@vars f2dee@exp) (list 'lambda f2ded@vars f2dee@exp))) (set! f2e79@f2dab@build-lambda f2dab@build-lambda) (set! f2dad@build-case-lambda (lambda (f2df2@ae f2df3@vars* f2df4@exp*) (letrec* ((f2df9@build-error (lambda (f2e30@ae) (list '(primitive error) ''apply (list 'quote '"invalid arg count")))) (f2dfb@build-pred (lambda (f2e18@ae f2e19@n f2e1a@vars) (call-with-values (lambda () (let f2e26@f ((f2e22@vars f2e1a@vars) (f2e23@count '0)) (if (pair? f2e22@vars) (f2e26@f (cdr f2e22@vars) (+ f2e23@count '1)) (if (null? f2e22@vars) (values f2e23@count '=) (values f2e23@count '>=))))) (lambda (f2e28@f2e1f f2e29@f2e21) (let ((f2e2c@pred f2e29@f2e21) (f2e2d@count f2e28@f2e1f)) (list (list 'primitive f2e2c@pred) f2e19@n (list 'quote f2e2d@count))))))) (f2dfd@build-apply (lambda (f2e10@ae f2e11@g f2e12@vars f2e13@exp) (list '(primitive apply) (f2dab@build-lambda f2e10@ae f2e12@vars f2e13@exp) f2e11@g))) (f2dff@expand-case-lambda (lambda (f2e00@ae f2e01@vars f2e02@exp*) (let ((f2e06@g (gensym)) (f2e07@n (gensym))) (list 'lambda f2e06@g (f2de1@build-let f2e00@ae (list f2e07@n) (list (list '(primitive length) f2e06@g)) (let f2e0e@f ((f2e0a@vars* f2df3@vars*) (f2e0b@exp* f2e02@exp*)) (if (null? f2e0a@vars*) (f2df9@build-error f2e00@ae) (list 'if (f2dfb@build-pred f2e00@ae f2e07@n (car f2e0a@vars*)) (f2dfd@build-apply f2e00@ae f2e06@g (car f2e0a@vars*) (car f2e0b@exp*)) (f2e0e@f (cdr f2e0a@vars*) (cdr f2e0b@exp*))))))))))) (if (= (length f2df4@exp*) '1) (f2dab@build-lambda f2df2@ae (car f2df3@vars*) (car f2df4@exp*)) (f2dff@expand-case-lambda f2df2@ae f2df3@vars* f2df4@exp*))))) (set! f2e7a@f2dad@build-case-lambda f2dad@build-case-lambda) (set! f2ddb@build-sequence (lambda (f2e32@ae f2e33@exps) (let f2e38@loop ((f2e36@exps f2e33@exps)) (if (null? (cdr f2e36@exps)) (car f2e36@exps) (if (equal? (car f2e36@exps) (f2ddd@build-void)) (f2e38@loop (cdr f2e36@exps)) (cons 'begin f2e36@exps)))))) (set! f2e7b@f2ddb@build-sequence f2ddb@build-sequence) (set! f2ddd@build-void (lambda () '((primitive void)))) (set! f2e7c@f2ddd@build-void f2ddd@build-void) (set! f2ddf@build-letrec (lambda (f2e3a@ae f2e3b@vars f2e3c@val-exps f2e3d@body-exp) (if (null? f2e3b@vars) f2e3d@body-exp (list 'letrec (map list f2e3b@vars f2e3c@val-exps) f2e3d@body-exp)))) (set! f2e7d@f2ddf@build-letrec f2ddf@build-letrec) (set! f2de1@build-let (lambda (f2e42@ae f2e43@vars f2e44@val-exps f2e45@body-exp) (if (null? f2e43@vars) f2e45@body-exp (list 'let (map list f2e43@vars f2e44@val-exps) f2e45@body-exp)))) (set! f2e7e@f2de1@build-let f2de1@build-let) (set! f2de3@build-named-let (lambda (f2e4a@ae f2e4b@name f2e4c@vars f2e4d@val-exps f2e4e@body-exp) (list 'let f2e4b@name (map list f2e4c@vars f2e4d@val-exps) f2e4e@body-exp))) (set! f2e7f@f2de3@build-named-let f2de3@build-named-let) (set! f2de5@build-letrec* (lambda (f2e54@ae f2e55@vars f2e56@val-exps f2e57@body-exp) (if (null? f2e55@vars) f2e57@body-exp (list 'letrec* (map list f2e55@vars f2e56@val-exps) f2e57@body-exp)))) (set! f2e80@f2de5@build-letrec* f2de5@build-letrec*) (set! f2de7@build-library-letrec* (lambda (f2e5c@ae f2e5d@name f2e5e@vars f2e5f@locs f2e60@val-exps f2e61@body-exp) (cons 'begin (append (map (lambda (f2e68@var) (cons 'set! (cons f2e68@var '((unspecified))))) f2e5e@vars) (append (apply append (map (lambda (f2e6a@var f2e6b@loc f2e6c@val-exp) (list (list 'set! f2e6a@var f2e6c@val-exp) (list 'set! f2e6b@loc f2e6a@var))) f2e5e@vars f2e5f@locs f2e60@val-exps)) (list f2e61@body-exp)))))) (set! f2e81@f2de7@build-library-letrec* f2de7@build-library-letrec*) (set! f2de9@build-receive (lambda (f2e70@ae f2e71@vars f2e72@producer f2e73@body*) (begin (display '"************** in ") (cons 'receive (cons f2e71@vars (cons f2e72@producer f2e73@body*)))))) (set! f2e82@f2de9@build-receive f2de9@build-receive) (void))
(begin (set! f2e91@file-options-macro (unspecified)) (set! f2e93@set-cons (unspecified)) (set! f2e95@set-union (unspecified)) (set! f2e9a@top-mark* (unspecified)) (set! f2e9c@top-marked? (unspecified)) (set! f2e9e@gen-lexical (unspecified)) (set! f2ea0@gen-global (unspecified)) (set! f2ea2@gen-label (unspecified)) (set! f2ea4@gen-top-level-label (unspecified)) (set! f2ea6@gen-define-label+loc (unspecified)) (set! f2ea8@gen-define-label (unspecified)) (set! f2eb2@rib? (unspecified)) (set! f2eb4@rib-sym* (unspecified)) (set! f2eb6@set-rib-sym*! (unspecified)) (set! f2eb8@rib-mark** (unspecified)) (set! f2eba@set-rib-mark**! (unspecified)) (set! f2ebc@rib-label* (unspecified)) (set! f2ebe@set-rib-label*! (unspecified)) (set! f2ec0@rib-sealed/freq (unspecified)) (set! f2ec2@set-rib-sealed/freq! (unspecified)) (set! f2ec4@rib-cache (unspecified)) (set! f2ec6@set-rib-cache! (unspecified)) (set! f2ec8@dummy (unspecified)) (set! f2eca@make-empty-rib (unspecified)) (set! f2ecc@extend-rib! (unspecified)) (set! f2ece@extend-rib/nc! (unspecified)) (set! f2ed0@make-rib-map (unspecified)) (set! f2ed2@seal-rib! (unspecified)) (set! f2ed4@unseal-rib! (unspecified)) (set! f2ed6@make-full-rib (unspecified)) (set! f2ed8@rp (unspecified)) (set! f2ee2@stx? (unspecified)) (set! f2ee4@stx-expr (unspecified)) (set! f2ee6@set-stx-expr! (unspecified)) (set! f2ee8@stx-mark* (unspecified)) (set! f2eea@set-stx-mark*! (unspecified)) (set! f2eec@stx-subst* (unspecified)) (set! f2eee@set-stx-subst*! (unspecified)) (set! f2ef0@stx-ae* (unspecified)) (set! f2ef2@set-stx-ae*! (unspecified)) (set! f2ef4@dummy (unspecified)) (set! f2ef6@datum->stx (unspecified)) (set! f2ef8@gen-mark (unspecified)) (set! f2efa@anti-mark (unspecified)) (set! f2efc@anti-mark? (unspecified)) (set! f2efe@mkstx (unspecified)) (set! f2f00@add-mark (unspecified)) (set! f2f02@add-subst (unspecified)) (set! f2f04@syntax-kind? (unspecified)) (set! f2f06@syntax-vector->list (unspecified)) (set! f2f08@syntax-pair? (unspecified)) (set! f2f0a@syntax-vector? (unspecified)) (set! f2f0c@syntax-null? (unspecified)) (set! f2f0e@syntax-list? (unspecified)) (set! f2f10@syntax-car (unspecified)) (set! f2f12@syntax-cdr (unspecified)) (set! f2f14@syntax->list (unspecified)) (set! f2f16@id? (unspecified)) (set! f2f18@id->sym (unspecified)) (set! f2f1a@bound-id=? (unspecified)) (set! f2f1c@free-id=? (unspecified)) (set! f2f1e@valid-bound-ids? (unspecified)) (set! f2f20@distinct-bound-ids? (unspecified)) (set! f2f22@bound-id-member? (unspecified)) (set! f2f24@self-evaluating? (unspecified)) (set! f2f26@strip-annotations (unspecified)) (set! f2f28@strip (unspecified)) (set! f2f2a@stx->datum (unspecified)) (set! f2f2c@id->label (unspecified)) (set! f2f2e@label->binding (unspecified)) (set! f2f30@make-binding (unspecified)) (set! f2f32@binding-type (unspecified)) (set! f2f34@binding-value (unspecified)) (set! f2f36@raise-unbound-error (unspecified)) (set! f2f38@syntax-type (unspecified)) (set! f2f46@sanitize-binding (unspecified)) (set! f2f48@make-variable-transformer (unspecified)) (set! f2f4a@variable-transformer? (unspecified)) (set! f2f4c@variable-transformer-procedure (unspecified)) (set! f2f4e@make-eval-transformer (unspecified)) (set! f309f@parse-define (unspecified)) (set! f30a1@parse-define-syntax (unspecified)) (set! f30a3@scheme-stx-hashtable (unspecified)) (set! f30a5@scheme-stx (unspecified)) (set! f30a7@lexical-var (unspecified)) (set! f30a9@lexical-mutable? (unspecified)) (set! f30ab@set-lexical-mutable! (unspecified)) (set! f30ad@add-lexical (unspecified)) (set! f30af@add-lexicals (unspecified)) (set! f30b1@letrec-helper (unspecified)) (set! f30b3@let-transformer (unspecified)) (set! f30b5@letrec-transformer (unspecified)) (set! f30b7@letrec*-transformer (unspecified)) (set! f30b9@fluid-let-syntax-transformer (unspecified)) (set! f30bb@type-descriptor-transformer (unspecified)) (set! f30bd@record-type-descriptor-transformer (unspecified)) (set! f30bf@record-constructor-descriptor-transformer (unspecified)) (set! f30c1@when-macro (unspecified)) (set! f30c3@unless-macro (unspecified)) (set! f30c5@if-transformer (unspecified)) (set! f30c7@and-transformer (unspecified)) (set! f30c9@or-transformer (unspecified)) (set! f30cb@case-macro (unspecified)) (set! f30cd@quote-transformer (unspecified)) (set! f30cf@case-lambda-transformer (unspecified)) (set! f30d1@lambda-transformer (unspecified)) (set! f30d3@bless (unspecified)) (set! f30d5@with-syntax-macro (unspecified)) (set! f30d7@invalid-fmls-error (unspecified)) (set! f30d9@let-macro (unspecified)) (set! f30db@let-values-macro (unspecified)) (set! f30dd@let*-values-macro (unspecified)) (set! f30df@trace-lambda-macro (unspecified)) (set! f30e1@trace-define-macro (unspecified)) (set! f30e3@trace-define-syntax-macro (unspecified)) (set! f30e5@trace-let/rec-syntax (unspecified)) (set! f30e7@trace-let-syntax-macro (unspecified)) (set! f30e9@trace-letrec-syntax-macro (unspecified)) (set! f30eb@guard-macro (unspecified)) (set! f30ed@define-enumeration-macro (unspecified)) (set! f30ef@time-macro (unspecified)) (set! f30f1@delay-macro (unspecified)) (set! f30f3@assert-macro (unspecified)) (set! f30f5@endianness-macro (unspecified)) (set! f30f7@identifier-syntax-macro (unspecified)) (set! f30f9@do-macro (unspecified)) (set! f30fb@let*-macro (unspecified)) (set! f30fd@or-macro (unspecified)) (set! f30ff@and-macro (unspecified)) (set! f3101@cond-macro (unspecified)) (set! f3103@do-include (unspecified)) (set! f3105@include-macro (unspecified)) (set! f3107@include-into-macro (unspecified)) (set! f3109@syntax-rules-macro (unspecified)) (set! f310b@quasiquote-macro (unspecified)) (set! f310d@quasisyntax-macro (unspecified)) (set! f310f@define-struct-macro (unspecified)) (set! f3111@define-record-type-macro (unspecified)) (set! f3113@define-condition-type-macro (unspecified)) (set! f3115@incorrect-usage-macro (unspecified)) (set! f3117@parameterize-macro (unspecified)) (set! f3119@foreign-call-transformer (unspecified)) (set! f311b@convert-pattern (unspecified)) (set! f311d@syntax-dispatch (unspecified)) (set! f311f@ellipsis? (unspecified)) (set! f3121@underscore? (unspecified)) (set! f3123@verify-literals (unspecified)) (set! f3125@syntax-case-transformer (unspecified)) (set! f3127@ellipsis-map (unspecified)) (set! f3129@syntax-transformer (unspecified)) (set! f312b@core-macro-transformer (unspecified)) (set! f312d@symbol-macro (unspecified)) (set! f312f@macro-transformer (unspecified)) (set! f3131@local-macro-transformer (unspecified)) (set! f3133@do-macro-call (unspecified)) (set! f3135@chi-macro (unspecified)) (set! f3137@chi-local-macro (unspecified)) (set! f3139@chi-global-macro (unspecified)) (set! f313b@chi-expr* (unspecified)) (set! f313d@chi-application (unspecified)) (set! f313f@chi-expr (unspecified)) (set! f3141@chi-set! (unspecified)) (set! f3143@verify-formals (unspecified)) (set! f3145@chi-lambda-clause (unspecified)) (set! f3147@chi-lambda-clause* (unspecified)) (set! f3149@chi-defun (unspecified)) (set! f314b@chi-rhs (unspecified)) (set! f314d@expand-interaction-rhs*/init* (unspecified)) (set! f314f@chi-rhs* (unspecified)) (set! f3151@find-bound=? (unspecified)) (set! f3153@find-dups (unspecified)) (set! f3155@chi-internal (unspecified)) (set! f3157@parse-module (unspecified)) (set! f3161@module-interface? (unspecified)) (set! f3163@module-interface-first-mark (unspecified)) (set! f3165@set-module-interface-first-mark! (unspecified)) (set! f3167@module-interface-exp-id-vec (unspecified)) (set! f3169@set-module-interface-exp-id-vec! (unspecified)) (set! f316b@module-interface-exp-lab-vec (unspecified)) (set! f316d@set-module-interface-exp-lab-vec! (unspecified)) (set! f316f@dummy (unspecified)) (set! f3171@module-interface-exp-id* (unspecified)) (set! f3173@chi-internal-module (unspecified)) (set! f3175@copy-rib-contents! (unspecified)) (set! f3177@chi-body*-macro (unspecified)) (set! f3179@chi-body* (unspecified)) (set! f317b@expand-transformer (unspecified)) (set! f317d@parse-exports (unspecified)) (set! f317f@parse-library-name (unspecified)) (set! f3181@parse-library (unspecified)) (set! f3183@parse-import-spec* (unspecified)) (set! f3185@make-top-rib (unspecified)) (set! f3187@make-collector (unspecified)) (set! f3189@inv-collector (unspecified)) (set! f318b@vis-collector (unspecified)) (set! f318d@imp-collector (unspecified)) (set! f318f@chi-library-internal (unspecified)) (set! f3191@chi-interaction-expr (unspecified)) (set! f3193@library-body-expander (unspecified)) (set! f3195@core-library-expander (unspecified)) (set! f3197@parse-top-level-program (unspecified)) (set! f3199@top-level-expander (unspecified)) (set! f319b@rp (unspecified)) (set! f31a5@env? (unspecified)) (set! f31a7@env-names (unspecified)) (set! f31a9@set-env-names! (unspecified)) (set! f31ab@env-labels (unspecified)) (set! f31ad@set-env-labels! (unspecified)) (set! f31af@env-itc (unspecified)) (set! f31b1@set-env-itc! (unspecified)) (set! f31b3@dummy (unspecified)) (set! f31b5@rp (unspecified)) (set! f31bf@interaction-env? (unspecified)) (set! f31c1@interaction-env-rib (unspecified)) (set! f31c3@set-interaction-env-rib! (unspecified)) (set! f31c5@interaction-env-r (unspecified)) (set! f31c7@set-interaction-env-r! (unspecified)) (set! f31c9@interaction-env-locs (unspecified)) (set! f31cb@set-interaction-env-locs! (unspecified)) (set! f31cd@dummy (unspecified)) (set! f31cf@interaction-environment-symbols (unspecified)) (set! f31d1@environment-bindings (unspecified)) (set! f31d3@parse-binding (unspecified)) (set! f31d5@environment? (unspecified)) (set! f31d7@environment-symbols (unspecified)) (set! f31d9@environment (unspecified)) (set! f31db@null-environment (unspecified)) (set! f31dd@scheme-report-environment (unspecified)) (set! f31df@expand (unspecified)) (set! f31e1@eval (unspecified)) (set! f31e3@library-expander (unspecified)) (set! f31e5@boot-library-expand (unspecified)) (set! f31e7@rev-map-append (unspecified)) (set! f31e9@build-exports (unspecified)) (set! f31eb@make-export-subst (unspecified)) (set! f31ed@make-export-env/macros (unspecified)) (set! f31ef@generate-temporaries (unspecified)) (set! f31f1@free-identifier=? (unspecified)) (set! f31f3@bound-identifier=? (unspecified)) (set! f31f5@make-source-condition (unspecified)) (set! f31f7@extract-position-condition (unspecified)) (set! f31f9@expression-position (unspecified)) (set! f31fb@assertion-error (unspecified)) (set! f31fd@syntax-error (unspecified)) (set! f31ff@syntax-violation* (unspecified)) (set! f3201@syntax-violation (unspecified)) (set! f3203@identifier? (unspecified)) (set! f3205@datum->syntax (unspecified)) (set! f3207@syntax->datum (unspecified)) (set! f3209@ungensym-all (unspecified)) (set! f320b@compile-r6rs-top-level (unspecified)) (set! f320d@pre-compile-r6rs-top-level (unspecified)) (set! f320f@interaction-environment (unspecified)) (set! f3211@top-level-context (unspecified)) (set! f2e91@file-options-macro (lambda (f3212@x) (letrec* ((f3215@valid-option? (lambda (f321e@x) (and (f2f16@id? f321e@x) (memq (f2f18@id->sym f321e@x) '(no-fail no-create no-truncate)))))) (let ((f3216@t f3212@x)) (let ((f3218@ls/false (f311d@syntax-dispatch f3216@t '(_ . each-any)))) (if (and f3218@ls/false (apply (lambda (f321a@opt*) (for-all f3215@valid-option? f321a@opt*)) f3218@ls/false)) (apply (lambda (f321c@opt*) (f30d3@bless (list 'make-file-options (list 'quote f321c@opt*)))) f3218@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3216@t))))))) (set! f4bbc@f2e91@file-options-macro f2e91@file-options-macro) (set! f2e93@set-cons (lambda (f3220@x f3221@ls) (if (memq f3220@x f3221@ls) f3221@ls (cons f3220@x f3221@ls)))) (set! f4bbd@f2e93@set-cons f2e93@set-cons) (set! f2e95@set-union (lambda (f3224@ls1 f3225@ls2) (if (null? f3224@ls1) f3225@ls2 (if (memq (car f3224@ls1) f3225@ls2) (f2e95@set-union (cdr f3224@ls1) f3225@ls2) (cons (car f3224@ls1) (f2e95@set-union (cdr f3224@ls1) f3225@ls2)))))) (set! f4bbe@f2e95@set-union f2e95@set-union) (set! f2e9a@top-mark* '(top)) (set! f4bbf@f2e9a@top-mark* f2e9a@top-mark*) (set! f2e9c@top-marked? (lambda (f3228@m*) (memq 'top f3228@m*))) (set! f4bc0@f2e9c@top-marked? f2e9c@top-marked?) (set! f2e9e@gen-lexical (lambda (f322a@sym) (if (symbol? f322a@sym) (gensym f322a@sym) (if (f2ee2@stx? f322a@sym) (f2e9e@gen-lexical (f2f18@id->sym f322a@sym)) (assertion-violation 'gen-lexical '"BUG: invalid arg" f322a@sym))))) (set! f4bc1@f2e9e@gen-lexical f2e9e@gen-lexical) (set! f2ea0@gen-global (lambda (f322c@x) (f2e9e@gen-lexical f322c@x))) (set! f4bc2@f2ea0@gen-global f2ea0@gen-global) (set! f2ea2@gen-label (lambda (f322e@_) (gensym))) (set! f4bc3@f2ea2@gen-label f2ea2@gen-label) (set! f2ea4@gen-top-level-label (lambda (f3230@id f3231@rib) (letrec* ((f3235@find (lambda (f3240@sym f3241@mark* f3242@sym* f3243@mark** f3244@label*) (and (pair? f3242@sym*) (if (and (eq? f3240@sym (car f3242@sym*)) (same-marks? f3241@mark* (car f3243@mark**))) (car f3244@label*) (f3235@find f3240@sym f3241@mark* (cdr f3242@sym*) (cdr f3243@mark**) (cdr f3244@label*))))))) (let ((f3236@sym (f2f18@id->sym f3230@id)) (f3237@mark* (f2ee8@stx-mark* f3230@id))) (let ((f323a@sym* (f2eb4@rib-sym* f3231@rib))) (let ((f323c@t (and (memq f3236@sym (f2eb4@rib-sym* f3231@rib)) (f3235@find f3236@sym f3237@mark* f323a@sym* (f2eb8@rib-mark** f3231@rib) (f2ebc@rib-label* f3231@rib))))) (if f323c@t ((lambda (f323e@label) (if (f2d31@f2b7e@imported-label->binding f323e@label) (gensym) f323e@label)) f323c@t) (gensym)))))))) (set! f4bc4@f2ea4@gen-top-level-label f2ea4@gen-top-level-label) (set! f2ea6@gen-define-label+loc (lambda (f324a@id f324b@rib) (let ((f324e@t (f3211@top-level-context))) (if f324e@t ((lambda (f3250@env) (let ((f3252@label (f2ea4@gen-top-level-label f324a@id f324b@rib)) (f3253@locs (f31c9@interaction-env-locs f3250@env))) (values f3252@label (let ((f3256@t (assq f3252@label f3253@locs))) (if f3256@t (cdr f3256@t) (let ((f3258@loc (f2e9e@gen-lexical f324a@id))) (begin (f31cb@set-interaction-env-locs! f3250@env (cons (cons f3252@label f3258@loc) f3253@locs)) f3258@loc))))))) f324e@t) (values (gensym) (f2e9e@gen-lexical f324a@id)))))) (set! f4bc5@f2ea6@gen-define-label+loc f2ea6@gen-define-label+loc) (set! f2ea8@gen-define-label (lambda (f325a@id f325b@rib) (if (f3211@top-level-context) (f2ea4@gen-top-level-label f325a@id f325b@rib) (gensym)))) (set! f4bc6@f2ea8@gen-define-label f2ea8@gen-define-label) (set! f2eb2@rib? (lambda (f325e@x) (and (simple-struct? f325e@x) (eq? (simple-struct-name f325e@x) 'rib)))) (set! f4bc7@f2eb2@rib? f2eb2@rib?) (set! f2eb4@rib-sym* (lambda (f3260@x) (simple-struct-ref f3260@x '0))) (set! f4bc8@f2eb4@rib-sym* f2eb4@rib-sym*) (set! f2eb6@set-rib-sym*! (lambda (f3262@x f3263@val) (simple-struct-set! f3262@x '0 f3263@val))) (set! f4bc9@f2eb6@set-rib-sym*! f2eb6@set-rib-sym*!) (set! f2eb8@rib-mark** (lambda (f3266@x) (simple-struct-ref f3266@x '1))) (set! f4bca@f2eb8@rib-mark** f2eb8@rib-mark**) (set! f2eba@set-rib-mark**! (lambda (f3268@x f3269@val) (simple-struct-set! f3268@x '1 f3269@val))) (set! f4bcb@f2eba@set-rib-mark**! f2eba@set-rib-mark**!) (set! f2ebc@rib-label* (lambda (f326c@x) (simple-struct-ref f326c@x '2))) (set! f4bcc@f2ebc@rib-label* f2ebc@rib-label*) (set! f2ebe@set-rib-label*! (lambda (f326e@x f326f@val) (simple-struct-set! f326e@x '2 f326f@val))) (set! f4bcd@f2ebe@set-rib-label*! f2ebe@set-rib-label*!) (set! f2ec0@rib-sealed/freq (lambda (f3272@x) (simple-struct-ref f3272@x '3))) (set! f4bce@f2ec0@rib-sealed/freq f2ec0@rib-sealed/freq) (set! f2ec2@set-rib-sealed/freq! (lambda (f3274@x f3275@val) (simple-struct-set! f3274@x '3 f3275@val))) (set! f4bcf@f2ec2@set-rib-sealed/freq! f2ec2@set-rib-sealed/freq!) (set! f2ec4@rib-cache (lambda (f3278@x) (simple-struct-ref f3278@x '4))) (set! f4bd0@f2ec4@rib-cache f2ec4@rib-cache) (set! f2ec6@set-rib-cache! (lambda (f327a@x f327b@val) (simple-struct-set! f327a@x '4 f327b@val))) (set! f4bd1@f2ec6@set-rib-cache! f2ec6@set-rib-cache!) (set! f2ec8@dummy '3) (set! f4bd2@f2ec8@dummy f2ec8@dummy) (set! f2eca@make-empty-rib (lambda () (make-simple-struct 'rib '6 (list '() '() '() '#f '#f)))) (set! f4bd3@f2eca@make-empty-rib f2eca@make-empty-rib) (set! f2ecc@extend-rib! (lambda (f327e@rib f327f@id f3280@label) (letrec* ((f3285@find (lambda (f3292@sym f3293@mark* f3294@sym* f3295@mark** f3296@label*) (and (pair? f3294@sym*) (if (and (eq? f3292@sym (car f3294@sym*)) (same-marks? f3293@mark* (car f3295@mark**))) f3296@label* (f3285@find f3292@sym f3293@mark* (cdr f3294@sym*) (cdr f3295@mark**) (cdr f3296@label*))))))) (begin (if (f2ec0@rib-sealed/freq f327e@rib) (assertion-violation 'extend-rib! '"BUG: rib is sealed" f327e@rib) (void)) (let ((f3286@sym (f2f18@id->sym f327f@id)) (f3287@mark* (f2ee8@stx-mark* f327f@id))) (let ((f328a@sym* (f2eb4@rib-sym* f327e@rib))) (let ((f328c@t (and (memq f3286@sym (f2eb4@rib-sym* f327e@rib)) (f3285@find f3286@sym f3287@mark* f328a@sym* (f2eb8@rib-mark** f327e@rib) (f2ebc@rib-label* f327e@rib))))) (if f328c@t ((lambda (f328e@p) (if (not (eq? f3280@label (car f328e@p))) (if (f3211@top-level-context) (set-car! f328e@p f3280@label) (f3201@syntax-violation '#f '"multiple definitions of identifier" f327f@id)) (void))) f328c@t) (begin (if (f2ec4@rib-cache f327e@rib) (hashtable-update! (f2ec4@rib-cache f327e@rib) f3286@sym (lambda (f3290@e) (cons (cons f3287@mark* f3280@label) f3290@e)) '()) (void)) (f2eb6@set-rib-sym*! f327e@rib (cons f3286@sym f328a@sym*)) (f2eba@set-rib-mark**! f327e@rib (cons f3287@mark* (f2eb8@rib-mark** f327e@rib))) (f2ebe@set-rib-label*! f327e@rib (cons f3280@label (f2ebc@rib-label* f327e@rib)))))))))))) (set! f4bd4@f2ecc@extend-rib! f2ecc@extend-rib!) (set! f2ece@extend-rib/nc! (lambda (f329c@rib f329d@id f329e@label) (let ((f32a2@sym (f2f18@id->sym f329d@id)) (f32a3@mark* (f2ee8@stx-mark* f329d@id))) (let ((f32a6@sym* (f2eb4@rib-sym* f329c@rib))) (begin (if (f2ec4@rib-cache f329c@rib) (hashtable-update! (f2ec4@rib-cache f329c@rib) f32a2@sym (lambda (f32a8@e) (cons (cons f32a3@mark* f329e@label) f32a8@e)) '()) (void)) (f2eb6@set-rib-sym*! f329c@rib (cons f32a2@sym f32a6@sym*)) (f2eba@set-rib-mark**! f329c@rib (cons f32a3@mark* (f2eb8@rib-mark** f329c@rib))) (f2ebe@set-rib-label*! f329c@rib (cons f329e@label (f2ebc@rib-label* f329c@rib)))))))) (set! f4bd5@f2ece@extend-rib/nc! f2ece@extend-rib/nc!) (set! f2ed0@make-rib-map (lambda (f32aa@sym*) (let ((f32ac@ht (make-eq-hashtable))) (let f32b2@f ((f32ae@i '0) (f32af@sym* f32aa@sym*)) (if (null? f32af@sym*) f32ac@ht (begin (hashtable-update! f32ac@ht (car f32af@sym*) (lambda (f32b4@x) (cons f32ae@i f32b4@x)) '()) (f32b2@f (+ f32ae@i '1) (cdr f32af@sym*)))))))) (set! f4bd6@f2ed0@make-rib-map f2ed0@make-rib-map) (set! f2ed2@seal-rib! (lambda (f32b6@rib) (let ((f32b8@sym* (f2eb4@rib-sym* f32b6@rib))) (if (not (null? f32b8@sym*)) (begin (f2eb6@set-rib-sym*! f32b6@rib (list->vector f32b8@sym*)) (f2eba@set-rib-mark**! f32b6@rib (list->vector (f2eb8@rib-mark** f32b6@rib))) (f2ebe@set-rib-label*! f32b6@rib (list->vector (f2ebc@rib-label* f32b6@rib))) (f2ec2@set-rib-sealed/freq! f32b6@rib (f2ed0@make-rib-map f32b8@sym*))) (void))))) (set! f4bd7@f2ed2@seal-rib! f2ed2@seal-rib!) (set! f2ed4@unseal-rib! (lambda (f32ba@rib) (if (f2ec0@rib-sealed/freq f32ba@rib) (begin (f2ec2@set-rib-sealed/freq! f32ba@rib '#f) (f2eb6@set-rib-sym*! f32ba@rib (vector->list (f2eb4@rib-sym* f32ba@rib))) (f2eba@set-rib-mark**! f32ba@rib (vector->list (f2eb8@rib-mark** f32ba@rib))) (f2ebe@set-rib-label*! f32ba@rib (vector->list (f2ebc@rib-label* f32ba@rib)))) (void)))) (set! f4bd8@f2ed4@unseal-rib! f2ed4@unseal-rib!) (set! f2ed6@make-full-rib (lambda (f32bc@id* f32bd@label*) (let ((f32c0@r (make-simple-struct 'rib '6 (list (map f2f18@id->sym f32bc@id*) (map f2ee8@stx-mark* f32bc@id*) f32bd@label* '#f '#f)))) (begin (f2ed2@seal-rib! f32c0@r) f32c0@r)))) (set! f4bd9@f2ed6@make-full-rib f2ed6@make-full-rib) (set! f2ed8@rp (f2a63@f293e@make-record-printer 'stx (lambda (f32c2@x f32c3@p f32c4@wr) (begin (display '"#<syntax " f32c3@p) (write (f2f2a@stx->datum f32c2@x) f32c3@p) (let ((f32c8@expr (f2ee4@stx-expr f32c2@x))) (if (f2a5a@f292c@annotation? f32c8@expr) (let ((f32ca@src (f2a5b@f292e@annotation-source f32c8@expr))) (if (pair? f32ca@src) (begin (display '" [" f32c3@p) (display (cdr f32ca@src) f32c3@p) (display '" of " f32c3@p) (display (car f32ca@src) f32c3@p) (display '"]" f32c3@p)) (void))) (void))) (display '">" f32c3@p))))) (set! f4bda@f2ed8@rp f2ed8@rp) (set! f2ee2@stx? (lambda (f32cc@x) (and (simple-struct? f32cc@x) (eq? (simple-struct-name f32cc@x) 'stx)))) (set! f4bdb@f2ee2@stx? f2ee2@stx?) (set! f2ee4@stx-expr (lambda (f32ce@x) (simple-struct-ref f32ce@x '0))) (set! f4bdc@f2ee4@stx-expr f2ee4@stx-expr) (set! f2ee6@set-stx-expr! (lambda (f32d0@x f32d1@val) (simple-struct-set! f32d0@x '0 f32d1@val))) (set! f4bdd@f2ee6@set-stx-expr! f2ee6@set-stx-expr!) (set! f2ee8@stx-mark* (lambda (f32d4@x) (simple-struct-ref f32d4@x '1))) (set! f4bde@f2ee8@stx-mark* f2ee8@stx-mark*) (set! f2eea@set-stx-mark*! (lambda (f32d6@x f32d7@val) (simple-struct-set! f32d6@x '1 f32d7@val))) (set! f4bdf@f2eea@set-stx-mark*! f2eea@set-stx-mark*!) (set! f2eec@stx-subst* (lambda (f32da@x) (simple-struct-ref f32da@x '2))) (set! f4be0@f2eec@stx-subst* f2eec@stx-subst*) (set! f2eee@set-stx-subst*! (lambda (f32dc@x f32dd@val) (simple-struct-set! f32dc@x '2 f32dd@val))) (set! f4be1@f2eee@set-stx-subst*! f2eee@set-stx-subst*!) (set! f2ef0@stx-ae* (lambda (f32e0@x) (simple-struct-ref f32e0@x '3))) (set! f4be2@f2ef0@stx-ae* f2ef0@stx-ae*) (set! f2ef2@set-stx-ae*! (lambda (f32e2@x f32e3@val) (simple-struct-set! f32e2@x '3 f32e3@val))) (set! f4be3@f2ef2@set-stx-ae*! f2ef2@set-stx-ae*!) (set! f2ef4@dummy '3) (set! f4be4@f2ef4@dummy f2ef4@dummy) (set! f2ef6@datum->stx (lambda (f32e6@id f32e7@datum) (make-simple-struct 'stx '5 (list f32e7@datum (f2ee8@stx-mark* f32e6@id) (f2eec@stx-subst* f32e6@id) (f2ef0@stx-ae* f32e6@id))))) (set! f4be5@f2ef6@datum->stx f2ef6@datum->stx) (set! f2ef8@gen-mark (lambda () (string '#\m))) (set! f4be6@f2ef8@gen-mark f2ef8@gen-mark) (set! f2efa@anti-mark '#f) (set! f4be7@f2efa@anti-mark f2efa@anti-mark) (set! f2efc@anti-mark? not) (set! f4be8@f2efc@anti-mark? f2efc@anti-mark?) (set! f2efe@mkstx (lambda (f32ea@e f32eb@m* f32ec@s* f32ed@ae*) (if (and (f2ee2@stx? f32ea@e) (not (f2e9c@top-marked? f32eb@m*))) (call-with-values (lambda () (join-wraps f32eb@m* f32ec@s* f32ed@ae* f32ea@e)) (lambda (f32f8@f32f3 f32f9@f32f5 f32fa@f32f7) (let ((f32fe@ae* f32fa@f32f7) (f32ff@s* f32f9@f32f5) (f3300@m* f32f8@f32f3)) (make-simple-struct 'stx '5 (list (f2ee4@stx-expr f32ea@e) f3300@m* f32ff@s* f32fe@ae*))))) (make-simple-struct 'stx '5 (list f32ea@e f32eb@m* f32ec@s* f32ed@ae*))))) (set! f4be9@f2efe@mkstx f2efe@mkstx) (set! f2f00@add-mark (lambda (f3304@m f3305@e f3306@ae) (f2efe@mkstx f3305@e (list f3304@m) '(shift) (list f3306@ae)))) (set! f4bea@f2f00@add-mark f2f00@add-mark) (set! f2f02@add-subst (lambda (f330a@subst f330b@e) (f2efe@mkstx f330b@e '() (list f330a@subst) '()))) (set! f4beb@f2f02@add-subst f2f02@add-subst) (set! f2f04@syntax-kind? (lambda (f330e@x f330f@p?) (if (f2ee2@stx? f330e@x) (f2f04@syntax-kind? (f2ee4@stx-expr f330e@x) f330f@p?) (if (f2a5a@f292c@annotation? f330e@x) (f2f04@syntax-kind? (f2a5c@f2930@annotation-expression f330e@x) f330f@p?) (f330f@p? f330e@x))))) (set! f4bec@f2f04@syntax-kind? f2f04@syntax-kind?) (set! f2f06@syntax-vector->list (lambda (f3312@x) (if (f2ee2@stx? f3312@x) (let ((f3314@ls (f2f06@syntax-vector->list (f2ee4@stx-expr f3312@x))) (f3315@m* (f2ee8@stx-mark* f3312@x)) (f3316@s* (f2eec@stx-subst* f3312@x)) (f3317@ae* (f2ef0@stx-ae* f3312@x))) (map (lambda (f331c@x) (f2efe@mkstx f331c@x f3315@m* f3316@s* f3317@ae*)) f3314@ls)) (if (f2a5a@f292c@annotation? f3312@x) (f2f06@syntax-vector->list (f2a5c@f2930@annotation-expression f3312@x)) (if (vector? f3312@x) (vector->list f3312@x) (assertion-violation 'syntax-vector->list '"BUG: not a syntax vector" f3312@x)))))) (set! f4bed@f2f06@syntax-vector->list f2f06@syntax-vector->list) (set! f2f08@syntax-pair? (lambda (f331e@x) (f2f04@syntax-kind? f331e@x pair?))) (set! f4bee@f2f08@syntax-pair? f2f08@syntax-pair?) (set! f2f0a@syntax-vector? (lambda (f3320@x) (f2f04@syntax-kind? f3320@x vector?))) (set! f4bef@f2f0a@syntax-vector? f2f0a@syntax-vector?) (set! f2f0c@syntax-null? (lambda (f3322@x) (f2f04@syntax-kind? f3322@x null?))) (set! f4bf0@f2f0c@syntax-null? f2f0c@syntax-null?) (set! f2f0e@syntax-list? (lambda (f3324@x) (or (f2f0c@syntax-null? f3324@x) (and (f2f08@syntax-pair? f3324@x) (f2f0e@syntax-list? (f2f12@syntax-cdr f3324@x)))))) (set! f4bf1@f2f0e@syntax-list? f2f0e@syntax-list?) (set! f2f10@syntax-car (lambda (f3326@x) (if (f2ee2@stx? f3326@x) (f2efe@mkstx (f2f10@syntax-car (f2ee4@stx-expr f3326@x)) (f2ee8@stx-mark* f3326@x) (f2eec@stx-subst* f3326@x) (f2ef0@stx-ae* f3326@x)) (if (f2a5a@f292c@annotation? f3326@x) (f2f10@syntax-car (f2a5c@f2930@annotation-expression f3326@x)) (if (pair? f3326@x) (car f3326@x) (assertion-violation 'syntax-car '"BUG: not a pair" f3326@x)))))) (set! f4bf2@f2f10@syntax-car f2f10@syntax-car) (set! f2f12@syntax-cdr (lambda (f3328@x) (if (f2ee2@stx? f3328@x) (f2efe@mkstx (f2f12@syntax-cdr (f2ee4@stx-expr f3328@x)) (f2ee8@stx-mark* f3328@x) (f2eec@stx-subst* f3328@x) (f2ef0@stx-ae* f3328@x)) (if (f2a5a@f292c@annotation? f3328@x) (f2f12@syntax-cdr (f2a5c@f2930@annotation-expression f3328@x)) (if (pair? f3328@x) (cdr f3328@x) (assertion-violation 'syntax-cdr '"BUG: not a pair" f3328@x)))))) (set! f4bf3@f2f12@syntax-cdr f2f12@syntax-cdr) (set! f2f14@syntax->list (lambda (f332a@x) (if (f2f08@syntax-pair? f332a@x) (cons (f2f10@syntax-car f332a@x) (f2f14@syntax->list (f2f12@syntax-cdr f332a@x))) (if (f2f0c@syntax-null? f332a@x) '() (assertion-violation 'syntax->list '"BUG: invalid argument" f332a@x))))) (set! f4bf4@f2f14@syntax->list f2f14@syntax->list) (set! f2f16@id? (lambda (f332c@x) (and (f2ee2@stx? f332c@x) (symbol? (f2ee4@stx-expr f332c@x))))) (set! f4bf5@f2f16@id? f2f16@id?) (set! f2f18@id->sym (lambda (f332e@x) (f2ee4@stx-expr f332e@x))) (set! f4bf6@f2f18@id->sym f2f18@id->sym) (set! f2f1a@bound-id=? (lambda (f3330@x f3331@y) (and (eq? (f2f18@id->sym f3330@x) (f2f18@id->sym f3331@y)) (same-marks? (f2ee8@stx-mark* f3330@x) (f2ee8@stx-mark* f3331@y))))) (set! f4bf7@f2f1a@bound-id=? f2f1a@bound-id=?) (set! f2f1c@free-id=? (lambda (f3334@i f3335@j) (let ((f3338@t0 (id->real-label f3334@i)) (f3339@t1 (id->real-label f3335@j))) (if (or f3338@t0 f3339@t1) (eq? f3338@t0 f3339@t1) (eq? (f2f18@id->sym f3334@i) (f2f18@id->sym f3335@j)))))) (set! f4bf8@f2f1c@free-id=? f2f1c@free-id=?) (set! f2f1e@valid-bound-ids? (lambda (f333c@id*) (and (for-all f2f16@id? f333c@id*) (f2f20@distinct-bound-ids? f333c@id*)))) (set! f4bf9@f2f1e@valid-bound-ids? f2f1e@valid-bound-ids?) (set! f2f20@distinct-bound-ids? (lambda (f333e@id*) (or (null? f333e@id*) (and (not (f2f22@bound-id-member? (car f333e@id*) (cdr f333e@id*))) (f2f20@distinct-bound-ids? (cdr f333e@id*)))))) (set! f4bfa@f2f20@distinct-bound-ids? f2f20@distinct-bound-ids?) (set! f2f22@bound-id-member? (lambda (f3340@id f3341@id*) (and (pair? f3341@id*) (or (f2f1a@bound-id=? f3340@id (car f3341@id*)) (f2f22@bound-id-member? f3340@id (cdr f3341@id*)))))) (set! f4bfb@f2f22@bound-id-member? f2f22@bound-id-member?) (set! f2f24@self-evaluating? (lambda (f3344@x) (or (number? f3344@x) (string? f3344@x) (char? f3344@x) (boolean? f3344@x) (regexp? f3344@x) (bytevector? f3344@x)))) (set! f4bfc@f2f24@self-evaluating? f2f24@self-evaluating?) (set! f2f26@strip-annotations (lambda (f3346@x) (if (pair? f3346@x) (cons (f2f26@strip-annotations (car f3346@x)) (f2f26@strip-annotations (cdr f3346@x))) (if (vector? f3346@x) (vector-map f2f26@strip-annotations f3346@x) (if (f2a5a@f292c@annotation? f3346@x) (f2a59@f292a@annotation-stripped f3346@x) f3346@x))))) (set! f4bfd@f2f26@strip-annotations f2f26@strip-annotations) (set! f2f28@strip (lambda (f3348@x f3349@m*) (if (f2e9c@top-marked? f3349@m*) (if (or (f2a5a@f292c@annotation? f3348@x) (and (pair? f3348@x) (f2a5a@f292c@annotation? (car f3348@x))) (and (vector? f3348@x) (> (vector-length f3348@x) '0) (f2a5a@f292c@annotation? (vector-ref f3348@x '0)))) (f2f26@strip-annotations f3348@x) f3348@x) (let f334e@f ((f334c@x f3348@x)) (if (f2ee2@stx? f334c@x) (begin (if (pair? (f2ee4@stx-expr f334c@x)) (begin (set-source-info! (f2ee4@stx-expr f334c@x) '#f) (set-source-info! (cdr (f2ee4@stx-expr f334c@x)) '#f) (set-source-info! (car (f2ee4@stx-expr f334c@x)) '#f)) (void)) (f2f28@strip (f2ee4@stx-expr f334c@x) (f2ee8@stx-mark* f334c@x))) (if (f2a5a@f292c@annotation? f334c@x) (f2a59@f292a@annotation-stripped f334c@x) (if (pair? f334c@x) (let ((f3350@a (f334e@f (car f334c@x))) (f3351@d (f334e@f (cdr f334c@x)))) (if (and (eq? f3350@a (car f334c@x)) (eq? f3351@d (cdr f334c@x))) f334c@x (cons f3350@a f3351@d))) (if (vector? f334c@x) (let ((f3354@old (vector->list f334c@x))) (let ((f3356@new (map f334e@f f3354@old))) (if (for-all eq? f3354@old f3356@new) f334c@x (list->vector f3356@new)))) f334c@x)))))))) (set! f4bfe@f2f28@strip f2f28@strip) (set! f2f2a@stx->datum (lambda (f3358@x) (f2f28@strip f3358@x '()))) (set! f4bff@f2f2a@stx->datum f2f2a@stx->datum) (set! f2f2c@id->label (lambda (f335a@id) (or (id->real-label f335a@id) (let ((f335c@t (f3211@top-level-context))) (if f335c@t ((lambda (f335e@env) (let ((f3360@rib (f31c1@interaction-env-rib f335e@env))) (call-with-values (lambda () (f2ea6@gen-define-label+loc f335a@id f3360@rib)) (lambda (f3366@f3363 f3367@f3365) (let ((f336a@loc_ f3367@f3365) (f336b@lab f3366@f3363)) (begin (f2ecc@extend-rib! f3360@rib f335a@id f336b@lab) f336b@lab)))))) f335c@t) '#f))))) (set! f4c00@f2f2c@id->label f2f2c@id->label) (set! f2f2e@label->binding (lambda (f336e@x f336f@r) (let ((f3372@t (f2d31@f2b7e@imported-label->binding f336e@x))) (if f3372@t ((lambda (f3374@b) (if (and (pair? f3374@b) (eq? (car f3374@b) '$core-rtd)) (cons '$rtd (map f30d3@bless (cdr f3374@b))) (if (and (pair? f3374@b) (eq? (car f3374@b) 'global-rtd)) (let ((f3376@lib (cadr f3374@b)) (f3377@loc (cddr f3374@b))) (cons '$rtd (symbol-value f3377@loc))) f3374@b))) f3372@t) (let ((f337a@t (assq f336e@x f336f@r))) (if f337a@t (cdr f337a@t) (let ((f337c@t (f3211@top-level-context))) (if f337c@t ((lambda (f337e@env) (let ((f3380@t (assq f336e@x (f31c9@interaction-env-locs f337e@env)))) (if f3380@t ((lambda (f3382@p) (cons* 'lexical (cdr f3382@p) '#f)) f3380@t) '(displaced-lexical . #f)))) f337c@t) '(displaced-lexical . #f))))))))) (set! f4c01@f2f2e@label->binding f2f2e@label->binding) (set! f2f30@make-binding cons) (set! f4c02@f2f30@make-binding f2f30@make-binding) (set! f2f32@binding-type car) (set! f4c03@f2f32@binding-type f2f32@binding-type) (set! f2f34@binding-value cdr) (set! f4c04@f2f34@binding-value f2f34@binding-value) (set! f2f36@raise-unbound-error (lambda (f3384@id) (f31ff@syntax-violation* '#f '"unbound identifier" f3384@id (make-undefined-violation)))) (set! f4c05@f2f36@raise-unbound-error f2f36@raise-unbound-error) (set! f2f38@syntax-type (lambda (f3386@e f3387@r) (if (f2f16@id? f3386@e) (let ((f338a@id f3386@e)) (let ((f338c@label (f2f2c@id->label f338a@id))) (let ((f338e@b (f2f2e@label->binding f338c@label f3387@r))) (let ((f3390@type (f2f32@binding-type f338e@b))) (begin (if (not f338c@label) (f2f36@raise-unbound-error f338a@id) (void)) (let ((f3392@t f3390@type)) (if (memv f3392@t '(lexical core-prim macro macro! global local-macro local-macro! global-macro global-macro! displaced-lexical syntax import export $module $core-rtd library mutable)) (values f3390@type (f2f34@binding-value f338e@b) f338a@id) (values 'other '#f '#f)))))))) (if (f2f08@syntax-pair? f3386@e) (let ((f3394@id (f2f10@syntax-car f3386@e))) (if (f2f16@id? f3394@id) (let ((f3396@label (f2f2c@id->label f3394@id))) (let ((f3398@b (f2f2e@label->binding f3396@label f3387@r))) (let ((f339a@type (f2f32@binding-type f3398@b))) (begin (if (not f3396@label) (f2f36@raise-unbound-error f3394@id) (void)) (let ((f339c@t f339a@type)) (if (memv f339c@t '(define define-syntax core-macro begin macro macro! local-macro local-macro! global-macro global-macro! module library set! let-syntax letrec-syntax import export $core-rtd)) (values f339a@type (f2f34@binding-value f3398@b) f3394@id) (values 'call '#f '#f))))))) (values 'call '#f '#f))) (let ((f339e@d (f2f2a@stx->datum f3386@e))) (if (f2f24@self-evaluating? f339e@d) (values 'constant f339e@d '#f) (values 'other '#f '#f))))))) (set! f4c06@f2f38@syntax-type f2f38@syntax-type) (set! f2f46@sanitize-binding (lambda (f33a0@x f33a1@src) (if (procedure? f33a0@x) (cons* 'local-macro f33a0@x f33a1@src) (if (and (pair? f33a0@x) (eq? (car f33a0@x) 'macro!) (procedure? (cdr f33a0@x))) (cons* 'local-macro! (cdr f33a0@x) f33a1@src) (if (and (pair? f33a0@x) (eq? (car f33a0@x) '$rtd)) f33a0@x (assertion-violation 'expand '"invalid transformer" f33a0@x)))))) (set! f4c07@f2f46@sanitize-binding f2f46@sanitize-binding) (set! f2f48@make-variable-transformer (lambda (f33a4@x) (if (procedure? f33a4@x) (cons 'macro! f33a4@x) (assertion-violation 'make-variable-transformer '"not a procedure" f33a4@x)))) (set! f4c08@f2f48@make-variable-transformer f2f48@make-variable-transformer) (set! f2f4a@variable-transformer? (lambda (f33a6@x) (and (pair? f33a6@x) (eq? (car f33a6@x) 'macro!) (procedure? (cdr f33a6@x))))) (set! f4c09@f2f4a@variable-transformer? f2f4a@variable-transformer?) (set! f2f4c@variable-transformer-procedure (lambda (f33a8@x) (if (f2f4a@variable-transformer? f33a8@x) (cdr f33a8@x) (assertion-violation 'variable-transformer-procedure '"not a variable transformer" f33a8@x)))) (set! f4c0a@f2f4c@variable-transformer-procedure f2f4c@variable-transformer-procedure) (set! f2f4e@make-eval-transformer (lambda (f33aa@x) (f2f46@sanitize-binding (eval-core (f2abc@f2a74@expanded->core f33aa@x)) f33aa@x))) (set! f4c0b@f2f4e@make-eval-transformer f2f4e@make-eval-transformer) (set! f309f@parse-define (lambda (f33ac@x) (let ((f33ae@t f33ac@x)) (let ((f33b0@ls/false (f311d@syntax-dispatch f33ae@t '(_ (any . any) any . each-any)))) (if (and f33b0@ls/false (apply (lambda (f33b2@id f33b3@fmls f33b4@b f33b5@b*) (f2f16@id? f33b2@id)) f33b0@ls/false)) (apply (lambda (f33ba@id f33bb@fmls f33bc@b f33bd@b*) (begin (f3143@verify-formals f33bb@fmls f33ac@x) (values f33ba@id (cons 'defun (cons f33bb@fmls (cons f33bc@b f33bd@b*)))))) f33b0@ls/false) (let ((f33c2@t f33ae@t)) (let ((f33c4@ls/false (f311d@syntax-dispatch f33c2@t '(_ any any)))) (if (and f33c4@ls/false (apply (lambda (f33c6@id f33c7@val) (f2f16@id? f33c6@id)) f33c4@ls/false)) (apply (lambda (f33ca@id f33cb@val) (values f33ca@id (cons 'expr f33cb@val))) f33c4@ls/false) (let ((f33ce@t f33c2@t)) (let ((f33d0@ls/false (f311d@syntax-dispatch f33ce@t '(_ any)))) (if (and f33d0@ls/false (apply (lambda (f33d2@id) (f2f16@id? f33d2@id)) f33d0@ls/false)) (apply (lambda (f33d4@id) (values f33d4@id (cons 'expr (f30d3@bless '(void))))) f33d0@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f33ce@t)))))))))))) (set! f4c0c@f309f@parse-define f309f@parse-define) (set! f30a1@parse-define-syntax (lambda (f33d6@x) (let ((f33d8@t f33d6@x)) (let ((f33da@ls/false (f311d@syntax-dispatch f33d8@t '(_ any any)))) (if (and f33da@ls/false (apply (lambda (f33dc@id f33dd@val) (f2f16@id? f33dc@id)) f33da@ls/false)) (apply (lambda (f33e0@id f33e1@val) (values f33e0@id f33e1@val)) f33da@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f33d8@t)))))) (set! f4c0d@f30a1@parse-define-syntax f30a1@parse-define-syntax) (set! f30a3@scheme-stx-hashtable (make-eq-hashtable)) (set! f4c0e@f30a3@scheme-stx-hashtable f30a3@scheme-stx-hashtable) (set! f30a5@scheme-stx (lambda (f33e4@sym) (or (hashtable-ref f30a3@scheme-stx-hashtable f33e4@sym '#f) (let ((f33e6@subst (f2d0d@f2b36@library-subst (f2d2b@f2b72@find-library-by-name '(psyntax system $all))))) (let ((f33e8@stx (make-simple-struct 'stx '5 (list f33e4@sym f2e9a@top-mark* '() '())))) (let ((f33ea@stx (let ((f33ec@t (assq f33e4@sym f33e6@subst))) (if f33ec@t ((lambda (f33ee@x) (let ((f33f0@name (car f33ee@x)) (f33f1@label (cdr f33ee@x))) (f2f02@add-subst (make-simple-struct 'rib '6 (list (list f33f0@name) (list f2e9a@top-mark*) (list f33f1@label) '#f '#f)) f33e8@stx))) f33ec@t) f33e8@stx)))) (begin (hashtable-set! f30a3@scheme-stx-hashtable f33e4@sym f33ea@stx) f33ea@stx))))))) (set! f4c0f@f30a5@scheme-stx f30a5@scheme-stx) (set! f30a7@lexical-var car) (set! f4c10@f30a7@lexical-var f30a7@lexical-var) (set! f30a9@lexical-mutable? cdr) (set! f4c11@f30a9@lexical-mutable? f30a9@lexical-mutable?) (set! f30ab@set-lexical-mutable! set-cdr!) (set! f4c12@f30ab@set-lexical-mutable! f30ab@set-lexical-mutable!) (set! f30ad@add-lexical (lambda (f33f4@lab f33f5@lex f33f6@r) (cons (cons* f33f4@lab 'lexical f33f5@lex '#f) f33f6@r))) (set! f4c13@f30ad@add-lexical f30ad@add-lexical) (set! f30af@add-lexicals (lambda (f33fa@lab* f33fb@lex* f33fc@r) (if (null? f33fa@lab*) f33fc@r (f30af@add-lexicals (cdr f33fa@lab*) (cdr f33fb@lex*) (f30ad@add-lexical (car f33fa@lab*) (car f33fb@lex*) f33fc@r))))) (set! f4c14@f30af@add-lexicals f30af@add-lexicals) (set! f30b1@letrec-helper (lambda (f3400@e f3401@r f3402@mr f3403@build) (let ((f3408@t f3400@e)) (let ((f340a@ls/false (f311d@syntax-dispatch f3408@t '(_ #(each (any any)) any . each-any)))) (if f340a@ls/false (apply (lambda (f340c@lhs* f340d@rhs* f340e@b f340f@b*) (if (not (f2f1e@valid-bound-ids? f340c@lhs*)) (f30d7@invalid-fmls-error f3400@e f340c@lhs*) (let ((f3414@lex* (map f2e9e@gen-lexical f340c@lhs*)) (f3415@lab* (map f2ea2@gen-label f340c@lhs*))) (let ((f3418@rib (f2ed6@make-full-rib f340c@lhs* f3415@lab*)) (f3419@r (f30af@add-lexicals f3415@lab* f3414@lex* f3401@r))) (let ((f341c@body (f3155@chi-internal (f2f02@add-subst f3418@rib (cons f340e@b f340f@b*)) f3419@r f3402@mr)) (f341d@rhs* (f313b@chi-expr* (map (lambda (f3420@x) (f2f02@add-subst f3418@rib f3420@x)) f340d@rhs*) f3419@r f3402@mr))) (f3403@build '#f f3414@lex* f341d@rhs* f341c@body)))))) f340a@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3408@t)))))) (set! f4c15@f30b1@letrec-helper f30b1@letrec-helper) (set! f30b3@let-transformer (lambda (f3422@e f3423@r f3424@mr) (let ((f3428@t f3422@e)) (let ((f342a@ls/false (f311d@syntax-dispatch f3428@t '(_ #(each (any any)) any . each-any)))) (if f342a@ls/false (apply (lambda (f342c@lhs* f342d@rhs* f342e@b f342f@b*) (if (not (f2f1e@valid-bound-ids? f342c@lhs*)) (f30d7@invalid-fmls-error f3422@e f342c@lhs*) (let ((f3434@lex* (map f2e9e@gen-lexical f342c@lhs*)) (f3435@lab* (map f2ea2@gen-label f342c@lhs*)) (f3436@rhs* (f313b@chi-expr* f342d@rhs* f3423@r f3424@mr))) (let ((f343a@rib (f2ed6@make-full-rib f342c@lhs* f3435@lab*)) (f343b@r (f30af@add-lexicals f3435@lab* f3434@lex* f3423@r))) (let ((f343e@body (f3155@chi-internal (f2f02@add-subst f343a@rib (cons f342e@b f342f@b*)) f343b@r f3424@mr))) (f2e7e@f2de1@build-let '#f f3434@lex* f3436@rhs* f343e@body)))))) f342a@ls/false) (let ((f3440@t f3428@t)) (let ((f3442@ls/false (f311d@syntax-dispatch f3440@t '(_ any #(each (any any)) any . each-any)))) (if f3442@ls/false (apply (lambda (f3444@loop f3445@lhs* f3446@rhs* f3447@b f3448@b*) (if (not (f2f1e@valid-bound-ids? f3445@lhs*)) (f30d7@invalid-fmls-error f3422@e f3445@lhs*) (let ((f344e@lex* (map f2e9e@gen-lexical f3445@lhs*)) (f344f@lab* (map f2ea2@gen-label f3445@lhs*)) (f3450@rhs* (f313b@chi-expr* f3446@rhs* f3423@r f3424@mr)) (f3451@loop-lex (f2e9e@gen-lexical f3444@loop)) (f3452@loop-lab (f2ea2@gen-label f3444@loop))) (let ((f3458@loop-rib (f2ed6@make-full-rib (list f3444@loop) (list f3452@loop-lab))) (f3459@rib (f2ed6@make-full-rib f3445@lhs* f344f@lab*)) (f345a@r (f30af@add-lexicals (cons f3452@loop-lab f344f@lab*) (cons f3451@loop-lex f344e@lex*) f3423@r))) (let ((f345e@body (f3155@chi-internal (f2f02@add-subst f3458@loop-rib (f2f02@add-subst f3459@rib (cons f3447@b f3448@b*))) f345a@r f3424@mr))) (f2e7f@f2de3@build-named-let '#f f3451@loop-lex f344e@lex* f3450@rhs* f345e@body)))))) f3442@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3440@t))))))))) (set! f4c16@f30b3@let-transformer f30b3@let-transformer) (set! f30b5@letrec-transformer (lambda (f3460@e f3461@r f3462@mr) (f30b1@letrec-helper f3460@e f3461@r f3462@mr f2e7d@f2ddf@build-letrec))) (set! f4c17@f30b5@letrec-transformer f30b5@letrec-transformer) (set! f30b7@letrec*-transformer (lambda (f3466@e f3467@r f3468@mr) (f30b1@letrec-helper f3466@e f3467@r f3468@mr f2e80@f2de5@build-letrec*))) (set! f4c18@f30b7@letrec*-transformer f30b7@letrec*-transformer) (set! f30b9@fluid-let-syntax-transformer (lambda (f346c@e f346d@r f346e@mr) (letrec* ((f3473@lookup (lambda (f3486@x) (or (f2f2c@id->label f3486@x) (f3201@syntax-violation '#f '"unbound identifier" f346c@e f3486@x))))) (let ((f3474@t f346c@e)) (let ((f3476@ls/false (f311d@syntax-dispatch f3474@t '(_ #(each (any any)) any . each-any)))) (if f3476@ls/false (apply (lambda (f3478@lhs* f3479@rhs* f347a@b f347b@b*) (if (not (f2f1e@valid-bound-ids? f3478@lhs*)) (f30d7@invalid-fmls-error f346c@e f3478@lhs*) (let ((f3480@lab* (map f3473@lookup f3478@lhs*)) (f3481@rhs* (map (lambda (f3484@x) (f2f4e@make-eval-transformer (f317b@expand-transformer f3484@x f346e@mr))) f3479@rhs*))) (f3155@chi-internal (cons f347a@b f347b@b*) (append (map cons f3480@lab* f3481@rhs*) f346d@r) (append (map cons f3480@lab* f3481@rhs*) f346e@mr))))) f3476@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3474@t))))))) (set! f4c19@f30b9@fluid-let-syntax-transformer f30b9@fluid-let-syntax-transformer) (set! f30bb@type-descriptor-transformer (lambda (f3488@e f3489@r f348a@mr) (let ((f348e@t f3488@e)) (let ((f3490@ls/false (f311d@syntax-dispatch f348e@t '(_ any)))) (if (and f3490@ls/false (apply (lambda (f3492@id) (f2f16@id? f3492@id)) f3490@ls/false)) (apply (lambda (f3494@id) (let ((f3496@lab (f2f2c@id->label f3494@id))) (let ((f3498@b (f2f2e@label->binding f3496@lab f3489@r))) (let ((f349a@type (f2f32@binding-type f3498@b))) (begin (if (not f3496@lab) (f2f36@raise-unbound-error f3494@id) (void)) (if (not (and (eq? f349a@type '$rtd) (not (list? (f2f34@binding-value f3498@b))))) (f3201@syntax-violation '#f '"not a record type" f3488@e) (void)) (list 'quote (f2f34@binding-value f3498@b))))))) f3490@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f348e@t)))))) (set! f4c1a@f30bb@type-descriptor-transformer f30bb@type-descriptor-transformer) (set! f30bd@record-type-descriptor-transformer (lambda (f349c@e f349d@r f349e@mr) (let ((f34a2@t f349c@e)) (let ((f34a4@ls/false (f311d@syntax-dispatch f34a2@t '(_ any)))) (if (and f34a4@ls/false (apply (lambda (f34a6@id) (f2f16@id? f34a6@id)) f34a4@ls/false)) (apply (lambda (f34a8@id) (let ((f34aa@lab (f2f2c@id->label f34a8@id))) (let ((f34ac@b (f2f2e@label->binding f34aa@lab f349d@r))) (let ((f34ae@type (f2f32@binding-type f34ac@b))) (begin (if (not f34aa@lab) (f2f36@raise-unbound-error f34a8@id) (void)) (if (not (and (eq? f34ae@type '$rtd) (list? (f2f34@binding-value f34ac@b)))) (f3201@syntax-violation '#f '"not a record type" f349c@e) (void)) (f313f@chi-expr (car (f2f34@binding-value f34ac@b)) f349d@r f349e@mr)))))) f34a4@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f34a2@t)))))) (set! f4c1b@f30bd@record-type-descriptor-transformer f30bd@record-type-descriptor-transformer) (set! f30bf@record-constructor-descriptor-transformer (lambda (f34b0@e f34b1@r f34b2@mr) (let ((f34b6@t f34b0@e)) (let ((f34b8@ls/false (f311d@syntax-dispatch f34b6@t '(_ any)))) (if (and f34b8@ls/false (apply (lambda (f34ba@id) (f2f16@id? f34ba@id)) f34b8@ls/false)) (apply (lambda (f34bc@id) (let ((f34be@lab (f2f2c@id->label f34bc@id))) (let ((f34c0@b (f2f2e@label->binding f34be@lab f34b1@r))) (let ((f34c2@type (f2f32@binding-type f34c0@b))) (begin (if (not f34be@lab) (f2f36@raise-unbound-error f34bc@id) (void)) (if (not (and (eq? f34c2@type '$rtd) (list? (f2f34@binding-value f34c0@b)))) (f3201@syntax-violation '#f '"invalid type" f34b0@e) (void)) (f313f@chi-expr (cadr (f2f34@binding-value f34c0@b)) f34b1@r f34b2@mr)))))) f34b8@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f34b6@t)))))) (set! f4c1c@f30bf@record-constructor-descriptor-transformer f30bf@record-constructor-descriptor-transformer) (set! f30c1@when-macro (lambda (f34c4@e) (let ((f34c6@t f34c4@e)) (let ((f34c8@ls/false (f311d@syntax-dispatch f34c6@t '(_ any any . each-any)))) (if f34c8@ls/false (apply (lambda (f34ca@test f34cb@e f34cc@e*) (f30d3@bless (list 'if f34ca@test (cons 'begin (cons f34cb@e f34cc@e*))))) f34c8@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f34c6@t)))))) (set! f4c1d@f30c1@when-macro f30c1@when-macro) (set! f30c3@unless-macro (lambda (f34d0@e) (let ((f34d2@t f34d0@e)) (let ((f34d4@ls/false (f311d@syntax-dispatch f34d2@t '(_ any any . each-any)))) (if f34d4@ls/false (apply (lambda (f34d6@test f34d7@e f34d8@e*) (f30d3@bless (list 'if (list 'not f34d6@test) (cons 'begin (cons f34d7@e f34d8@e*))))) f34d4@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f34d2@t)))))) (set! f4c1e@f30c3@unless-macro f30c3@unless-macro) (set! f30c5@if-transformer (lambda (f34dc@e f34dd@r f34de@mr) (let ((f34e2@t f34dc@e)) (let ((f34e4@ls/false (f311d@syntax-dispatch f34e2@t '(_ any any any)))) (if f34e4@ls/false (apply (lambda (f34e6@e0 f34e7@e1 f34e8@e2) (list 'if (f313f@chi-expr f34e6@e0 f34dd@r f34de@mr) (f313f@chi-expr f34e7@e1 f34dd@r f34de@mr) (f313f@chi-expr f34e8@e2 f34dd@r f34de@mr))) f34e4@ls/false) (let ((f34ec@t f34e2@t)) (let ((f34ee@ls/false (f311d@syntax-dispatch f34ec@t '(_ any any)))) (if f34ee@ls/false (apply (lambda (f34f0@e0 f34f1@e1) (list 'if (f313f@chi-expr f34f0@e0 f34dd@r f34de@mr) (f313f@chi-expr f34f1@e1 f34dd@r f34de@mr) (f2e7c@f2ddd@build-void))) f34ee@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f34ec@t))))))))) (set! f4c1f@f30c5@if-transformer f30c5@if-transformer) (set! f30c7@and-transformer (lambda (f34f4@e f34f5@r f34f6@mr) (let ((f34fa@t f34f4@e)) (let ((f34fc@ls/false (f311d@syntax-dispatch f34fa@t '(_ . each-any)))) (if f34fc@ls/false (apply (lambda (f34fe@e*) (cons 'and (f313b@chi-expr* f34fe@e* f34f5@r f34f6@mr))) f34fc@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f34fa@t)))))) (set! f4c20@f30c7@and-transformer f30c7@and-transformer) (set! f30c9@or-transformer (lambda (f3500@e f3501@r f3502@mr) (let ((f3506@t f3500@e)) (let ((f3508@ls/false (f311d@syntax-dispatch f3506@t '(_ . each-any)))) (if f3508@ls/false (apply (lambda (f350a@e*) (cons 'or (f313b@chi-expr* f350a@e* f3501@r f3502@mr))) f3508@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3506@t)))))) (set! f4c21@f30c9@or-transformer f30c9@or-transformer) (set! f30cb@case-macro (lambda (f350c@e) (letrec* ((f350f@build-last (lambda (f3536@cls) (let ((f3538@t f3536@cls)) (let ((f353a@ls/false (f311d@syntax-dispatch f3538@t '(#(scheme-id else) any . each-any)))) (if f353a@ls/false (apply (lambda (f353c@e f353d@e*) (cons 'begin (cons f353c@e f353d@e*))) f353a@ls/false) (let ((f3540@t f3538@t)) (let ((f3542@ls/false (f311d@syntax-dispatch f3540@t '_))) (if f3542@ls/false (apply (lambda () (f3511@build-one f3536@cls '(if #f #f))) f3542@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3540@t))))))))) (f3511@build-one (lambda (f3528@cls f3529@k) (let ((f352c@t f3528@cls)) (let ((f352e@ls/false (f311d@syntax-dispatch f352c@t '(each-any any . each-any)))) (if f352e@ls/false (apply (lambda (f3530@d* f3531@e f3532@e*) (list 'if (list 'memv 't (list 'quote f3530@d*)) (cons 'begin (cons f3531@e f3532@e*)) f3529@k)) f352e@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f352c@t))))))) (let ((f3512@t f350c@e)) (let ((f3514@ls/false (f311d@syntax-dispatch f3512@t '(_ any)))) (if f3514@ls/false (apply (lambda (f3516@expr) (f30d3@bless (cons 'let (cons (list (list 't f3516@expr)) '((if #f #f)))))) f3514@ls/false) (let ((f3518@t f3512@t)) (let ((f351a@ls/false (f311d@syntax-dispatch f3518@t '(_ any any . each-any)))) (if f351a@ls/false (apply (lambda (f351c@expr f351d@cls f351e@cls*) (f30d3@bless (list 'let (list (list 't f351c@expr)) (let f3526@f ((f3522@cls f351d@cls) (f3523@cls* f351e@cls*)) (if (null? f3523@cls*) (f350f@build-last f3522@cls) (f3511@build-one f3522@cls (f3526@f (car f3523@cls*) (cdr f3523@cls*)))))))) f351a@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3518@t)))))))))) (set! f4c22@f30cb@case-macro f30cb@case-macro) (set! f30cd@quote-transformer (lambda (f3544@e f3545@r f3546@mr) (let ((f354a@t f3544@e)) (let ((f354c@ls/false (f311d@syntax-dispatch f354a@t '(_ any)))) (if f354c@ls/false (apply (lambda (f354e@datum) (list 'quote (f2f2a@stx->datum f354e@datum))) f354c@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f354a@t)))))) (set! f4c23@f30cd@quote-transformer f30cd@quote-transformer) (set! f30cf@case-lambda-transformer (lambda (f3550@e f3551@r f3552@mr) (let ((f3556@t f3550@e)) (let ((f3558@ls/false (f311d@syntax-dispatch f3556@t '(_ . #(each (any any . each-any)))))) (if f3558@ls/false (apply (lambda (f355a@fmls* f355b@b* f355c@b**) (call-with-values (lambda () (f3147@chi-lambda-clause* f3550@e f355a@fmls* (map cons f355b@b* f355c@b**) f3551@r f3552@mr)) (lambda (f3564@f3561 f3565@f3563) (let ((f3568@body* f3565@f3563) (f3569@fmls* f3564@f3561)) (f2e7a@f2dad@build-case-lambda '#f f3569@fmls* f3568@body*))))) f3558@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3556@t)))))) (set! f4c24@f30cf@case-lambda-transformer f30cf@case-lambda-transformer) (set! f30d1@lambda-transformer (lambda (f356c@e f356d@r f356e@mr) (let ((f3572@t f356c@e)) (let ((f3574@ls/false (f311d@syntax-dispatch f3572@t '(_ any any . each-any)))) (if f3574@ls/false (apply (lambda (f3576@fmls f3577@b f3578@b*) (call-with-values (lambda () (f3145@chi-lambda-clause f356c@e f3576@fmls (cons f3577@b f3578@b*) f356d@r f356e@mr)) (lambda (f3580@f357d f3581@f357f) (let ((f3584@body f3581@f357f) (f3585@fmls f3580@f357d)) (f2e79@f2dab@build-lambda '#f f3585@fmls f3584@body))))) f3574@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3572@t)))))) (set! f4c25@f30d1@lambda-transformer f30d1@lambda-transformer) (set! f30d3@bless (lambda (f3588@x) (f2efe@mkstx (let f358c@f ((f358a@x f3588@x)) (if (f2ee2@stx? f358a@x) f358a@x (if (pair? f358a@x) (cons (f358c@f (car f358a@x)) (f358c@f (cdr f358a@x))) (if (symbol? f358a@x) (f30a5@scheme-stx f358a@x) (if (vector? f358a@x) (vector-map f358c@f f358a@x) f358a@x))))) '() '() '()))) (set! f4c26@f30d3@bless f30d3@bless) (set! f30d5@with-syntax-macro (lambda (f358e@e) (let ((f3590@t f358e@e)) (let ((f3592@ls/false (f311d@syntax-dispatch f3590@t '(_ #(each (any any)) any . each-any)))) (if f3592@ls/false (apply (lambda (f3594@pat* f3595@expr* f3596@b f3597@b*) (let ((f359c@idn* (let f35a0@f ((f359e@pat* f3594@pat*)) (if (null? f359e@pat*) '() (call-with-values (lambda () (f311b@convert-pattern (car f359e@pat*) '())) (lambda (f35a6@f35a3 f35a7@f35a5) (let ((f35aa@idn* f35a7@f35a5) (f35ab@pat f35a6@f35a3)) (append f35aa@idn* (f35a0@f (cdr f359e@pat*)))))))))) (begin (f3143@verify-formals (map car f359c@idn*) f358e@e) (let ((f35ae@t* (f31ef@generate-temporaries f3595@expr*))) (f30d3@bless (list 'let (map list f35ae@t* f3595@expr*) (let f35b4@f ((f35b0@pat* f3594@pat*) (f35b1@t* f35ae@t*)) (if (null? f35b0@pat*) (cons 'begin (cons '#f (cons f3596@b f3597@b*))) (list 'syntax-case (car f35b1@t*) '() (list (car f35b0@pat*) (f35b4@f (cdr f35b0@pat*) (cdr f35b1@t*))) (list '_ (list 'assertion-violation ''with-syntax '"pattern does not match value" (list 'quote (car f35b0@pat*)) (car f35b1@t*)))))))))))) f3592@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3590@t)))))) (set! f4c27@f30d5@with-syntax-macro f30d5@with-syntax-macro) (set! f30d7@invalid-fmls-error (lambda (f35b6@stx f35b7@fmls) (let ((f35ba@t f35b7@fmls)) (let ((f35bc@ls/false (f311d@syntax-dispatch f35ba@t '#(each+ any () any)))) (if f35bc@ls/false (apply (lambda (f35be@id* f35bf@last) (let f35c4@f ((f35c2@id* (if (f2f16@id? f35bf@last) (cons f35bf@last f35be@id*) (if (f2f0c@syntax-null? f35bf@last) f35be@id* (f3201@syntax-violation '#f '"not an identifier" f35b6@stx f35bf@last))))) (if (null? f35c2@id*) (values) (if (not (f2f16@id? (car f35c2@id*))) (f3201@syntax-violation '#f '"not an identifier" f35b6@stx (car f35c2@id*)) (begin (f35c4@f (cdr f35c2@id*)) (if (f2f22@bound-id-member? (car f35c2@id*) (cdr f35c2@id*)) (f3201@syntax-violation '#f '"duplicate binding" f35b6@stx (car f35c2@id*)) (void))))))) f35bc@ls/false) (let ((f35c6@t f35ba@t)) (let ((f35c8@ls/false (f311d@syntax-dispatch f35c6@t '_))) (if f35c8@ls/false (apply (lambda () (f3201@syntax-violation '#f '"malformed binding form" f35b6@stx f35b7@fmls)) f35c8@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f35c6@t))))))))) (set! f4c28@f30d7@invalid-fmls-error f30d7@invalid-fmls-error) (set! f30d9@let-macro (lambda (f35ca@stx) (let ((f35cc@t f35ca@stx)) (let ((f35ce@ls/false (f311d@syntax-dispatch f35cc@t '(_ #(each (any any)) any . each-any)))) (if f35ce@ls/false (apply (lambda (f35d0@lhs* f35d1@rhs* f35d2@b f35d3@b*) (if (f2f1e@valid-bound-ids? f35d0@lhs*) (f30d3@bless (cons (cons 'lambda (cons f35d0@lhs* (cons f35d2@b f35d3@b*))) f35d1@rhs*)) (f30d7@invalid-fmls-error f35ca@stx f35d0@lhs*))) f35ce@ls/false) (let ((f35d8@t f35cc@t)) (let ((f35da@ls/false (f311d@syntax-dispatch f35d8@t '(_ any #(each (any any)) any . each-any)))) (if (and f35da@ls/false (apply (lambda (f35dc@f f35dd@lhs* f35de@rhs* f35df@b f35e0@b*) (f2f16@id? f35dc@f)) f35da@ls/false)) (apply (lambda (f35e6@f f35e7@lhs* f35e8@rhs* f35e9@b f35ea@b*) (if (f2f1e@valid-bound-ids? f35e7@lhs*) (f30d3@bless (cons (list 'letrec (list (list f35e6@f (cons 'lambda (cons f35e7@lhs* (cons f35e9@b f35ea@b*))))) f35e6@f) f35e8@rhs*)) (f30d7@invalid-fmls-error f35ca@stx f35e7@lhs*))) f35da@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f35d8@t))))))))) (set! f4c29@f30d9@let-macro f30d9@let-macro) (set! f30db@let-values-macro (lambda (f35f0@stx) (letrec* ((f35f3@rename (lambda (f3658@x f3659@old* f365a@new*) (begin (if (not (f2f16@id? f3658@x)) (f3201@syntax-violation '#f '"not an indentifier" f35f0@stx f3658@x) (void)) (if (f2f22@bound-id-member? f3658@x f3659@old*) (f3201@syntax-violation '#f '"duplicate binding" f35f0@stx f3658@x) (void)) (let ((f365e@y (gensym (f3207@syntax->datum f3658@x)))) (values f365e@y (cons f3658@x f3659@old*) (cons f365e@y f365a@new*)))))) (f35f5@rename* (lambda (f3646@x* f3647@old* f3648@new*) (if (null? f3646@x*) (values '() f3647@old* f3648@new*) (call-with-values (lambda () (f35f3@rename (car f3646@x*) f3647@old* f3648@new*)) (lambda (f364c@x f364d@old* f364e@new*) (call-with-values (lambda () (f35f5@rename* (cdr f3646@x*) f364d@old* f364e@new*)) (lambda (f3652@x* f3653@old* f3654@new*) (values (cons f364c@x f3652@x*) f3653@old* f3654@new*))))))))) (let ((f35f6@t f35f0@stx)) (let ((f35f8@ls/false (f311d@syntax-dispatch f35f6@t '(_ () any . each-any)))) (if f35f8@ls/false (apply (lambda (f35fa@b f35fb@b*) (cons* (f30d3@bless 'let) '() f35fa@b f35fb@b*)) f35f8@ls/false) (let ((f35fe@t f35f6@t)) (let ((f3600@ls/false (f311d@syntax-dispatch f35fe@t '(_ #(each (any any)) any . each-any)))) (if f3600@ls/false (apply (lambda (f3602@lhs* f3603@rhs* f3604@b f3605@b*) (f30d3@bless (let f3612@f ((f360a@lhs* f3602@lhs*) (f360b@rhs* f3603@rhs*) (f360c@old* '()) (f360d@new* '())) (if (null? f360a@lhs*) (cons 'let (cons (map list f360c@old* f360d@new*) (cons f3604@b f3605@b*))) (let ((f3614@t (car f360a@lhs*))) (let ((f3616@ls/false (f311d@syntax-dispatch f3614@t 'each-any))) (if f3616@ls/false (apply (lambda (f3618@x*) (call-with-values (lambda () (f35f5@rename* f3618@x* f360c@old* f360d@new*)) (lambda (f3620@f361b f3621@f361d f3622@f361f) (let ((f3626@new* f3622@f361f) (f3627@old* f3621@f361d) (f3628@y* f3620@f361b)) (list 'call-with-values (list 'lambda '() (car f360b@rhs*)) (list 'lambda f3628@y* (f3612@f (cdr f360a@lhs*) (cdr f360b@rhs*) f3627@old* f3626@new*))))))) f3616@ls/false) (let ((f362c@t f3614@t)) (let ((f362e@ls/false (f311d@syntax-dispatch f362c@t '#(each+ any () any)))) (if f362e@ls/false (apply (lambda (f3630@x* f3631@x) (call-with-values (lambda () (f35f3@rename f3631@x f360c@old* f360d@new*)) (lambda (f3634@y f3635@old* f3636@new*) (call-with-values (lambda () (f35f5@rename* f3630@x* f3635@old* f3636@new*)) (lambda (f363a@y* f363b@old* f363c@new*) (list 'call-with-values (list 'lambda '() (car f360b@rhs*)) (list 'lambda (append f363a@y* f3634@y) (f3612@f (cdr f360a@lhs*) (cdr f360b@rhs*) f363b@old* f363c@new*)))))))) f362e@ls/false) (let ((f3640@t f362c@t)) (let ((f3642@ls/false (f311d@syntax-dispatch f3640@t 'any))) (if f3642@ls/false (apply (lambda (f3644@others) (f3201@syntax-violation '#f '"malformed bindings" f35f0@stx f3644@others)) f3642@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3640@t)))))))))))))) f3600@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f35fe@t)))))))))) (set! f4c2a@f30db@let-values-macro f30db@let-values-macro) (set! f30dd@let*-values-macro (lambda (f3660@stx) (letrec* ((f3663@check (lambda (f3692@x*) (if (not (null? f3692@x*)) (let ((f3694@x (car f3692@x*))) (begin (if (not (f2f16@id? f3694@x)) (f3201@syntax-violation '#f '"not an identifier" f3660@stx f3694@x) (void)) (f3663@check (cdr f3692@x*)) (if (f2f22@bound-id-member? f3694@x (cdr f3692@x*)) (f3201@syntax-violation '#f '"duplicate identifier" f3660@stx f3694@x) (void)))) (void))))) (let ((f3664@t f3660@stx)) (let ((f3666@ls/false (f311d@syntax-dispatch f3664@t '(_ () any . each-any)))) (if f3666@ls/false (apply (lambda (f3668@b f3669@b*) (cons* (f30d3@bless 'let) '() f3668@b f3669@b*)) f3666@ls/false) (let ((f366c@t f3664@t)) (let ((f366e@ls/false (f311d@syntax-dispatch f366c@t '(_ #(each (any any)) any . each-any)))) (if f366e@ls/false (apply (lambda (f3670@lhs* f3671@rhs* f3672@b f3673@b*) (f30d3@bless (let f367c@f ((f3678@lhs* f3670@lhs*) (f3679@rhs* f3671@rhs*)) (if (null? f3678@lhs*) (cons 'begin (cons f3672@b f3673@b*)) (let ((f367e@t (car f3678@lhs*))) (let ((f3680@ls/false (f311d@syntax-dispatch f367e@t 'each-any))) (if f3680@ls/false (apply (lambda (f3682@x*) (begin (f3663@check f3682@x*) (list 'call-with-values (list 'lambda '() (car f3679@rhs*)) (list 'lambda f3682@x* (f367c@f (cdr f3678@lhs*) (cdr f3679@rhs*)))))) f3680@ls/false) (let ((f3684@t f367e@t)) (let ((f3686@ls/false (f311d@syntax-dispatch f3684@t '#(each+ any () any)))) (if f3686@ls/false (apply (lambda (f3688@x* f3689@x) (begin (f3663@check (cons f3689@x f3688@x*)) (list 'call-with-values (list 'lambda '() (car f3679@rhs*)) (list 'lambda (append f3688@x* f3689@x) (f367c@f (cdr f3678@lhs*) (cdr f3679@rhs*)))))) f3686@ls/false) (let ((f368c@t f3684@t)) (let ((f368e@ls/false (f311d@syntax-dispatch f368c@t 'any))) (if f368e@ls/false (apply (lambda (f3690@others) (f3201@syntax-violation '#f '"malformed bindings" f3660@stx f3690@others)) f368e@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f368c@t)))))))))))))) f366e@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f366c@t)))))))))) (set! f4c2b@f30dd@let*-values-macro f30dd@let*-values-macro) (set! f30df@trace-lambda-macro (lambda (f3696@stx) (let ((f3698@t f3696@stx)) (let ((f369a@ls/false (f311d@syntax-dispatch f3698@t '(_ any each-any any . each-any)))) (if f369a@ls/false (apply (lambda (f369c@who f369d@fmls f369e@b f369f@b*) (if (f2f1e@valid-bound-ids? f369d@fmls) (f30d3@bless (list 'make-traced-procedure (list 'quote f369c@who) (cons 'lambda (cons f369d@fmls (cons f369e@b f369f@b*))))) (f30d7@invalid-fmls-error f3696@stx f369d@fmls))) f369a@ls/false) (let ((f36a4@t f3698@t)) (let ((f36a6@ls/false (f311d@syntax-dispatch f36a4@t '(_ any #(each+ any () any) any . each-any)))) (if f36a6@ls/false (apply (lambda (f36a8@who f36a9@fmls f36aa@last f36ab@b f36ac@b*) (if (f2f1e@valid-bound-ids? (cons f36aa@last f36a9@fmls)) (f30d3@bless (list 'make-traced-procedure (list 'quote f36a8@who) (cons 'lambda (cons (append f36a9@fmls f36aa@last) (cons f36ab@b f36ac@b*))))) (f30d7@invalid-fmls-error f3696@stx (append f36a9@fmls f36aa@last)))) f36a6@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f36a4@t))))))))) (set! f4c2c@f30df@trace-lambda-macro f30df@trace-lambda-macro) (set! f30e1@trace-define-macro (lambda (f36b2@stx) (let ((f36b4@t f36b2@stx)) (let ((f36b6@ls/false (f311d@syntax-dispatch f36b4@t '(_ (any . each-any) any . each-any)))) (if f36b6@ls/false (apply (lambda (f36b8@who f36b9@fmls f36ba@b f36bb@b*) (if (f2f1e@valid-bound-ids? f36b9@fmls) (f30d3@bless (list 'define f36b8@who (list 'make-traced-procedure (list 'quote f36b8@who) (cons 'lambda (cons f36b9@fmls (cons f36ba@b f36bb@b*)))))) (f30d7@invalid-fmls-error f36b2@stx f36b9@fmls))) f36b6@ls/false) (let ((f36c0@t f36b4@t)) (let ((f36c2@ls/false (f311d@syntax-dispatch f36c0@t '(_ (any . #(each+ any () any)) any . each-any)))) (if f36c2@ls/false (apply (lambda (f36c4@who f36c5@fmls f36c6@last f36c7@b f36c8@b*) (if (f2f1e@valid-bound-ids? (cons f36c6@last f36c5@fmls)) (f30d3@bless (list 'define f36c4@who (list 'make-traced-procedure (list 'quote f36c4@who) (cons 'lambda (cons (append f36c5@fmls f36c6@last) (cons f36c7@b f36c8@b*)))))) (f30d7@invalid-fmls-error f36b2@stx (append f36c5@fmls f36c6@last)))) f36c2@ls/false) (let ((f36ce@t f36c0@t)) (let ((f36d0@ls/false (f311d@syntax-dispatch f36ce@t '(_ any any)))) (if f36d0@ls/false (apply (lambda (f36d2@who f36d3@expr) (if (f2f16@id? f36d2@who) (f30d3@bless (list 'define f36d2@who (list 'let (list (list 'v f36d3@expr)) (cons 'if (cons '(procedure? v) (cons (cons 'make-traced-procedure (cons (list 'quote f36d2@who) '(v))) '((assertion-violation 'trace-define "not a procedure" v)))))))) (f3201@syntax-violation '#f '"invalid name" f36b2@stx))) f36d0@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f36ce@t)))))))))))) (set! f4c2d@f30e1@trace-define-macro f30e1@trace-define-macro) (set! f30e3@trace-define-syntax-macro (lambda (f36d6@stx) (let ((f36d8@t f36d6@stx)) (let ((f36da@ls/false (f311d@syntax-dispatch f36d8@t '(_ any any)))) (if f36da@ls/false (apply (lambda (f36dc@who f36dd@expr) (if (f2f16@id? f36dc@who) (f30d3@bless (list 'define-syntax f36dc@who (list 'make-traced-macro (list 'quote f36dc@who) f36dd@expr))) (f3201@syntax-violation '#f '"invalid name" f36d6@stx))) f36da@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f36d8@t)))))) (set! f4c2e@f30e3@trace-define-syntax-macro f30e3@trace-define-syntax-macro) (set! f30e5@trace-let/rec-syntax (lambda (f36e0@who) (lambda (f36e2@stx) (let ((f36e4@t f36e2@stx)) (let ((f36e6@ls/false (f311d@syntax-dispatch f36e4@t '(_ #(each (any any)) any . each-any)))) (if f36e6@ls/false (apply (lambda (f36e8@lhs* f36e9@rhs* f36ea@b f36eb@b*) (if (f2f1e@valid-bound-ids? f36e8@lhs*) (let ((f36f0@rhs* (map (lambda (f36f2@lhs f36f3@rhs) (list 'make-traced-macro (list 'quote f36f2@lhs) f36f3@rhs)) f36e8@lhs* f36e9@rhs*))) (f30d3@bless (cons f36e0@who (cons (map list f36e8@lhs* f36f0@rhs*) (cons f36ea@b f36eb@b*))))) (f30d7@invalid-fmls-error f36e2@stx f36e8@lhs*))) f36e6@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f36e4@t))))))) (set! f4c2f@f30e5@trace-let/rec-syntax f30e5@trace-let/rec-syntax) (set! f30e7@trace-let-syntax-macro (f30e5@trace-let/rec-syntax 'let-syntax)) (set! f4c30@f30e7@trace-let-syntax-macro f30e7@trace-let-syntax-macro) (set! f30e9@trace-letrec-syntax-macro (f30e5@trace-let/rec-syntax 'letrec-syntax)) (set! f4c31@f30e9@trace-letrec-syntax-macro f30e9@trace-letrec-syntax-macro) (set! f30eb@guard-macro (lambda (f36f6@x) (letrec* ((f36f9@gen-clauses (lambda (f3710@con f3711@outerk f3712@clause*) (letrec* ((f3717@f (lambda (f3750@x f3751@k) (let ((f3754@t f3750@x)) (let ((f3756@ls/false (f311d@syntax-dispatch f3754@t '(any #(scheme-id =>) any)))) (if f3756@ls/false (apply (lambda (f3758@e f3759@p) (let ((f375c@t (gensym))) (list 'let (list (list f375c@t f3758@e)) (list 'if f375c@t (list f3759@p f375c@t) f3751@k)))) f3756@ls/false) (let ((f375e@t f3754@t)) (let ((f3760@ls/false (f311d@syntax-dispatch f375e@t '(any)))) (if f3760@ls/false (apply (lambda (f3762@e) (let ((f3764@t (gensym))) (list 'let (list (list f3764@t f3762@e)) (list 'if f3764@t f3764@t f3751@k)))) f3760@ls/false) (let ((f3766@t f375e@t)) (let ((f3768@ls/false (f311d@syntax-dispatch f3766@t '(any any . each-any)))) (if f3768@ls/false (apply (lambda (f376a@e f376b@v f376c@v*) (list 'if f376a@e (cons 'begin (cons f376b@v f376c@v*)) f3751@k)) f3768@ls/false) (let ((f3770@t f3766@t)) (let ((f3772@ls/false (f311d@syntax-dispatch f3770@t '_))) (if f3772@ls/false (apply (lambda () (f3201@syntax-violation '#f '"invalid guard clause" f3750@x)) f3772@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3770@t))))))))))))))) (f3719@f* (lambda (f3726@x*) (let ((f3728@t f3726@x*)) (let ((f372a@ls/false (f311d@syntax-dispatch f3728@t '()))) (if f372a@ls/false (apply (lambda () (let ((f372c@g (gensym))) (values (list f372c@g (list 'lambda '() (list 'raise-continuable f3710@con))) f372c@g))) f372a@ls/false) (let ((f372e@t f3728@t)) (let ((f3730@ls/false (f311d@syntax-dispatch f372e@t '((#(scheme-id else) any . each-any))))) (if f3730@ls/false (apply (lambda (f3732@e f3733@e*) (values (cons 'begin (cons f3732@e f3733@e*)) '#f)) f3730@ls/false) (let ((f3736@t f372e@t)) (let ((f3738@ls/false (f311d@syntax-dispatch f3736@t '(any . any)))) (if f3738@ls/false (apply (lambda (f373a@cls f373b@cls*) (call-with-values (lambda () (f3719@f* f373b@cls*)) (lambda (f3742@f373f f3743@f3741) (let ((f3746@g f3743@f3741) (f3747@e f3742@f373f)) (values (f3717@f f373a@cls f3747@e) f3746@g))))) f3738@ls/false) (let ((f374a@t f3736@t)) (let ((f374c@ls/false (f311d@syntax-dispatch f374a@t 'any))) (if f374c@ls/false (apply (lambda (f374e@others) (f3201@syntax-violation '#f '"invalid guard clause" f374e@others)) f374c@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f374a@t)))))))))))))))) (call-with-values (lambda () (f3719@f* f3712@clause*)) (lambda (f371e@f371b f371f@f371d) (let ((f3722@raisek f371f@f371d) (f3723@code f371e@f371b)) (if f3722@raisek (list (list 'call/cc (list 'lambda (list f3722@raisek) (list f3711@outerk (list 'lambda '() f3723@code))))) (list f3711@outerk (list 'lambda '() f3723@code)))))))))) (let ((f36fa@t f36f6@x)) (let ((f36fc@ls/false (f311d@syntax-dispatch f36fa@t '(_ (any . each-any) any . each-any)))) (if (and f36fc@ls/false (apply (lambda (f36fe@con f36ff@clause* f3700@b f3701@b*) (f2f16@id? f36fe@con)) f36fc@ls/false)) (apply (lambda (f3706@con f3707@clause* f3708@b f3709@b*) (let ((f370e@outerk (gensym))) (f30d3@bless (list (list 'call/cc (list 'lambda (list f370e@outerk) (list 'lambda '() (list 'with-exception-handler (list 'lambda (list f3706@con) (f36f9@gen-clauses f3706@con f370e@outerk f3707@clause*)) (cons 'lambda (cons '() (cons f3708@b f3709@b*))))))))))) f36fc@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f36fa@t))))))) (set! f4c32@f30eb@guard-macro f30eb@guard-macro) (set! f30ed@define-enumeration-macro (lambda (f3774@stx) (letrec* ((f3777@set? (lambda (f3790@x) (or (null? f3790@x) (and (not (memq (car f3790@x) (cdr f3790@x))) (f3777@set? (cdr f3790@x)))))) (f3779@remove-dups (lambda (f378e@ls) (if (null? f378e@ls) '() (cons (car f378e@ls) (f3779@remove-dups (remq (car f378e@ls) (cdr f378e@ls)))))))) (let ((f377a@t f3774@stx)) (let ((f377c@ls/false (f311d@syntax-dispatch f377a@t '(_ any each-any any)))) (if (and f377c@ls/false (apply (lambda (f377e@name f377f@id* f3780@maker) (and (f2f16@id? f377e@name) (f2f16@id? f3780@maker) (for-all f2f16@id? f377f@id*))) f377c@ls/false)) (apply (lambda (f3784@name f3785@id* f3786@maker) (let ((f378a@name* (f3779@remove-dups (f3207@syntax->datum f3785@id*))) (f378b@mk (gensym))) (f30d3@bless (list 'begin (list 'define f378b@mk (list 'enum-set-constructor (list 'make-enumeration (list 'quote f378a@name*)))) (list 'define-syntax f3784@name (list 'lambda '(x) (list 'syntax-case 'x '() (list '(_ n) '(identifier? (syntax n)) (list 'if (list 'memq '(syntax->datum (syntax n)) (list 'quote f378a@name*)) '(syntax 'n) (cons 'syntax-violation (cons (list 'quote f3784@name) '("not a member of set" x (syntax n))))))))) (list 'define-syntax f3786@maker (list 'lambda '(x) (list 'syntax-case 'x '() (list '(_ n* ...) (list 'begin (cons 'for-each (cons (list 'lambda '(n) (list 'unless '(identifier? n) (cons 'syntax-violation (cons (list 'quote f3786@maker) '("non-identifier argument" x n)))) (list 'unless (list 'memq '(syntax->datum n) (list 'quote f378a@name*)) (cons 'syntax-violation (cons (list 'quote f3786@maker) '("not a member of set" x n))))) '((syntax (n* ...))))) (list 'syntax (cons f378b@mk '('(n* ...))))))))))))) f377c@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f377a@t))))))) (set! f4c33@f30ed@define-enumeration-macro f30ed@define-enumeration-macro) (set! f30ef@time-macro (lambda (f3792@stx) (let ((f3794@t f3792@stx)) (let ((f3796@ls/false (f311d@syntax-dispatch f3794@t '(_ any)))) (if f3796@ls/false (apply (lambda (f3798@expr) (f30d3@bless (cons 'let* (cons (cons '(start (time-usage)) (cons (list 'result (list (list 'lambda '() f3798@expr))) '((end (time-usage)) (used (map - end start)) (real (car used)) (user (cadr used)) (sys (caddr used))))) '((format #t "~%;;~a real ~a user ~a sys~%~!" real user sys) result))))) f3796@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3794@t)))))) (set! f4c34@f30ef@time-macro f30ef@time-macro) (set! f30f1@delay-macro (lambda (f379a@stx) (let ((f379c@t f379a@stx)) (let ((f379e@ls/false (f311d@syntax-dispatch f379c@t '(_ any)))) (if f379e@ls/false (apply (lambda (f37a0@expr) (f30d3@bless (list 'make-promise (list 'lambda '() f37a0@expr)))) f379e@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f379c@t)))))) (set! f4c35@f30f1@delay-macro f30f1@delay-macro) (set! f30f3@assert-macro (lambda (f37a2@stx) (let ((f37a4@t f37a2@stx)) (let ((f37a6@ls/false (f311d@syntax-dispatch f37a4@t '(_ any)))) (if f37a6@ls/false (apply (lambda (f37a8@expr) (let ((f37aa@pos (or (f31f9@expression-position f37a2@stx) (f31f9@expression-position f37a8@expr)))) (f30d3@bless (list 'let (list (list 'x f37a8@expr)) (list 'if 'x 'x (list 'assertion-error (list 'quote f37a8@expr) (list 'quote f37aa@pos))))))) f37a6@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f37a4@t)))))) (set! f4c36@f30f3@assert-macro f30f3@assert-macro) (set! f30f5@endianness-macro (lambda (f37ac@stx) (let ((f37ae@t f37ac@stx)) (let ((f37b0@ls/false (f311d@syntax-dispatch f37ae@t '(_ any)))) (if f37b0@ls/false (apply (lambda (f37b2@e) (let ((f37b4@t (f3207@syntax->datum f37b2@e))) (if (memv f37b4@t '(little)) (f30d3@bless ''little) (if (memv f37b4@t '(big)) (f30d3@bless ''big) (f3201@syntax-violation '#f '"endianness must be big or little" f37ac@stx))))) f37b0@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f37ae@t)))))) (set! f4c37@f30f5@endianness-macro f30f5@endianness-macro) (set! f30f7@identifier-syntax-macro (lambda (f37b6@stx) (let ((f37b8@t f37b6@stx)) (let ((f37ba@ls/false (f311d@syntax-dispatch f37b8@t '(_ any)))) (if f37ba@ls/false (apply (lambda (f37bc@expr) (f30d3@bless (list 'lambda '(x) (list 'syntax-case 'x '() (list 'id '(identifier? (syntax id)) (list 'syntax f37bc@expr)) (list '(id e* ...) '(identifier? (syntax id)) (cons 'cons (cons (list 'syntax f37bc@expr) '((syntax (e* ...)))))))))) f37ba@ls/false) (let ((f37be@t f37b8@t)) (let ((f37c0@ls/false (f311d@syntax-dispatch f37be@t '(_ (any any) ((#(scheme-id set!) any any) any))))) (if (and f37c0@ls/false (apply (lambda (f37c2@id1 f37c3@expr1 f37c4@id2 f37c5@expr2 f37c6@expr3) (and (f2f16@id? f37c2@id1) (f2f16@id? f37c4@id2) (f2f16@id? f37c5@expr2))) f37c0@ls/false)) (apply (lambda (f37cc@id1 f37cd@expr1 f37ce@id2 f37cf@expr2 f37d0@expr3) (f30d3@bless (list 'cons ''macro! (list 'lambda '(x) (list 'syntax-case 'x '(set!) (list 'id '(identifier? (syntax id)) (list 'syntax f37cd@expr1)) (list (list 'set! 'id f37cf@expr2) (list 'syntax f37d0@expr3)) (list '(id e* ...) '(identifier? (syntax id)) (list 'syntax (cons f37cd@expr1 '(e* ...))))))))) f37c0@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f37be@t))))))))) (set! f4c38@f30f7@identifier-syntax-macro f30f7@identifier-syntax-macro) (set! f30f9@do-macro (lambda (f37d6@stx) (letrec* ((f37d9@bind (lambda (f37f0@x) (let ((f37f2@t f37f0@x)) (let ((f37f4@ls/false (f311d@syntax-dispatch f37f2@t '(any any)))) (if f37f4@ls/false (apply (lambda (f37f6@x f37f7@init) (list f37f6@x f37f7@init f37f6@x)) f37f4@ls/false) (let ((f37fa@t f37f2@t)) (let ((f37fc@ls/false (f311d@syntax-dispatch f37fa@t '(any any any)))) (if f37fc@ls/false (apply (lambda (f37fe@x f37ff@init f3800@step) (list f37fe@x f37ff@init f3800@step)) f37fc@ls/false) (let ((f3804@t f37fa@t)) (let ((f3806@ls/false (f311d@syntax-dispatch f3804@t '_))) (if f3806@ls/false (apply (lambda () (f3201@syntax-violation '#f '"invalid binding" f37d6@stx)) f3806@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3804@t))))))))))))) (let ((f37da@t f37d6@stx)) (let ((f37dc@ls/false (f311d@syntax-dispatch f37da@t '(_ each-any (any . each-any) . each-any)))) (if f37dc@ls/false (apply (lambda (f37de@binding* f37df@test f37e0@expr* f37e1@command*) (let ((f37e6@t (map f37d9@bind f37de@binding*))) (let ((f37e8@ls/false (f311d@syntax-dispatch f37e6@t '#(each (any any any))))) (if f37e8@ls/false (apply (lambda (f37ea@x* f37eb@init* f37ec@step*) (if (f2f1e@valid-bound-ids? f37ea@x*) (f30d3@bless (list 'letrec (list (list 'loop (list 'lambda f37ea@x* (list 'if f37df@test (cons 'begin (cons '(if #f #f) f37e0@expr*)) (cons 'begin (append f37e1@command* (list (cons 'loop f37ec@step*)))))))) (cons 'loop f37eb@init*))) (f3201@syntax-violation '#f '"invalid bindings" f37d6@stx))) f37e8@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f37e6@t))))) f37dc@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f37da@t))))))) (set! f4c39@f30f9@do-macro f30f9@do-macro) (set! f30fb@let*-macro (lambda (f3808@stx) (let ((f380a@t f3808@stx)) (let ((f380c@ls/false (f311d@syntax-dispatch f380a@t '(_ #(each (any any)) any . each-any)))) (if (and f380c@ls/false (apply (lambda (f380e@lhs* f380f@rhs* f3810@b f3811@b*) (for-all f2f16@id? f380e@lhs*)) f380c@ls/false)) (apply (lambda (f3816@lhs* f3817@rhs* f3818@b f3819@b*) (f30d3@bless (let f3820@f ((f381e@x* (map list f3816@lhs* f3817@rhs*))) (if (null? f381e@x*) (cons 'let (cons '() (cons f3818@b f3819@b*))) (list 'let (list (car f381e@x*)) (f3820@f (cdr f381e@x*))))))) f380c@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f380a@t)))))) (set! f4c3a@f30fb@let*-macro f30fb@let*-macro) (set! f30fd@or-macro (lambda (f3822@stx) (let ((f3824@t f3822@stx)) (let ((f3826@ls/false (f311d@syntax-dispatch f3824@t '(_)))) (if f3826@ls/false (apply (lambda () '#f) f3826@ls/false) (let ((f3828@t f3824@t)) (let ((f382a@ls/false (f311d@syntax-dispatch f3828@t '(_ any . each-any)))) (if f382a@ls/false (apply (lambda (f382c@e f382d@e*) (f30d3@bless (let f3834@f ((f3830@e f382c@e) (f3831@e* f382d@e*)) (if (null? f3831@e*) (list 'begin '#f f3830@e) (list 'let (list (list 't f3830@e)) (list 'if 't 't (f3834@f (car f3831@e*) (cdr f3831@e*)))))))) f382a@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3828@t))))))))) (set! f4c3b@f30fd@or-macro f30fd@or-macro) (set! f30ff@and-macro (lambda (f3836@stx) (let ((f3838@t f3836@stx)) (let ((f383a@ls/false (f311d@syntax-dispatch f3838@t '(_)))) (if f383a@ls/false (apply (lambda () '#t) f383a@ls/false) (let ((f383c@t f3838@t)) (let ((f383e@ls/false (f311d@syntax-dispatch f383c@t '(_ any . each-any)))) (if f383e@ls/false (apply (lambda (f3840@e f3841@e*) (f30d3@bless (let f3848@f ((f3844@e f3840@e) (f3845@e* f3841@e*)) (if (null? f3845@e*) (list 'begin '#f f3844@e) (cons 'if (cons f3844@e (cons (f3848@f (car f3845@e*) (cdr f3845@e*)) '(#f)))))))) f383e@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f383c@t))))))))) (set! f4c3c@f30ff@and-macro f30ff@and-macro) (set! f3101@cond-macro (lambda (f384a@stx) (let ((f384c@t f384a@stx)) (let ((f384e@ls/false (f311d@syntax-dispatch f384c@t '(_ any . each-any)))) (if f384e@ls/false (apply (lambda (f3850@cls f3851@cls*) (f30d3@bless (let f3858@f ((f3854@cls f3850@cls) (f3855@cls* f3851@cls*)) (if (null? f3855@cls*) (let ((f385a@t f3854@cls)) (let ((f385c@ls/false (f311d@syntax-dispatch f385a@t '(#(scheme-id else) any . each-any)))) (if f385c@ls/false (apply (lambda (f385e@e f385f@e*) (cons 'begin (cons f385e@e f385f@e*))) f385c@ls/false) (let ((f3862@t f385a@t)) (let ((f3864@ls/false (f311d@syntax-dispatch f3862@t '(any #(scheme-id =>) any)))) (if f3864@ls/false (apply (lambda (f3866@e f3867@p) (list 'let (list (list 't f3866@e)) (list 'if 't (cons f3867@p '(t))))) f3864@ls/false) (let ((f386a@t f3862@t)) (let ((f386c@ls/false (f311d@syntax-dispatch f386a@t '(any)))) (if f386c@ls/false (apply (lambda (f386e@e) (cons 'or (cons f386e@e '((if #f #f))))) f386c@ls/false) (let ((f3870@t f386a@t)) (let ((f3872@ls/false (f311d@syntax-dispatch f3870@t '(any . each-any)))) (if f3872@ls/false (apply (lambda (f3874@e f3875@e*) (list 'if f3874@e (cons 'begin f3875@e*))) f3872@ls/false) (let ((f3878@t f3870@t)) (let ((f387a@ls/false (f311d@syntax-dispatch f3878@t '_))) (if f387a@ls/false (apply (lambda () (f3201@syntax-violation '#f '"invalid last clause" f384a@stx)) f387a@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3878@t)))))))))))))))) (let ((f387c@t f3854@cls)) (let ((f387e@ls/false (f311d@syntax-dispatch f387c@t '(#(scheme-id else) any . each-any)))) (if f387e@ls/false (apply (lambda (f3880@e f3881@e*) (f3201@syntax-violation '#f '"incorrect position of keyword else" f384a@stx)) f387e@ls/false) (let ((f3884@t f387c@t)) (let ((f3886@ls/false (f311d@syntax-dispatch f3884@t '(any #(scheme-id =>) any)))) (if f3886@ls/false (apply (lambda (f3888@e f3889@p) (list 'let (list (list 't f3888@e)) (list 'if 't (cons f3889@p '(t)) (f3858@f (car f3855@cls*) (cdr f3855@cls*))))) f3886@ls/false) (let ((f388c@t f3884@t)) (let ((f388e@ls/false (f311d@syntax-dispatch f388c@t '(any)))) (if f388e@ls/false (apply (lambda (f3890@e) (list 'or f3890@e (f3858@f (car f3855@cls*) (cdr f3855@cls*)))) f388e@ls/false) (let ((f3892@t f388c@t)) (let ((f3894@ls/false (f311d@syntax-dispatch f3892@t '(any . each-any)))) (if f3894@ls/false (apply (lambda (f3896@e f3897@e*) (list 'if f3896@e (cons 'begin f3897@e*) (f3858@f (car f3855@cls*) (cdr f3855@cls*)))) f3894@ls/false) (let ((f389a@t f3892@t)) (let ((f389c@ls/false (f311d@syntax-dispatch f389a@t '_))) (if f389c@ls/false (apply (lambda () (f3201@syntax-violation '#f '"invalid last clause" f384a@stx)) f389c@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f389a@t)))))))))))))))))))) f384e@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f384c@t)))))) (set! f4c3d@f3101@cond-macro f3101@cond-macro) (set! f3103@do-include (lambda (f389e@stx f389f@id f38a0@filename) (let ((f38a4@filename (f2f2a@stx->datum f38a0@filename))) (begin (if (not (and (string? f38a4@filename) (f2f16@id? f389f@id))) (f3201@syntax-violation '#f '"invalid syntax" f389e@stx) (void)) (cons (f30d3@bless 'begin) (with-input-from-file f38a4@filename (lambda () (let f38a8@f ((f38a6@ls '())) (let ((f38aa@x (f2a58@f2928@read-annotated))) (if (eof-object? f38aa@x) (reverse f38a6@ls) (f38a8@f (cons (f2ef6@datum->stx f389f@id f38aa@x) f38a6@ls)))))))))))) (set! f4c3e@f3103@do-include f3103@do-include) (set! f3105@include-macro (lambda (f38ac@e) (let ((f38ae@t f38ac@e)) (let ((f38b0@ls/false (f311d@syntax-dispatch f38ae@t '(any any)))) (if f38b0@ls/false (apply (lambda (f38b2@id f38b3@filename) (f3103@do-include f38ac@e f38b2@id f38b3@filename)) f38b0@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f38ae@t)))))) (set! f4c3f@f3105@include-macro f3105@include-macro) (set! f3107@include-into-macro (lambda (f38b6@e) (let ((f38b8@t f38b6@e)) (let ((f38ba@ls/false (f311d@syntax-dispatch f38b8@t '(_ any any)))) (if f38ba@ls/false (apply (lambda (f38bc@id f38bd@filename) (f3103@do-include f38b6@e f38bc@id f38bd@filename)) f38ba@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f38b8@t)))))) (set! f4c40@f3107@include-into-macro f3107@include-into-macro) (set! f3109@syntax-rules-macro (lambda (f38c0@e) (let ((f38c2@t f38c0@e)) (let ((f38c4@ls/false (f311d@syntax-dispatch f38c2@t '(_ each-any . #(each (any any)))))) (if f38c4@ls/false (apply (lambda (f38c6@lits f38c7@pat* f38c8@tmp*) (begin (f3123@verify-literals f38c6@lits f38c0@e) (f30d3@bless (list 'lambda '(x) (cons 'syntax-case (cons 'x (cons f38c6@lits (map (lambda (f38cc@pat f38cd@tmp) (let ((f38d0@t f38cc@pat)) (let ((f38d2@ls/false (f311d@syntax-dispatch f38d0@t '(_ . any)))) (if f38d2@ls/false (apply (lambda (f38d4@rest) (list (cons 'g f38d4@rest) (list 'syntax f38cd@tmp))) f38d2@ls/false) (let ((f38d6@t f38d0@t)) (let ((f38d8@ls/false (f311d@syntax-dispatch f38d6@t '_))) (if f38d8@ls/false (apply (lambda () (f3201@syntax-violation '#f '"invalid syntax-rules pattern" f38c0@e f38cc@pat)) f38d8@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f38d6@t)))))))) f38c7@pat* f38c8@tmp*)))))))) f38c4@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f38c2@t)))))) (set! f4c41@f3109@syntax-rules-macro f3109@syntax-rules-macro) (set! f310b@quasiquote-macro (letrec* ((f38db@datum (lambda (f39dc@x) (list (f30a5@scheme-stx 'quote) (f2efe@mkstx f39dc@x '() '() '())))) (f38f7@quasicons* (lambda (f39d4@x f39d5@y) (let f39da@f ((f39d8@x f39d4@x)) (if (null? f39d8@x) f39d5@y (f38f9@quasicons (car f39d8@x) (f39da@f (cdr f39d8@x))))))) (f38f9@quasicons (lambda (f39ae@x f39af@y) (let ((f39b2@t f39af@y)) (let ((f39b4@ls/false (f311d@syntax-dispatch f39b2@t '(#(scheme-id quote) any)))) (if f39b4@ls/false (apply (lambda (f39b6@dy) (let ((f39b8@t f39ae@x)) (let ((f39ba@ls/false (f311d@syntax-dispatch f39b8@t '(#(scheme-id quote) any)))) (if f39ba@ls/false (apply (lambda (f39bc@dx) (list (f30a5@scheme-stx 'quote) (cons f39bc@dx f39b6@dy))) f39ba@ls/false) (let ((f39be@t f39b8@t)) (let ((f39c0@ls/false (f311d@syntax-dispatch f39be@t '_))) (if f39c0@ls/false (apply (lambda () (let ((f39c2@t f39b6@dy)) (let ((f39c4@ls/false (f311d@syntax-dispatch f39c2@t '()))) (if f39c4@ls/false (apply (lambda () (list (f30a5@scheme-stx 'list) f39ae@x)) f39c4@ls/false) (let ((f39c6@t f39c2@t)) (let ((f39c8@ls/false (f311d@syntax-dispatch f39c6@t '_))) (if f39c8@ls/false (apply (lambda () (list (f30a5@scheme-stx 'cons) f39ae@x f39af@y)) f39c8@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f39c6@t)))))))) f39c0@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f39be@t)))))))) f39b4@ls/false) (let ((f39ca@t f39b2@t)) (let ((f39cc@ls/false (f311d@syntax-dispatch f39ca@t '(#(scheme-id list) . each-any)))) (if f39cc@ls/false (apply (lambda (f39ce@stuff) (cons* (f30a5@scheme-stx 'list) f39ae@x f39ce@stuff)) f39cc@ls/false) (let ((f39d0@t f39ca@t)) (let ((f39d2@ls/false (f311d@syntax-dispatch f39d0@t '_))) (if f39d2@ls/false (apply (lambda () (list (f30a5@scheme-stx 'cons) f39ae@x f39af@y)) f39d2@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f39d0@t)))))))))))) (f38fb@quasiappend (lambda (f3994@x f3995@y) (let ((f3998@ls (let f399c@f ((f399a@x f3994@x)) (if (null? f399a@x) (let ((f399e@t f3995@y)) (let ((f39a0@ls/false (f311d@syntax-dispatch f399e@t '(#(scheme-id quote) ())))) (if f39a0@ls/false (apply (lambda () '()) f39a0@ls/false) (let ((f39a2@t f399e@t)) (let ((f39a4@ls/false (f311d@syntax-dispatch f39a2@t '_))) (if f39a4@ls/false (apply (lambda () (list f3995@y)) f39a4@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f39a2@t))))))) (let ((f39a6@t (car f399a@x))) (let ((f39a8@ls/false (f311d@syntax-dispatch f39a6@t '(#(scheme-id quote) ())))) (if f39a8@ls/false (apply (lambda () (f399c@f (cdr f399a@x))) f39a8@ls/false) (let ((f39aa@t f39a6@t)) (let ((f39ac@ls/false (f311d@syntax-dispatch f39aa@t '_))) (if f39ac@ls/false (apply (lambda () (cons (car f399a@x) (f399c@f (cdr f399a@x)))) f39ac@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f39aa@t))))))))))) (if (null? f3998@ls) (list (f30a5@scheme-stx 'quote) '()) (if (null? (cdr f3998@ls)) (car f3998@ls) (cons* (f30a5@scheme-stx 'append) f3998@ls)))))) (f38fd@quasivector (lambda (f3962@x) (let ((f3964@pat-x f3962@x)) (let ((f3966@t f3964@pat-x)) (let ((f3968@ls/false (f311d@syntax-dispatch f3966@t '(#(scheme-id quote) each-any)))) (if f3968@ls/false (apply (lambda (f396a@x*) (list (f30a5@scheme-stx 'quote) (list->vector f396a@x*))) f3968@ls/false) (let ((f396c@t f3966@t)) (let ((f396e@ls/false (f311d@syntax-dispatch f396c@t '_))) (if f396e@ls/false (apply (lambda () (let f3976@f ((f3970@x f3962@x) (f3971@k (lambda (f3974@ls) (cons* (f30a5@scheme-stx 'vector) f3974@ls)))) (let ((f3978@t f3970@x)) (let ((f397a@ls/false (f311d@syntax-dispatch f3978@t '(#(scheme-id quote) each-any)))) (if f397a@ls/false (apply (lambda (f397c@x*) (f3971@k (map (lambda (f397e@x) (list (f30a5@scheme-stx 'quote) f397e@x)) f397c@x*))) f397a@ls/false) (let ((f3980@t f3978@t)) (let ((f3982@ls/false (f311d@syntax-dispatch f3980@t '(#(scheme-id list) . each-any)))) (if f3982@ls/false (apply (lambda (f3984@x*) (f3971@k f3984@x*)) f3982@ls/false) (let ((f3986@t f3980@t)) (let ((f3988@ls/false (f311d@syntax-dispatch f3986@t '(#(scheme-id cons) any any)))) (if f3988@ls/false (apply (lambda (f398a@x f398b@y) (f3976@f f398b@y (lambda (f398e@ls) (f3971@k (cons f398a@x f398e@ls))))) f3988@ls/false) (let ((f3990@t f3986@t)) (let ((f3992@ls/false (f311d@syntax-dispatch f3990@t '_))) (if f3992@ls/false (apply (lambda () (list (f30a5@scheme-stx 'list->vector) f3964@pat-x)) f3992@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3990@t))))))))))))))) f396e@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f396c@t)))))))))) (f38ff@vquasi (lambda (f3940@p f3941@lev) (let ((f3944@t f3940@p)) (let ((f3946@ls/false (f311d@syntax-dispatch f3944@t '(any . any)))) (if f3946@ls/false (apply (lambda (f3948@p f3949@q) (let ((f394c@t f3948@p)) (let ((f394e@ls/false (f311d@syntax-dispatch f394c@t '(#(scheme-id unquote) . each-any)))) (if f394e@ls/false (apply (lambda (f3950@p) (if (= f3941@lev '0) (f38f7@quasicons* f3950@p (f38ff@vquasi f3949@q f3941@lev)) (f38f9@quasicons (f38f9@quasicons (f38db@datum 'unquote) (f3901@quasi f3950@p (- f3941@lev '1))) (f38ff@vquasi f3949@q f3941@lev)))) f394e@ls/false) (let ((f3952@t f394c@t)) (let ((f3954@ls/false (f311d@syntax-dispatch f3952@t '(#(scheme-id unquote-splicing) . each-any)))) (if f3954@ls/false (apply (lambda (f3956@p) (if (= f3941@lev '0) (f38fb@quasiappend f3956@p (f38ff@vquasi f3949@q f3941@lev)) (f38f9@quasicons (f38f9@quasicons (f38db@datum 'unquote-splicing) (f3901@quasi f3956@p (- f3941@lev '1))) (f38ff@vquasi f3949@q f3941@lev)))) f3954@ls/false) (let ((f3958@t f3952@t)) (let ((f395a@ls/false (f311d@syntax-dispatch f3958@t 'any))) (if f395a@ls/false (apply (lambda (f395c@p) (f38f9@quasicons (f3901@quasi f395c@p f3941@lev) (f38ff@vquasi f3949@q f3941@lev))) f395a@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3958@t))))))))))) f3946@ls/false) (let ((f395e@t f3944@t)) (let ((f3960@ls/false (f311d@syntax-dispatch f395e@t '()))) (if f3960@ls/false (apply (lambda () (list (f30a5@scheme-stx 'quote) '())) f3960@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f395e@t))))))))) (f3901@quasi (lambda (f390a@p f390b@lev) (let ((f390e@t f390a@p)) (let ((f3910@ls/false (f311d@syntax-dispatch f390e@t '(#(scheme-id unquote) any)))) (if f3910@ls/false (apply (lambda (f3912@p) (if (= f390b@lev '0) f3912@p (f38f9@quasicons (f38db@datum 'unquote) (f3901@quasi (list f3912@p) (- f390b@lev '1))))) f3910@ls/false) (let ((f3914@t f390e@t)) (let ((f3916@ls/false (f311d@syntax-dispatch f3914@t '((#(scheme-id unquote) . each-any) . any)))) (if f3916@ls/false (apply (lambda (f3918@p f3919@q) (if (= f390b@lev '0) (f38f7@quasicons* f3918@p (f3901@quasi f3919@q f390b@lev)) (f38f9@quasicons (f38f9@quasicons (f38db@datum 'unquote) (f3901@quasi f3918@p (- f390b@lev '1))) (f3901@quasi f3919@q f390b@lev)))) f3916@ls/false) (let ((f391c@t f3914@t)) (let ((f391e@ls/false (f311d@syntax-dispatch f391c@t '((#(scheme-id unquote-splicing) . each-any) . any)))) (if f391e@ls/false (apply (lambda (f3920@p f3921@q) (if (= f390b@lev '0) (f38fb@quasiappend f3920@p (f3901@quasi f3921@q f390b@lev)) (f38f9@quasicons (f38f9@quasicons (f38db@datum 'unquote-splicing) (f3901@quasi f3920@p (- f390b@lev '1))) (f3901@quasi f3921@q f390b@lev)))) f391e@ls/false) (let ((f3924@t f391c@t)) (let ((f3926@ls/false (f311d@syntax-dispatch f3924@t '(#(scheme-id quasiquote) any)))) (if f3926@ls/false (apply (lambda (f3928@p) (f38f9@quasicons (f38db@datum 'quasiquote) (f3901@quasi (list f3928@p) (+ f390b@lev '1)))) f3926@ls/false) (let ((f392a@t f3924@t)) (let ((f392c@ls/false (f311d@syntax-dispatch f392a@t '(any . any)))) (if f392c@ls/false (apply (lambda (f392e@p f392f@q) (f38f9@quasicons (f3901@quasi f392e@p f390b@lev) (f3901@quasi f392f@q f390b@lev))) f392c@ls/false) (let ((f3932@t f392a@t)) (let ((f3934@ls/false (f311d@syntax-dispatch f3932@t '#(vector each-any)))) (if (and f3934@ls/false (apply (lambda (f3936@x) (not (f2ee2@stx? f3936@x))) f3934@ls/false)) (apply (lambda (f3938@x) (f38fd@quasivector (f38ff@vquasi f3938@x f390b@lev))) f3934@ls/false) (let ((f393a@t f3932@t)) (let ((f393c@ls/false (f311d@syntax-dispatch f393a@t 'any))) (if f393c@ls/false (apply (lambda (f393e@p) (list (f30a5@scheme-stx 'quote) f393e@p)) f393c@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f393a@t))))))))))))))))))))))))) (lambda (f3902@x) (let ((f3904@t f3902@x)) (let ((f3906@ls/false (f311d@syntax-dispatch f3904@t '(_ any)))) (if f3906@ls/false (apply (lambda (f3908@e) (f3901@quasi f3908@e '0)) f3906@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3904@t))))))) (set! f4c42@f310b@quasiquote-macro f310b@quasiquote-macro) (set! f310d@quasisyntax-macro (letrec* ((f39df@quasi (lambda (f39fa@p f39fb@lev) (let ((f39fe@t f39fa@p)) (let ((f3a00@ls/false (f311d@syntax-dispatch f39fe@t '(#(scheme-id unsyntax) any)))) (if f3a00@ls/false (apply (lambda (f3a02@p) (if (= f39fb@lev '0) (let ((f3a04@g (gensym))) (values (list f3a04@g) (list f3a02@p) f3a04@g)) (call-with-values (lambda () (f39df@quasi f3a02@p (- f39fb@lev '1))) (lambda (f3a0c@f3a07 f3a0d@f3a09 f3a0e@f3a0b) (let ((f3a12@p f3a0e@f3a0b) (f3a13@rhs* f3a0d@f3a09) (f3a14@lhs* f3a0c@f3a07)) (values f3a14@lhs* f3a13@rhs* (list 'unsyntax f3a12@p))))))) f3a00@ls/false) (let ((f3a18@t f39fe@t)) (let ((f3a1a@ls/false (f311d@syntax-dispatch f3a18@t '#(scheme-id unsyntax)))) (if (and f3a1a@ls/false (apply (lambda () (= f39fb@lev '0)) f3a1a@ls/false)) (apply (lambda () (f3201@syntax-violation '#f '"incorrect use of unsyntax" f39fa@p)) f3a1a@ls/false) (let ((f3a1c@t f3a18@t)) (let ((f3a1e@ls/false (f311d@syntax-dispatch f3a1c@t '((#(scheme-id unsyntax) . each-any) . any)))) (if f3a1e@ls/false (apply (lambda (f3a20@p* f3a21@q) (call-with-values (lambda () (f39df@quasi f3a21@q f39fb@lev)) (lambda (f3a2a@f3a25 f3a2b@f3a27 f3a2c@f3a29) (let ((f3a30@q f3a2c@f3a29) (f3a31@rhs* f3a2b@f3a27) (f3a32@lhs* f3a2a@f3a25)) (if (= f39fb@lev '0) (let ((f3a36@g* (map (lambda (f3a38@x) (gensym)) f3a20@p*))) (values (append f3a36@g* f3a32@lhs*) (append f3a20@p* f3a31@rhs*) (append f3a36@g* f3a30@q))) (call-with-values (lambda () (f39df@quasi f3a20@p* (- f39fb@lev '1))) (lambda (f3a40@f3a3b f3a41@f3a3d f3a42@f3a3f) (let ((f3a46@p* f3a42@f3a3f) (f3a47@rhs2* f3a41@f3a3d) (f3a48@lhs2* f3a40@f3a3b)) (values (append f3a48@lhs2* f3a32@lhs*) (append f3a47@rhs2* f3a31@rhs*) (cons (cons 'unsyntax f3a46@p*) f3a30@q)))))))))) f3a1e@ls/false) (let ((f3a4c@t f3a1c@t)) (let ((f3a4e@ls/false (f311d@syntax-dispatch f3a4c@t '((#(scheme-id unsyntax-splicing) . each-any) . any)))) (if f3a4e@ls/false (apply (lambda (f3a50@p* f3a51@q) (call-with-values (lambda () (f39df@quasi f3a51@q f39fb@lev)) (lambda (f3a5a@f3a55 f3a5b@f3a57 f3a5c@f3a59) (let ((f3a60@q f3a5c@f3a59) (f3a61@rhs* f3a5b@f3a57) (f3a62@lhs* f3a5a@f3a55)) (if (= f39fb@lev '0) (let ((f3a66@g* (map (lambda (f3a68@x) (gensym)) f3a50@p*))) (values (append (map (lambda (f3a6a@g) (cons f3a6a@g '(...))) f3a66@g*) f3a62@lhs*) (append f3a50@p* f3a61@rhs*) (append (apply append (map (lambda (f3a6c@g) (cons f3a6c@g '(...))) f3a66@g*)) f3a60@q))) (call-with-values (lambda () (f39df@quasi f3a50@p* (- f39fb@lev '1))) (lambda (f3a74@f3a6f f3a75@f3a71 f3a76@f3a73) (let ((f3a7a@p* f3a76@f3a73) (f3a7b@rhs2* f3a75@f3a71) (f3a7c@lhs2* f3a74@f3a6f)) (values (append f3a7c@lhs2* f3a62@lhs*) (append f3a7b@rhs2* f3a61@rhs*) (cons (cons 'unsyntax-splicing f3a7a@p*) f3a60@q)))))))))) f3a4e@ls/false) (let ((f3a80@t f3a4c@t)) (let ((f3a82@ls/false (f311d@syntax-dispatch f3a80@t '#(scheme-id unsyntax-splicing)))) (if (and f3a82@ls/false (apply (lambda () (= f39fb@lev '0)) f3a82@ls/false)) (apply (lambda () (f3201@syntax-violation '#f '"incorrect use of unsyntax-splicing" f39fa@p)) f3a82@ls/false) (let ((f3a84@t f3a80@t)) (let ((f3a86@ls/false (f311d@syntax-dispatch f3a84@t '(#(scheme-id quasisyntax) any)))) (if f3a86@ls/false (apply (lambda (f3a88@p) (call-with-values (lambda () (f39df@quasi f3a88@p (+ f39fb@lev '1))) (lambda (f3a90@f3a8b f3a91@f3a8d f3a92@f3a8f) (let ((f3a96@p f3a92@f3a8f) (f3a97@rhs* f3a91@f3a8d) (f3a98@lhs* f3a90@f3a8b)) (values f3a98@lhs* f3a97@rhs* (list 'quasisyntax f3a96@p)))))) f3a86@ls/false) (let ((f3a9c@t f3a84@t)) (let ((f3a9e@ls/false (f311d@syntax-dispatch f3a9c@t '(any . any)))) (if f3a9e@ls/false (apply (lambda (f3aa0@p f3aa1@q) (call-with-values (lambda () (f39df@quasi f3aa0@p f39fb@lev)) (lambda (f3ab0@f3aa5 f3ab1@f3aa7 f3ab2@f3aa9) (call-with-values (lambda () (f39df@quasi f3aa1@q f39fb@lev)) (lambda (f3ab6@f3aab f3ab7@f3aad f3ab8@f3aaf) (let ((f3abc@q f3ab8@f3aaf) (f3abd@rhs2* f3ab7@f3aad) (f3abe@lhs2* f3ab6@f3aab) (f3abf@p f3ab2@f3aa9) (f3ac0@rhs* f3ab1@f3aa7) (f3ac1@lhs* f3ab0@f3aa5)) (values (append f3abe@lhs2* f3ac1@lhs*) (append f3abd@rhs2* f3ac0@rhs*) (cons f3abf@p f3abc@q)))))))) f3a9e@ls/false) (let ((f3ac8@t f3a9c@t)) (let ((f3aca@ls/false (f311d@syntax-dispatch f3ac8@t '#(vector each-any)))) (if f3aca@ls/false (apply (lambda (f3acc@x*) (call-with-values (lambda () (f39df@quasi f3acc@x* f39fb@lev)) (lambda (f3ad4@f3acf f3ad5@f3ad1 f3ad6@f3ad3) (let ((f3ada@x* f3ad6@f3ad3) (f3adb@rhs* f3ad5@f3ad1) (f3adc@lhs* f3ad4@f3acf)) (values f3adc@lhs* f3adb@rhs* (list->vector f3ada@x*)))))) f3aca@ls/false) (let ((f3ae0@t f3ac8@t)) (let ((f3ae2@ls/false (f311d@syntax-dispatch f3ae0@t '_))) (if f3ae2@ls/false (apply (lambda () (values '() '() f39fa@p)) f3ae2@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3ae0@t))))))))))))))))))))))))))))))) (lambda (f39e0@x) (let ((f39e2@t f39e0@x)) (let ((f39e4@ls/false (f311d@syntax-dispatch f39e2@t '(_ any)))) (if f39e4@ls/false (apply (lambda (f39e6@e) (call-with-values (lambda () (f39df@quasi f39e6@e '0)) (lambda (f39ee@f39e9 f39ef@f39eb f39f0@f39ed) (let ((f39f4@v f39f0@f39ed) (f39f5@rhs* f39ef@f39eb) (f39f6@lhs* f39ee@f39e9)) (f30d3@bless (list 'syntax-case (cons 'list f39f5@rhs*) '() (list f39f6@lhs* (list 'syntax f39f4@v)))))))) f39e4@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f39e2@t))))))) (set! f4c43@f310d@quasisyntax-macro f310d@quasisyntax-macro) (set! f310f@define-struct-macro (lambda (f3ae4@stx) (f3201@syntax-violation '#f '"define-struct not supported" f3ae4@stx))) (set! f4c44@f310f@define-struct-macro f310f@define-struct-macro) (set! f3111@define-record-type-macro (lambda (f3ae6@x) (letrec* ((f3ae9@id (lambda (f3cdc@ctxt . f3cde@str*) (f3205@datum->syntax f3cdc@ctxt (string->symbol (apply string-append (map (lambda (f3ce0@x) (if (symbol? f3ce0@x) (symbol->string f3ce0@x) (if (string? f3ce0@x) f3ce0@x (assertion-violation 'define-record-type '"BUG")))) f3cde@str*)))))) (f3aeb@get-record-name (lambda (f3cca@spec) (let ((f3ccc@t f3cca@spec)) (let ((f3cce@ls/false (f311d@syntax-dispatch f3ccc@t '(any any any)))) (if f3cce@ls/false (apply (lambda (f3cd0@foo f3cd1@make-foo f3cd2@foo?) f3cd0@foo) f3cce@ls/false) (let ((f3cd6@t f3ccc@t)) (let ((f3cd8@ls/false (f311d@syntax-dispatch f3cd6@t 'any))) (if f3cd8@ls/false (apply (lambda (f3cda@foo) f3cda@foo) f3cd8@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3cd6@t))))))))) (f3aed@get-record-constructor-name (lambda (f3cb6@spec) (let ((f3cb8@t f3cb6@spec)) (let ((f3cba@ls/false (f311d@syntax-dispatch f3cb8@t '(any any any)))) (if f3cba@ls/false (apply (lambda (f3cbc@foo f3cbd@make-foo f3cbe@foo?) f3cbd@make-foo) f3cba@ls/false) (let ((f3cc2@t f3cb8@t)) (let ((f3cc4@ls/false (f311d@syntax-dispatch f3cc2@t 'any))) (if (and f3cc4@ls/false (apply (lambda (f3cc6@foo) (f2f16@id? f3cc6@foo)) f3cc4@ls/false)) (apply (lambda (f3cc8@foo) (f3ae9@id f3cc8@foo '"make-" (f2f2a@stx->datum f3cc8@foo))) f3cc4@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3cc2@t))))))))) (f3aef@get-record-predicate-name (lambda (f3ca2@spec) (let ((f3ca4@t f3ca2@spec)) (let ((f3ca6@ls/false (f311d@syntax-dispatch f3ca4@t '(any any any)))) (if f3ca6@ls/false (apply (lambda (f3ca8@foo f3ca9@make-foo f3caa@foo?) f3caa@foo?) f3ca6@ls/false) (let ((f3cae@t f3ca4@t)) (let ((f3cb0@ls/false (f311d@syntax-dispatch f3cae@t 'any))) (if (and f3cb0@ls/false (apply (lambda (f3cb2@foo) (f2f16@id? f3cb2@foo)) f3cb0@ls/false)) (apply (lambda (f3cb4@foo) (f3ae9@id f3cb4@foo (f2f2a@stx->datum f3cb4@foo) '"?")) f3cb0@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3cae@t))))))))) (f3af1@get-clause (lambda (f3c90@id f3c91@ls) (let ((f3c94@t f3c91@ls)) (let ((f3c96@ls/false (f311d@syntax-dispatch f3c94@t '()))) (if f3c96@ls/false (apply (lambda () '#f) f3c96@ls/false) (let ((f3c98@t f3c94@t)) (let ((f3c9a@ls/false (f311d@syntax-dispatch f3c98@t '((any . any) . any)))) (if f3c9a@ls/false (apply (lambda (f3c9c@x f3c9d@rest f3c9e@ls) (if (f2f1c@free-id=? (f30d3@bless f3c90@id) f3c9c@x) (cons f3c9c@x f3c9d@rest) (f3af1@get-clause f3c90@id f3c9e@ls))) f3c9a@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3c98@t))))))))) (f3af3@foo-rtd-code (lambda (f3c3e@name f3c3f@clause* f3c40@parent-rtd-code) (letrec* ((f3c45@convert-field-spec* (lambda (f3c76@ls) (list->vector (map (lambda (f3c78@x) (let ((f3c7a@t f3c78@x)) (let ((f3c7c@ls/false (f311d@syntax-dispatch f3c7a@t '(#(scheme-id mutable) any . any)))) (if f3c7c@ls/false (apply (lambda (f3c7e@name f3c7f@rest) (list 'mutable f3c7e@name)) f3c7c@ls/false) (let ((f3c82@t f3c7a@t)) (let ((f3c84@ls/false (f311d@syntax-dispatch f3c82@t '(#(scheme-id immutable) any . any)))) (if f3c84@ls/false (apply (lambda (f3c86@name f3c87@rest) (list 'immutable f3c86@name)) f3c84@ls/false) (let ((f3c8a@t f3c82@t)) (let ((f3c8c@ls/false (f311d@syntax-dispatch f3c8a@t 'any))) (if f3c8c@ls/false (apply (lambda (f3c8e@name) (list 'immutable f3c8e@name)) f3c8c@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3c8a@t))))))))))) f3c76@ls))))) (let ((f3c46@uid-code (let ((f3c4e@t (f3af1@get-clause 'nongenerative f3c3f@clause*))) (let ((f3c50@ls/false (f311d@syntax-dispatch f3c4e@t '(_)))) (if f3c50@ls/false (apply (lambda () (list 'quote (gensym))) f3c50@ls/false) (let ((f3c52@t f3c4e@t)) (let ((f3c54@ls/false (f311d@syntax-dispatch f3c52@t '(_ any)))) (if f3c54@ls/false (apply (lambda (f3c56@uid) (list 'quote f3c56@uid)) f3c54@ls/false) (let ((f3c58@t f3c52@t)) (let ((f3c5a@ls/false (f311d@syntax-dispatch f3c58@t '_))) (if f3c5a@ls/false (apply (lambda () '#f) f3c5a@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3c58@t))))))))))) (f3c47@sealed? (let ((f3c5c@t (f3af1@get-clause 'sealed f3c3f@clause*))) (let ((f3c5e@ls/false (f311d@syntax-dispatch f3c5c@t '(_ #(atom #t))))) (if f3c5e@ls/false (apply (lambda () '#t) f3c5e@ls/false) (let ((f3c60@t f3c5c@t)) (let ((f3c62@ls/false (f311d@syntax-dispatch f3c60@t '_))) (if f3c62@ls/false (apply (lambda () '#f) f3c62@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3c60@t)))))))) (f3c48@opaque? (let ((f3c64@t (f3af1@get-clause 'opaque f3c3f@clause*))) (let ((f3c66@ls/false (f311d@syntax-dispatch f3c64@t '(_ #(atom #t))))) (if f3c66@ls/false (apply (lambda () '#t) f3c66@ls/false) (let ((f3c68@t f3c64@t)) (let ((f3c6a@ls/false (f311d@syntax-dispatch f3c68@t '_))) (if f3c6a@ls/false (apply (lambda () '#f) f3c6a@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3c68@t)))))))) (f3c49@fields (let ((f3c6c@t (f3af1@get-clause 'fields f3c3f@clause*))) (let ((f3c6e@ls/false (f311d@syntax-dispatch f3c6c@t '(_ . each-any)))) (if f3c6e@ls/false (apply (lambda (f3c70@field-spec*) (list 'quote (f3c45@convert-field-spec* f3c70@field-spec*))) f3c6e@ls/false) (let ((f3c72@t f3c6c@t)) (let ((f3c74@ls/false (f311d@syntax-dispatch f3c72@t '_))) (if f3c74@ls/false (apply (lambda () ''#()) f3c74@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3c72@t))))))))) (f30d3@bless (list 'make-record-type-descriptor (list 'quote f3c3e@name) f3c40@parent-rtd-code f3c46@uid-code f3c47@sealed? f3c48@opaque? f3c49@fields)))))) (f3af5@parent-rtd-code (lambda (f3c26@clause*) (let ((f3c28@t (f3af1@get-clause 'parent f3c26@clause*))) (let ((f3c2a@ls/false (f311d@syntax-dispatch f3c28@t '(_ any)))) (if f3c2a@ls/false (apply (lambda (f3c2c@name) (list 'record-type-descriptor f3c2c@name)) f3c2a@ls/false) (let ((f3c2e@t f3c28@t)) (let ((f3c30@ls/false (f311d@syntax-dispatch f3c2e@t '#(atom #f)))) (if f3c30@ls/false (apply (lambda () (let ((f3c32@t (f3af1@get-clause 'parent-rtd f3c26@clause*))) (let ((f3c34@ls/false (f311d@syntax-dispatch f3c32@t '(_ any any)))) (if f3c34@ls/false (apply (lambda (f3c36@rtd f3c37@rcd) f3c36@rtd) f3c34@ls/false) (let ((f3c3a@t f3c32@t)) (let ((f3c3c@ls/false (f311d@syntax-dispatch f3c3a@t '#(atom #f)))) (if f3c3c@ls/false (apply (lambda () '#f) f3c3c@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3c3a@t)))))))) f3c30@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3c2e@t))))))))) (f3af7@parent-rcd-code (lambda (f3c0e@clause*) (let ((f3c10@t (f3af1@get-clause 'parent f3c0e@clause*))) (let ((f3c12@ls/false (f311d@syntax-dispatch f3c10@t '(_ any)))) (if f3c12@ls/false (apply (lambda (f3c14@name) (list 'record-constructor-descriptor f3c14@name)) f3c12@ls/false) (let ((f3c16@t f3c10@t)) (let ((f3c18@ls/false (f311d@syntax-dispatch f3c16@t '#(atom #f)))) (if f3c18@ls/false (apply (lambda () (let ((f3c1a@t (f3af1@get-clause 'parent-rtd f3c0e@clause*))) (let ((f3c1c@ls/false (f311d@syntax-dispatch f3c1a@t '(_ any any)))) (if f3c1c@ls/false (apply (lambda (f3c1e@rtd f3c1f@rcd) f3c1f@rcd) f3c1c@ls/false) (let ((f3c22@t f3c1a@t)) (let ((f3c24@ls/false (f311d@syntax-dispatch f3c22@t '#(atom #f)))) (if f3c24@ls/false (apply (lambda () '#f) f3c24@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3c22@t)))))))) f3c18@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3c16@t))))))))) (f3af9@foo-rcd-code (lambda (f3c06@clause* f3c07@foo-rtd f3c08@protocol f3c09@parent-rcd-code) (list 'make-record-constructor-descriptor f3c07@foo-rtd f3c09@parent-rcd-code f3c08@protocol))) (f3afb@get-protocol-code (lambda (f3bfa@clause*) (let ((f3bfc@t (f3af1@get-clause 'protocol f3bfa@clause*))) (let ((f3bfe@ls/false (f311d@syntax-dispatch f3bfc@t '(_ any)))) (if f3bfe@ls/false (apply (lambda (f3c00@expr) f3c00@expr) f3bfe@ls/false) (let ((f3c02@t f3bfc@t)) (let ((f3c04@ls/false (f311d@syntax-dispatch f3c02@t '_))) (if f3c04@ls/false (apply (lambda () '#f) f3c04@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3c02@t))))))))) (f3afd@get-fields (lambda (f3be8@clause*) (let ((f3bea@t f3be8@clause*)) (let ((f3bec@ls/false (f311d@syntax-dispatch f3bea@t '()))) (if f3bec@ls/false (apply (lambda () '()) f3bec@ls/false) (let ((f3bee@t f3bea@t)) (let ((f3bf0@ls/false (f311d@syntax-dispatch f3bee@t '((#(scheme-id fields) . each-any) . _)))) (if f3bf0@ls/false (apply (lambda (f3bf2@f*) f3bf2@f*) f3bf0@ls/false) (let ((f3bf4@t f3bee@t)) (let ((f3bf6@ls/false (f311d@syntax-dispatch f3bf4@t '(_ . any)))) (if f3bf6@ls/false (apply (lambda (f3bf8@rest) (f3afd@get-fields f3bf8@rest)) f3bf6@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3bf4@t)))))))))))) (f3aff@get-mutator-indices (lambda (f3bd0@fields) (let f3bd6@f ((f3bd2@fields f3bd0@fields) (f3bd3@i '0)) (let ((f3bd8@t f3bd2@fields)) (let ((f3bda@ls/false (f311d@syntax-dispatch f3bd8@t '()))) (if f3bda@ls/false (apply (lambda () '()) f3bda@ls/false) (let ((f3bdc@t f3bd8@t)) (let ((f3bde@ls/false (f311d@syntax-dispatch f3bdc@t '((#(scheme-id mutable) . _) . any)))) (if f3bde@ls/false (apply (lambda (f3be0@rest) (cons f3bd3@i (f3bd6@f f3be0@rest (+ f3bd3@i '1)))) f3bde@ls/false) (let ((f3be2@t f3bdc@t)) (let ((f3be4@ls/false (f311d@syntax-dispatch f3be2@t '(_ . any)))) (if f3be4@ls/false (apply (lambda (f3be6@rest) (f3bd6@f f3be6@rest (+ f3bd3@i '1))) f3be4@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3be2@t))))))))))))) (f3b01@get-mutators (lambda (f3ba6@foo f3ba7@fields) (letrec* ((f3bab@gen-name (lambda (f3bce@x) (f3205@datum->syntax f3ba6@foo (string->symbol (string-append (symbol->string (f3207@syntax->datum f3ba6@foo)) '"-" (symbol->string (f3207@syntax->datum f3bce@x)) '"-set!")))))) (let f3bae@f ((f3bac@fields f3ba7@fields)) (let ((f3bb0@t f3bac@fields)) (let ((f3bb2@ls/false (f311d@syntax-dispatch f3bb0@t '()))) (if f3bb2@ls/false (apply (lambda () '()) f3bb2@ls/false) (let ((f3bb4@t f3bb0@t)) (let ((f3bb6@ls/false (f311d@syntax-dispatch f3bb4@t '((#(scheme-id mutable) any any any) . any)))) (if f3bb6@ls/false (apply (lambda (f3bb8@name f3bb9@accessor f3bba@mutator f3bbb@rest) (cons f3bba@mutator (f3bae@f f3bbb@rest))) f3bb6@ls/false) (let ((f3bc0@t f3bb4@t)) (let ((f3bc2@ls/false (f311d@syntax-dispatch f3bc0@t '((#(scheme-id mutable) any) . any)))) (if f3bc2@ls/false (apply (lambda (f3bc4@name f3bc5@rest) (cons (f3bab@gen-name f3bc4@name) (f3bae@f f3bc5@rest))) f3bc2@ls/false) (let ((f3bc8@t f3bc0@t)) (let ((f3bca@ls/false (f311d@syntax-dispatch f3bc8@t '(_ . any)))) (if f3bca@ls/false (apply (lambda (f3bcc@rest) (f3bae@f f3bcc@rest)) f3bca@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3bc8@t))))))))))))))))) (f3b03@get-accessors (lambda (f3b62@foo f3b63@fields) (letrec* ((f3b67@gen-name (lambda (f3ba4@x) (f3205@datum->syntax f3b62@foo (string->symbol (string-append (symbol->string (f3207@syntax->datum f3b62@foo)) '"-" (symbol->string (f3207@syntax->datum f3ba4@x)))))))) (map (lambda (f3b68@field) (let ((f3b6a@t f3b68@field)) (let ((f3b6c@ls/false (f311d@syntax-dispatch f3b6a@t '(#(scheme-id mutable) any any any)))) (if (and f3b6c@ls/false (apply (lambda (f3b6e@name f3b6f@accessor f3b70@mutator) (f2f16@id? f3b6f@accessor)) f3b6c@ls/false)) (apply (lambda (f3b74@name f3b75@accessor f3b76@mutator) f3b75@accessor) f3b6c@ls/false) (let ((f3b7a@t f3b6a@t)) (let ((f3b7c@ls/false (f311d@syntax-dispatch f3b7a@t '(#(scheme-id immutable) any any)))) (if (and f3b7c@ls/false (apply (lambda (f3b7e@name f3b7f@accessor) (f2f16@id? f3b7f@accessor)) f3b7c@ls/false)) (apply (lambda (f3b82@name f3b83@accessor) f3b83@accessor) f3b7c@ls/false) (let ((f3b86@t f3b7a@t)) (let ((f3b88@ls/false (f311d@syntax-dispatch f3b86@t '(#(scheme-id mutable) any)))) (if (and f3b88@ls/false (apply (lambda (f3b8a@name) (f2f16@id? f3b8a@name)) f3b88@ls/false)) (apply (lambda (f3b8c@name) (f3b67@gen-name f3b8c@name)) f3b88@ls/false) (let ((f3b8e@t f3b86@t)) (let ((f3b90@ls/false (f311d@syntax-dispatch f3b8e@t '(#(scheme-id immutable) any)))) (if (and f3b90@ls/false (apply (lambda (f3b92@name) (f2f16@id? f3b92@name)) f3b90@ls/false)) (apply (lambda (f3b94@name) (f3b67@gen-name f3b94@name)) f3b90@ls/false) (let ((f3b96@t f3b8e@t)) (let ((f3b98@ls/false (f311d@syntax-dispatch f3b96@t 'any))) (if (and f3b98@ls/false (apply (lambda (f3b9a@name) (f2f16@id? f3b9a@name)) f3b98@ls/false)) (apply (lambda (f3b9c@name) (f3b67@gen-name f3b9c@name)) f3b98@ls/false) (let ((f3b9e@t f3b96@t)) (let ((f3ba0@ls/false (f311d@syntax-dispatch f3b9e@t 'any))) (if f3ba0@ls/false (apply (lambda (f3ba2@others) (f3201@syntax-violation '#f '"invalid field spec" f3b68@field)) f3ba0@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3b9e@t)))))))))))))))))))) f3b63@fields)))) (f3b05@enumerate (lambda (f3b5a@ls) (let f3b60@f ((f3b5c@ls f3b5a@ls) (f3b5d@i '0)) (if (null? f3b5c@ls) '() (cons f3b5d@i (f3b60@f (cdr f3b5c@ls) (+ f3b5d@i '1))))))) (f3b07@do-define-record (lambda (f3b32@namespec f3b33@clause*) (let ((f3b36@foo (f3aeb@get-record-name f3b32@namespec))) (let ((f3b38@foo-rtd (gensym))) (let ((f3b3a@foo-rcd (gensym))) (let ((f3b3c@protocol (gensym))) (let ((f3b3e@make-foo (f3aed@get-record-constructor-name f3b32@namespec))) (let ((f3b40@fields (f3afd@get-fields f3b33@clause*))) (let ((f3b42@idx* (f3b05@enumerate f3b40@fields))) (let ((f3b44@foo-x* (f3b03@get-accessors f3b36@foo f3b40@fields))) (let ((f3b46@set-foo-x!* (f3b01@get-mutators f3b36@foo f3b40@fields))) (let ((f3b48@set-foo-idx* (f3aff@get-mutator-indices f3b40@fields))) (let ((f3b4a@foo? (f3aef@get-record-predicate-name f3b32@namespec))) (let ((f3b4c@foo-rtd-code (f3af3@foo-rtd-code f3b36@foo f3b33@clause* (f3af5@parent-rtd-code f3b33@clause*)))) (let ((f3b4e@foo-rcd-code (f3af9@foo-rcd-code f3b33@clause* f3b38@foo-rtd f3b3c@protocol (f3af7@parent-rcd-code f3b33@clause*)))) (let ((f3b50@protocol-code (f3afb@get-protocol-code f3b33@clause*))) (f30d3@bless (cons 'begin (cons (list 'define f3b38@foo-rtd f3b4c@foo-rtd-code) (cons (list 'define f3b3c@protocol f3b50@protocol-code) (cons (list 'define f3b3a@foo-rcd f3b4e@foo-rcd-code) (cons (list 'define-syntax f3b36@foo (list 'list ''$rtd (list 'syntax f3b38@foo-rtd) (list 'syntax f3b3a@foo-rcd))) (cons (list 'define f3b4a@foo? (list 'record-predicate f3b38@foo-rtd)) (cons (list 'define f3b3e@make-foo (list 'record-constructor f3b3a@foo-rcd)) (append (map (lambda (f3b52@foo-x f3b53@idx) (list 'define f3b52@foo-x (list 'record-accessor f3b38@foo-rtd f3b53@idx))) f3b44@foo-x* f3b42@idx*) (map (lambda (f3b56@set-foo-x! f3b57@idx) (list 'define f3b56@set-foo-x! (list 'record-mutator f3b38@foo-rtd f3b57@idx))) f3b46@set-foo-x!* f3b48@set-foo-idx*)))))))))))))))))))))))))) (f3b09@verify-clauses (lambda (f3b12@x f3b13@cls*) (letrec* ((f3b17@valid-kwds (map f30d3@bless '(fields parent parent-rtd protocol sealed opaque nongenerative))) (f3b19@free-id-member? (lambda (f3b2e@x f3b2f@ls) (and (pair? f3b2f@ls) (or (f2f1c@free-id=? f3b2e@x (car f3b2f@ls)) (f3b19@free-id-member? f3b2e@x (cdr f3b2f@ls))))))) (let f3b1e@f ((f3b1a@cls* f3b13@cls*) (f3b1b@seen* '())) (if (not (null? f3b1a@cls*)) (let ((f3b20@t (car f3b1a@cls*))) (let ((f3b22@ls/false (f311d@syntax-dispatch f3b20@t '(any . any)))) (if f3b22@ls/false (apply (lambda (f3b24@kwd f3b25@rest) (if (or (not (f2f16@id? f3b24@kwd)) (not (f3b19@free-id-member? f3b24@kwd f3b17@valid-kwds))) (f3201@syntax-violation '#f '"not a valid define-record-type keyword" f3b24@kwd) (if (f2f22@bound-id-member? f3b24@kwd f3b1b@seen*) (f3201@syntax-violation '#f '"duplicate use of keyword " f3b12@x f3b24@kwd) (f3b1e@f (cdr f3b1a@cls*) (cons f3b24@kwd f3b1b@seen*))))) f3b22@ls/false) (let ((f3b28@t f3b20@t)) (let ((f3b2a@ls/false (f311d@syntax-dispatch f3b28@t 'any))) (if f3b2a@ls/false (apply (lambda (f3b2c@cls) (f3201@syntax-violation '#f '"malformed define-record-type clause" f3b2c@cls)) f3b2a@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3b28@t))))))) (void))))))) (let ((f3b0a@t f3ae6@x)) (let ((f3b0c@ls/false (f311d@syntax-dispatch f3b0a@t '(_ any . each-any)))) (if f3b0c@ls/false (apply (lambda (f3b0e@namespec f3b0f@clause*) (begin (f3b09@verify-clauses f3ae6@x f3b0f@clause*) (f3b07@do-define-record f3b0e@namespec f3b0f@clause*))) f3b0c@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3b0a@t))))))) (set! f4c45@f3111@define-record-type-macro f3111@define-record-type-macro) (set! f3113@define-condition-type-macro (lambda (f3ce2@x) (letrec* ((f3ce5@mkname (lambda (f3d12@name f3d13@suffix) (f3205@datum->syntax f3d12@name (string->symbol (string-append (symbol->string (f3207@syntax->datum f3d12@name)) f3d13@suffix)))))) (let ((f3ce6@t f3ce2@x)) (let ((f3ce8@ls/false (f311d@syntax-dispatch f3ce6@t '(any any any any any . #(each (any any)))))) (if (and f3ce8@ls/false (apply (lambda (f3cea@ctxt f3ceb@name f3cec@super f3ced@constructor f3cee@predicate f3cef@field* f3cf0@accessor*) (and (f2f16@id? f3ceb@name) (f2f16@id? f3cec@super) (f2f16@id? f3ced@constructor) (f2f16@id? f3cee@predicate) (for-all f2f16@id? f3cef@field*) (for-all f2f16@id? f3cf0@accessor*))) f3ce8@ls/false)) (apply (lambda (f3cf8@ctxt f3cf9@name f3cfa@super f3cfb@constructor f3cfc@predicate f3cfd@field* f3cfe@accessor*) (let ((f3d06@aux-accessor* (map (lambda (f3d08@x) (gensym)) f3cfe@accessor*))) (f30d3@bless (cons 'begin (cons (cons 'define-record-type (cons (list f3cf9@name f3cfb@constructor (gensym)) (cons (list 'parent f3cfa@super) (cons (cons 'fields (map (lambda (f3d0a@field f3d0b@aux) (list 'immutable f3d0a@field f3d0b@aux)) f3cfd@field* f3d06@aux-accessor*)) '((nongenerative) (sealed #f) (opaque #f)))))) (cons (list 'define f3cfc@predicate (list 'condition-predicate (list 'record-type-descriptor f3cf9@name))) (map (lambda (f3d0e@accessor f3d0f@aux) (list 'define f3d0e@accessor (list 'condition-accessor (list 'record-type-descriptor f3cf9@name) f3d0f@aux))) f3cfe@accessor* f3d06@aux-accessor*))))))) f3ce8@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3ce6@t))))))) (set! f4c46@f3113@define-condition-type-macro f3113@define-condition-type-macro) (set! f3115@incorrect-usage-macro (lambda (f3d16@e) (f3201@syntax-violation '#f '"incorrect usage of auxiliary keyword" f3d16@e))) (set! f4c47@f3115@incorrect-usage-macro f3115@incorrect-usage-macro) (set! f3117@parameterize-macro (lambda (f3d18@e) (let ((f3d1a@t f3d18@e)) (let ((f3d1c@ls/false (f311d@syntax-dispatch f3d1a@t '(_ () any . each-any)))) (if f3d1c@ls/false (apply (lambda (f3d1e@b f3d1f@b*) (f30d3@bless (cons 'let (cons '() (cons f3d1e@b f3d1f@b*))))) f3d1c@ls/false) (let ((f3d22@t f3d1a@t)) (let ((f3d24@ls/false (f311d@syntax-dispatch f3d22@t '(_ #(each (any any)) any . each-any)))) (if f3d24@ls/false (apply (lambda (f3d26@olhs* f3d27@orhs* f3d28@b f3d29@b*) (let ((f3d2e@lhs* (f31ef@generate-temporaries f3d26@olhs*)) (f3d2f@rhs* (f31ef@generate-temporaries f3d27@orhs*))) (f30d3@bless (cons (list 'lambda (append f3d2e@lhs* f3d2f@rhs*) (list 'let (list (list 'swap (cons 'lambda (cons '() (map (lambda (f3d32@lhs f3d33@rhs) (list 'let (list (list 't (list f3d32@lhs))) (list f3d32@lhs f3d33@rhs) (cons 'set! (cons f3d33@rhs '(t))))) f3d2e@lhs* f3d2f@rhs*))))) (cons 'dynamic-wind (cons 'swap (cons (cons 'lambda (cons '() (cons f3d28@b f3d29@b*))) '(swap)))))) (append f3d26@olhs* f3d27@orhs*))))) f3d24@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3d22@t))))))))) (set! f4c48@f3117@parameterize-macro f3117@parameterize-macro) (set! f3119@foreign-call-transformer (lambda (f3d36@e f3d37@r f3d38@mr) (let ((f3d3c@t f3d36@e)) (let ((f3d3e@ls/false (f311d@syntax-dispatch f3d3c@t '(_ any . each-any)))) (if f3d3e@ls/false (apply (lambda (f3d40@name f3d41@arg*) (cons 'foreign-call (cons (f313f@chi-expr f3d40@name f3d37@r f3d38@mr) (f313b@chi-expr* f3d41@arg* f3d37@r f3d38@mr)))) f3d3e@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3d3c@t)))))) (set! f4c49@f3119@foreign-call-transformer f3119@foreign-call-transformer) (set! f311b@convert-pattern (lambda (f3d44@pattern f3d45@keys) (letrec* ((f3d49@cvt* (lambda (f3de8@p* f3de9@n f3dea@ids) (if (null? f3de8@p*) (values '() f3dea@ids) (call-with-values (lambda () (f3d49@cvt* (cdr f3de8@p*) f3de9@n f3dea@ids)) (lambda (f3df2@f3def f3df3@f3df1) (let ((f3df6@ids f3df3@f3df1) (f3df7@y f3df2@f3def)) (call-with-values (lambda () (f3d4b@cvt (car f3de8@p*) f3de9@n f3df6@ids)) (lambda (f3dfe@f3dfb f3dff@f3dfd) (let ((f3e02@ids f3dff@f3dfd) (f3e03@x f3dfe@f3dfb)) (values (cons f3e03@x f3df7@y) f3e02@ids)))))))))) (f3d4b@cvt (lambda (f3d4c@p f3d4d@n f3d4e@ids) (let ((f3d52@t f3d4c@p)) (let ((f3d54@ls/false (f311d@syntax-dispatch f3d52@t 'any))) (if (and f3d54@ls/false (apply (lambda (f3d56@id) (f2f16@id? f3d56@id)) f3d54@ls/false)) (apply (lambda (f3d58@id) (if (f2f22@bound-id-member? f3d4c@p f3d45@keys) (values (vector 'free-id f3d4c@p) f3d4e@ids) (if (f2f1c@free-id=? f3d4c@p (f30a5@scheme-stx '_)) (values '_ f3d4e@ids) (values 'any (cons (cons f3d4c@p f3d4d@n) f3d4e@ids))))) f3d54@ls/false) (let ((f3d5a@t f3d52@t)) (let ((f3d5c@ls/false (f311d@syntax-dispatch f3d5a@t '(any any)))) (if (and f3d5c@ls/false (apply (lambda (f3d5e@p f3d5f@dots) (f311f@ellipsis? f3d5f@dots)) f3d5c@ls/false)) (apply (lambda (f3d62@p f3d63@dots) (call-with-values (lambda () (f3d4b@cvt f3d62@p (+ f3d4d@n '1) f3d4e@ids)) (lambda (f3d6a@f3d67 f3d6b@f3d69) (let ((f3d6e@ids f3d6b@f3d69) (f3d6f@p f3d6a@f3d67)) (values (if (eq? f3d6f@p 'any) 'each-any (vector 'each f3d6f@p)) f3d6e@ids))))) f3d5c@ls/false) (let ((f3d72@t f3d5a@t)) (let ((f3d74@ls/false (f311d@syntax-dispatch f3d72@t '(any any . #(each+ any () any))))) (if (and f3d74@ls/false (apply (lambda (f3d76@x f3d77@dots f3d78@ys f3d79@z) (f311f@ellipsis? f3d77@dots)) f3d74@ls/false)) (apply (lambda (f3d7e@x f3d7f@dots f3d80@ys f3d81@z) (call-with-values (lambda () (f3d4b@cvt f3d81@z f3d4d@n f3d4e@ids)) (lambda (f3d8a@f3d87 f3d8b@f3d89) (let ((f3d8e@ids f3d8b@f3d89) (f3d8f@z f3d8a@f3d87)) (call-with-values (lambda () (f3d49@cvt* f3d80@ys f3d4d@n f3d8e@ids)) (lambda (f3d96@f3d93 f3d97@f3d95) (let ((f3d9a@ids f3d97@f3d95) (f3d9b@ys f3d96@f3d93)) (call-with-values (lambda () (f3d4b@cvt f3d7e@x (+ f3d4d@n '1) f3d9a@ids)) (lambda (f3da2@f3d9f f3da3@f3da1) (let ((f3da6@ids f3da3@f3da1) (f3da7@x f3da2@f3d9f)) (values (vector 'each+ f3da7@x (reverse f3d9b@ys) f3d8f@z) f3da6@ids))))))))))) f3d74@ls/false) (let ((f3daa@t f3d72@t)) (let ((f3dac@ls/false (f311d@syntax-dispatch f3daa@t '(any . any)))) (if f3dac@ls/false (apply (lambda (f3dae@x f3daf@y) (call-with-values (lambda () (f3d4b@cvt f3daf@y f3d4d@n f3d4e@ids)) (lambda (f3db6@f3db3 f3db7@f3db5) (let ((f3dba@ids f3db7@f3db5) (f3dbb@y f3db6@f3db3)) (call-with-values (lambda () (f3d4b@cvt f3dae@x f3d4d@n f3dba@ids)) (lambda (f3dc2@f3dbf f3dc3@f3dc1) (let ((f3dc6@ids f3dc3@f3dc1) (f3dc7@x f3dc2@f3dbf)) (values (cons f3dc7@x f3dbb@y) f3dc6@ids)))))))) f3dac@ls/false) (let ((f3dca@t f3daa@t)) (let ((f3dcc@ls/false (f311d@syntax-dispatch f3dca@t '()))) (if f3dcc@ls/false (apply (lambda () (values '() f3d4e@ids)) f3dcc@ls/false) (let ((f3dce@t f3dca@t)) (let ((f3dd0@ls/false (f311d@syntax-dispatch f3dce@t '#(vector each-any)))) (if (and f3dd0@ls/false (apply (lambda (f3dd2@p) (not (f2ee2@stx? f3dd2@p))) f3dd0@ls/false)) (apply (lambda (f3dd4@p) (call-with-values (lambda () (f3d4b@cvt f3dd4@p f3d4d@n f3d4e@ids)) (lambda (f3dda@f3dd7 f3ddb@f3dd9) (let ((f3dde@ids f3ddb@f3dd9) (f3ddf@p f3dda@f3dd7)) (values (vector 'vector f3ddf@p) f3dde@ids))))) f3dd0@ls/false) (let ((f3de2@t f3dce@t)) (let ((f3de4@ls/false (f311d@syntax-dispatch f3de2@t 'any))) (if f3de4@ls/false (apply (lambda (f3de6@datum) (values (vector 'atom (f2f2a@stx->datum f3de6@datum)) f3d4e@ids)) f3de4@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3de2@t))))))))))))))))))))))))) (f3d4b@cvt f3d44@pattern '0 '())))) (set! f4c4a@f311b@convert-pattern f311b@convert-pattern) (set! f311d@syntax-dispatch (letrec* ((f3e07@stx^ (lambda (f3ee2@e f3ee3@m* f3ee4@s* f3ee5@ae*) (if (and (null? f3ee3@m*) (null? f3ee4@s*) (null? f3ee5@ae*)) f3ee2@e (f2efe@mkstx f3ee2@e f3ee3@m* f3ee4@s* f3ee5@ae*)))) (f3e09@match-each (lambda (f3ec2@e f3ec3@p f3ec4@m* f3ec5@s* f3ec6@ae*) (if (pair? f3ec2@e) (let ((f3ecc@first (f3e15@match (car f3ec2@e) f3ec3@p f3ec4@m* f3ec5@s* f3ec6@ae* '()))) (and f3ecc@first (let ((f3ece@rest (f3e09@match-each (cdr f3ec2@e) f3ec3@p f3ec4@m* f3ec5@s* f3ec6@ae*))) (and f3ece@rest (cons f3ecc@first f3ece@rest))))) (if (null? f3ec2@e) '() (if (f2ee2@stx? f3ec2@e) (and (not (f2e9c@top-marked? f3ec4@m*)) (call-with-values (lambda () (join-wraps f3ec4@m* f3ec5@s* f3ec6@ae* f3ec2@e)) (lambda (f3ed6@f3ed1 f3ed7@f3ed3 f3ed8@f3ed5) (let ((f3edc@ae* f3ed8@f3ed5) (f3edd@s* f3ed7@f3ed3) (f3ede@m* f3ed6@f3ed1)) (f3e09@match-each (f2ee4@stx-expr f3ec2@e) f3ec3@p f3ede@m* f3edd@s* f3edc@ae*))))) (if (f2a5a@f292c@annotation? f3ec2@e) (f3e09@match-each (f2a5c@f2930@annotation-expression f3ec2@e) f3ec3@p f3ec4@m* f3ec5@s* f3ec6@ae*) '#f)))))) (f3e0b@match-each+ (lambda (f3e82@e f3e83@x-pat f3e84@y-pat f3e85@z-pat f3e86@m* f3e87@s* f3e88@ae* f3e89@r) (let f3e9a@f ((f3e92@e f3e82@e) (f3e93@m* f3e86@m*) (f3e94@s* f3e87@s*) (f3e95@ae* f3e88@ae*)) (if (pair? f3e92@e) (call-with-values (lambda () (f3e9a@f (cdr f3e92@e) f3e93@m* f3e94@s* f3e95@ae*)) (lambda (f3ea2@f3e9d f3ea3@f3e9f f3ea4@f3ea1) (let ((f3ea8@r f3ea4@f3ea1) (f3ea9@y-pat f3ea3@f3e9f) (f3eaa@xr* f3ea2@f3e9d)) (if f3ea8@r (if (null? f3ea9@y-pat) (let ((f3eae@xr (f3e15@match (car f3e92@e) f3e83@x-pat f3e93@m* f3e94@s* f3e95@ae* '()))) (if f3eae@xr (values (cons f3eae@xr f3eaa@xr*) f3ea9@y-pat f3ea8@r) (values '#f '#f '#f))) (values '() (cdr f3ea9@y-pat) (f3e15@match (car f3e92@e) (car f3ea9@y-pat) f3e93@m* f3e94@s* f3e95@ae* f3ea8@r))) (values '#f '#f '#f))))) (if (f2ee2@stx? f3e92@e) (if (f2e9c@top-marked? f3e93@m*) (values '() f3e84@y-pat (f3e15@match f3e92@e f3e85@z-pat f3e93@m* f3e94@s* f3e95@ae* f3e89@r)) (call-with-values (lambda () (join-wraps f3e93@m* f3e94@s* f3e95@ae* f3e92@e)) (lambda (f3eb6@f3eb1 f3eb7@f3eb3 f3eb8@f3eb5) (let ((f3ebc@ae* f3eb8@f3eb5) (f3ebd@s* f3eb7@f3eb3) (f3ebe@m* f3eb6@f3eb1)) (f3e9a@f (f2ee4@stx-expr f3e92@e) f3ebe@m* f3ebd@s* f3ebc@ae*))))) (if (f2a5a@f292c@annotation? f3e92@e) (f3e9a@f (f2a5c@f2930@annotation-expression f3e92@e) f3e93@m* f3e94@s* f3e95@ae*) (values '() f3e84@y-pat (f3e15@match f3e92@e f3e85@z-pat f3e93@m* f3e94@s* f3e95@ae* f3e89@r)))))))) (f3e0d@match-each-any (lambda (f3e66@e f3e67@m* f3e68@s* f3e69@ae*) (if (pair? f3e66@e) (let ((f3e6e@l (f3e0d@match-each-any (cdr f3e66@e) f3e67@m* f3e68@s* f3e69@ae*))) (and f3e6e@l (cons (f3e07@stx^ (car f3e66@e) f3e67@m* f3e68@s* f3e69@ae*) f3e6e@l))) (if (null? f3e66@e) '() (if (f2ee2@stx? f3e66@e) (and (not (f2e9c@top-marked? f3e67@m*)) (call-with-values (lambda () (join-wraps f3e67@m* f3e68@s* f3e69@ae* f3e66@e)) (lambda (f3e76@f3e71 f3e77@f3e73 f3e78@f3e75) (let ((f3e7c@ae* f3e78@f3e75) (f3e7d@s* f3e77@f3e73) (f3e7e@m* f3e76@f3e71)) (f3e0d@match-each-any (f2ee4@stx-expr f3e66@e) f3e7e@m* f3e7d@s* f3e7c@ae*))))) (if (f2a5a@f292c@annotation? f3e66@e) (f3e0d@match-each-any (f2a5c@f2930@annotation-expression f3e66@e) f3e67@m* f3e68@s* f3e69@ae*) '#f)))))) (f3e0f@match-empty (lambda (f3e60@p f3e61@r) (if (null? f3e60@p) f3e61@r (if (eq? f3e60@p '_) f3e61@r (if (eq? f3e60@p 'any) (cons '() f3e61@r) (if (pair? f3e60@p) (f3e0f@match-empty (car f3e60@p) (f3e0f@match-empty (cdr f3e60@p) f3e61@r)) (if (eq? f3e60@p 'each-any) (cons '() f3e61@r) (let ((f3e64@t (vector-ref f3e60@p '0))) (if (memv f3e64@t '(each)) (f3e0f@match-empty (vector-ref f3e60@p '1) f3e61@r) (if (memv f3e64@t '(each+)) (f3e0f@match-empty (vector-ref f3e60@p '1) (f3e0f@match-empty (reverse (vector-ref f3e60@p '2)) (f3e0f@match-empty (vector-ref f3e60@p '3) f3e61@r))) (if (memv f3e64@t '(free-id atom)) f3e61@r (if (memv f3e64@t '(scheme-id atom)) f3e61@r (if (memv f3e64@t '(vector)) (f3e0f@match-empty (vector-ref f3e60@p '1) f3e61@r) (assertion-violation 'syntax-dispatch '"invalid pattern" f3e60@p)))))))))))))) (f3e11@combine (lambda (f3e5c@r* f3e5d@r) (if (null? (car f3e5c@r*)) f3e5d@r (cons (map car f3e5c@r*) (f3e11@combine (map cdr f3e5c@r*) f3e5d@r))))) (f3e13@match* (lambda (f3e38@e f3e39@p f3e3a@m* f3e3b@s* f3e3c@ae* f3e3d@r) (if (null? f3e39@p) (and (null? f3e38@e) f3e3d@r) (if (pair? f3e39@p) (and (pair? f3e38@e) (f3e15@match (car f3e38@e) (car f3e39@p) f3e3a@m* f3e3b@s* f3e3c@ae* (f3e15@match (cdr f3e38@e) (cdr f3e39@p) f3e3a@m* f3e3b@s* f3e3c@ae* f3e3d@r))) (if (eq? f3e39@p 'each-any) (let ((f3e44@l (f3e0d@match-each-any f3e38@e f3e3a@m* f3e3b@s* f3e3c@ae*))) (and f3e44@l (cons f3e44@l f3e3d@r))) (let ((f3e46@t (vector-ref f3e39@p '0))) (if (memv f3e46@t '(each)) (if (null? f3e38@e) (f3e0f@match-empty (vector-ref f3e39@p '1) f3e3d@r) (let ((f3e48@r* (f3e09@match-each f3e38@e (vector-ref f3e39@p '1) f3e3a@m* f3e3b@s* f3e3c@ae*))) (and f3e48@r* (f3e11@combine f3e48@r* f3e3d@r)))) (if (memv f3e46@t '(free-id)) (and (symbol? f3e38@e) (f2e9c@top-marked? f3e3a@m*) (f2f1c@free-id=? (f3e07@stx^ f3e38@e f3e3a@m* f3e3b@s* f3e3c@ae*) (vector-ref f3e39@p '1)) f3e3d@r) (if (memv f3e46@t '(scheme-id)) (and (symbol? f3e38@e) (f2e9c@top-marked? f3e3a@m*) (f2f1c@free-id=? (f3e07@stx^ f3e38@e f3e3a@m* f3e3b@s* f3e3c@ae*) (f30a5@scheme-stx (vector-ref f3e39@p '1))) f3e3d@r) (if (memv f3e46@t '(each+)) (call-with-values (lambda () (f3e0b@match-each+ f3e38@e (vector-ref f3e39@p '1) (vector-ref f3e39@p '2) (vector-ref f3e39@p '3) f3e3a@m* f3e3b@s* f3e3c@ae* f3e3d@r)) (lambda (f3e50@f3e4b f3e51@f3e4d f3e52@f3e4f) (let ((f3e56@r f3e52@f3e4f) (f3e57@y-pat f3e51@f3e4d) (f3e58@xr* f3e50@f3e4b)) (and f3e56@r (null? f3e57@y-pat) (if (null? f3e58@xr*) (f3e0f@match-empty (vector-ref f3e39@p '1) f3e56@r) (f3e11@combine f3e58@xr* f3e56@r)))))) (if (memv f3e46@t '(atom)) (and (fast-equal? (vector-ref f3e39@p '1) (f2f28@strip f3e38@e f3e3a@m*)) f3e3d@r) (if (memv f3e46@t '(vector)) (and (vector? f3e38@e) (f3e15@match (vector->list f3e38@e) (vector-ref f3e39@p '1) f3e3a@m* f3e3b@s* f3e3c@ae* f3e3d@r)) (assertion-violation 'syntax-dispatch '"invalid pattern" f3e39@p))))))))))))) (f3e15@match (lambda (f3e1a@e f3e1b@p f3e1c@m* f3e1d@s* f3e1e@ae* f3e1f@r) (if (not f3e1f@r) '#f (if (eq? f3e1b@p '_) f3e1f@r (if (eq? f3e1b@p 'any) (cons (f3e07@stx^ f3e1a@e f3e1c@m* f3e1d@s* f3e1e@ae*) f3e1f@r) (if (f2ee2@stx? f3e1a@e) (and (not (f2e9c@top-marked? f3e1c@m*)) (call-with-values (lambda () (join-wraps f3e1c@m* f3e1d@s* f3e1e@ae* f3e1a@e)) (lambda (f3e2c@f3e27 f3e2d@f3e29 f3e2e@f3e2b) (let ((f3e32@ae* f3e2e@f3e2b) (f3e33@s* f3e2d@f3e29) (f3e34@m* f3e2c@f3e27)) (f3e15@match (f2ee4@stx-expr f3e1a@e) f3e1b@p f3e34@m* f3e33@s* f3e32@ae* f3e1f@r))))) (if (f2a5a@f292c@annotation? f3e1a@e) (f3e15@match (f2a5c@f2930@annotation-expression f3e1a@e) f3e1b@p f3e1c@m* f3e1d@s* f3e1e@ae* f3e1f@r) (f3e13@match* f3e1a@e f3e1b@p f3e1c@m* f3e1d@s* f3e1e@ae* f3e1f@r))))))))) (lambda (f3e16@e f3e17@p) (f3e15@match f3e16@e f3e17@p '() '() '() '())))) (set! f4c4b@f311d@syntax-dispatch f311d@syntax-dispatch) (set! f311f@ellipsis? (lambda (f3eea@x) (and (f2f16@id? f3eea@x) (f2f1c@free-id=? f3eea@x (f30a5@scheme-stx '...))))) (set! f4c4c@f311f@ellipsis? f311f@ellipsis?) (set! f3121@underscore? (lambda (f3eec@x) (and (f2f16@id? f3eec@x) (f2f1c@free-id=? f3eec@x (f30a5@scheme-stx '_))))) (set! f4c4d@f3121@underscore? f3121@underscore?) (set! f3123@verify-literals (lambda (f3eee@lits f3eef@expr) (for-each (lambda (f3ef2@x) (if (or (not (f2f16@id? f3ef2@x)) (f311f@ellipsis? f3ef2@x) (f3121@underscore? f3ef2@x)) (f3201@syntax-violation '#f '"invalid literal" f3eef@expr f3ef2@x) (void))) f3eee@lits))) (set! f4c4e@f3123@verify-literals f3123@verify-literals) (set! f3125@syntax-case-transformer (letrec* ((f3ef5@build-dispatch-call (lambda (f3f66@pvars f3f67@expr f3f68@y f3f69@r f3f6a@mr) (let ((f3f70@ids (map car f3f66@pvars)) (f3f71@levels (map cdr f3f66@pvars))) (let ((f3f74@labels (map f2ea2@gen-label f3f70@ids)) (f3f75@new-vars (map f2e9e@gen-lexical f3f70@ids))) (let ((f3f78@body (f313f@chi-expr (f2f02@add-subst (f2ed6@make-full-rib f3f70@ids f3f74@labels) f3f67@expr) (append (map (lambda (f3f7a@label f3f7b@var f3f7c@level) (cons f3f7a@label (f2f30@make-binding 'syntax (cons f3f7b@var f3f7c@level)))) f3f74@labels f3f75@new-vars (map cdr f3f66@pvars)) f3f69@r) f3f6a@mr))) (list '(primitive apply) (f2e79@f2dab@build-lambda '#f f3f75@new-vars f3f78@body) f3f68@y)))))) (f3ef7@invalid-ids-error (lambda (f3f5a@id* f3f5b@e f3f5c@class) (let f3f64@find ((f3f60@id* f3f5a@id*) (f3f61@ok* '())) (if (null? f3f60@id*) (f3201@syntax-violation '#f '"invalid syntax" f3f5b@e) (if (f2f16@id? (car f3f60@id*)) (if (f2f22@bound-id-member? (car f3f60@id*) f3f61@ok*) (f31fd@syntax-error (car f3f60@id*) '"duplicate " f3f5c@class) (f3f64@find (cdr f3f60@id*) (cons (car f3f60@id*) f3f61@ok*))) (f31fd@syntax-error (car f3f60@id*) '"invalid " f3f5c@class)))))) (f3ef9@gen-clause (lambda (f3f32@x f3f33@keys f3f34@clauses f3f35@r f3f36@mr f3f37@pat f3f38@fender f3f39@expr) (call-with-values (lambda () (f311b@convert-pattern f3f37@pat f3f33@keys)) (lambda (f3f46@f3f43 f3f47@f3f45) (let ((f3f4a@pvars f3f47@f3f45) (f3f4b@p f3f46@f3f43)) (if (not (f2f20@distinct-bound-ids? (map car f3f4a@pvars))) (f3ef7@invalid-ids-error (map car f3f4a@pvars) f3f37@pat '"pattern variable") (if (not (for-all (lambda (f3f4e@x) (not (f311f@ellipsis? (car f3f4e@x)))) f3f4a@pvars)) (f3201@syntax-violation '#f '"misplaced ellipsis in syntax-case pattern" f3f37@pat) (let ((f3f50@y (f2e9e@gen-lexical 'tmp))) (let ((f3f52@test (if (eq? f3f38@fender '#t) f3f50@y (let ((f3f54@call (f3ef5@build-dispatch-call f3f4a@pvars f3f38@fender f3f50@y f3f35@r f3f36@mr))) (list 'if f3f50@y f3f54@call (list 'quote '#f)))))) (let ((f3f56@conseq (f3ef5@build-dispatch-call f3f4a@pvars f3f39@expr f3f50@y f3f35@r f3f36@mr))) (let ((f3f58@altern (f3efb@gen-syntax-case f3f32@x f3f33@keys f3f34@clauses f3f35@r f3f36@mr))) (list (f2e79@f2dab@build-lambda '#f (list f3f50@y) (list 'if f3f52@test f3f56@conseq f3f58@altern)) (list '(primitive syntax-dispatch) f3f32@x (list 'quote f3f4b@p)))))))))))))) (f3efb@gen-syntax-case (lambda (f3f10@x f3f11@keys f3f12@clauses f3f13@r f3f14@mr) (if (null? f3f12@clauses) (list '(primitive syntax-error) f3f10@x) (let ((f3f1a@t (car f3f12@clauses))) (let ((f3f1c@ls/false (f311d@syntax-dispatch f3f1a@t '(any any)))) (if f3f1c@ls/false (apply (lambda (f3f1e@pat f3f1f@expr) (if (and (f2f16@id? f3f1e@pat) (not (f2f22@bound-id-member? f3f1e@pat f3f11@keys)) (not (f311f@ellipsis? f3f1e@pat))) (if (f2f1c@free-id=? f3f1e@pat (f30a5@scheme-stx '_)) (f313f@chi-expr f3f1f@expr f3f13@r f3f14@mr) (let ((f3f22@lab (f2ea2@gen-label f3f1e@pat)) (f3f23@lex (f2e9e@gen-lexical f3f1e@pat))) (let ((f3f26@body (f313f@chi-expr (f2f02@add-subst (f2ed6@make-full-rib (list f3f1e@pat) (list f3f22@lab)) f3f1f@expr) (cons (cons f3f22@lab (f2f30@make-binding 'syntax (cons f3f23@lex '0))) f3f13@r) f3f14@mr))) (list (f2e79@f2dab@build-lambda '#f (list f3f23@lex) f3f26@body) f3f10@x)))) (f3ef9@gen-clause f3f10@x f3f11@keys (cdr f3f12@clauses) f3f13@r f3f14@mr f3f1e@pat '#t f3f1f@expr))) f3f1c@ls/false) (let ((f3f28@t f3f1a@t)) (let ((f3f2a@ls/false (f311d@syntax-dispatch f3f28@t '(any any any)))) (if f3f2a@ls/false (apply (lambda (f3f2c@pat f3f2d@fender f3f2e@expr) (f3ef9@gen-clause f3f10@x f3f11@keys (cdr f3f12@clauses) f3f13@r f3f14@mr f3f2c@pat f3f2d@fender f3f2e@expr)) f3f2a@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3f28@t))))))))))) (lambda (f3efc@e f3efd@r f3efe@mr) (let ((f3f02@t f3efc@e)) (let ((f3f04@ls/false (f311d@syntax-dispatch f3f02@t '(_ any each-any . each-any)))) (if f3f04@ls/false (apply (lambda (f3f06@expr f3f07@keys f3f08@clauses) (begin (f3123@verify-literals f3f07@keys f3efc@e) (let ((f3f0c@x (f2e9e@gen-lexical 'tmp))) (let ((f3f0e@body (f3efb@gen-syntax-case f3f0c@x f3f07@keys f3f08@clauses f3efd@r f3efe@mr))) (list (f2e79@f2dab@build-lambda '#f (list f3f0c@x) f3f0e@body) (f313f@chi-expr f3f06@expr f3efd@r f3efe@mr)))))) f3f04@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3f02@t))))))) (set! f4c4f@f3125@syntax-case-transformer f3125@syntax-case-transformer) (set! f3127@ellipsis-map (lambda (f3f80@proc f3f81@ls . f3f84@ls*) (letrec* ((f3f87@who '...)) (begin (if (not (list? f3f81@ls)) (assertion-violation f3f87@who '"not a list" f3f81@ls) (void)) (if (not (null? f3f84@ls*)) (let ((f3f88@n (length f3f81@ls))) (for-each (lambda (f3f8a@x) (begin (if (not (list? f3f8a@x)) (assertion-violation f3f87@who '"not a list" f3f8a@x) (void)) (if (not (= (length f3f8a@x) f3f88@n)) (assertion-violation f3f87@who '"length mismatch" f3f81@ls f3f8a@x) (void)))) f3f84@ls*)) (void)) (apply map f3f80@proc f3f81@ls f3f84@ls*))))) (set! f4c50@f3127@ellipsis-map f3127@ellipsis-map) (set! f3129@syntax-transformer (letrec* ((f3f8d@gen-syntax (lambda (f4004@src f4005@e f4006@r f4007@maps f4008@ellipsis? f4009@vec?) (let ((f4010@t f4005@e)) (let ((f4012@ls/false (f311d@syntax-dispatch f4010@t 'any))) (if (and f4012@ls/false (apply (lambda (f4014@dots) (f4008@ellipsis? f4014@dots)) f4012@ls/false)) (apply (lambda (f4016@dots) (f3201@syntax-violation '#f '"misplaced ellipsis in syntax form" f4004@src)) f4012@ls/false) (let ((f4018@t f4010@t)) (let ((f401a@ls/false (f311d@syntax-dispatch f4018@t 'any))) (if (and f401a@ls/false (apply (lambda (f401c@id) (f2f16@id? f401c@id)) f401a@ls/false)) (apply (lambda (f401e@id) (let ((f4020@label (f2f2c@id->label f4005@e))) (let ((f4022@b (f2f2e@label->binding f4020@label f4006@r))) (if (eq? (f2f32@binding-type f4022@b) 'syntax) (call-with-values (lambda () (let ((f4028@var.lev (f2f34@binding-value f4022@b))) (f3f8f@gen-ref f4004@src (car f4028@var.lev) (cdr f4028@var.lev) f4007@maps))) (lambda (f402a@f4025 f402b@f4027) (let ((f402e@maps f402b@f4027) (f402f@var f402a@f4025)) (values (list 'ref f402f@var) f402e@maps)))) (values (list 'quote f4005@e) f4007@maps))))) f401a@ls/false) (let ((f4032@t f4018@t)) (let ((f4034@ls/false (f311d@syntax-dispatch f4032@t '(any any)))) (if (and f4034@ls/false (apply (lambda (f4036@dots f4037@e) (f4008@ellipsis? f4036@dots)) f4034@ls/false)) (apply (lambda (f403a@dots f403b@e) (if f4009@vec? (f3201@syntax-violation '#f '"misplaced ellipsis in syntax form" f4004@src) (f3f8d@gen-syntax f4004@src f403b@e f4006@r f4007@maps (lambda (f403e@x) '#f) '#f))) f4034@ls/false) (let ((f4040@t f4032@t)) (let ((f4042@ls/false (f311d@syntax-dispatch f4040@t '(any any . any)))) (if (and f4042@ls/false (apply (lambda (f4044@x f4045@dots f4046@y) (f4008@ellipsis? f4045@dots)) f4042@ls/false)) (apply (lambda (f404a@x f404b@dots f404c@y) (let f4062@f ((f4050@y f404c@y) (f4051@k (lambda (f4054@maps) (call-with-values (lambda () (f3f8d@gen-syntax f4004@src f404a@x f4006@r (cons '() f4054@maps) f4008@ellipsis? '#f)) (lambda (f405a@f4057 f405b@f4059) (let ((f405e@maps f405b@f4059) (f405f@x f405a@f4057)) (if (null? (car f405e@maps)) (f3201@syntax-violation '#f '"extra ellipsis in syntax form" f4004@src) (values (f3f95@gen-map f405f@x (car f405e@maps)) (cdr f405e@maps))))))))) (let ((f4064@t f4050@y)) (let ((f4066@ls/false (f311d@syntax-dispatch f4064@t '()))) (if f4066@ls/false (apply (lambda () (f4051@k f4007@maps)) f4066@ls/false) (let ((f4068@t f4064@t)) (let ((f406a@ls/false (f311d@syntax-dispatch f4068@t '(any . any)))) (if (and f406a@ls/false (apply (lambda (f406c@dots f406d@y) (f4008@ellipsis? f406c@dots)) f406a@ls/false)) (apply (lambda (f4070@dots f4071@y) (f4062@f f4071@y (lambda (f4074@maps) (call-with-values (lambda () (f4051@k (cons '() f4074@maps))) (lambda (f407a@f4077 f407b@f4079) (let ((f407e@maps f407b@f4079) (f407f@x f407a@f4077)) (if (null? (car f407e@maps)) (f3201@syntax-violation '#f '"extra ellipsis in syntax form" f4004@src) (values (f3f93@gen-mappend f407f@x (car f407e@maps)) (cdr f407e@maps))))))))) f406a@ls/false) (let ((f4082@t f4068@t)) (let ((f4084@ls/false (f311d@syntax-dispatch f4082@t '_))) (if f4084@ls/false (apply (lambda () (call-with-values (lambda () (f3f8d@gen-syntax f4004@src f4050@y f4006@r f4007@maps f4008@ellipsis? f4009@vec?)) (lambda (f408a@f4087 f408b@f4089) (let ((f408e@maps f408b@f4089) (f408f@y f408a@f4087)) (call-with-values (lambda () (f4051@k f408e@maps)) (lambda (f4096@f4093 f4097@f4095) (let ((f409a@maps f4097@f4095) (f409b@x f4096@f4093)) (values (f3f91@gen-append f409b@x f408f@y) f409a@maps)))))))) f4084@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f4082@t)))))))))))) f4042@ls/false) (let ((f409e@t f4040@t)) (let ((f40a0@ls/false (f311d@syntax-dispatch f409e@t '(any . any)))) (if f40a0@ls/false (apply (lambda (f40a2@x f40a3@y) (call-with-values (lambda () (f3f8d@gen-syntax f4004@src f40a2@x f4006@r f4007@maps f4008@ellipsis? '#f)) (lambda (f40aa@f40a7 f40ab@f40a9) (let ((f40ae@maps f40ab@f40a9) (f40af@xnew f40aa@f40a7)) (call-with-values (lambda () (f3f8d@gen-syntax f4004@src f40a3@y f4006@r f40ae@maps f4008@ellipsis? f4009@vec?)) (lambda (f40b6@f40b3 f40b7@f40b5) (let ((f40ba@maps f40b7@f40b5) (f40bb@ynew f40b6@f40b3)) (values (f3f97@gen-cons f4005@e f40a2@x f40a3@y f40af@xnew f40bb@ynew) f40ba@maps)))))))) f40a0@ls/false) (let ((f40be@t f409e@t)) (let ((f40c0@ls/false (f311d@syntax-dispatch f40be@t '#(vector each-any)))) (if f40c0@ls/false (apply (lambda (f40c2@ls) (call-with-values (lambda () (f3f8d@gen-syntax f4004@src f40c2@ls f4006@r f4007@maps f4008@ellipsis? '#t)) (lambda (f40c8@f40c5 f40c9@f40c7) (let ((f40cc@maps f40c9@f40c7) (f40cd@lsnew f40c8@f40c5)) (values (f3f99@gen-vector f4005@e f40c2@ls f40cd@lsnew) f40cc@maps))))) f40c0@ls/false) (let ((f40d0@t f40be@t)) (let ((f40d2@ls/false (f311d@syntax-dispatch f40d0@t '_))) (if f40d2@ls/false (apply (lambda () (values (list 'quote f4005@e) f4007@maps)) f40d2@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f40d0@t)))))))))))))))))))))))) (f3f8f@gen-ref (lambda (f3fea@src f3feb@var f3fec@level f3fed@maps) (if (= f3fec@level '0) (values f3feb@var f3fed@maps) (if (null? f3fed@maps) (f3201@syntax-violation '#f '"missing ellipsis in syntax form" f3fea@src) (call-with-values (lambda () (f3f8f@gen-ref f3fea@src f3feb@var (- f3fec@level '1) (cdr f3fed@maps))) (lambda (f3ff6@f3ff3 f3ff7@f3ff5) (let ((f3ffa@outer-maps f3ff7@f3ff5) (f3ffb@outer-var f3ff6@f3ff3)) (let ((f3ffe@t (assq f3ffb@outer-var (car f3fed@maps)))) (if f3ffe@t ((lambda (f4000@b) (values (cdr f4000@b) f3fed@maps)) f3ffe@t) (let ((f4002@inner-var (f2e9e@gen-lexical 'tmp))) (values f4002@inner-var (cons (cons (cons f3ffb@outer-var f4002@inner-var) (car f3fed@maps)) f3ffa@outer-maps)))))))))))) (f3f91@gen-append (lambda (f3fe6@x f3fe7@y) (if (fast-equal? f3fe7@y ''()) f3fe6@x (list 'append f3fe6@x f3fe7@y)))) (f3f93@gen-mappend (lambda (f3fe2@e f3fe3@map-env) (list 'apply '(primitive append) (f3f95@gen-map f3fe2@e f3fe3@map-env)))) (f3f95@gen-map (lambda (f3fd0@e f3fd1@map-env) (let ((f3fd4@formals (map cdr f3fd1@map-env)) (f3fd5@actuals (map (lambda (f3fd8@x) (list 'ref (car f3fd8@x))) f3fd1@map-env))) (if (eq? (car f3fd0@e) 'ref) (car f3fd5@actuals) (if (for-all (lambda (f3fda@x) (and (eq? (car f3fda@x) 'ref) (memq (cadr f3fda@x) f3fd4@formals))) (cdr f3fd0@e)) (let ((f3fdc@args (map (let ((f3fde@r (map cons f3fd4@formals f3fd5@actuals))) (lambda (f3fe0@x) (cdr (assq (cadr f3fe0@x) f3fde@r)))) (cdr f3fd0@e)))) (cons 'map (cons (list 'primitive (car f3fd0@e)) f3fdc@args))) (cons* 'map (list 'lambda f3fd4@formals f3fd0@e) f3fd5@actuals)))))) (f3f97@gen-cons (lambda (f3fc0@e f3fc1@x f3fc2@y f3fc3@xnew f3fc4@ynew) (let ((f3fca@t (car f3fc4@ynew))) (if (memv f3fca@t '(quote)) (if (eq? (car f3fc3@xnew) 'quote) (let ((f3fcc@xnew (cadr f3fc3@xnew)) (f3fcd@ynew (cadr f3fc4@ynew))) (if (and (eq? f3fcc@xnew f3fc1@x) (eq? f3fcd@ynew f3fc2@y)) (list 'quote f3fc0@e) (list 'quote (cons f3fcc@xnew f3fcd@ynew)))) (if (null? (cadr f3fc4@ynew)) (list 'list f3fc3@xnew) (list 'cons f3fc3@xnew f3fc4@ynew))) (if (memv f3fca@t '(list)) (cons 'list (cons f3fc3@xnew (cdr f3fc4@ynew))) (list 'cons f3fc3@xnew f3fc4@ynew)))))) (f3f99@gen-vector (lambda (f3fba@e f3fbb@ls f3fbc@lsnew) (if (eq? (car f3fbc@lsnew) 'quote) (if (eq? (cadr f3fbc@lsnew) f3fbb@ls) (list 'quote f3fba@e) (list 'quote (list->vector (cadr f3fbc@lsnew)))) (if (eq? (car f3fbc@lsnew) 'list) (cons 'vector (cdr f3fbc@lsnew)) (list 'list->vector f3fbc@lsnew))))) (f3f9b@regen (lambda (f3fb4@x) (let ((f3fb6@t (car f3fb4@x))) (if (memv f3fb6@t '(ref)) (cadr f3fb4@x) (if (memv f3fb6@t '(primitive)) (list 'primitive (cadr f3fb4@x)) (if (memv f3fb6@t '(quote)) (list 'quote (cadr f3fb4@x)) (if (memv f3fb6@t '(lambda)) (f2e79@f2dab@build-lambda '#f (cadr f3fb4@x) (f3f9b@regen (caddr f3fb4@x))) (if (memv f3fb6@t '(map)) (let ((f3fb8@ls (map f3f9b@regen (cdr f3fb4@x)))) (cons '(primitive ellipsis-map) f3fb8@ls)) (cons (list 'primitive (car f3fb4@x)) (map f3f9b@regen (cdr f3fb4@x)))))))))))) (lambda (f3f9c@e f3f9d@r f3f9e@mr) (let ((f3fa2@t f3f9c@e)) (let ((f3fa4@ls/false (f311d@syntax-dispatch f3fa2@t '(_ any)))) (if f3fa4@ls/false (apply (lambda (f3fa6@x) (call-with-values (lambda () (f3f8d@gen-syntax f3f9c@e f3fa6@x f3f9d@r '() f311f@ellipsis? '#f)) (lambda (f3fac@f3fa9 f3fad@f3fab) (let ((f3fb0@maps f3fad@f3fab) (f3fb1@e f3fac@f3fa9)) (f3f9b@regen f3fb1@e))))) f3fa4@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f3fa2@t))))))) (set! f4c51@f3129@syntax-transformer f3129@syntax-transformer) (set! f312b@core-macro-transformer (lambda (f40d4@name) (let ((f40d6@t f40d4@name)) (if (memv f40d6@t '(quote)) f30cd@quote-transformer (if (memv f40d6@t '(lambda)) f30d1@lambda-transformer (if (memv f40d6@t '(case-lambda)) f30cf@case-lambda-transformer (if (memv f40d6@t '(letrec)) f30b5@letrec-transformer (if (memv f40d6@t '(letrec*)) f30b7@letrec*-transformer (if (memv f40d6@t '(let)) f30b3@let-transformer (if (memv f40d6@t '(if)) f30c5@if-transformer (if (memv f40d6@t '(and)) f30c7@and-transformer (if (memv f40d6@t '(or)) f30c9@or-transformer (if (memv f40d6@t '(foreign-call)) f3119@foreign-call-transformer (if (memv f40d6@t '(syntax-case)) f3125@syntax-case-transformer (if (memv f40d6@t '(syntax)) f3129@syntax-transformer (if (memv f40d6@t '(type-descriptor)) f30bb@type-descriptor-transformer (if (memv f40d6@t '(record-type-descriptor)) f30bd@record-type-descriptor-transformer (if (memv f40d6@t '(record-constructor-descriptor)) f30bf@record-constructor-descriptor-transformer (if (memv f40d6@t '(fluid-let-syntax)) f30b9@fluid-let-syntax-transformer (assertion-violation 'macro-transformer '"BUG: cannot find transformer" f40d4@name)))))))))))))))))))) (set! f4c52@f312b@core-macro-transformer f312b@core-macro-transformer) (set! f312d@symbol-macro (lambda (f40d8@x f40d9@set) (let ((f40dc@t f40d8@x)) (let ((f40de@ls/false (f311d@syntax-dispatch f40dc@t '(_ any)))) (if (and f40de@ls/false (apply (lambda (f40e0@name) (and (f2f16@id? f40e0@name) (memq (f2f18@id->sym f40e0@name) f40d9@set))) f40de@ls/false)) (apply (lambda (f40e2@name) (f30d3@bless (list 'quote f40e2@name))) f40de@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f40dc@t)))))) (set! f4c53@f312d@symbol-macro f312d@symbol-macro) (set! f312f@macro-transformer (lambda (f40e4@x) (if (procedure? f40e4@x) f40e4@x (if (symbol? f40e4@x) (let ((f40e6@t f40e4@x)) (if (memv f40e6@t '(define-record-type)) f3111@define-record-type-macro (if (memv f40e6@t '(define-struct)) f310f@define-struct-macro (if (memv f40e6@t '(include)) f3105@include-macro (if (memv f40e6@t '(cond)) f3101@cond-macro (if (memv f40e6@t '(let)) f30d9@let-macro (if (memv f40e6@t '(do)) f30f9@do-macro (if (memv f40e6@t '(or)) f30fd@or-macro (if (memv f40e6@t '(and)) f30ff@and-macro (if (memv f40e6@t '(let*)) f30fb@let*-macro (if (memv f40e6@t '(let-values)) f30db@let-values-macro (if (memv f40e6@t '(let*-values)) f30dd@let*-values-macro (if (memv f40e6@t '(syntax-rules)) f3109@syntax-rules-macro (if (memv f40e6@t '(quasiquote)) f310b@quasiquote-macro (if (memv f40e6@t '(quasisyntax)) f310d@quasisyntax-macro (if (memv f40e6@t '(with-syntax)) f30d5@with-syntax-macro (if (memv f40e6@t '(when)) f30c1@when-macro (if (memv f40e6@t '(unless)) f30c3@unless-macro (if (memv f40e6@t '(case)) f30cb@case-macro (if (memv f40e6@t '(identifier-syntax)) f30f7@identifier-syntax-macro (if (memv f40e6@t '(time)) f30ef@time-macro (if (memv f40e6@t '(delay)) f30f1@delay-macro (if (memv f40e6@t '(assert)) f30f3@assert-macro (if (memv f40e6@t '(endianness)) f30f5@endianness-macro (if (memv f40e6@t '(guard)) f30eb@guard-macro (if (memv f40e6@t '(define-enumeration)) f30ed@define-enumeration-macro (if (memv f40e6@t '(trace-lambda)) f30df@trace-lambda-macro (if (memv f40e6@t '(trace-define)) f30e1@trace-define-macro (if (memv f40e6@t '(trace-define-syntax)) f30e3@trace-define-syntax-macro (if (memv f40e6@t '(trace-let-syntax)) f30e7@trace-let-syntax-macro (if (memv f40e6@t '(trace-letrec-syntax)) f30e9@trace-letrec-syntax-macro (if (memv f40e6@t '(define-condition-type)) f3113@define-condition-type-macro (if (memv f40e6@t '(parameterize)) f3117@parameterize-macro (if (memv f40e6@t '(include-into)) f3107@include-into-macro (if (memv f40e6@t '(eol-style)) (lambda (f40e8@x) (f312d@symbol-macro f40e8@x '(none lf cr crlf nel crnel ls))) (if (memv f40e6@t '(error-handling-mode)) (lambda (f40ea@x) (f312d@symbol-macro f40ea@x '(ignore raise replace))) (if (memv f40e6@t '(buffer-mode)) (lambda (f40ec@x) (f312d@symbol-macro f40ec@x '(none line block))) (if (memv f40e6@t '(file-options)) f2e91@file-options-macro (if (memv f40e6@t '(... => _ else unquote unquote-splicing unsyntax unsyntax-splicing fields mutable immutable parent protocol sealed opaque nongenerative parent-rtd)) f3115@incorrect-usage-macro (error 'macro-transformer '"BUG: invalid macro" f40e4@x)))))))))))))))))))))))))))))))))))))))) (error 'core-macro-transformer '"BUG: invalid macro" f40e4@x))))) (set! f4c54@f312f@macro-transformer f312f@macro-transformer) (set! f3131@local-macro-transformer (lambda (f40ee@x) (car f40ee@x))) (set! f4c55@f3131@local-macro-transformer f3131@local-macro-transformer) (set! f3133@do-macro-call (lambda (f40f0@transformer f40f1@expr) (let ((f40f4@out (f40f0@transformer (f2f00@add-mark f2efa@anti-mark f40f1@expr '#f)))) (begin (let f40f8@f ((f40f6@x f40f4@out)) (if (not (f2ee2@stx? f40f6@x)) (if (pair? f40f6@x) (begin (f40f8@f (car f40f6@x)) (f40f8@f (cdr f40f6@x))) (if (vector? f40f6@x) (vector-for-each f40f8@f f40f6@x) (if (symbol? f40f6@x) (f3201@syntax-violation '#f '"raw symbol encountered in output of macro" f40f1@expr f40f6@x) (void)))) (void))) (f2f00@add-mark (f2ef8@gen-mark) f40f4@out f40f1@expr))))) (set! f4c56@f3133@do-macro-call f3133@do-macro-call) (set! f3135@chi-macro (lambda (f40fa@p f40fb@e) (f3133@do-macro-call (f312f@macro-transformer f40fa@p) f40fb@e))) (set! f4c57@f3135@chi-macro f3135@chi-macro) (set! f3137@chi-local-macro (lambda (f40fe@p f40ff@e) (f3133@do-macro-call (f3131@local-macro-transformer f40fe@p) f40ff@e))) (set! f4c58@f3137@chi-local-macro f3137@chi-local-macro) (set! f3139@chi-global-macro (lambda (f4102@p f4103@e) (let ((f4106@lib (car f4102@p)) (f4107@loc (cdr f4102@p))) (begin (f2d33@f2b82@visit-library f4106@lib) (let ((f410a@x (symbol-value f4107@loc))) (let ((f410c@transformer (if (procedure? f410a@x) f410a@x (assertion-violation 'chi-global-macro '"BUG: not a procedure" f410a@x)))) (f3133@do-macro-call f410c@transformer f4103@e))))))) (set! f4c59@f3139@chi-global-macro f3139@chi-global-macro) (set! f313b@chi-expr* (lambda (f410e@e* f410f@r f4110@mr) (if (null? f410e@e*) '() (let ((f4114@e (f313f@chi-expr (car f410e@e*) f410f@r f4110@mr))) (cons f4114@e (f313b@chi-expr* (cdr f410e@e*) f410f@r f4110@mr)))))) (set! f4c5a@f313b@chi-expr* f313b@chi-expr*) (set! f313d@chi-application (lambda (f4116@e f4117@r f4118@mr) (let ((f411c@t f4116@e)) (let ((f411e@ls/false (f311d@syntax-dispatch f411c@t '(any . each-any)))) (if f411e@ls/false (apply (lambda (f4120@rator f4121@rands) (let ((f4124@rator (f313f@chi-expr f4120@rator f4117@r f4118@mr))) (cons f4124@rator (f313b@chi-expr* f4121@rands f4117@r f4118@mr)))) f411e@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f411c@t)))))) (set! f4c5b@f313d@chi-application f313d@chi-application) (set! f313f@chi-expr (lambda (f4126@e f4127@r f4128@mr) (call-with-values (lambda () (f2f38@syntax-type f4126@e f4127@r)) (lambda (f4132@f412d f4133@f412f f4134@f4131) (let ((f4138@kwd f4134@f4131) (f4139@value f4133@f412f) (f413a@type f4132@f412d)) (let ((f413e@t f413a@type)) (if (memv f413e@t '(core-macro)) (let ((f4140@transformer (f312b@core-macro-transformer f4139@value))) (f4140@transformer f4126@e f4127@r f4128@mr)) (if (memv f413e@t '(global)) (let ((f4142@lib (car f4139@value))) (let ((f4144@loc (cdr f4139@value))) (begin ((f3189@inv-collector) f4142@lib) f4144@loc))) (if (memv f413e@t '(core-prim)) (let ((f4146@name f4139@value)) (list 'primitive f4146@name)) (if (memv f413e@t '(call)) (f313d@chi-application f4126@e f4127@r f4128@mr) (if (memv f413e@t '(lexical)) (let ((f4148@lex (f30a7@lexical-var f4139@value))) f4148@lex) (if (memv f413e@t '(global-macro global-macro!)) (f313f@chi-expr (f3139@chi-global-macro f4139@value f4126@e) f4127@r f4128@mr) (if (memv f413e@t '(local-macro local-macro!)) (f313f@chi-expr (f3137@chi-local-macro f4139@value f4126@e) f4127@r f4128@mr) (if (memv f413e@t '(macro macro!)) (f313f@chi-expr (f3135@chi-macro f4139@value f4126@e) f4127@r f4128@mr) (if (memv f413e@t '(constant)) (let ((f414a@datum f4139@value)) (list 'quote f414a@datum)) (if (memv f413e@t '(set!)) (f3141@chi-set! f4126@e f4127@r f4128@mr) (if (memv f413e@t '(begin)) (let ((f414c@t f4126@e)) (let ((f414e@ls/false (f311d@syntax-dispatch f414c@t '(_ any . each-any)))) (if f414e@ls/false (apply (lambda (f4150@x f4151@x*) (f2e7b@f2ddb@build-sequence '#f (f313b@chi-expr* (cons f4150@x f4151@x*) f4127@r f4128@mr))) f414e@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f414c@t)))) (if (memv f413e@t '(let-syntax letrec-syntax)) (let ((f4154@t f4126@e)) (let ((f4156@ls/false (f311d@syntax-dispatch f4154@t '(_ #(each (any any)) any . each-any)))) (if (and f4156@ls/false (apply (lambda (f4158@xlhs* f4159@xrhs* f415a@xbody f415b@xbody*) (if (not (f2f1e@valid-bound-ids? f4158@xlhs*)) (f3201@syntax-violation '#f '"invalid identifiers" f4126@e) (void))) f4156@ls/false)) (apply (lambda (f4160@xlhs* f4161@xrhs* f4162@xbody f4163@xbody*) (let ((f4168@xlab* (map f2ea2@gen-label f4160@xlhs*))) (let ((f416a@xrib (f2ed6@make-full-rib f4160@xlhs* f4168@xlab*))) (let ((f416c@xb* (map (lambda (f416e@x) (f2f4e@make-eval-transformer (f317b@expand-transformer (if (eq? f413a@type 'let-syntax) f416e@x (f2f02@add-subst f416a@xrib f416e@x)) f4128@mr))) f4161@xrhs*))) (f2e7b@f2ddb@build-sequence '#f (f313b@chi-expr* (map (lambda (f4170@x) (f2f02@add-subst f416a@xrib f4170@x)) (cons f4162@xbody f4163@xbody*)) (append (map cons f4168@xlab* f416c@xb*) f4127@r) (append (map cons f4168@xlab* f416c@xb*) f4128@mr))))))) f4156@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f4154@t)))) (if (memv f413e@t '(displaced-lexical)) (f3201@syntax-violation '#f '"identifier out of context" f4126@e) (if (memv f413e@t '(syntax)) (f3201@syntax-violation '#f '"reference to pattern variable outside a syntax form" f4126@e) (if (memv f413e@t '(define define-syntax module import library)) (f3201@syntax-violation '#f (string-append (let ((f4172@t f413a@type)) (if (memv f4172@t '(define)) '"a definition" (if (memv f4172@t '(define-syntax)) '"a define-syntax" (if (memv f4172@t '(module)) '"a module definition" (if (memv f4172@t '(library)) '"a library definition" (if (memv f4172@t '(import)) '"an import declaration" (if (memv f4172@t '(export)) '"an export declaration" '"a non-expression"))))))) '" was found where an expression was expected") f4126@e) (if (memv f413e@t '(mutable)) (f3201@syntax-violation '#f '"attempt to reference an unexportable variable" f4126@e) (f3201@syntax-violation '#f '"invalid expression" f4126@e))))))))))))))))))))))) (set! f4c5c@f313f@chi-expr f313f@chi-expr) (set! f3141@chi-set! (lambda (f4174@e f4175@r f4176@mr) (let ((f417a@t f4174@e)) (let ((f417c@ls/false (f311d@syntax-dispatch f417a@t '(_ any any)))) (if (and f417c@ls/false (apply (lambda (f417e@x f417f@v) (f2f16@id? f417e@x)) f417c@ls/false)) (apply (lambda (f4182@x f4183@v) (call-with-values (lambda () (f2f38@syntax-type f4182@x f4175@r)) (lambda (f418c@f4187 f418d@f4189 f418e@f418b) (let ((f4192@kwd f418e@f418b) (f4193@value f418d@f4189) (f4194@type f418c@f4187)) (let ((f4198@t f4194@type)) (if (memv f4198@t '(lexical)) (begin (f30ab@set-lexical-mutable! f4193@value '#t) (list 'set! (f30a7@lexical-var f4193@value) (f313f@chi-expr f4183@v f4175@r f4176@mr))) (if (memv f4198@t '(core-prim)) (f3201@syntax-violation '#f '"cannot modify imported core primitive" f4174@e) (if (memv f4198@t '(global)) (f3201@syntax-violation '#f '"attempt to modify imported binding" f4174@e) (if (memv f4198@t '(global-macro!)) (f313f@chi-expr (f3139@chi-global-macro f4193@value f4174@e) f4175@r f4176@mr) (if (memv f4198@t '(local-macro!)) (f313f@chi-expr (f3137@chi-local-macro f4193@value f4174@e) f4175@r f4176@mr) (if (memv f4198@t '(mutable)) (f3201@syntax-violation '#f '"attempt to assign to an unexportable variable" f4174@e) (f3201@syntax-violation '#f '"invalid syntax" f4174@e)))))))))))) f417c@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f417a@t)))))) (set! f4c5d@f3141@chi-set! f3141@chi-set!) (set! f3143@verify-formals (lambda (f419a@fmls f419b@stx) (let ((f419e@t f419a@fmls)) (let ((f41a0@ls/false (f311d@syntax-dispatch f419e@t 'each-any))) (if f41a0@ls/false (apply (lambda (f41a2@x*) (if (not (f2f1e@valid-bound-ids? f41a2@x*)) (f30d7@invalid-fmls-error f419b@stx f419a@fmls) (void))) f41a0@ls/false) (let ((f41a4@t f419e@t)) (let ((f41a6@ls/false (f311d@syntax-dispatch f41a4@t '#(each+ any () any)))) (if f41a6@ls/false (apply (lambda (f41a8@x* f41a9@x) (if (not (f2f1e@valid-bound-ids? (cons f41a9@x f41a8@x*))) (f30d7@invalid-fmls-error f419b@stx f419a@fmls) (void))) f41a6@ls/false) (let ((f41ac@t f41a4@t)) (let ((f41ae@ls/false (f311d@syntax-dispatch f41ac@t '_))) (if f41ae@ls/false (apply (lambda () (f3201@syntax-violation '#f '"invalid syntax" f419b@stx)) f41ae@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f41ac@t)))))))))))) (set! f4c5e@f3143@verify-formals f3143@verify-formals) (set! f3145@chi-lambda-clause (lambda (f41b0@stx f41b1@fmls f41b2@body* f41b3@r f41b4@mr) (let ((f41ba@t f41b1@fmls)) (let ((f41bc@ls/false (f311d@syntax-dispatch f41ba@t 'each-any))) (if f41bc@ls/false (apply (lambda (f41be@x*) (begin (f3143@verify-formals f41b1@fmls f41b0@stx) (let ((f41c0@lex* (map f2e9e@gen-lexical f41be@x*)) (f41c1@lab* (map f2ea2@gen-label f41be@x*))) (values f41c0@lex* (f3155@chi-internal (f2f02@add-subst (f2ed6@make-full-rib f41be@x* f41c1@lab*) f41b2@body*) (f30af@add-lexicals f41c1@lab* f41c0@lex* f41b3@r) f41b4@mr))))) f41bc@ls/false) (let ((f41c4@t f41ba@t)) (let ((f41c6@ls/false (f311d@syntax-dispatch f41c4@t '#(each+ any () any)))) (if f41c6@ls/false (apply (lambda (f41c8@x* f41c9@x) (begin (f3143@verify-formals f41b1@fmls f41b0@stx) (let ((f41cc@lex* (map f2e9e@gen-lexical f41c8@x*)) (f41cd@lab* (map f2ea2@gen-label f41c8@x*)) (f41ce@lex (f2e9e@gen-lexical f41c9@x)) (f41cf@lab (f2ea2@gen-label f41c9@x))) (values (append f41cc@lex* f41ce@lex) (f3155@chi-internal (f2f02@add-subst (f2ed6@make-full-rib (cons f41c9@x f41c8@x*) (cons f41cf@lab f41cd@lab*)) f41b2@body*) (f30af@add-lexicals (cons f41cf@lab f41cd@lab*) (cons f41ce@lex f41cc@lex*) f41b3@r) f41b4@mr))))) f41c6@ls/false) (let ((f41d4@t f41c4@t)) (let ((f41d6@ls/false (f311d@syntax-dispatch f41d4@t '_))) (if f41d6@ls/false (apply (lambda () (f3201@syntax-violation '#f '"invalid syntax" f41b1@fmls)) f41d6@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f41d4@t)))))))))))) (set! f4c5f@f3145@chi-lambda-clause f3145@chi-lambda-clause) (set! f3147@chi-lambda-clause* (lambda (f41d8@stx f41d9@fmls* f41da@body** f41db@r f41dc@mr) (if (null? f41d9@fmls*) (values '() '()) (call-with-values (lambda () (f3145@chi-lambda-clause f41d8@stx (car f41d9@fmls*) (car f41da@body**) f41db@r f41dc@mr)) (lambda (f41e6@f41e3 f41e7@f41e5) (let ((f41ea@b f41e7@f41e5) (f41eb@a f41e6@f41e3)) (call-with-values (lambda () (f3147@chi-lambda-clause* f41d8@stx (cdr f41d9@fmls*) (cdr f41da@body**) f41db@r f41dc@mr)) (lambda (f41f2@f41ef f41f3@f41f1) (let ((f41f6@b* f41f3@f41f1) (f41f7@a* f41f2@f41ef)) (values (cons f41eb@a f41f7@a*) (cons f41ea@b f41f6@b*))))))))))) (set! f4c60@f3147@chi-lambda-clause* f3147@chi-lambda-clause*) (set! f3149@chi-defun (lambda (f41fa@x f41fb@r f41fc@mr) (let ((f4200@fmls (car f41fa@x)) (f4201@body* (cdr f41fa@x))) (call-with-values (lambda () (f3145@chi-lambda-clause f4200@fmls f4200@fmls f4201@body* f41fb@r f41fc@mr)) (lambda (f4208@f4205 f4209@f4207) (let ((f420c@body f4209@f4207) (f420d@fmls f4208@f4205)) (f2e79@f2dab@build-lambda '#f f420d@fmls f420c@body))))))) (set! f4c61@f3149@chi-defun f3149@chi-defun) (set! f314b@chi-rhs (lambda (f4210@rhs f4211@r f4212@mr) (let ((f4216@t (car f4210@rhs))) (if (memv f4216@t '(defun)) (f3149@chi-defun (cdr f4210@rhs) f4211@r f4212@mr) (if (memv f4216@t '(expr)) (let ((f4218@expr (cdr f4210@rhs))) (f313f@chi-expr f4218@expr f4211@r f4212@mr)) (if (memv f4216@t '(top-expr)) (let ((f421a@expr (cdr f4210@rhs))) (f2e7b@f2ddb@build-sequence '#f (list (f313f@chi-expr f421a@expr f4211@r f4212@mr) (f2e7c@f2ddd@build-void)))) (assertion-violation 'chi-rhs '"BUG: invalid rhs" f4210@rhs))))))) (set! f4c62@f314b@chi-rhs f314b@chi-rhs) (set! f314d@expand-interaction-rhs*/init* (lambda (f421c@lhs* f421d@rhs* f421e@init* f421f@r f4220@mr) (let f422a@f ((f4226@lhs* f421c@lhs*) (f4227@rhs* f421d@rhs*)) (if (null? f4226@lhs*) (map (lambda (f422c@x) (f313f@chi-expr f422c@x f421f@r f4220@mr)) f421e@init*) (let ((f422e@lhs (car f4226@lhs*)) (f422f@rhs (car f4227@rhs*))) (let ((f4232@t (car f422f@rhs))) (if (memv f4232@t '(defun)) (let ((f4234@rhs (f3149@chi-defun (cdr f422f@rhs) f421f@r f4220@mr))) (cons (list 'set! f422e@lhs f4234@rhs) (f422a@f (cdr f4226@lhs*) (cdr f4227@rhs*)))) (if (memv f4232@t '(expr)) (let ((f4236@rhs (f313f@chi-expr (cdr f422f@rhs) f421f@r f4220@mr))) (cons (list 'set! f422e@lhs f4236@rhs) (f422a@f (cdr f4226@lhs*) (cdr f4227@rhs*)))) (if (memv f4232@t '(top-expr)) (let ((f4238@e (f313f@chi-expr (cdr f422f@rhs) f421f@r f4220@mr))) (cons f4238@e (f422a@f (cdr f4226@lhs*) (cdr f4227@rhs*)))) (error 'expand-interaction '"invallid" f422f@rhs)))))))))) (set! f4c63@f314d@expand-interaction-rhs*/init* f314d@expand-interaction-rhs*/init*) (set! f314f@chi-rhs* (lambda (f423a@rhs* f423b@r f423c@mr) (let f4242@f ((f4240@ls f423a@rhs*)) (if (null? f4240@ls) '() (let ((f4244@a (f314b@chi-rhs (car f4240@ls) f423b@r f423c@mr))) (cons f4244@a (f4242@f (cdr f4240@ls)))))))) (set! f4c64@f314f@chi-rhs* f314f@chi-rhs*) (set! f3151@find-bound=? (lambda (f4246@x f4247@lhs* f4248@rhs*) (if (null? f4247@lhs*) '#f (if (f2f1a@bound-id=? f4246@x (car f4247@lhs*)) (car f4248@rhs*) (f3151@find-bound=? f4246@x (cdr f4247@lhs*) (cdr f4248@rhs*)))))) (set! f4c65@f3151@find-bound=? f3151@find-bound=?) (set! f3153@find-dups (lambda (f424c@ls) (let f4252@f ((f424e@ls f424c@ls) (f424f@dups '())) (if (null? f424e@ls) f424f@dups (let ((f4254@t (f3151@find-bound=? (car f424e@ls) (cdr f424e@ls) (cdr f424e@ls)))) (if f4254@t ((lambda (f4256@x) (f4252@f (cdr f424e@ls) (cons (list (car f424e@ls) f4256@x) f424f@dups))) f4254@t) (f4252@f (cdr f424e@ls) f424f@dups))))))) (set! f4c66@f3153@find-dups f3153@find-dups) (set! f3155@chi-internal (lambda (f4258@e* f4259@r f425a@mr) (let ((f425e@rib (f2eca@make-empty-rib))) (call-with-values (lambda () (f3179@chi-body* (map (lambda (f4270@x) (f2f02@add-subst f425e@rib f4270@x)) (f2f14@syntax->list f4258@e*)) f4259@r f425a@mr '() '() '() '() '() f425e@rib '#f)) (lambda (f4272@f4261 f4273@f4263 f4274@f4265 f4275@f4267 f4276@f4269 f4277@f426b f4278@f426d f4279@f426f) (let ((f4282@_exp* f4279@f426f) (f4283@kwd* f4278@f426d) (f4284@mod** f4277@f426b) (f4285@rhs* f4276@f4269) (f4286@lex* f4275@f4267) (f4287@mr f4274@f4265) (f4288@r f4273@f4263) (f4289@e* f4272@f4261)) (begin (if (null? f4289@e*) (f3201@syntax-violation '#f '"no expression in body" f4289@e*) (void)) (let ((f4292@init* (f313b@chi-expr* (append (apply append (reverse f4284@mod**)) f4289@e*) f4288@r f4287@mr))) (let ((f4294@rhs* (f314f@chi-rhs* f4285@rhs* f4288@r f4287@mr))) (f2e80@f2de5@build-letrec* '#f (reverse f4286@lex*) (reverse f4294@rhs*) (f2e7b@f2ddb@build-sequence '#f f4292@init*))))))))))) (set! f4c67@f3155@chi-internal f3155@chi-internal) (set! f3157@parse-module (lambda (f4296@e) (let ((f4298@t f4296@e)) (let ((f429a@ls/false (f311d@syntax-dispatch f4298@t '(_ each-any . each-any)))) (if f429a@ls/false (apply (lambda (f429c@export* f429d@b*) (begin (if (not (for-all f2f16@id? f429c@export*)) (f3201@syntax-violation '#f '"module exports must be identifiers" f4296@e) (void)) (values '#f (list->vector f429c@export*) f429d@b*))) f429a@ls/false) (let ((f42a0@t f4298@t)) (let ((f42a2@ls/false (f311d@syntax-dispatch f42a0@t '(_ any each-any . each-any)))) (if f42a2@ls/false (apply (lambda (f42a4@name f42a5@export* f42a6@b*) (begin (if (not (f2f16@id? f42a4@name)) (f3201@syntax-violation '#f '"module name must be an identifier" f4296@e) (void)) (if (not (for-all f2f16@id? f42a5@export*)) (f3201@syntax-violation '#f '"module exports must be identifiers" f4296@e) (void)) (values f42a4@name (list->vector f42a5@export*) f42a6@b*))) f42a2@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f42a0@t))))))))) (set! f4c68@f3157@parse-module f3157@parse-module) (set! f3161@module-interface? (lambda (f42aa@x) (and (simple-struct? f42aa@x) (eq? (simple-struct-name f42aa@x) 'module-interface)))) (set! f4c69@f3161@module-interface? f3161@module-interface?) (set! f3163@module-interface-first-mark (lambda (f42ac@x) (simple-struct-ref f42ac@x '0))) (set! f4c6a@f3163@module-interface-first-mark f3163@module-interface-first-mark) (set! f3165@set-module-interface-first-mark! (lambda (f42ae@x f42af@val) (simple-struct-set! f42ae@x '0 f42af@val))) (set! f4c6b@f3165@set-module-interface-first-mark! f3165@set-module-interface-first-mark!) (set! f3167@module-interface-exp-id-vec (lambda (f42b2@x) (simple-struct-ref f42b2@x '1))) (set! f4c6c@f3167@module-interface-exp-id-vec f3167@module-interface-exp-id-vec) (set! f3169@set-module-interface-exp-id-vec! (lambda (f42b4@x f42b5@val) (simple-struct-set! f42b4@x '1 f42b5@val))) (set! f4c6d@f3169@set-module-interface-exp-id-vec! f3169@set-module-interface-exp-id-vec!) (set! f316b@module-interface-exp-lab-vec (lambda (f42b8@x) (simple-struct-ref f42b8@x '2))) (set! f4c6e@f316b@module-interface-exp-lab-vec f316b@module-interface-exp-lab-vec) (set! f316d@set-module-interface-exp-lab-vec! (lambda (f42ba@x f42bb@val) (simple-struct-set! f42ba@x '2 f42bb@val))) (set! f4c6f@f316d@set-module-interface-exp-lab-vec! f316d@set-module-interface-exp-lab-vec!) (set! f316f@dummy '3) (set! f4c70@f316f@dummy f316f@dummy) (set! f3171@module-interface-exp-id* (lambda (f42be@iface f42bf@id) (letrec* ((f42c3@diff-marks (lambda (f42ca@ls f42cb@x) (begin (if (null? f42ca@ls) (error 'diff-marks '"BUG: should not happen") (void)) (let ((f42ce@a (car f42ca@ls))) (if (eq? f42ce@a f42cb@x) '() (cons f42ce@a (f42c3@diff-marks (cdr f42ca@ls) f42cb@x)))))))) (let ((f42c4@diff (f42c3@diff-marks (f2ee8@stx-mark* f42bf@id) (f3163@module-interface-first-mark f42be@iface))) (f42c5@id-vec (f3167@module-interface-exp-id-vec f42be@iface))) (if (null? f42c4@diff) f42c5@id-vec (vector-map (lambda (f42c8@x) (make-simple-struct 'stx '5 (list (f2ee4@stx-expr f42c8@x) (append f42c4@diff (f2ee8@stx-mark* f42c8@x)) '() '()))) f42c5@id-vec)))))) (set! f4c71@f3171@module-interface-exp-id* f3171@module-interface-exp-id*) (set! f3173@chi-internal-module (lambda (f42d0@e f42d1@r f42d2@mr f42d3@lex* f42d4@rhs* f42d5@mod** f42d6@kwd*) (call-with-values (lambda () (f3157@parse-module f42d0@e)) (lambda (f42e4@f42df f42e5@f42e1 f42e6@f42e3) (let ((f42ea@e* f42e6@f42e3) (f42eb@exp-id* f42e5@f42e1) (f42ec@name f42e4@f42df)) (let ((f42f0@rib (f2eca@make-empty-rib))) (let ((f42f2@e* (map (lambda (f42f4@x) (f2f02@add-subst f42f0@rib f42f4@x)) (f2f14@syntax->list f42ea@e*)))) (call-with-values (lambda () (f3179@chi-body* f42f2@e* f42d1@r f42d2@mr f42d3@lex* f42d4@rhs* f42d5@mod** f42d6@kwd* '() f42f0@rib '#f)) (lambda (f4306@f42f7 f4307@f42f9 f4308@f42fb f4309@f42fd f430a@f42ff f430b@f4301 f430c@f4303 f430d@f4305) (let ((f4316@_exp* f430d@f4305) (f4317@kwd* f430c@f4303) (f4318@mod** f430b@f4301) (f4319@rhs* f430a@f42ff) (f431a@lex* f4309@f42fd) (f431b@mr f4308@f42fb) (f431c@r f4307@f42f9) (f431d@e* f4306@f42f7)) (let ((f4326@exp-lab* (vector-map (lambda (f432a@x) (or (f2f2c@id->label (make-simple-struct 'stx '5 (list (f2f18@id->sym f432a@x) (f2ee8@stx-mark* f432a@x) (list f42f0@rib) '()))) (f3201@syntax-violation '#f '"cannot find module export" f432a@x))) f42eb@exp-id*)) (f4327@mod** (cons f431d@e* f4318@mod**))) (if (not f42ec@name) (values f431a@lex* f4319@rhs* f42eb@exp-id* f4326@exp-lab* f431c@r f431b@mr f4327@mod** f4317@kwd*) (let ((f432c@lab (f2ea2@gen-label 'module)) (f432d@iface (make-simple-struct 'module-interface '4 (list (car (f2ee8@stx-mark* f42ec@name)) (vector-map (lambda (f4330@x) (make-simple-struct 'stx '5 (list (f2ee4@stx-expr f4330@x) (f2ee8@stx-mark* f4330@x) '() '()))) f42eb@exp-id*) f4326@exp-lab*)))) (values f431a@lex* f4319@rhs* (vector f42ec@name) (vector f432c@lab) (cons (cons f432c@lab (cons '$module f432d@iface)) f431c@r) (cons (cons f432c@lab (cons '$module f432d@iface)) f431b@mr) f4327@mod** f4317@kwd*)))))))))))))) (set! f4c72@f3173@chi-internal-module f3173@chi-internal-module) (set! f3175@copy-rib-contents! (lambda (f4332@from-rib f4333@to-rib) (for-each (lambda (f4336@sym f4337@mark* f4338@label) (let ((f433c@id (make-simple-struct 'stx '5 (list f4336@sym f4337@mark* '() '())))) (f2ecc@extend-rib! f4333@to-rib f433c@id f4338@label))) (f2eb4@rib-sym* f4332@from-rib) (f2eb8@rib-mark** f4332@from-rib) (f2ebc@rib-label* f4332@from-rib)))) (set! f4c73@f3175@copy-rib-contents! f3175@copy-rib-contents!) (set! f3177@chi-body*-macro (lambda (f433e@e* f433f@r f4340@mr f4341@lex* f4342@rhs* f4343@mod** f4344@kwd* f4345@exp* f4346@rib f4347@top? f4348@e) (let ((f4354@rib2 (f2eca@make-empty-rib))) (call-with-values (lambda () (f3179@chi-body* (list (f2f02@add-subst f4354@rib2 f4348@e)) f433f@r f4340@mr f4341@lex* f4342@rhs* f4343@mod** f4344@kwd* f4345@exp* f4354@rib2 f4347@top?)) (lambda (f4366@f4357 f4367@f4359 f4368@f435b f4369@f435d f436a@f435f f436b@f4361 f436c@f4363 f436d@f4365) (let ((f4376@exp* f436d@f4365) (f4377@kwd* f436c@f4363) (f4378@mod** f436b@f4361) (f4379@rhs* f436a@f435f) (f437a@lex* f4369@f435d) (f437b@mr f4368@f435b) (f437c@r f4367@f4359) (f437d@e1* f4366@f4357)) (begin (f3175@copy-rib-contents! f4354@rib2 f4346@rib) (if (null? f437d@e1*) (f3179@chi-body* f433e@e* f437c@r f437b@mr f437a@lex* f4379@rhs* f4378@mod** f4377@kwd* f4376@exp* f4346@rib f4347@top?) (values (append f437d@e1* f433e@e*) f437c@r f437b@mr f437a@lex* f4379@rhs* f4378@mod** f4377@kwd* f4376@exp*))))))))) (set! f4c74@f3177@chi-body*-macro f3177@chi-body*-macro) (set! f3179@chi-body* (lambda (f4386@e* f4387@r f4388@mr f4389@lex* f438a@rhs* f438b@mod** f438c@kwd* f438d@exp* f438e@rib f438f@top?) (if (null? f4386@e*) (values f4386@e* f4387@r f4388@mr f4389@lex* f438a@rhs* f438b@mod** f438c@kwd* f438d@exp*) (let ((f439a@e (car f4386@e*))) (call-with-values (lambda () (f2f38@syntax-type f439a@e f4387@r)) (lambda (f43a2@f439d f43a3@f439f f43a4@f43a1) (let ((f43a8@kwd f43a4@f43a1) (f43a9@value f43a3@f439f) (f43aa@type f43a2@f439d)) (let ((f43ae@kwd* (if (f2f16@id? f43a8@kwd) (cons f43a8@kwd f438c@kwd*) f438c@kwd*))) (let ((f43b0@t f43aa@type)) (if (memv f43b0@t '(define)) (call-with-values (lambda () (f309f@parse-define f439a@e)) (lambda (f43b6@f43b3 f43b7@f43b5) (let ((f43ba@rhs f43b7@f43b5) (f43bb@id f43b6@f43b3)) (begin (if (f2f22@bound-id-member? f43bb@id f43ae@kwd*) (f3201@syntax-violation '#f '"cannot redefine keyword" f439a@e) (void)) (call-with-values (lambda () (f2ea6@gen-define-label+loc f43bb@id f438e@rib)) (lambda (f43c2@f43bf f43c3@f43c1) (let ((f43c6@lex f43c3@f43c1) (f43c7@lab f43c2@f43bf)) (begin (f2ecc@extend-rib! f438e@rib f43bb@id f43c7@lab) (f3179@chi-body* (cdr f4386@e*) (f30ad@add-lexical f43c7@lab f43c6@lex f4387@r) f4388@mr (cons f43c6@lex f4389@lex*) (cons f43ba@rhs f438a@rhs*) f438b@mod** f43ae@kwd* f438d@exp* f438e@rib f438f@top?))))))))) (if (memv f43b0@t '(define-syntax)) (call-with-values (lambda () (f30a1@parse-define-syntax f439a@e)) (lambda (f43ce@f43cb f43cf@f43cd) (let ((f43d2@rhs f43cf@f43cd) (f43d3@id f43ce@f43cb)) (begin (if (f2f22@bound-id-member? f43d3@id f43ae@kwd*) (f3201@syntax-violation '#f '"cannot redefine keyword" f439a@e) (void)) (let ((f43d6@lab (f2ea8@gen-define-label f43d3@id f438e@rib)) (f43d7@expanded-rhs (f317b@expand-transformer f43d2@rhs f4388@mr))) (begin (f2ecc@extend-rib! f438e@rib f43d3@id f43d6@lab) (let ((f43da@b (f2f4e@make-eval-transformer f43d7@expanded-rhs))) (f3179@chi-body* (cdr f4386@e*) (cons (cons f43d6@lab f43da@b) f4387@r) (cons (cons f43d6@lab f43da@b) f4388@mr) f4389@lex* f438a@rhs* f438b@mod** f43ae@kwd* f438d@exp* f438e@rib f438f@top?)))))))) (if (memv f43b0@t '(let-syntax letrec-syntax)) (let ((f43dc@t f439a@e)) (let ((f43de@ls/false (f311d@syntax-dispatch f43dc@t '(_ #(each (any any)) . each-any)))) (if (and f43de@ls/false (apply (lambda (f43e0@xlhs* f43e1@xrhs* f43e2@xbody*) (if (not (f2f1e@valid-bound-ids? f43e0@xlhs*)) (f3201@syntax-violation '#f '"invalid identifiers" f439a@e) (void))) f43de@ls/false)) (apply (lambda (f43e6@xlhs* f43e7@xrhs* f43e8@xbody*) (let ((f43ec@xlab* (map f2ea2@gen-label f43e6@xlhs*))) (let ((f43ee@xrib (f2ed6@make-full-rib f43e6@xlhs* f43ec@xlab*))) (let ((f43f0@xb* (map (lambda (f43f2@x) (f2f4e@make-eval-transformer (f317b@expand-transformer (if (eq? f43aa@type 'let-syntax) f43f2@x (f2f02@add-subst f43ee@xrib f43f2@x)) f4388@mr))) f43e7@xrhs*))) (f3179@chi-body* (append (map (lambda (f43f4@x) (f2f02@add-subst f43ee@xrib f43f4@x)) f43e8@xbody*) (cdr f4386@e*)) (append (map cons f43ec@xlab* f43f0@xb*) f4387@r) (append (map cons f43ec@xlab* f43f0@xb*) f4388@mr) f4389@lex* f438a@rhs* f438b@mod** f43ae@kwd* f438d@exp* f438e@rib f438f@top?))))) f43de@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f43dc@t)))) (if (memv f43b0@t '(begin)) (let ((f43f6@t f439a@e)) (let ((f43f8@ls/false (f311d@syntax-dispatch f43f6@t '(_ . each-any)))) (if f43f8@ls/false (apply (lambda (f43fa@x*) (f3179@chi-body* (append f43fa@x* (cdr f4386@e*)) f4387@r f4388@mr f4389@lex* f438a@rhs* f438b@mod** f43ae@kwd* f438d@exp* f438e@rib f438f@top?)) f43f8@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f43f6@t)))) (if (memv f43b0@t '(global-macro global-macro!)) (f3177@chi-body*-macro (cdr f4386@e*) f4387@r f4388@mr f4389@lex* f438a@rhs* f438b@mod** f43ae@kwd* f438d@exp* f438e@rib f438f@top? (f3139@chi-global-macro f43a9@value f439a@e)) (if (memv f43b0@t '(local-macro local-macro!)) (f3177@chi-body*-macro (cdr f4386@e*) f4387@r f4388@mr f4389@lex* f438a@rhs* f438b@mod** f43ae@kwd* f438d@exp* f438e@rib f438f@top? (f3137@chi-local-macro f43a9@value f439a@e)) (if (memv f43b0@t '(macro macro!)) (f3177@chi-body*-macro (cdr f4386@e*) f4387@r f4388@mr f4389@lex* f438a@rhs* f438b@mod** f43ae@kwd* f438d@exp* f438e@rib f438f@top? (f3135@chi-macro f43a9@value f439a@e)) (if (memv f43b0@t '(module)) (call-with-values (lambda () (f3173@chi-internal-module f439a@e f4387@r f4388@mr f4389@lex* f438a@rhs* f438b@mod** f43ae@kwd*)) (lambda (f440c@f43fd f440d@f43ff f440e@f4401 f440f@f4403 f4410@f4405 f4411@f4407 f4412@f4409 f4413@f440b) (let ((f441c@kwd* f4413@f440b) (f441d@mod** f4412@f4409) (f441e@mr f4411@f4407) (f441f@r f4410@f4405) (f4420@m-exp-lab* f440f@f4403) (f4421@m-exp-id* f440e@f4401) (f4422@rhs* f440d@f43ff) (f4423@lex* f440c@f43fd)) (begin (vector-for-each (lambda (f442c@id f442d@lab) (f2ecc@extend-rib! f438e@rib f442c@id f442d@lab)) f4421@m-exp-id* f4420@m-exp-lab*) (f3179@chi-body* (cdr f4386@e*) f441f@r f441e@mr f4423@lex* f4422@rhs* f441d@mod** f441c@kwd* f438d@exp* f438e@rib f438f@top?))))) (if (memv f43b0@t '(library)) (begin (f31e3@library-expander (f2f2a@stx->datum f439a@e)) (f3179@chi-body* (cdr f4386@e*) f4387@r f4388@mr f4389@lex* f438a@rhs* f438b@mod** f43ae@kwd* f438d@exp* f438e@rib f438f@top?)) (if (memv f43b0@t '(export)) (let ((f4430@t f439a@e)) (let ((f4432@ls/false (f311d@syntax-dispatch f4430@t '(_ . each-any)))) (if f4432@ls/false (apply (lambda (f4434@exp-decl*) (f3179@chi-body* (cdr f4386@e*) f4387@r f4388@mr f4389@lex* f438a@rhs* f438b@mod** f43ae@kwd* (append f4434@exp-decl* f438d@exp*) f438e@rib f438f@top?)) f4432@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f4430@t)))) (if (memv f43b0@t '(import)) (letrec* ((f4437@module-import? (lambda (f448a@e) (let ((f448c@t f448a@e)) (let ((f448e@ls/false (f311d@syntax-dispatch f448c@t '(_ any)))) (if (and f448e@ls/false (apply (lambda (f4490@id) (f2f16@id? f4490@id)) f448e@ls/false)) (apply (lambda (f4492@id) '#t) f448e@ls/false) (let ((f4494@t f448c@t)) (let ((f4496@ls/false (f311d@syntax-dispatch f4494@t '(_ . each-any)))) (if f4496@ls/false (apply (lambda (f4498@imp*) '#f) f4496@ls/false) (let ((f449a@t f4494@t)) (let ((f449c@ls/false (f311d@syntax-dispatch f449a@t '_))) (if f449c@ls/false (apply (lambda () (f3201@syntax-violation '#f '"malformed import form" f448a@e)) f449c@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f449a@t)))))))))))) (f4439@module-import (lambda (f4468@e f4469@r) (let ((f446c@t f4468@e)) (let ((f446e@ls/false (f311d@syntax-dispatch f446c@t '(_ any)))) (if (and f446e@ls/false (apply (lambda (f4470@id) (f2f16@id? f4470@id)) f446e@ls/false)) (apply (lambda (f4472@id) (call-with-values (lambda () (f2f38@syntax-type f4472@id f4469@r)) (lambda (f447a@f4475 f447b@f4477 f447c@f4479) (let ((f4480@kwd f447c@f4479) (f4481@value f447b@f4477) (f4482@type f447a@f4475)) (let ((f4486@t f4482@type)) (if (memv f4486@t '($module)) (let ((f4488@iface f4481@value)) (values (f3171@module-interface-exp-id* f4488@iface f4472@id) (f316b@module-interface-exp-lab-vec f4488@iface))) (f3201@syntax-violation '#f '"invalid import" f4468@e))))))) f446e@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f446c@t)))))) (f443b@library-import (lambda (f444c@e) (let ((f444e@t f444c@e)) (let ((f4450@ls/false (f311d@syntax-dispatch f444e@t '(any . each-any)))) (if f4450@ls/false (apply (lambda (f4452@ctxt f4453@imp*) (call-with-values (lambda () (f3183@parse-import-spec* (f3207@syntax->datum f4453@imp*))) (lambda (f445a@f4457 f445b@f4459) (let ((f445e@subst-labels f445b@f4459) (f445f@subst-names f445a@f4457)) (values (vector-map (lambda (f4462@name) (f2ef6@datum->stx f4452@ctxt f4462@name)) f445f@subst-names) f445e@subst-labels))))) f4450@ls/false) (let ((f4464@t f444e@t)) (let ((f4466@ls/false (f311d@syntax-dispatch f4464@t '_))) (if f4466@ls/false (apply (lambda () (f3201@syntax-violation '#f '"invalid import form" f444c@e)) f4466@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f4464@t)))))))))) (begin (call-with-values (lambda () (if (f4437@module-import? f439a@e) (f4439@module-import f439a@e f4387@r) (f443b@library-import f439a@e))) (lambda (f4440@f443d f4441@f443f) (let ((f4444@lab* f4441@f443f) (f4445@id* f4440@f443d)) (vector-for-each (lambda (f4448@id f4449@lab) (f2ecc@extend-rib! f438e@rib f4448@id f4449@lab)) f4445@id* f4444@lab*)))) (f3179@chi-body* (cdr f4386@e*) f4387@r f4388@mr f4389@lex* f438a@rhs* f438b@mod** f43ae@kwd* f438d@exp* f438e@rib f438f@top?))) (if f438f@top? (f3179@chi-body* (cdr f4386@e*) f4387@r f4388@mr (cons (f2e9e@gen-lexical 'dummy) f4389@lex*) (cons (cons 'top-expr f439a@e) f438a@rhs*) f438b@mod** f43ae@kwd* f438d@exp* f438e@rib f438f@top?) (values f4386@e* f4387@r f4388@mr f4389@lex* f438a@rhs* f438b@mod** f43ae@kwd* f438d@exp*)))))))))))))))))))))) (set! f4c75@f3179@chi-body* f3179@chi-body*) (set! f317b@expand-transformer (lambda (f449e@expr f449f@r) (let ((f44a2@rtc (f3187@make-collector))) (let ((f44a4@expanded-rhs (let ((f44ae@f44a7 f3189@inv-collector) (f44af@f44a9 f318b@vis-collector) (f44b0@f44ab f44a2@rtc) (f44b1@f44ad (lambda (f44b6@x) (values)))) (let ((f44b8@swap (lambda () (begin (let ((f44ba@t (f44ae@f44a7))) (begin (f44ae@f44a7 f44b0@f44ab) (set! f44b0@f44ab f44ba@t))) (let ((f44bc@t (f44af@f44a9))) (begin (f44af@f44a9 f44b1@f44ad) (set! f44b1@f44ad f44bc@t))))))) (dynamic-wind f44b8@swap (lambda () (f313f@chi-expr f449e@expr f449f@r f449f@r)) f44b8@swap))))) (begin (for-each (let ((f44be@mark-visit (f318b@vis-collector))) (lambda (f44c0@x) (begin (f2d32@f2b80@invoke-library f44c0@x) (f44be@mark-visit f44c0@x)))) (f44a2@rtc)) f44a4@expanded-rhs))))) (set! f4c76@f317b@expand-transformer f317b@expand-transformer) (set! f317d@parse-exports (lambda (f44c2@exp*) (let f44ca@f ((f44c4@exp* f44c2@exp*) (f44c5@int* '()) (f44c6@ext* '())) (if (null? f44c4@exp*) (begin (if (not (f2f1e@valid-bound-ids? f44c6@ext*)) (f3201@syntax-violation 'export '"invalid exports" (f3153@find-dups f44c6@ext*)) (void)) (values (map f3207@syntax->datum f44c6@ext*) f44c5@int*)) (let ((f44cc@t (car f44c4@exp*))) (let ((f44ce@ls/false (f311d@syntax-dispatch f44cc@t '(any . #(each (any any)))))) (if f44ce@ls/false (apply (lambda (f44d0@rename f44d1@i* f44d2@e*) (begin (if (not (and (eq? (f3207@syntax->datum f44d0@rename) 'rename) (for-all f2f16@id? f44d1@i*) (for-all f2f16@id? f44d2@e*))) (f3201@syntax-violation 'export '"invalid export specifier" (car f44c4@exp*)) (void)) (f44ca@f (cdr f44c4@exp*) (append f44d1@i* f44c5@int*) (append f44d2@e* f44c6@ext*)))) f44ce@ls/false) (let ((f44d6@t f44cc@t)) (let ((f44d8@ls/false (f311d@syntax-dispatch f44d6@t 'any))) (if f44d8@ls/false (apply (lambda (f44da@ie) (begin (if (not (f2f16@id? f44da@ie)) (f3201@syntax-violation 'export '"invalid export" f44da@ie) (void)) (f44ca@f (cdr f44c4@exp*) (cons f44da@ie f44c5@int*) (cons f44da@ie f44c6@ext*)))) f44d8@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f44d6@t))))))))))) (set! f4c77@f317d@parse-exports f317d@parse-exports) (set! f317f@parse-library-name (lambda (f44dc@spec) (letrec* ((f44df@parse (lambda (f44ec@x) (let ((f44ee@t f44ec@x)) (let ((f44f0@ls/false (f311d@syntax-dispatch f44ee@t '(each-any)))) (if (and f44f0@ls/false (apply (lambda (f44f2@v*) (for-all (lambda (f44f4@x) (let ((f44f6@x (f3207@syntax->datum f44f4@x))) (and (integer? f44f6@x) (exact? f44f6@x)))) f44f2@v*)) f44f0@ls/false)) (apply (lambda (f44f8@v*) (values '() (map f3207@syntax->datum f44f8@v*))) f44f0@ls/false) (let ((f44fa@t f44ee@t)) (let ((f44fc@ls/false (f311d@syntax-dispatch f44fa@t '(any . any)))) (if (and f44fc@ls/false (apply (lambda (f44fe@x f44ff@rest) (symbol? (f3207@syntax->datum f44fe@x))) f44fc@ls/false)) (apply (lambda (f4502@x f4503@rest) (call-with-values (lambda () (f44df@parse f4503@rest)) (lambda (f450a@f4507 f450b@f4509) (let ((f450e@v* f450b@f4509) (f450f@x* f450a@f4507)) (values (cons (f3207@syntax->datum f4502@x) f450f@x*) f450e@v*))))) f44fc@ls/false) (let ((f4512@t f44fa@t)) (let ((f4514@ls/false (f311d@syntax-dispatch f4512@t '()))) (if f4514@ls/false (apply (lambda () (values '() '())) f4514@ls/false) (let ((f4516@t f4512@t)) (let ((f4518@ls/false (f311d@syntax-dispatch f4516@t '_))) (if f4518@ls/false (apply (lambda () (f3201@syntax-violation '#f '"invalid library name" f44dc@spec)) f4518@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f4516@t)))))))))))))))) (call-with-values (lambda () (f44df@parse f44dc@spec)) (lambda (f44e4@f44e1 f44e5@f44e3) (let ((f44e8@ver* f44e5@f44e3) (f44e9@name* f44e4@f44e1)) (begin (if (null? f44e9@name*) (f3201@syntax-violation '#f '"empty library name" f44dc@spec) (void)) (values f44e9@name* f44e8@ver*)))))))) (set! f4c78@f317f@parse-library-name f317f@parse-library-name) (set! f3181@parse-library (lambda (f451a@e) (let ((f451c@t f451a@e)) (let ((f451e@ls/false (f311d@syntax-dispatch f451c@t '(any each-any (any . each-any) (any . each-any) . each-any)))) (if (and f451e@ls/false (apply (lambda (f4520@library f4521@name* f4522@export f4523@exp* f4524@import f4525@imp* f4526@b*) (and (eq? (f3207@syntax->datum f4522@export) 'export) (eq? (f3207@syntax->datum f4524@import) 'import) (eq? (f3207@syntax->datum f4520@library) 'library))) f451e@ls/false)) (apply (lambda (f452e@library f452f@name* f4530@export f4531@exp* f4532@import f4533@imp* f4534@b*) (values f452f@name* f4531@exp* f4533@imp* f4534@b*)) f451e@ls/false) (let ((f453c@t f451c@t)) (let ((f453e@ls/false (f311d@syntax-dispatch f453c@t '_))) (if f453e@ls/false (apply (lambda () (f3201@syntax-violation '#f '"malformed library" f451a@e)) f453e@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f453c@t))))))))) (set! f4c79@f3181@parse-library f3181@parse-library) (set! f3183@parse-import-spec* (letrec* ((f4541@idsyn? (lambda (f474a@x) (symbol? (f3207@syntax->datum f474a@x)))) (f4543@dup-error (lambda (f4748@name) (f3201@syntax-violation 'import '"two imports with different bindings" f4748@name))) (f4545@merge-substs (lambda (f4736@s f4737@subst) (letrec* ((f473b@insert-to-subst (lambda (f473c@a f473d@subst) (let ((f4740@name (car f473c@a)) (f4741@label (cdr f473c@a))) (let ((f4744@t (assq f4740@name f473d@subst))) (if f4744@t ((lambda (f4746@x) (if (eq? (cdr f4746@x) f4741@label) f473d@subst (f4543@dup-error f4740@name))) f4744@t) (cons f473c@a f473d@subst))))))) (if (null? f4736@s) f4737@subst (f473b@insert-to-subst (car f4736@s) (f4545@merge-substs (cdr f4736@s) f4737@subst)))))) (f4547@exclude* (lambda (f4706@sym* f4707@subst) (letrec* ((f470b@exclude (lambda (f4724@sym f4725@subst) (if (null? f4725@subst) (f3201@syntax-violation 'import '"cannot rename unbound identifier" f4724@sym) (if (eq? f4724@sym (caar f4725@subst)) (values (cdar f4725@subst) (cdr f4725@subst)) (let ((f4728@a (car f4725@subst))) (call-with-values (lambda () (f470b@exclude f4724@sym (cdr f4725@subst))) (lambda (f472e@f472b f472f@f472d) (let ((f4732@subst f472f@f472d) (f4733@old f472e@f472b)) (values f4733@old (cons f4728@a f4732@subst))))))))))) (if (null? f4706@sym*) (values '() f4707@subst) (call-with-values (lambda () (f470b@exclude (car f4706@sym*) f4707@subst)) (lambda (f4710@f470d f4711@f470f) (let ((f4714@subst f4711@f470f) (f4715@old f4710@f470d)) (call-with-values (lambda () (f4547@exclude* (cdr f4706@sym*) f4714@subst)) (lambda (f471c@f4719 f471d@f471b) (let ((f4720@subst f471d@f471b) (f4721@old* f471c@f4719)) (values (cons f4715@old f4721@old*) f4720@subst))))))))))) (f4549@find* (lambda (f46fe@sym* f46ff@subst) (map (lambda (f4702@x) (let ((f4704@t (assq f4702@x f46ff@subst))) (if f4704@t (cdr f4704@t) (f3201@syntax-violation 'import '"cannot find identifier" f4702@x)))) f46fe@sym*))) (f454b@rem* (lambda (f46f6@sym* f46f7@subst) (let f46fc@f ((f46fa@subst f46f7@subst)) (if (null? f46fa@subst) '() (if (memq (caar f46fa@subst) f46f6@sym*) (f46fc@f (cdr f46fa@subst)) (cons (car f46fa@subst) (f46fc@f (cdr f46fa@subst)))))))) (f454d@remove-dups (lambda (f46f4@ls) (if (null? f46f4@ls) '() (if (memq (car f46f4@ls) (cdr f46f4@ls)) (f454d@remove-dups (cdr f46f4@ls)) (cons (car f46f4@ls) (f454d@remove-dups (cdr f46f4@ls))))))) (f454f@parse-library-name (lambda (f460c@spec) (letrec* ((f460f@subversion? (lambda (f46f0@x) (let ((f46f2@x (f3207@syntax->datum f46f0@x))) (and (integer? f46f2@x) (exact? f46f2@x) (>= f46f2@x '0))))) (f4611@subversion-pred (lambda (f4690@x*) (let ((f4692@t f4690@x*)) (let ((f4694@ls/false (f311d@syntax-dispatch f4692@t 'any))) (if (and f4694@ls/false (apply (lambda (f4696@n) (f460f@subversion? f4696@n)) f4694@ls/false)) (apply (lambda (f4698@n) (lambda (f469a@x) (= f469a@x (f3207@syntax->datum f4698@n)))) f4694@ls/false) (let ((f469c@t f4692@t)) (let ((f469e@ls/false (f311d@syntax-dispatch f469c@t '(any . each-any)))) (if (and f469e@ls/false (apply (lambda (f46a0@p? f46a1@sub*) (eq? (f3207@syntax->datum f46a0@p?) 'and)) f469e@ls/false)) (apply (lambda (f46a4@p? f46a5@sub*) (let ((f46a8@p* (map f4611@subversion-pred f46a5@sub*))) (lambda (f46aa@x) (for-all (lambda (f46ac@p) (f46ac@p f46aa@x)) f46a8@p*)))) f469e@ls/false) (let ((f46ae@t f469c@t)) (let ((f46b0@ls/false (f311d@syntax-dispatch f46ae@t '(any . each-any)))) (if (and f46b0@ls/false (apply (lambda (f46b2@p? f46b3@sub*) (eq? (f3207@syntax->datum f46b2@p?) 'or)) f46b0@ls/false)) (apply (lambda (f46b6@p? f46b7@sub*) (let ((f46ba@p* (map f4611@subversion-pred f46b7@sub*))) (lambda (f46bc@x) (exists (lambda (f46be@p) (f46be@p f46bc@x)) f46ba@p*)))) f46b0@ls/false) (let ((f46c0@t f46ae@t)) (let ((f46c2@ls/false (f311d@syntax-dispatch f46c0@t '(any any)))) (if (and f46c2@ls/false (apply (lambda (f46c4@p? f46c5@sub) (eq? (f3207@syntax->datum f46c4@p?) 'not)) f46c2@ls/false)) (apply (lambda (f46c8@p? f46c9@sub) (let ((f46cc@p (f4611@subversion-pred f46c9@sub))) (lambda (f46ce@x) (not (f46cc@p f46ce@x))))) f46c2@ls/false) (let ((f46d0@t f46c0@t)) (let ((f46d2@ls/false (f311d@syntax-dispatch f46d0@t '(any any)))) (if (and f46d2@ls/false (apply (lambda (f46d4@p? f46d5@n) (and (eq? (f3207@syntax->datum f46d4@p?) '<=) (f460f@subversion? f46d5@n))) f46d2@ls/false)) (apply (lambda (f46d8@p? f46d9@n) (lambda (f46dc@x) (<= f46dc@x (f3207@syntax->datum f46d9@n)))) f46d2@ls/false) (let ((f46de@t f46d0@t)) (let ((f46e0@ls/false (f311d@syntax-dispatch f46de@t '(any any)))) (if (and f46e0@ls/false (apply (lambda (f46e2@p? f46e3@n) (and (eq? (f3207@syntax->datum f46e2@p?) '>=) (f460f@subversion? f46e3@n))) f46e0@ls/false)) (apply (lambda (f46e6@p? f46e7@n) (lambda (f46ea@x) (>= f46ea@x (f3207@syntax->datum f46e7@n)))) f46e0@ls/false) (let ((f46ec@t f46de@t)) (let ((f46ee@ls/false (f311d@syntax-dispatch f46ec@t '_))) (if f46ee@ls/false (apply (lambda () (f3201@syntax-violation 'import '"invalid sub-version spec" f460c@spec f4690@x*)) f46ee@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f46ec@t)))))))))))))))))))))))) (f4613@version-pred (lambda (f4640@x*) (let ((f4642@t f4640@x*)) (let ((f4644@ls/false (f311d@syntax-dispatch f4642@t '()))) (if f4644@ls/false (apply (lambda () (lambda (f4646@x) '#t)) f4644@ls/false) (let ((f4648@t f4642@t)) (let ((f464a@ls/false (f311d@syntax-dispatch f4648@t '(any . each-any)))) (if (and f464a@ls/false (apply (lambda (f464c@c f464d@ver*) (eq? (f3207@syntax->datum f464c@c) 'and)) f464a@ls/false)) (apply (lambda (f4650@c f4651@ver*) (let ((f4654@p* (map f4613@version-pred f4651@ver*))) (lambda (f4656@x) (for-all (lambda (f4658@p) (f4658@p f4656@x)) f4654@p*)))) f464a@ls/false) (let ((f465a@t f4648@t)) (let ((f465c@ls/false (f311d@syntax-dispatch f465a@t '(any . each-any)))) (if (and f465c@ls/false (apply (lambda (f465e@c f465f@ver*) (eq? (f3207@syntax->datum f465e@c) 'or)) f465c@ls/false)) (apply (lambda (f4662@c f4663@ver*) (let ((f4666@p* (map f4613@version-pred f4663@ver*))) (lambda (f4668@x) (exists (lambda (f466a@p) (f466a@p f4668@x)) f4666@p*)))) f465c@ls/false) (let ((f466c@t f465a@t)) (let ((f466e@ls/false (f311d@syntax-dispatch f466c@t '(any any)))) (if (and f466e@ls/false (apply (lambda (f4670@c f4671@ver) (eq? (f3207@syntax->datum f4670@c) 'not)) f466e@ls/false)) (apply (lambda (f4674@c f4675@ver) (let ((f4678@p (f4613@version-pred f4675@ver))) (lambda (f467a@x) (not (f4678@p f467a@x))))) f466e@ls/false) (let ((f467c@t f466c@t)) (let ((f467e@ls/false (f311d@syntax-dispatch f467c@t 'each-any))) (if f467e@ls/false (apply (lambda (f4680@sub*) (let ((f4682@p* (map f4611@subversion-pred f4680@sub*))) (lambda (f4684@x) (let f468a@f ((f4686@p* f4682@p*) (f4687@x f4684@x)) (if (null? f4686@p*) '#t (if (null? f4687@x) '#f (and ((car f4686@p*) (car f4687@x)) (f468a@f (cdr f4686@p*) (cdr f4687@x))))))))) f467e@ls/false) (let ((f468c@t f467c@t)) (let ((f468e@ls/false (f311d@syntax-dispatch f468c@t '_))) (if f468e@ls/false (apply (lambda () (f3201@syntax-violation 'import '"invalid version spec" f460c@spec f4640@x*)) f468e@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f468c@t)))))))))))))))))))))) (let f4616@f ((f4614@x f460c@spec)) (let ((f4618@t f4614@x)) (let ((f461a@ls/false (f311d@syntax-dispatch f4618@t '(each-any)))) (if f461a@ls/false (apply (lambda (f461c@version-spec*) (values '() (f4613@version-pred f461c@version-spec*))) f461a@ls/false) (let ((f461e@t f4618@t)) (let ((f4620@ls/false (f311d@syntax-dispatch f461e@t '(any . any)))) (if (and f4620@ls/false (apply (lambda (f4622@x f4623@x*) (f4541@idsyn? f4622@x)) f4620@ls/false)) (apply (lambda (f4626@x f4627@x*) (call-with-values (lambda () (f4616@f f4627@x*)) (lambda (f462e@f462b f462f@f462d) (let ((f4632@pred f462f@f462d) (f4633@name f462e@f462b)) (values (cons (f3207@syntax->datum f4626@x) f4633@name) f4632@pred))))) f4620@ls/false) (let ((f4636@t f461e@t)) (let ((f4638@ls/false (f311d@syntax-dispatch f4636@t '()))) (if f4638@ls/false (apply (lambda () (values '() (lambda (f463a@x) '#t))) f4638@ls/false) (let ((f463c@t f4636@t)) (let ((f463e@ls/false (f311d@syntax-dispatch f463c@t '_))) (if f463e@ls/false (apply (lambda () (f3201@syntax-violation '#f '"invalid import spec" f460c@spec)) f463e@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f463c@t))))))))))))))))) (f4551@import-library (lambda (f45fc@spec*) (call-with-values (lambda () (f454f@parse-library-name f45fc@spec*)) (lambda (f4602@f45ff f4603@f4601) (let ((f4606@pred f4603@f4601) (f4607@name f4602@f45ff)) (begin (if (null? f4607@name) (f3201@syntax-violation 'import '"empty library name" f45fc@spec*) (void)) (let ((f460a@lib (f2d2b@f2b72@find-library-by-name f4607@name))) (begin (if (not f460a@lib) (f3201@syntax-violation 'import '"cannot find library with required name" f4607@name) (void)) (if (not (f4606@pred (f2d05@f2b26@library-version f460a@lib))) (f3201@syntax-violation 'import '"library does not satisfy version specification" f45fc@spec* f460a@lib) (void)) ((f318d@imp-collector) f460a@lib) (f2d0d@f2b36@library-subst f460a@lib))))))))) (f4553@get-import (lambda (f456e@spec) (let ((f4570@t f456e@spec)) (let ((f4572@ls/false (f311d@syntax-dispatch f4570@t '(any . each-any)))) (if (and f4572@ls/false (apply (lambda (f4574@x f4575@x*) (not (memq (f3207@syntax->datum f4574@x) '(for rename except only prefix library)))) f4572@ls/false)) (apply (lambda (f4578@x f4579@x*) (f4551@import-library (cons f4578@x f4579@x*))) f4572@ls/false) (let ((f457c@t f4570@t)) (let ((f457e@ls/false (f311d@syntax-dispatch f457c@t '(any any . #(each (any any)))))) (if (and f457e@ls/false (apply (lambda (f4580@rename f4581@isp f4582@old* f4583@new*) (and (eq? (f3207@syntax->datum f4580@rename) 'rename) (for-all f4541@idsyn? f4582@old*) (for-all f4541@idsyn? f4583@new*))) f457e@ls/false)) (apply (lambda (f4588@rename f4589@isp f458a@old* f458b@new*) (let ((f4590@subst (f4553@get-import f4589@isp)) (f4591@old* (map f3207@syntax->datum f458a@old*)) (f4592@new* (map f3207@syntax->datum f458b@new*))) (let ((f4596@old-label* (f4549@find* f4591@old* f4590@subst))) (let ((f4598@subst (f454b@rem* f4591@old* f4590@subst))) (f4545@merge-substs (map cons f4592@new* f4596@old-label*) f4598@subst))))) f457e@ls/false) (let ((f459a@t f457c@t)) (let ((f459c@ls/false (f311d@syntax-dispatch f459a@t '(any any . each-any)))) (if (and f459c@ls/false (apply (lambda (f459e@except f459f@isp f45a0@sym*) (and (eq? (f3207@syntax->datum f459e@except) 'except) (for-all f4541@idsyn? f45a0@sym*))) f459c@ls/false)) (apply (lambda (f45a4@except f45a5@isp f45a6@sym*) (let ((f45aa@subst (f4553@get-import f45a5@isp))) (f454b@rem* (map f3207@syntax->datum f45a6@sym*) f45aa@subst))) f459c@ls/false) (let ((f45ac@t f459a@t)) (let ((f45ae@ls/false (f311d@syntax-dispatch f45ac@t '(any any . each-any)))) (if (and f45ae@ls/false (apply (lambda (f45b0@only f45b1@isp f45b2@sym*) (and (eq? (f3207@syntax->datum f45b0@only) 'only) (for-all f4541@idsyn? f45b2@sym*))) f45ae@ls/false)) (apply (lambda (f45b6@only f45b7@isp f45b8@sym*) (let ((f45bc@subst (f4553@get-import f45b7@isp)) (f45bd@sym* (map f3207@syntax->datum f45b8@sym*))) (let ((f45c0@sym* (f454d@remove-dups f45bd@sym*))) (let ((f45c2@lab* (f4549@find* f45c0@sym* f45bc@subst))) (map cons f45c0@sym* f45c2@lab*))))) f45ae@ls/false) (let ((f45c4@t f45ac@t)) (let ((f45c6@ls/false (f311d@syntax-dispatch f45c4@t '(any any any)))) (if (and f45c6@ls/false (apply (lambda (f45c8@prefix f45c9@isp f45ca@p) (and (eq? (f3207@syntax->datum f45c8@prefix) 'prefix) (f4541@idsyn? f45ca@p))) f45c6@ls/false)) (apply (lambda (f45ce@prefix f45cf@isp f45d0@p) (let ((f45d4@subst (f4553@get-import f45cf@isp)) (f45d5@prefix (symbol->string (f3207@syntax->datum f45d0@p)))) (map (lambda (f45d8@x) (cons (string->symbol (string-append f45d5@prefix (symbol->string (car f45d8@x)))) (cdr f45d8@x))) f45d4@subst))) f45c6@ls/false) (let ((f45da@t f45c4@t)) (let ((f45dc@ls/false (f311d@syntax-dispatch f45da@t '(any each-any)))) (if (and f45dc@ls/false (apply (lambda (f45de@library f45df@spec*) (eq? (f3207@syntax->datum f45de@library) 'library)) f45dc@ls/false)) (apply (lambda (f45e2@library f45e3@spec*) (f4551@import-library f45e3@spec*)) f45dc@ls/false) (let ((f45e6@t f45da@t)) (let ((f45e8@ls/false (f311d@syntax-dispatch f45e6@t '(any any . any)))) (if (and f45e8@ls/false (apply (lambda (f45ea@for f45eb@isp f45ec@rest) (eq? (f3207@syntax->datum f45ea@for) 'for)) f45e8@ls/false)) (apply (lambda (f45f0@for f45f1@isp f45f2@rest) (f4553@get-import f45f1@isp)) f45e8@ls/false) (let ((f45f6@t f45e6@t)) (let ((f45f8@ls/false (f311d@syntax-dispatch f45f6@t 'any))) (if f45f8@ls/false (apply (lambda (f45fa@spec) (f3201@syntax-violation 'import '"invalid import spec" f45fa@spec)) f45f8@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f45f6@t))))))))))))))))))))))))))) (f4555@add-imports! (lambda (f455e@imp f455f@h) (let ((f4562@subst (f4553@get-import f455e@imp))) (for-each (lambda (f4564@x) (let ((f4566@name (car f4564@x)) (f4567@label (cdr f4564@x))) (let ((f456a@t (hashtable-ref f455f@h f4566@name '#f))) (if f456a@t ((lambda (f456c@l) (if (not (eq? f456c@l f4567@label)) (f4543@dup-error f4566@name) (void))) f456a@t) (hashtable-set! f455f@h f4566@name f4567@label))))) f4562@subst))))) (lambda (f4556@imp*) (let f455c@f ((f4558@imp* f4556@imp*) (f4559@h (make-eq-hashtable))) (if (null? f4558@imp*) (hashtable-entries f4559@h) (begin (f4555@add-imports! (car f4558@imp*) f4559@h) (f455c@f (cdr f4558@imp*) f4559@h))))))) (set! f4c7a@f3183@parse-import-spec* f3183@parse-import-spec*) (set! f3185@make-top-rib (lambda (f474c@names f474d@labels) (let ((f4750@rib (f2eca@make-empty-rib))) (begin (vector-for-each (lambda (f4752@name f4753@label) (begin (if (not (symbol? f4752@name)) (error 'make-top-rib '"BUG: not a symbol" f4752@name) (void)) (f2ece@extend-rib/nc! f4750@rib (make-simple-struct 'stx '5 (list f4752@name f2e9a@top-mark* '() '())) f4753@label))) f474c@names f474d@labels) f4750@rib)))) (set! f4c7b@f3185@make-top-rib f3185@make-top-rib) (set! f3187@make-collector (lambda () (let ((f4756@ls '())) (lambda f475a (let ((f475b (length f475a))) (if (= f475b '0) (apply (lambda () f4756@ls) f475a) (if (= f475b '1) (apply (lambda (f4758@x) (set! f4756@ls (f2e93@set-cons f4758@x f4756@ls))) f475a) (error 'apply '"invalid arg count")))))))) (set! f4c7c@f3187@make-collector f3187@make-collector) (set! f3189@inv-collector (f2a66@f2944@make-parameter (lambda f475c@args (assertion-violation 'inv-collector '"BUG: not initialized")) (lambda (f475e@x) (begin (if (not (procedure? f475e@x)) (assertion-violation 'inv-collector '"BUG: not a procedure" f475e@x) (void)) f475e@x)))) (set! f4c7d@f3189@inv-collector f3189@inv-collector) (set! f318b@vis-collector (f2a66@f2944@make-parameter (lambda f4760@args (assertion-violation 'vis-collector '"BUG: not initialized")) (lambda (f4762@x) (begin (if (not (procedure? f4762@x)) (assertion-violation 'vis-collector '"BUG: not a procedure" f4762@x) (void)) f4762@x)))) (set! f4c7e@f318b@vis-collector f318b@vis-collector) (set! f318d@imp-collector (f2a66@f2944@make-parameter (lambda f4764@args (assertion-violation 'imp-collector '"BUG: not initialized")) (lambda (f4766@x) (begin (if (not (procedure? f4766@x)) (assertion-violation 'imp-collector '"BUG: not a procedure" f4766@x) (void)) f4766@x)))) (set! f4c7f@f318d@imp-collector f318d@imp-collector) (set! f318f@chi-library-internal (lambda (f4768@e* f4769@rib f476a@top?) (call-with-values (lambda () (f3179@chi-body* f4768@e* '() '() '() '() '() '() '() f4769@rib f476a@top?)) (lambda (f477e@f476f f477f@f4771 f4780@f4773 f4781@f4775 f4782@f4777 f4783@f4779 f4784@f477b f4785@f477d) (let ((f478e@exp* f4785@f477d) (f478f@_kwd* f4784@f477b) (f4790@mod** f4783@f4779) (f4791@rhs* f4782@f4777) (f4792@lex* f4781@f4775) (f4793@mr f4780@f4773) (f4794@r f477f@f4771) (f4795@e* f477e@f476f)) (values (append (apply append (reverse f4790@mod**)) f4795@e*) f4794@r f4793@mr (reverse f4792@lex*) (reverse f4791@rhs*) f478e@exp*)))))) (set! f4c80@f318f@chi-library-internal f318f@chi-library-internal) (set! f3191@chi-interaction-expr (lambda (f479e@e f479f@rib f47a0@r) (call-with-values (lambda () (f3179@chi-body* (list f479e@e) f47a0@r f47a0@r '() '() '() '() '() f479f@rib '#t)) (lambda (f47b4@f47a5 f47b5@f47a7 f47b6@f47a9 f47b7@f47ab f47b8@f47ad f47b9@f47af f47ba@f47b1 f47bb@f47b3) (let ((f47c4@_exp* f47bb@f47b3) (f47c5@_kwd* f47ba@f47b1) (f47c6@mod** f47b9@f47af) (f47c7@rhs* f47b8@f47ad) (f47c8@lex* f47b7@f47ab) (f47c9@mr f47b6@f47a9) (f47ca@r f47b5@f47a7) (f47cb@e* f47b4@f47a5)) (let ((f47d4@e* (f314d@expand-interaction-rhs*/init* (reverse f47c8@lex*) (reverse f47c7@rhs*) (append (apply append (reverse f47c6@mod**)) f47cb@e*) f47ca@r f47c9@mr))) (let ((f47d6@e (if (null? f47d4@e*) (f2e7c@f2ddd@build-void) (if (null? (cdr f47d4@e*)) (car f47d4@e*) (f2e7b@f2ddb@build-sequence '#f f47d4@e*))))) (values f47d6@e f47ca@r)))))))) (set! f4c81@f3191@chi-interaction-expr f3191@chi-interaction-expr) (set! f3193@library-body-expander (lambda (f47d8@name f47d9@main-exp* f47da@imp* f47db@b* f47dc@top?) (letrec* ((f47e3@itc (f3187@make-collector))) (let ((f47ec@f47e5 f318d@imp-collector) (f47ed@f47e7 f3211@top-level-context) (f47ee@f47e9 f47e3@itc) (f47ef@f47eb '#f)) (let ((f47f4@swap (lambda () (begin (let ((f47f6@t (f47ec@f47e5))) (begin (f47ec@f47e5 f47ee@f47e9) (set! f47ee@f47e9 f47f6@t))) (let ((f47f8@t (f47ed@f47e7))) (begin (f47ed@f47e7 f47ef@f47eb) (set! f47ef@f47eb f47f8@t))))))) (dynamic-wind f47f4@swap (lambda () (call-with-values (lambda () (f3183@parse-import-spec* f47da@imp*)) (lambda (f47fe@f47fb f47ff@f47fd) (let ((f4802@subst-labels f47ff@f47fd) (f4803@subst-names f47fe@f47fb)) (let ((f4806@rib (f3185@make-top-rib f4803@subst-names f4802@subst-labels))) (letrec* ((f4809@wrap (lambda (f4884@x) (make-simple-struct 'stx '5 (list f4884@x f2e9a@top-mark* (list f4806@rib) '()))))) (let ((f480a@b* (map f4809@wrap f47db@b*)) (f480b@main-exp* (map f4809@wrap f47d9@main-exp*)) (f480c@rtc (f3187@make-collector)) (f480d@vtc (f3187@make-collector))) (let ((f481a@f4813 f3189@inv-collector) (f481b@f4815 f318b@vis-collector) (f481c@f4817 f480c@rtc) (f481d@f4819 f480d@vtc)) (let ((f4822@swap (lambda () (begin (let ((f4824@t (f481a@f4813))) (begin (f481a@f4813 f481c@f4817) (set! f481c@f4817 f4824@t))) (let ((f4826@t (f481b@f4815))) (begin (f481b@f4815 f481d@f4819) (set! f481d@f4819 f4826@t))))))) (dynamic-wind f4822@swap (lambda () (call-with-values (lambda () (f318f@chi-library-internal f480a@b* f4806@rib f47dc@top?)) (lambda (f4834@f4829 f4835@f482b f4836@f482d f4837@f482f f4838@f4831 f4839@f4833) (let ((f4840@internal-exp* f4839@f4833) (f4841@rhs* f4838@f4831) (f4842@lex* f4837@f482f) (f4843@mr f4836@f482d) (f4844@r f4835@f482b) (f4845@init* f4834@f4829)) (call-with-values (lambda () (f317d@parse-exports (append f480b@main-exp* f4840@internal-exp*))) (lambda (f4850@f484d f4851@f484f) (let ((f4854@exp-id* f4851@f484f) (f4855@exp-name* f4850@f484d)) (begin (f2ed2@seal-rib! f4806@rib) (let ((f4858@init* (f313b@chi-expr* f4845@init* f4844@r f4843@mr))) (let ((f485a@rhs* (f314f@chi-rhs* f4841@rhs* f4844@r f4843@mr))) (begin (f2ed4@unseal-rib! f4806@rib) (let ((f485c@loc* (map f2ea0@gen-global f4842@lex*)) (f485d@export-subst (f31eb@make-export-subst f4855@exp-name* f4854@exp-id*))) (letrec* ((f4861@errstr '"attempt to export mutated variable")) (call-with-values (lambda () (f31ed@make-export-env/macros f4842@lex* f485c@loc* f4844@r)) (lambda (f4868@f4863 f4869@f4865 f486a@f4867) (let ((f486e@macro* f486a@f4867) (f486f@global* f4869@f4865) (f4870@export-env f4868@f4863)) (begin (for-each (lambda (f4874@s) (let ((f4876@name (car f4874@s)) (f4877@label (cdr f4874@s))) (let ((f487a@p (assq f4877@label f4870@export-env))) (if f487a@p (let ((f487c@b (cdr f487a@p))) (let ((f487e@type (car f487c@b))) (if (eq? f487e@type 'mutable) (f3201@syntax-violation 'export f4861@errstr f4876@name) (void)))) (void))))) f485d@export-subst) (let ((f4880@invoke-body (f2e81@f2de7@build-library-letrec* '#f f47d8@name f4842@lex* f485c@loc* f485a@rhs* (if (null? f4858@init*) (f2e7c@f2ddd@build-void) (f2e7b@f2ddb@build-sequence '#f f4858@init*)))) (f4881@invoke-definitions (map f2e78@f2d3a@build-global-define (map cdr f486f@global*)))) (values (f47e3@itc) (f480c@rtc) (f480d@vtc) (f2e7b@f2ddb@build-sequence '#f (append f4881@invoke-definitions (list f4880@invoke-body))) f486e@macro* f485d@export-subst f4870@export-env))))))))))))))))))) f4822@swap)))))))))) f47f4@swap)))))) (set! f4c82@f3193@library-body-expander f3193@library-body-expander) (set! f3195@core-library-expander (lambda (f4886@e f4887@verify-name) (call-with-values (lambda () (f3181@parse-library f4886@e)) (lambda (f4892@f488b f4893@f488d f4894@f488f f4895@f4891) (let ((f489a@b* f4895@f4891) (f489b@imp* f4894@f488f) (f489c@exp* f4893@f488d) (f489d@name* f4892@f488b)) (call-with-values (lambda () (f317f@parse-library-name f489d@name*)) (lambda (f48a6@f48a3 f48a7@f48a5) (let ((f48aa@ver f48a7@f48a5) (f48ab@name f48a6@f48a3)) (begin (f4887@verify-name f48ab@name) (call-with-values (lambda () (f3193@library-body-expander f48ab@name f489c@exp* f489b@imp* f489a@b* '#f)) (lambda (f48bc@f48af f48bd@f48b1 f48be@f48b3 f48bf@f48b5 f48c0@f48b7 f48c1@f48b9 f48c2@f48bb) (let ((f48ca@export-env f48c2@f48bb) (f48cb@export-subst f48c1@f48b9) (f48cc@visit-code f48c0@f48b7) (f48cd@invoke-code f48bf@f48b5) (f48ce@visit-req* f48be@f48b3) (f48cf@invoke-req* f48bd@f48b1) (f48d0@imp* f48bc@f48af)) (values f48ab@name f48aa@ver f48d0@imp* f48cf@invoke-req* f48ce@visit-req* f48cd@invoke-code f48cc@visit-code f48cb@export-subst f48ca@export-env))))))))))))) (set! f4c83@f3195@core-library-expander f3195@core-library-expander) (set! f3197@parse-top-level-program (lambda (f48d8@e*) (let ((f48da@t f48d8@e*)) (let ((f48dc@ls/false (f311d@syntax-dispatch f48da@t '((any . each-any) . each-any)))) (if (and f48dc@ls/false (apply (lambda (f48de@import f48df@imp* f48e0@b*) (eq? (f3207@syntax->datum f48de@import) 'import)) f48dc@ls/false)) (apply (lambda (f48e4@import f48e5@imp* f48e6@b*) (values f48e5@imp* f48e6@b*)) f48dc@ls/false) (let ((f48ea@t f48da@t)) (let ((f48ec@ls/false (f311d@syntax-dispatch f48ea@t '((any . any) . any)))) (if (and f48ec@ls/false (apply (lambda (f48ee@import f48ef@x f48f0@y) (eq? (f3207@syntax->datum f48ee@import) 'import)) f48ec@ls/false)) (apply (lambda (f48f4@import f48f5@x f48f6@y) (f3201@syntax-violation 'expander '"invalid syntax of top-level program" (f2f10@syntax-car f48d8@e*))) f48ec@ls/false) (let ((f48fa@t f48ea@t)) (let ((f48fc@ls/false (f311d@syntax-dispatch f48fa@t '_))) (if f48fc@ls/false (apply (lambda () (assertion-violation 'expander '"top-level program is missing an (import ---) clause")) f48fc@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f48fa@t)))))))))))) (set! f4c84@f3197@parse-top-level-program f3197@parse-top-level-program) (set! f3199@top-level-expander (lambda (f48fe@e*) (call-with-values (lambda () (f3197@parse-top-level-program f48fe@e*)) (lambda (f4904@f4901 f4905@f4903) (let ((f4908@b* f4905@f4903) (f4909@imp* f4904@f4901)) (call-with-values (lambda () (f3193@library-body-expander '() '() f4909@imp* f4908@b* '#t)) (lambda (f491a@f490d f491b@f490f f491c@f4911 f491d@f4913 f491e@f4915 f491f@f4917 f4920@f4919) (let ((f4928@export-env f4920@f4919) (f4929@export-subst f491f@f4917) (f492a@visit-code f491e@f4915) (f492b@invoke-code f491d@f4913) (f492c@visit-req* f491c@f4911) (f492d@invoke-req* f491b@f490f) (f492e@imp* f491a@f490d)) (values f492d@invoke-req* f492b@invoke-code))))))))) (set! f4c85@f3199@top-level-expander f3199@top-level-expander) (set! f319b@rp (f2a63@f293e@make-record-printer 'env (lambda (f4936@x f4937@p f4938@wr) (display '"#<environment>" f4937@p)))) (set! f4c86@f319b@rp f319b@rp) (set! f31a5@env? (lambda (f493c@x) (and (simple-struct? f493c@x) (eq? (simple-struct-name f493c@x) 'env)))) (set! f4c87@f31a5@env? f31a5@env?) (set! f31a7@env-names (lambda (f493e@x) (simple-struct-ref f493e@x '0))) (set! f4c88@f31a7@env-names f31a7@env-names) (set! f31a9@set-env-names! (lambda (f4940@x f4941@val) (simple-struct-set! f4940@x '0 f4941@val))) (set! f4c89@f31a9@set-env-names! f31a9@set-env-names!) (set! f31ab@env-labels (lambda (f4944@x) (simple-struct-ref f4944@x '1))) (set! f4c8a@f31ab@env-labels f31ab@env-labels) (set! f31ad@set-env-labels! (lambda (f4946@x f4947@val) (simple-struct-set! f4946@x '1 f4947@val))) (set! f4c8b@f31ad@set-env-labels! f31ad@set-env-labels!) (set! f31af@env-itc (lambda (f494a@x) (simple-struct-ref f494a@x '2))) (set! f4c8c@f31af@env-itc f31af@env-itc) (set! f31b1@set-env-itc! (lambda (f494c@x f494d@val) (simple-struct-set! f494c@x '2 f494d@val))) (set! f4c8d@f31b1@set-env-itc! f31b1@set-env-itc!) (set! f31b3@dummy '3) (set! f4c8e@f31b3@dummy f31b3@dummy) (set! f31b5@rp (f2a63@f293e@make-record-printer 'interaction-env (lambda (f4950@x f4951@p f4952@wr) (display '"#<environment>" f4951@p)))) (set! f4c8f@f31b5@rp f31b5@rp) (set! f31bf@interaction-env? (lambda (f4956@x) (and (simple-struct? f4956@x) (eq? (simple-struct-name f4956@x) 'interaction-env)))) (set! f4c90@f31bf@interaction-env? f31bf@interaction-env?) (set! f31c1@interaction-env-rib (lambda (f4958@x) (simple-struct-ref f4958@x '0))) (set! f4c91@f31c1@interaction-env-rib f31c1@interaction-env-rib) (set! f31c3@set-interaction-env-rib! (lambda (f495a@x f495b@val) (simple-struct-set! f495a@x '0 f495b@val))) (set! f4c92@f31c3@set-interaction-env-rib! f31c3@set-interaction-env-rib!) (set! f31c5@interaction-env-r (lambda (f495e@x) (simple-struct-ref f495e@x '1))) (set! f4c93@f31c5@interaction-env-r f31c5@interaction-env-r) (set! f31c7@set-interaction-env-r! (lambda (f4960@x f4961@val) (simple-struct-set! f4960@x '1 f4961@val))) (set! f4c94@f31c7@set-interaction-env-r! f31c7@set-interaction-env-r!) (set! f31c9@interaction-env-locs (lambda (f4964@x) (simple-struct-ref f4964@x '2))) (set! f4c95@f31c9@interaction-env-locs f31c9@interaction-env-locs) (set! f31cb@set-interaction-env-locs! (lambda (f4966@x f4967@val) (simple-struct-set! f4966@x '2 f4967@val))) (set! f4c96@f31cb@set-interaction-env-locs! f31cb@set-interaction-env-locs!) (set! f31cd@dummy '3) (set! f4c97@f31cd@dummy f31cd@dummy) (set! f31cf@interaction-environment-symbols (lambda () (f31d7@environment-symbols (f320f@interaction-environment)))) (set! f4c98@f31cf@interaction-environment-symbols f31cf@interaction-environment-symbols) (set! f31d1@environment-bindings (lambda (f496a@e) (vector->list (vector-map (lambda (f496c@name f496d@label) (f31d3@parse-binding (cons f496c@name (f2d31@f2b7e@imported-label->binding f496d@label)))) (f31a7@env-names f496a@e) (f31ab@env-labels f496a@e))))) (set! f4c99@f31d1@environment-bindings f31d1@environment-bindings) (set! f31d3@parse-binding (lambda (f4970@b) (cons (car f4970@b) (let ((f4972@t (cadr f4970@b))) (if (memv f4972@t '(core-prim global)) 'procedure (if (memv f4972@t '(core-macro macro global-macro)) 'syntax (if (memv f4972@t '($core-rtd)) 'record (if (eq? (car f4970@b) (cadr f4970@b)) 'syntax 'unknown)))))))) (set! f4c9a@f31d3@parse-binding f31d3@parse-binding) (set! f31d5@environment? (lambda (f4974@x) (or (f31a5@env? f4974@x) (f31bf@interaction-env? f4974@x)))) (set! f4c9b@f31d5@environment? f31d5@environment?) (set! f31d7@environment-symbols (lambda (f4976@x) (if (f31a5@env? f4976@x) (vector->list (f31a7@env-names f4976@x)) (if (f31bf@interaction-env? f4976@x) (map values (f2eb4@rib-sym* (f31c1@interaction-env-rib f4976@x))) (assertion-violation 'environment-symbols '"not an environment" f4976@x))))) (set! f4c9c@f31d7@environment-symbols f31d7@environment-symbols) (set! f31d9@environment (lambda f4978@imp* (let ((f497a@itc (f3187@make-collector))) (let ((f4980@f497d f318d@imp-collector) (f4981@f497f f497a@itc)) (let ((f4984@swap (lambda () (let ((f4986@t (f4980@f497d))) (begin (f4980@f497d f4981@f497f) (set! f4981@f497f f4986@t)))))) (dynamic-wind f4984@swap (lambda () (call-with-values (lambda () (f3183@parse-import-spec* f4978@imp*)) (lambda (f498c@f4989 f498d@f498b) (let ((f4990@subst-labels f498d@f498b) (f4991@subst-names f498c@f4989)) (make-simple-struct 'env '4 (list f4991@subst-names f4990@subst-labels f497a@itc)))))) f4984@swap)))))) (set! f4c9d@f31d9@environment f31d9@environment) (set! f31db@null-environment (lambda (f4994@n) (begin (if (not (eqv? f4994@n '5)) (assertion-violation 'null-environment '"not 5" f4994@n) (void)) (f31d9@environment '(psyntax null-environment-5))))) (set! f4c9e@f31db@null-environment f31db@null-environment) (set! f31dd@scheme-report-environment (lambda (f4996@n) (begin (if (not (eqv? f4996@n '5)) (assertion-violation 'scheme-report-environment '"not 5" f4996@n) (void)) (f31d9@environment '(psyntax scheme-report-environment-5))))) (set! f4c9f@f31dd@scheme-report-environment f31dd@scheme-report-environment) (set! f31df@expand (lambda (f4998@x f4999@env) (if (f31a5@env? f4999@env) (let ((f499c@rib (f3185@make-top-rib (f31a7@env-names f4999@env) (f31ab@env-labels f4999@env)))) (let ((f499e@x (make-simple-struct 'stx '5 (list f4998@x f2e9a@top-mark* (list f499c@rib) '()))) (f499f@itc (f31af@env-itc f4999@env)) (f49a0@rtc (f3187@make-collector)) (f49a1@vtc (f3187@make-collector))) (let ((f49a6@x (let ((f49b8@f49a9 f3211@top-level-context) (f49b9@f49ab f3189@inv-collector) (f49ba@f49ad f318b@vis-collector) (f49bb@f49af f318d@imp-collector) (f49bc@f49b1 '#f) (f49bd@f49b3 f49a0@rtc) (f49be@f49b5 f49a1@vtc) (f49bf@f49b7 f499f@itc)) (let ((f49c8@swap (lambda () (begin (let ((f49ca@t (f49b8@f49a9))) (begin (f49b8@f49a9 f49bc@f49b1) (set! f49bc@f49b1 f49ca@t))) (let ((f49cc@t (f49b9@f49ab))) (begin (f49b9@f49ab f49bd@f49b3) (set! f49bd@f49b3 f49cc@t))) (let ((f49ce@t (f49ba@f49ad))) (begin (f49ba@f49ad f49be@f49b5) (set! f49be@f49b5 f49ce@t))) (let ((f49d0@t (f49bb@f49af))) (begin (f49bb@f49af f49bf@f49b7) (set! f49bf@f49b7 f49d0@t))))))) (dynamic-wind f49c8@swap (lambda () (f313f@chi-expr f499e@x '() '())) f49c8@swap))))) (begin (f2ed2@seal-rib! f499c@rib) (values f49a6@x (f49a0@rtc)))))) (if (f31bf@interaction-env? f4999@env) (let ((f49d2@rib (f31c1@interaction-env-rib f4999@env)) (f49d3@r (f31c5@interaction-env-r f4999@env)) (f49d4@rtc (f3187@make-collector))) (let ((f49d8@x (make-simple-struct 'stx '5 (list f4998@x f2e9a@top-mark* (list f49d2@rib) '())))) (call-with-values (lambda () (let ((f49ee@f49df f3211@top-level-context) (f49ef@f49e1 f3189@inv-collector) (f49f0@f49e3 f318b@vis-collector) (f49f1@f49e5 f318d@imp-collector) (f49f2@f49e7 f4999@env) (f49f3@f49e9 f49d4@rtc) (f49f4@f49eb (f3187@make-collector)) (f49f5@f49ed (f3187@make-collector))) (let ((f49fe@swap (lambda () (begin (let ((f4a00@t (f49ee@f49df))) (begin (f49ee@f49df f49f2@f49e7) (set! f49f2@f49e7 f4a00@t))) (let ((f4a02@t (f49ef@f49e1))) (begin (f49ef@f49e1 f49f3@f49e9) (set! f49f3@f49e9 f4a02@t))) (let ((f4a04@t (f49f0@f49e3))) (begin (f49f0@f49e3 f49f4@f49eb) (set! f49f4@f49eb f4a04@t))) (let ((f4a06@t (f49f1@f49e5))) (begin (f49f1@f49e5 f49f5@f49ed) (set! f49f5@f49ed f4a06@t))))))) (dynamic-wind f49fe@swap (lambda () (f3191@chi-interaction-expr f49d8@x f49d2@rib f49d3@r)) f49fe@swap)))) (lambda (f4a08@f49db f4a09@f49dd) (let ((f4a0c@r^ f4a09@f49dd) (f4a0d@e f4a08@f49db)) (begin (f31c7@set-interaction-env-r! f4999@env f4a0c@r^) (values f4a0d@e (f49d4@rtc)))))))) (assertion-violation 'expand '"not an environment" f4999@env))))) (set! f4ca0@f31df@expand f31df@expand) (set! f31e1@eval (lambda (f4a10@x f4a11@env) (begin (if (not (f31d5@environment? f4a11@env)) (error 'eval '"not an environment" f4a11@env) (void)) (call-with-values (lambda () (f31df@expand f4a10@x f4a11@env)) (lambda (f4a18@f4a15 f4a19@f4a17) (let ((f4a1c@invoke-req* f4a19@f4a17) (f4a1d@x f4a18@f4a15)) (begin (for-each f2d32@f2b80@invoke-library f4a1c@invoke-req*) (eval-core (f2abc@f2a74@expanded->core f4a1d@x))))))))) (set! f4ca1@f31e1@eval f31e1@eval) (set! f31e3@library-expander (lambda f4a8e (let ((f4a8f (length f4a8e))) (if (= f4a8f '3) (apply (lambda (f4a20@x f4a21@filename f4a22@verify-name) (letrec* ((f4a27@build-visit-code (lambda (f4a7c@macro*) (if (null? f4a7c@macro*) (f2e7c@f2ddd@build-void) (f2e7b@f2ddb@build-sequence '#f (map (lambda (f4a7e@x) (let ((f4a80@loc (car f4a7e@x)) (f4a81@src (cddr f4a7e@x))) (list 'set! f4a80@loc f4a81@src))) f4a7c@macro*))))) (f4a29@visit! (lambda (f4a74@macro*) (for-each (lambda (f4a76@x) (let ((f4a78@loc (car f4a76@x)) (f4a79@proc (cadr f4a76@x))) (set-symbol-value! f4a78@loc f4a79@proc))) f4a74@macro*)))) (call-with-values (lambda () (f3195@core-library-expander f4a20@x f4a22@verify-name)) (lambda (f4a3c@f4a2b f4a3d@f4a2d f4a3e@f4a2f f4a3f@f4a31 f4a40@f4a33 f4a41@f4a35 f4a42@f4a37 f4a43@f4a39 f4a44@f4a3b) (let ((f4a4e@export-env f4a44@f4a3b) (f4a4f@export-subst f4a43@f4a39) (f4a50@macro* f4a42@f4a37) (f4a51@invoke-code f4a41@f4a35) (f4a52@vis* f4a40@f4a33) (f4a53@inv* f4a3f@f4a31) (f4a54@imp* f4a3e@f4a2f) (f4a55@ver f4a3d@f4a2d) (f4a56@name f4a3c@f4a2b)) (let ((f4a60@id (gensym)) (f4a61@name f4a56@name) (f4a62@ver f4a55@ver) (f4a63@imp* (map f2d36@f2b88@library-spec f4a54@imp*)) (f4a64@vis* (map f2d36@f2b88@library-spec f4a52@vis*)) (f4a65@inv* (map f2d36@f2b88@library-spec f4a53@inv*)) (f4a66@visit-proc (lambda () (f4a29@visit! f4a50@macro*))) (f4a67@invoke-proc (lambda () (eval-core (f2abc@f2a74@expanded->core f4a51@invoke-code)))) (f4a68@visit-code (f4a27@build-visit-code f4a50@macro*)) (f4a69@invoke-code f4a51@invoke-code)) (begin (f2d30@f2b7c@install-library f4a60@id f4a61@name f4a62@ver f4a63@imp* f4a64@vis* f4a65@inv* f4a4f@export-subst f4a4e@export-env f4a66@visit-proc f4a67@invoke-proc f4a68@visit-code f4a69@invoke-code '#t f4a21@filename) (values f4a60@id f4a61@name f4a62@ver f4a63@imp* f4a64@vis* f4a65@inv* f4a69@invoke-code f4a68@visit-code f4a4f@export-subst f4a4e@export-env)))))))) f4a8e) (if (= f4a8f '2) (apply (lambda (f4a84@x f4a85@filename) (f31e3@library-expander f4a84@x f4a85@filename (lambda (f4a88@x) (values)))) f4a8e) (if (= f4a8f '1) (apply (lambda (f4a8a@x) (f31e3@library-expander f4a8a@x '#f (lambda (f4a8c@x) (values)))) f4a8e) (error 'apply '"invalid arg count"))))))) (set! f4ca2@f31e3@library-expander f31e3@library-expander) (set! f31e5@boot-library-expand (lambda (f4a90@x) (call-with-values (lambda () (f31e3@library-expander f4a90@x)) (lambda (f4aa6@f4a93 f4aa7@f4a95 f4aa8@f4a97 f4aa9@f4a99 f4aaa@f4a9b f4aab@f4a9d f4aac@f4a9f f4aad@f4aa1 f4aae@f4aa3 f4aaf@f4aa5) (let ((f4aba@export-env f4aaf@f4aa5) (f4abb@export-subst f4aae@f4aa3) (f4abc@visit-code f4aad@f4aa1) (f4abd@invoke-code f4aac@f4a9f) (f4abe@inv* f4aab@f4a9d) (f4abf@vis* f4aaa@f4a9b) (f4ac0@imp* f4aa9@f4a99) (f4ac1@ver f4aa8@f4a97) (f4ac2@name f4aa7@f4a95) (f4ac3@id f4aa6@f4a93)) (values f4ac2@name f4abd@invoke-code f4abb@export-subst f4aba@export-env)))))) (set! f4ca3@f31e5@boot-library-expand f31e5@boot-library-expand) (set! f31e7@rev-map-append (lambda (f4ace@f f4acf@ls f4ad0@ac) (if (null? f4acf@ls) f4ad0@ac (f31e7@rev-map-append f4ace@f (cdr f4acf@ls) (cons (f4ace@f (car f4acf@ls)) f4ad0@ac))))) (set! f4ca4@f31e7@rev-map-append f31e7@rev-map-append) (set! f31e9@build-exports (lambda (f4ad4@lex*+loc* f4ad5@init*) (f2e7b@f2ddb@build-sequence '#f (cons (f2e7c@f2ddd@build-void) (f31e7@rev-map-append (lambda (f4ad8@x) (list 'set! (cdr f4ad8@x) (car f4ad8@x))) f4ad4@lex*+loc* f4ad5@init*))))) (set! f4ca5@f31e9@build-exports f31e9@build-exports) (set! f31eb@make-export-subst (lambda (f4ada@name* f4adb@id*) (map (lambda (f4ade@name f4adf@id) (let ((f4ae2@label (f2f2c@id->label f4adf@id))) (begin (if (not f4ae2@label) (f3201@syntax-violation '#f '"cannot export unbound identifier" f4adf@id) (void)) (cons f4ade@name f4ae2@label)))) f4ada@name* f4adb@id*))) (set! f4ca6@f31eb@make-export-subst f31eb@make-export-subst) (set! f31ed@make-export-env/macros (lambda (f4ae4@lex* f4ae5@loc* f4ae6@r) (letrec* ((f4aeb@lookup (lambda (f4b08@x) (let f4b10@f ((f4b0a@x f4b08@x) (f4b0b@lex* f4ae4@lex*) (f4b0c@loc* f4ae5@loc*)) (if (pair? f4b0b@lex*) (if (eq? f4b0a@x (car f4b0b@lex*)) (car f4b0c@loc*) (f4b10@f f4b0a@x (cdr f4b0b@lex*) (cdr f4b0c@loc*))) (assertion-violation 'lookup-make-export '"BUG")))))) (let f4af4@f ((f4aec@r f4ae6@r) (f4aed@env '()) (f4aee@global* '()) (f4aef@macro* '())) (if (null? f4aec@r) (values f4aed@env f4aee@global* f4aef@macro*) (let ((f4af6@x (car f4aec@r))) (let ((f4af8@label (car f4af6@x)) (f4af9@b (cdr f4af6@x))) (let ((f4afc@t (f2f32@binding-type f4af9@b))) (if (memv f4afc@t '(lexical)) (let ((f4afe@v (f2f34@binding-value f4af9@b))) (let ((f4b00@loc (f4aeb@lookup (f30a7@lexical-var f4afe@v))) (f4b01@type (if (f30a9@lexical-mutable? f4afe@v) 'mutable 'global))) (f4af4@f (cdr f4aec@r) (cons (cons* f4af8@label f4b01@type f4b00@loc) f4aed@env) (cons (cons (f30a7@lexical-var f4afe@v) f4b00@loc) f4aee@global*) f4aef@macro*))) (if (memv f4afc@t '(local-macro)) (let ((f4b04@loc (gensym))) (f4af4@f (cdr f4aec@r) (cons (cons* f4af8@label 'global-macro f4b04@loc) f4aed@env) f4aee@global* (cons (cons f4b04@loc (f2f34@binding-value f4af9@b)) f4aef@macro*))) (if (memv f4afc@t '(local-macro!)) (let ((f4b06@loc (gensym))) (f4af4@f (cdr f4aec@r) (cons (cons* f4af8@label 'global-macro! f4b06@loc) f4aed@env) f4aee@global* (cons (cons f4b06@loc (f2f34@binding-value f4af9@b)) f4aef@macro*))) (if (memv f4afc@t '($rtd $module)) (f4af4@f (cdr f4aec@r) (cons f4af6@x f4aed@env) f4aee@global* f4aef@macro*) (assertion-violation 'expander '"BUG: do not know how to export" (f2f32@binding-type f4af9@b) (f2f34@binding-value f4af9@b)))))))))))))) (set! f4ca7@f31ed@make-export-env/macros f31ed@make-export-env/macros) (set! f31ef@generate-temporaries (lambda (f4b12@ls) (let ((f4b14@t f4b12@ls)) (let ((f4b16@ls/false (f311d@syntax-dispatch f4b14@t 'each-any))) (if f4b16@ls/false (apply (lambda (f4b18@ls) (map (lambda (f4b1a@x) (make-simple-struct 'stx '5 (list (let ((f4b1c@x (f3207@syntax->datum f4b1a@x))) (if (or (symbol? f4b1c@x) (string? f4b1c@x)) (gensym f4b1c@x) (gensym 't))) f2e9a@top-mark* '() '()))) f4b18@ls)) f4b16@ls/false) (let ((f4b1e@t f4b14@t)) (let ((f4b20@ls/false (f311d@syntax-dispatch f4b1e@t '_))) (if f4b20@ls/false (apply (lambda () (assertion-violation 'generate-temporaries '"not a list")) f4b20@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f4b1e@t))))))))) (set! f4ca8@f31ef@generate-temporaries f31ef@generate-temporaries) (set! f31f1@free-identifier=? (lambda (f4b22@x f4b23@y) (if (f2f16@id? f4b22@x) (if (f2f16@id? f4b23@y) (f2f1c@free-id=? f4b22@x f4b23@y) (assertion-violation 'free-identifier=? '"not an identifier" f4b23@y)) (assertion-violation 'free-identifier=? '"not an identifier" f4b22@x)))) (set! f4ca9@f31f1@free-identifier=? f31f1@free-identifier=?) (set! f31f3@bound-identifier=? (lambda (f4b26@x f4b27@y) (if (f2f16@id? f4b26@x) (if (f2f16@id? f4b27@y) (f2f1a@bound-id=? f4b26@x f4b27@y) (assertion-violation 'bound-identifier=? '"not an identifier" f4b27@y)) (assertion-violation 'bound-identifier=? '"not an identifier" f4b26@x)))) (set! f4caa@f31f3@bound-identifier=? f31f3@bound-identifier=?) (set! f31f5@make-source-condition (lambda (f4b2a@x) (letrec* ((f4b34@f4b2f (make-record-type-descriptor '&source-information &condition-rtd 'f4b32 '#f '#f '#((immutable file-name) (immutable line)))) (f4b36@f4b31 '#f) (f4b38@f4b30 (make-record-constructor-descriptor f4b34@f4b2f &condition-rcd f4b36@f4b31)) (f4b3b@f4b2e (record-predicate f4b34@f4b2f)) (f4b3d@make-source-condition (record-constructor f4b38@f4b30)) (f4b3f@f4b2c (record-accessor f4b34@f4b2f '0)) (f4b41@f4b2d (record-accessor f4b34@f4b2f '1)) (f4b43@source-condition? (condition-predicate f4b34@f4b2f)) (f4b45@source-filename (condition-accessor f4b34@f4b2f f4b3f@f4b2c)) (f4b47@source-character (condition-accessor f4b34@f4b2f f4b41@f4b2d))) (if (and (pair? f4b2a@x) (pair? (cdr f4b2a@x))) (f4b3d@make-source-condition (car f4b2a@x) (cadr f4b2a@x)) (condition))))) (set! f4cab@f31f5@make-source-condition f31f5@make-source-condition) (set! f31f7@extract-position-condition (lambda (f4b48@x) (f31f5@make-source-condition (f31f9@expression-position f4b48@x)))) (set! f4cac@f31f7@extract-position-condition f31f7@extract-position-condition) (set! f31f9@expression-position (lambda (f4b4a@x) (and (f2ee2@stx? f4b4a@x) (let ((f4b4c@x (f2ee4@stx-expr f4b4a@x))) (and (f2a5a@f292c@annotation? f4b4c@x) (f2a5b@f292e@annotation-source f4b4c@x)))))) (set! f4cad@f31f9@expression-position f31f9@expression-position) (set! f31fb@assertion-error (lambda (f4b4e@expr f4b4f@pos) (raise (condition (make-assertion-violation) (make-who-condition 'assert) (make-message-condition '"assertion failed") (make-irritants-condition (list f4b4e@expr)) (f31f5@make-source-condition f4b4f@pos))))) (set! f4cae@f31fb@assertion-error f31fb@assertion-error) (set! f31fd@syntax-error (lambda (f4b52@x . f4b54@args) (begin (if (not (for-all string? f4b54@args)) (assertion-violation 'syntax-error '"invalid argument" f4b54@args) (void)) (raise (condition (make-message-condition (if (null? f4b54@args) '"invalid syntax" (apply string-append f4b54@args))) (make-syntax-violation (f3207@syntax->datum f4b52@x) '#f) (f31f7@extract-position-condition f4b52@x)))))) (set! f4caf@f31fd@syntax-error f31fd@syntax-error) (set! f31ff@syntax-violation* (lambda (f4b56@who f4b57@msg f4b58@form f4b59@condition-object) (begin (if (not (string? f4b57@msg)) (assertion-violation 'syntax-violation '"message is not a string" f4b57@msg) (void)) (let ((f4b5e@who (if (or (string? f4b56@who) (symbol? f4b56@who)) f4b56@who (if (not f4b56@who) (let ((f4b60@t f4b58@form)) (let ((f4b62@ls/false (f311d@syntax-dispatch f4b60@t 'any))) (if (and f4b62@ls/false (apply (lambda (f4b64@id) (f2f16@id? f4b64@id)) f4b62@ls/false)) (apply (lambda (f4b66@id) (f3207@syntax->datum f4b66@id)) f4b62@ls/false) (let ((f4b68@t f4b60@t)) (let ((f4b6a@ls/false (f311d@syntax-dispatch f4b68@t '(any . any)))) (if (and f4b6a@ls/false (apply (lambda (f4b6c@id f4b6d@rest) (f2f16@id? f4b6c@id)) f4b6a@ls/false)) (apply (lambda (f4b70@id f4b71@rest) (f3207@syntax->datum f4b70@id)) f4b6a@ls/false) (let ((f4b74@t f4b68@t)) (let ((f4b76@ls/false (f311d@syntax-dispatch f4b74@t '_))) (if f4b76@ls/false (apply (lambda () '#f) f4b76@ls/false) (f3201@syntax-violation '#f '"invalid syntax" f4b74@t)))))))))) (assertion-violation 'syntax-violation '"invalid who argument" f4b56@who))))) (raise (condition (if f4b5e@who (make-who-condition f4b5e@who) (condition)) (make-message-condition f4b57@msg) f4b59@condition-object (f31f7@extract-position-condition f4b58@form))))))) (set! f4cb0@f31ff@syntax-violation* f31ff@syntax-violation*) (set! f3201@syntax-violation (lambda f4b86 (let ((f4b87 (length f4b86))) (if (= f4b87 '3) (apply (lambda (f4b78@who f4b79@msg f4b7a@form) (f3201@syntax-violation f4b78@who f4b79@msg f4b7a@form '#f)) f4b86) (if (= f4b87 '4) (apply (lambda (f4b7e@who f4b7f@msg f4b80@form f4b81@subform) (f31ff@syntax-violation* f4b7e@who f4b7f@msg f4b80@form (make-syntax-violation (f3207@syntax->datum f4b80@form) (f3207@syntax->datum f4b81@subform)))) f4b86) (error 'apply '"invalid arg count")))))) (set! f4cb1@f3201@syntax-violation f3201@syntax-violation) (set! f3203@identifier? (lambda (f4b88@x) (f2f16@id? f4b88@x))) (set! f4cb2@f3203@identifier? f3203@identifier?) (set! f3205@datum->syntax (lambda (f4b8a@id f4b8b@datum) (if (f2f16@id? f4b8a@id) (f2ef6@datum->stx f4b8a@id f4b8b@datum) (assertion-violation 'datum->syntax '"not an identifier" f4b8a@id)))) (set! f4cb3@f3205@datum->syntax f3205@datum->syntax) (set! f3207@syntax->datum (lambda (f4b8e@x) (f2f2a@stx->datum f4b8e@x))) (set! f4cb4@f3207@syntax->datum f3207@syntax->datum) (set! f3209@ungensym-all (lambda (f4b90@code) (if (pair? f4b90@code) (cons (f3209@ungensym-all (car f4b90@code)) (f3209@ungensym-all (cdr f4b90@code))) (if (symbol? f4b90@code) (ungensym f4b90@code) f4b90@code)))) (set! f4cb5@f3209@ungensym-all f3209@ungensym-all) (set! f320b@compile-r6rs-top-level (lambda (f4b92@x*) (call-with-values (lambda () (f3199@top-level-expander f4b92@x*)) (lambda (f4b98@f4b95 f4b99@f4b97) (let ((f4b9c@invoke-code f4b99@f4b97) (f4b9d@lib* f4b98@f4b95)) (lambda () (begin (for-each f2d32@f2b80@invoke-library f4b9d@lib*) (let ((f4ba0@expanded (f2abc@f2a74@expanded->core f4b9c@invoke-code))) (begin (if (symbol-value 'debug-expand) (format '#t '"psyntax expanded=~a\n" (f3209@ungensym-all f4ba0@expanded)) (void)) (eval-core f4ba0@expanded)))))))))) (set! f4cb6@f320b@compile-r6rs-top-level f320b@compile-r6rs-top-level) (set! f320d@pre-compile-r6rs-top-level (lambda (f4ba2@x*) (call-with-values (lambda () (f3199@top-level-expander f4ba2@x*)) (lambda (f4ba8@f4ba5 f4ba9@f4ba7) (let ((f4bac@invoke-code f4ba9@f4ba7) (f4bad@lib* f4ba8@f4ba5)) (begin (for-each f2d32@f2b80@invoke-library f4bad@lib*) (f2a64@f2940@compile-core (f2abc@f2a74@expanded->core f4bac@invoke-code)))))))) (set! f4cb7@f320d@pre-compile-r6rs-top-level f320d@pre-compile-r6rs-top-level) (set! f320f@interaction-environment (let ((f4bb0@the-env '#f)) (lambda () (or f4bb0@the-env (let ((f4bb2@lib (f2d2b@f2b72@find-library-by-name '(mosh interaction))) (f4bb3@rib (f2eca@make-empty-rib))) (begin (let ((f4bb6@subst (f2d0d@f2b36@library-subst f4bb2@lib))) (begin (f2eb6@set-rib-sym*! f4bb3@rib (map car f4bb6@subst)) (f2eba@set-rib-mark**! f4bb3@rib (map (lambda (f4bb8@x) f2e9a@top-mark*) f4bb6@subst)) (f2ebe@set-rib-label*! f4bb3@rib (map cdr f4bb6@subst)))) (let ((f4bba@env (make-simple-struct 'interaction-env '4 (list f4bb3@rib '() '())))) (begin (set! f4bb0@the-env f4bba@env) f4bba@env)))))))) (set! f4cb8@f320f@interaction-environment f320f@interaction-environment) (set! f3211@top-level-context (f2a66@f2944@make-parameter '#f)) (set! f4cb9@f3211@top-level-context f3211@top-level-context) (f2d28@f2b6c@current-library-expander f31e3@library-expander))
(begin (begin (f2ab9@f2a6e@current-primitive-locations (lambda (f520f@x) (let ((f5211@t (assq f520f@x '((syntax-error . f4caf@f31fd@syntax-error) (syntax-dispatch . f4c4b@f311d@syntax-dispatch) (load . f4e39@f4ce0@load) (interaction-environment . f4cb8@f320f@interaction-environment) (library-path . f2d20@f2b5c@library-path) (mosh-cache-dir . f2a67@f2946@mosh-cache-dir) (make-parameter . f2a66@f2944@make-parameter) (make-variable-transformer . f4c08@f2f48@make-variable-transformer) (identifier? . f4cb2@f3203@identifier?) (generate-temporaries . f4ca8@f31ef@generate-temporaries) (free-identifier=? . f4ca9@f31f1@free-identifier=?) (syntax->datum . f4cb4@f3207@syntax->datum) (datum->syntax . f4cb3@f3205@datum->syntax) (bound-identifier=? . f4caa@f31f3@bound-identifier=?) (scheme-report-environment . f4c9f@f31dd@scheme-report-environment) (null-environment . f4c9e@f31db@null-environment) (command-line . f4e36@f4cda@command-line) (eval . f4ca1@f31e1@eval) (environment . f4c9d@f31d9@environment) (syntax-violation . f4cb1@f3201@syntax-violation) (assertion-error . f4cae@f31fb@assertion-error))))) (if f5211@t (cdr f5211@t) '#f)))) (f2d30@f2b7c@install-library 'f51ec '(mosh interaction) '() '() '() '() '((regexp? . f51ac) (alist->eq-hash-table . f51a8) (format . f51a5) (string-split . f5195) (call-process . f518e) (set-current-directory! . f518a) (expand-path . f5189) (current-directory . f5188) (%spawn . f5187) (%waitpid . f5186) (simple-struct-name . f5185) (simple-struct-set! . f5184) (simple-struct-ref . f5183) (make-simple-struct . f5182) (simple-struct? . f5181) (pointer-ref-c-int64 . f5180) (pointer-ref-c-int32 . f517f) (pointer-ref-c-int16 . f517e) (pointer-ref-c-int8 . f517d) (pointer-ref-c-uint64 . f517c) (pointer-ref-c-uint32 . f517b) (pointer-ref-c-uint16 . f517a) (pointer-ref-c-uint8 . f5179) (pointer-set-c-uint64! . f5178) (pointer-set-c-uint32! . f5177) (pointer-set-c-uint16! . f5176) (pointer-set-c-uint8! . f5175) (pointer-set-c-int64! . f5174) (pointer-set-c-int32! . f5173) (pointer-set-c-int16! . f5172) (pointer-set-c-int8! . f5171) (pointer-set-c-pointer! . f5170) (pointer-set-c-double! . f516f) (pointer-set-c-float! . f516e) (pointer-set-c-long-long! . f516d) (pointer-set-c-long! . f516c) (pointer-set-c-int! . f516b) (pointer-set-c-short! . f516a) (pointer-set-c-char! . f5169) (pointer-ref-c-pointer . f5168) (pointer-ref-c-double . f5167) (pointer-ref-c-float . f5166) (pointer-ref-c-unsigned-long-long . f5165) (pointer-ref-c-signed-long-long . f5164) (pointer-ref-c-unsigned-long . f5163) (pointer-ref-c-signed-long . f5162) (pointer-ref-c-unsigned-int . f5161) (pointer-ref-c-signed-int . f5160) (pointer-ref-c-unsigned-short . f515f) (pointer-ref-c-signed-short . f515e) (pointer-ref-c-unsigned-char . f515d) (pointer-ref-c-signed-char . f515c) (pointer->integer . f515b) (integer->pointer . f515a) (pointer? . f5159) (shared-errno . f5158) (%ffi-supported? . f5153) (%ffi-pointer->string . f5152) (%ffi-call . f5151) (%ffi-lookup . f5150) (%ffi-open . f514f) (null-terminated-utf8->string . f514e) (null-terminated-bytevector->string . f514d) (%exec . f514c) (%fork . f514b) (%pipe . f514a) (p . f5149) (whereis . f512d) (register . f512c) (vm-join! . f512b) (vm-set-value! . f512a) (vm? . f5129) (main-vm? . f5128) (vm-eval . f5127) (vm-self . f5126) (vm-start! . f5125) (make-vm . f5124) (mutex-try-lock! . f5123) (mutex-unlock! . f5122) (mutex-lock! . f5121) (mutex? . f5120) (make-mutex . f511f) (condition-variable-notify-all! . f511e) (condition-variable-notify! . f511d) (condition-variable-wait! . f511c) (make-condition-variable . f511b) (write/ss . f511a) (string-upcase . f5101) (string-titlecase . f5100) (string-normalize-nfkd . f50ff) (string-normalize-nfkc . f50fe) (string-normalize-nfd . f50fd) (string-normalize-nfc . f50fc) (string-foldcase . f50fb) (string-downcase . f50fa) (string-ci>? . f50f9) (string-ci>=? . f50f8) (string-ci=? . f50f7) (string-ci<? . f50f6) (string-ci<=? . f50f5) (char-whitespace? . f50f4) (char-upper-case? . f50f3) (char-title-case? . f50f2) (char-numeric? . f50f1) (char-lower-case? . f50f0) (char-general-category . f50ef) (char-upcase . f50ee) (char-titlecase . f50ed) (char-foldcase . f50ec) (char-downcase . f50eb) (char-ci>? . f50ea) (char-ci>=? . f50e9) (char-ci=? . f50e8) (char-ci<? . f50e7) (char-ci<=? . f50e6) (char-alphabetic? . f50e5) (make-variable-transformer . f2f47) (identifier? . f3202) (generate-temporaries . f31ee) (free-identifier=? . f31f0) (syntax->datum . f3206) (datum->syntax . f3204) (bound-identifier=? . f31f2) (record-type-descriptor? . f50e4) (record-predicate . f50e3) (record-mutator . f50e2) (record-constructor . f50e1) (record-accessor . f50e0) (make-record-type-descriptor . f50df) (make-record-constructor-descriptor . f50de) (record? . f50dd) (record-type-uid . f50dc) (record-type-sealed? . f50db) (record-type-parent . f50da) (record-type-opaque? . f50d9) (record-type-name . f50d8) (record-type-generative? . f50d7) (record-type-field-names . f50d6) (record-rtd . f50d5) (record-field-mutable? . f50d4) (delete-file . f50d3) (file-exists? . f50d2) (vector-sort! . f50d1) (vector-sort . f50d0) (list-sort . f50cf) (symbol-hash . f50ce) (string-ci-hash . f50cd) (string-hash . f50cc) (equal-hash . f50cb) (hashtable-equivalence-function . f50ca) (make-hashtable . f50c9) (hashtable-hash-function . f50c8) (make-eqv-hashtable . f50c7) (make-eq-hashtable . f50c6) (hashtable? . f50c5) (hashtable-update! . f50c4) (hashtable-size . f50c3) (hashtable-set! . f50c2) (hashtable-ref . f50c1) (hashtable-mutable? . f50c0) (hashtable-keys . f50bf) (hashtable-entries . f50be) (hashtable-delete! . f50bd) (hashtable-copy . f50bc) (hashtable-contains? . f50bb) (hashtable-clear! . f50ba) (call-with-output-file . f50b9) (call-with-input-file . f50b8) (write-char . f50b7) (write . f50b6) (with-output-to-file . f50b5) (with-input-from-file . f50b4) (read-char . f50b3) (read . f50b2) (peek-char . f50b1) (open-output-file . f50b0) (open-input-file . f50af) (newline . f50ae) (display . f50ad) (close-output-port . f50ac) (close-input-port . f50ab) (eof-object? . f50aa) (eof-object . f50a9) (current-error-port . f50a8) (current-output-port . f50a7) (current-input-port . f50a6) (output-port? . f50a5) (input-port? . f50a4) (utf-8-codec . f50a3) (utf-16-codec . f50a2) (transcoder-error-handling-mode . f50a1) (transcoder-eol-style . f50a0) (transcoder-codec . f509f) (transcoded-port . f509e) (textual-port? . f509d) (string->bytevector . f509c) (standard-output-port . f509b) (standard-input-port . f509a) (standard-error-port . f5099) (set-port-position! . f5098) (put-u8 . f5097) (put-string . f5096) (put-datum . f5095) (put-char . f5094) (put-bytevector . f5093) (port? . f5092) (port-transcoder . f5091) (port-position . f5090) (port-has-set-port-position!? . f508f) (port-has-port-position? . f508e) (port-eof? . f508d) (output-port-buffer-mode . f508c) (open-string-output-port . f508b) (open-string-input-port . f508a) (open-file-output-port . f5089) (open-file-input/output-port . f5088) (open-file-input-port . f5087) (open-bytevector-output-port . f5086) (open-bytevector-input-port . f5085) (native-transcoder . f5084) (native-eol-style . f5083) (make-transcoder . f5082) (latin-1-codec . f5081) (make-i/o-write-error . f5080) (make-i/o-read-error . f507f) (make-i/o-port-error . f507e) (make-i/o-invalid-position-error . f507d) (make-i/o-filename-error . f507c) (make-i/o-file-protection-error . f507b) (make-i/o-file-is-read-only-error . f507a) (make-i/o-file-does-not-exist-error . f5079) (make-i/o-file-already-exists-error . f5078) (make-i/o-error . f5077) (make-i/o-encoding-error . f5076) (make-i/o-decoding-error . f5075) (make-custom-textual-output-port . f5074) (make-custom-textual-input/output-port . f5073) (make-custom-textual-input-port . f5072) (make-custom-binary-output-port . f5071) (make-custom-binary-input/output-port . f5070) (make-custom-binary-input-port . f506f) (make-bytevector . f506e) (lookahead-u8 . f506d) (lookahead-char . f506c) (i/o-write-error? . f506b) (i/o-read-error? . f506a) (i/o-port-error? . f5069) (i/o-invalid-position-error? . f5068) (i/o-filename-error? . f5067) (i/o-file-protection-error? . f5066) (i/o-file-is-read-only-error? . f5065) (i/o-file-does-not-exist-error? . f5064) (i/o-file-already-exists-error? . f5063) (i/o-error? . f5062) (i/o-error-position . f5061) (i/o-error-port . f5060) (i/o-error-filename . f505f) (i/o-encoding-error? . f505e) (i/o-encoding-error-char . f505d) (i/o-decoding-error? . f505c) (get-u8 . f505b) (get-string-n! . f505a) (get-string-n . f5059) (get-string-all . f5058) (get-line . f5057) (get-datum . f5056) (get-char . f5055) (get-bytevector-some . f5054) (get-bytevector-n! . f5053) (get-bytevector-n . f5052) (get-bytevector-all . f5051) (flush-output-port . f5050) (close-port . f504f) (exit . f5047) (command-line . f4cd9) (string-fill! . f5046) (string-set! . f5045) (set-cdr! . f5044) (set-car! . f5043) (remove . f5042) (remv . f5041) (remp . f5040) (remq . f503f) (partition . f503e) (memv . f503d) (memq . f503c) (memp . f503b) (member . f503a) (exists . f5039) (for-all . f5038) (fold-right . f5037) (fold-left . f5036) (find . f5035) (filter . f5034) (cons* . f5033) (assv . f5032) (assq . f5031) (assp . f5030) (assoc . f502f) (call-with-string-output-port . f502e) (call-with-port . f502d) (call-with-bytevector-output-port . f502c) (bytevector->string . f502b) (buffer-mode? . f502a) (binary-port? . f5029) (with-exception-handler . f5028) (raise-continuable . f5027) (raise . f5026) (eval . f31e0) (environment . f31d8) (make-enumeration . f5025) (enum-set=? . f5024) (enum-set-universe . f5023) (enum-set-union . f5022) (enum-set-subset? . f5021) (enum-set-projection . f5020) (enum-set-member? . f501f) (enum-set-intersection . f501e) (enum-set-indexer . f501d) (enum-set-difference . f501c) (enum-set-constructor . f501b) (enum-set-complement . f501a) (enum-set->list . f5019) (who-condition? . f5018) (warning? . f5017) (violation? . f5016) (undefined-violation? . f5015) (syntax-violation? . f5014) (syntax-violation-subform . f5013) (syntax-violation-form . f5012) (syntax-violation . f3200) (simple-conditions . f5011) (serious-condition? . f5010) (non-continuable-violation? . f500f) (message-condition? . f500e) (make-who-condition . f500d) (make-warning . f500c) (make-violation . f500b) (make-undefined-violation . f500a) (make-syntax-violation . f5009) (make-serious-condition . f5008) (make-non-continuable-violation . f5007) (make-message-condition . f5006) (make-lexical-violation . f5005) (make-irritants-condition . f5004) (make-implementation-restriction-violation . f5003) (make-error . f5002) (make-assertion-violation . f5001) (lexical-violation? . f5000) (irritants-condition? . f4fff) (implementation-restriction-violation? . f4ffe) (error? . f4ffd) (condition-who . f4ffc) (condition-predicate . f4ffb) (condition-message . f4ffa) (condition-irritants . f4ff9) (condition-accessor . f4ff8) (condition . f4ff7) (assertion-violation? . f4ff6) (condition? . f4ff5) (utf32->string . f4ff4) (utf16->string . f4ff3) (utf8->string . f4ff2) (uint-list->bytevector . f4ff1) (u8-list->bytevector . f4ff0) (string->utf8 . f4fef) (string->utf32 . f4fee) (string->utf16 . f4fed) (sint-list->bytevector . f4fec) (native-endianness . f4feb) (bytevector? . f4fea) (bytevector=? . f4fe9) (bytevector-uint-set! . f4fe8) (bytevector-uint-ref . f4fe7) (bytevector-u8-set! . f4fe6) (bytevector-u8-ref . f4fe5) (bytevector-u64-set! . f4fe4) (bytevector-u64-ref . f4fe3) (bytevector-u64-native-set! . f4fe2) (bytevector-u64-native-ref . f4fe1) (bytevector-u32-set! . f4fe0) (bytevector-u32-ref . f4fdf) (bytevector-u32-native-set! . f4fde) (bytevector-u32-native-ref . f4fdd) (bytevector-u16-set! . f4fdc) (bytevector-u16-ref . f4fdb) (bytevector-u16-native-set! . f4fda) (bytevector-u16-native-ref . f4fd9) (bytevector-sint-set! . f4fd8) (bytevector-sint-ref . f4fd7) (bytevector-s8-set! . f4fd6) (bytevector-s8-ref . f4fd5) (bytevector-s64-set! . f4fd4) (bytevector-s64-ref . f4fd3) (bytevector-s64-native-set! . f4fd2) (bytevector-s64-native-ref . f4fd1) (bytevector-s32-set! . f4fd0) (bytevector-s32-ref . f4fcf) (bytevector-s32-native-set! . f4fce) (bytevector-s32-native-ref . f4fcd) (bytevector-s16-set! . f4fcc) (bytevector-s16-ref . f4fcb) (bytevector-s16-native-set! . f4fca) (bytevector-s16-native-ref . f4fc9) (bytevector-length . f4fc8) (bytevector-ieee-single-ref . f4fc7) (bytevector-ieee-single-set! . f4fc6) (bytevector-ieee-single-native-set! . f4fc5) (bytevector-ieee-single-native-ref . f4fc4) (bytevector-ieee-double-set! . f4fc3) (bytevector-ieee-double-ref . f4fc2) (bytevector-ieee-double-native-set! . f4fc1) (bytevector-ieee-double-native-ref . f4fc0) (bytevector-fill! . f4fbf) (bytevector-copy! . f4fbe) (bytevector-copy . f4fbd) (bytevector->uint-list . f4fbc) (bytevector->u8-list . f4fbb) (bytevector->sint-list . f4fba) (no-nans-violation? . f4fb9) (no-infinities-violation? . f4fb8) (make-no-nans-violation . f4fb7) (make-no-infinities-violation . f4fb6) (real->flonum . f4fb5) (flzero? . f4fb4) (fltruncate . f4fb3) (fltan . f4fb2) (flsqrt . f4fb1) (flsin . f4fb0) (flround . f4faf) (flpositive? . f4fae) (flonum? . f4fad) (flodd? . f4fac) (flnumerator . f4fab) (flnegative? . f4faa) (flnan? . f4fa9) (flmod0 . f4fa8) (flmod . f4fa7) (flmin . f4fa6) (flmax . f4fa5) (fllog . f4fa4) (flinteger? . f4fa3) (flinfinite? . f4fa2) (flfloor . f4fa1) (flfinite? . f4fa0) (flexpt . f4f9f) (flexp . f4f9e) (fleven? . f4f9d) (fldiv0-and-mod0 . f4f9c) (fldiv0 . f4f9b) (fldiv-and-mod . f4f9a) (fldiv . f4f99) (fldenominator . f4f98) (flcos . f4f97) (flceiling . f4f96) (flatan . f4f95) (flasin . f4f94) (flacos . f4f93) (flabs . f4f92) (fl>? . f4f91) (fl>=? . f4f90) (fl=? . f4f8f) (fl<? . f4f8e) (fl<=? . f4f8d) (fl/ . f4f8c) (fl- . f4f8b) (fl+ . f4f8a) (fl* . f4f89) (fixnum->flonum . f4f88) (fxzero? . f4f87) (fxxor . f4f86) (fxrotate-bit-field . f4f85) (fxreverse-bit-field . f4f84) (fxpositive? . f4f83) (fxodd? . f4f82) (fxnot . f4f81) (fxnegative? . f4f80) (fxmod0 . f4f7f) (fxmod . f4f7e) (fxmin . f4f7d) (fxmax . f4f7c) (fxlength . f4f7b) (fxior . f4f7a) (fxif . f4f79) (fxfirst-bit-set . f4f78) (fxeven? . f4f77) (fxdiv0-and-mod0 . f4f76) (fxdiv0 . f4f75) (fxdiv-and-mod . f4f74) (fxdiv . f4f73) (fxcopy-bit-field . f4f72) (fxcopy-bit . f4f71) (fxbit-set? . f4f70) (fxbit-field . f4f6f) (fxbit-count . f4f6e) (fxarithmetic-shift-right . f4f6d) (fxarithmetic-shift-left . f4f6c) (fxarithmetic-shift . f4f6b) (fxand . f4f6a) (fx>? . f4f69) (fx>=? . f4f68) (fx=? . f4f67) (fx<? . f4f66) (fx<=? . f4f65) (fx-/carry . f4f64) (fx- . f4f63) (fx+/carry . f4f62) (fx+ . f4f61) (fx*/carry . f4f60) (fx* . f4f5f) (greatest-fixnum . f4f5e) (least-fixnum . f4f5d) (fixnum-width . f4f5c) (fixnum? . f4f5b) (bitwise-rotate-bit-field . f4f5a) (bitwise-reverse-bit-field . f4f59) (bitwise-length . f4f58) (bitwise-if . f4f57) (bitwise-first-bit-set . f4f56) (bitwise-copy-bit-field . f4f55) (bitwise-copy-bit . f4f54) (bitwise-bit-set? . f4f53) (bitwise-bit-field . f4f52) (bitwise-bit-count . f4f51) (bitwise-xor . f4f50) (bitwise-ior . f4f4f) (bitwise-and . f4f4e) (bitwise-not . f4f4d) (bitwise-arithmetic-shift-right . f4f4c) (bitwise-arithmetic-shift-left . f4f4b) (bitwise-arithmetic-shift . f4f4a) (zero? . f4f49) (vector? . f4f48) (vector-set! . f4f47) (vector-ref . f4f46) (vector-map . f4f45) (vector-length . f4f44) (vector-for-each . f4f43) (vector-fill! . f4f42) (vector->list . f4f41) (vector . f4f40) (values . f4f3f) (truncate . f4f3e) (tan . f4f3d) (symbol? . f4f3c) (symbol=? . f4f3b) (symbol->string . f4f3a) (substring . f4f39) (string? . f4f38) (string>? . f4f37) (string>=? . f4f36) (string=? . f4f35) (string<? . f4f34) (string<=? . f4f33) (string-ref . f4f32) (string-length . f4f31) (string-for-each . f4f30) (string-copy . f4f2f) (string-append . f4f2e) (string->symbol . f4f2d) (string->number . f4f2c) (string->list . f4f2b) (string . f4f2a) (sqrt . f4f29) (sin . f4f28) (round . f4f27) (reverse . f4f26) (real? . f4f25) (real-valued? . f4f24) (real-part . f4f23) (rationalize . f4f22) (rational? . f4f21) (rational-valued? . f4f20) (procedure? . f4f1f) (positive? . f4f1e) (pair? . f4f1d) (odd? . f4f1c) (numerator . f4f1b) (number? . f4f1a) (number->string . f4f19) (null? . f4f18) (not . f4f17) (negative? . f4f16) (nan? . f4f15) (min . f4f14) (max . f4f13) (map . f4f12) (make-vector . f4f11) (make-string . f4f10) (make-rectangular . f4f0f) (make-polar . f4f0e) (magnitude . f4f0d) (log . f4f0c) (list? . f4f0b) (list-tail . f4f0a) (list-ref . f4f09) (list->vector . f4f08) (list->string . f4f07) (list . f4f06) (length . f4f05) (lcm . f4f04) (integer? . f4f03) (integer-valued? . f4f02) (integer->char . f4f01) (infinite? . f4f00) (inexact? . f4eff) (inexact . f4efe) (imag-part . f4efd) (gcd . f4efc) (for-each . f4efb) (floor . f4efa) (finite? . f4ef9) (expt . f4ef8) (exp . f4ef7) (exact? . f4ef6) (exact-integer-sqrt . f4ef5) (exact . f4ef4) (even? . f4ef3) (error . f4ef2) (eqv? . f4ef1) (equal? . f4ef0) (eq? . f4eef) (dynamic-wind . f4eee) (div0-and-mod0 . f4eed) (mod0 . f4eec) (div0 . f4eeb) (div-and-mod . f4eea) (mod . f4ee9) (div . f4ee8) (denominator . f4ee7) (cos . f4ee6) (cons . f4ee5) (complex? . f4ee4) (char? . f4ee3) (char>? . f4ee2) (char>=? . f4ee1) (char=? . f4ee0) (char<? . f4edf) (char<=? . f4ede) (char->integer . f4edd) (ceiling . f4edc) (call-with-values . f4edb) (call/cc . f4eda) (call-with-current-continuation . f4ed9) (cddddr . f4ed8) (cdddar . f4ed7) (cddadr . f4ed6) (cddaar . f4ed5) (cdaddr . f4ed4) (cdadar . f4ed3) (cdaadr . f4ed2) (cdaaar . f4ed1) (cadddr . f4ed0) (caddar . f4ecf) (cadadr . f4ece) (cadaar . f4ecd) (caaddr . f4ecc) (caadar . f4ecb) (caaadr . f4eca) (caaaar . f4ec9) (cdddr . f4ec8) (cddar . f4ec7) (cdadr . f4ec6) (cdaar . f4ec5) (caddr . f4ec4) (cadar . f4ec3) (caadr . f4ec2) (caaar . f4ec1) (cddr . f4ec0) (cdar . f4ebf) (cadr . f4ebe) (caar . f4ebd) (cdr . f4ebc) (car . f4ebb) (boolean? . f4eba) (boolean=? . f4eb9) (atan . f4eb8) (assertion-violation . f4eb7) (asin . f4eb6) (apply . f4eb5) (append . f4eb4) (angle . f4eb3) (acos . f4eb2) (abs . f4eb1) (/ . f4eb0) (* . f4eaf) (- . f4eae) (+ . f4ead) (>= . f4eac) (> . f4eab) (= . f4eaa) (<= . f4ea9) (< . f4ea8) (library . f4ea7) (&no-nans . f4ea6) (&no-infinities . f4ea5) (&i/o-encoding . f4ea4) (&i/o-decoding . f4ea3) (&i/o-port . f4ea2) (&i/o-file-does-not-exist . f4ea1) (&i/o-file-already-exists . f4ea0) (&i/o-file-is-read-only . f4e9f) (&i/o-file-protection . f4e9e) (&i/o-filename . f4e9d) (&i/o-invalid-position . f4e9c) (&i/o-write . f4e9b) (&i/o-read . f4e9a) (&i/o . f4e99) (&undefined . f4e98) (&syntax . f4e97) (&lexical . f4e96) (&implementation-restriction . f4e95) (&non-continuable . f4e94) (&who . f4e93) (&irritants . f4e92) (&assertion . f4e91) (&violation . f4e90) (&error . f4e8f) (&serious . f4e8e) (&warning . f4e8d) (&message . f4e8c) (&condition . f4e8b) (define-condition-type . f4e8a) (define-enumeration . f4e89) (define-record-type . f4e88) (parent-rtd . f4e87) (nongenerative . f4e86) (opaque . f4e85) (sealed . f4e84) (protocol . f4e83) (parent . f4e82) (immutable . f4e81) (mutable . f4e80) (fields . f4e7f) (error-handling-mode . f4e7e) (file-options . f4e7d) (buffer-mode . f4e7c) (eol-style . f4e7b) (guard . f4e7a) (unsyntax-splicing . f4e77) (unsyntax . f4e76) (unquote-splicing . f4e75) (unquote . f4e74) (_ . f4e73) (else . f4e72) (=> . f4e71) (... . f4e70) (assert . f4e6f) (endianness . f4e6e) (time . f4e6c) (do . f4e6b) (cond . f4e6a) (let* . f4e69) (let*-values . f4e68) (let-values . f4e67) (identifier-syntax . f4e66) (with-syntax . f4e65) (quasisyntax . f4e64) (quasiquote . f4e63) (syntax-rules . f4e62) (include . f4e61) (record-constructor-descriptor . f4e5f) (record-type-descriptor . f4e5e) (case . f4e5d) (unless . f4e5b) (when . f4e5a) (or . f4e59) (and . f4e58) (if . f4e57) (let . f4e56) (letrec* . f4e55) (letrec . f4e54) (case-lambda . f4e52) (lambda . f4e51) (syntax . f4e50) (syntax-case . f4e4f) (quote . f4e4e) (letrec-syntax . f4e4c) (let-syntax . f4e4b) (set! . f4e4a) (import . f4e49) (begin . f4e48) (define-syntax . f4e46) (define . f4e45)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f51ed '(psyntax null-environment-5) '() '() '() '() '((make-promise . f5048) (unquote-splicing . f4e75) (unquote . f4e74) (_ . f4e73) (else . f4e72) (=> . f4e71) (... . f4e70) (delay . f4e6d) (do . f4e6b) (cond . f4e6a) (let* . f4e69) (quasiquote . f4e63) (syntax-rules . f4e62) (case . f4e5d) (or . f4e59) (and . f4e58) (if . f4e57) (let . f4e56) (letrec . f4e54) (lambda . f4e51) (quote . f4e4e) (letrec-syntax . f4e4c) (let-syntax . f4e4b) (set! . f4e4a) (begin . f4e48) (define-syntax . f4e46) (define . f4e45)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f51ee '(psyntax scheme-report-environment-5) '() '() '() '() '((string-ci>? . f50f9) (string-ci>=? . f50f8) (string-ci=? . f50f7) (string-ci<? . f50f6) (string-ci<=? . f50f5) (char-whitespace? . f50f4) (char-upper-case? . f50f3) (char-numeric? . f50f1) (char-lower-case? . f50f0) (char-upcase . f50ee) (char-downcase . f50eb) (char-ci>? . f50ea) (char-ci>=? . f50e9) (char-ci=? . f50e8) (char-ci<? . f50e7) (char-ci<=? . f50e6) (char-alphabetic? . f50e5) (call-with-output-file . f50b9) (call-with-input-file . f50b8) (write-char . f50b7) (write . f50b6) (with-output-to-file . f50b5) (with-input-from-file . f50b4) (read-char . f50b3) (read . f50b2) (peek-char . f50b1) (open-output-file . f50b0) (open-input-file . f50af) (newline . f50ae) (display . f50ad) (close-output-port . f50ac) (close-input-port . f50ab) (eof-object . f50a9) (current-output-port . f50a7) (current-input-port . f50a6) (output-port? . f50a5) (input-port? . f50a4) (scheme-report-environment . f31dc) (quotient . f504e) (null-environment . f31da) (remainder . f504d) (modulo . f504c) (inexact->exact . f504b) (force . f504a) (exact->inexact . f5049) (make-promise . f5048) (string-fill! . f5046) (string-set! . f5045) (set-cdr! . f5044) (set-car! . f5043) (memv . f503d) (memq . f503c) (member . f503a) (assv . f5032) (assq . f5031) (assoc . f502f) (eval . f31e0) (zero? . f4f49) (vector? . f4f48) (vector-set! . f4f47) (vector-ref . f4f46) (vector-length . f4f44) (vector-fill! . f4f42) (vector->list . f4f41) (vector . f4f40) (values . f4f3f) (truncate . f4f3e) (tan . f4f3d) (symbol? . f4f3c) (symbol->string . f4f3a) (substring . f4f39) (string? . f4f38) (string>? . f4f37) (string>=? . f4f36) (string=? . f4f35) (string<? . f4f34) (string<=? . f4f33) (string-ref . f4f32) (string-length . f4f31) (string-copy . f4f2f) (string-append . f4f2e) (string->symbol . f4f2d) (string->number . f4f2c) (string->list . f4f2b) (string . f4f2a) (sqrt . f4f29) (sin . f4f28) (round . f4f27) (reverse . f4f26) (real? . f4f25) (real-part . f4f23) (rationalize . f4f22) (rational? . f4f21) (procedure? . f4f1f) (positive? . f4f1e) (pair? . f4f1d) (odd? . f4f1c) (numerator . f4f1b) (number? . f4f1a) (number->string . f4f19) (not . f4f17) (negative? . f4f16) (min . f4f14) (max . f4f13) (map . f4f12) (make-vector . f4f11) (make-string . f4f10) (make-rectangular . f4f0f) (make-polar . f4f0e) (magnitude . f4f0d) (log . f4f0c) (list? . f4f0b) (list-tail . f4f0a) (list-ref . f4f09) (list->vector . f4f08) (list->string . f4f07) (list . f4f06) (length . f4f05) (lcm . f4f04) (integer? . f4f03) (integer->char . f4f01) (inexact? . f4eff) (imag-part . f4efd) (gcd . f4efc) (for-each . f4efb) (floor . f4efa) (expt . f4ef8) (exp . f4ef7) (exact? . f4ef6) (even? . f4ef3) (eqv? . f4ef1) (equal? . f4ef0) (eq? . f4eef) (dynamic-wind . f4eee) (denominator . f4ee7) (cos . f4ee6) (cons . f4ee5) (complex? . f4ee4) (char? . f4ee3) (char>? . f4ee2) (char>=? . f4ee1) (char=? . f4ee0) (char<? . f4edf) (char<=? . f4ede) (char->integer . f4edd) (ceiling . f4edc) (call-with-values . f4edb) (call-with-current-continuation . f4ed9) (cddddr . f4ed8) (cdddar . f4ed7) (cddadr . f4ed6) (cddaar . f4ed5) (cdaddr . f4ed4) (cdadar . f4ed3) (cdaadr . f4ed2) (cdaaar . f4ed1) (cadddr . f4ed0) (caddar . f4ecf) (cadadr . f4ece) (cadaar . f4ecd) (caaddr . f4ecc) (caadar . f4ecb) (caaadr . f4eca) (caaaar . f4ec9) (cdddr . f4ec8) (cddar . f4ec7) (cdadr . f4ec6) (cdaar . f4ec5) (caddr . f4ec4) (cadar . f4ec3) (caadr . f4ec2) (caaar . f4ec1) (cddr . f4ec0) (cdar . f4ebf) (cadr . f4ebe) (caar . f4ebd) (cdr . f4ebc) (car . f4ebb) (boolean? . f4eba) (atan . f4eb8) (asin . f4eb6) (apply . f4eb5) (append . f4eb4) (angle . f4eb3) (acos . f4eb2) (abs . f4eb1) (/ . f4eb0) (* . f4eaf) (- . f4eae) (+ . f4ead) (>= . f4eac) (> . f4eab) (= . f4eaa) (<= . f4ea9) (< . f4ea8) (unquote-splicing . f4e75) (unquote . f4e74) (else . f4e72) (=> . f4e71) (... . f4e70) (delay . f4e6d) (do . f4e6b) (cond . f4e6a) (let* . f4e69) (quasiquote . f4e63) (syntax-rules . f4e62) (case . f4e5d) (or . f4e59) (and . f4e58) (if . f4e57) (let . f4e56) (letrec . f4e54) (lambda . f4e51) (quote . f4e4e) (letrec-syntax . f4e4c) (let-syntax . f4e4b) (set! . f4e4a) (begin . f4e48) (define-syntax . f4e46) (define . f4e45)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f51ef '(psyntax modules) '() '() '() '() '((module . f4e47)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f51f0 '(chez parameters) '() '() '() '() '() '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f51f1 '(rnrs) '(6) '() '() '() '((regexp? . f51ac) (string-upcase . f5101) (string-titlecase . f5100) (string-normalize-nfkd . f50ff) (string-normalize-nfkc . f50fe) (string-normalize-nfd . f50fd) (string-normalize-nfc . f50fc) (string-foldcase . f50fb) (string-downcase . f50fa) (string-ci>? . f50f9) (string-ci>=? . f50f8) (string-ci=? . f50f7) (string-ci<? . f50f6) (string-ci<=? . f50f5) (char-whitespace? . f50f4) (char-upper-case? . f50f3) (char-title-case? . f50f2) (char-numeric? . f50f1) (char-lower-case? . f50f0) (char-general-category . f50ef) (char-upcase . f50ee) (char-titlecase . f50ed) (char-foldcase . f50ec) (char-downcase . f50eb) (char-ci>? . f50ea) (char-ci>=? . f50e9) (char-ci=? . f50e8) (char-ci<? . f50e7) (char-ci<=? . f50e6) (char-alphabetic? . f50e5) (make-variable-transformer . f2f47) (identifier? . f3202) (generate-temporaries . f31ee) (free-identifier=? . f31f0) (syntax->datum . f3206) (datum->syntax . f3204) (bound-identifier=? . f31f2) (record-type-descriptor? . f50e4) (record-predicate . f50e3) (record-mutator . f50e2) (record-constructor . f50e1) (record-accessor . f50e0) (make-record-type-descriptor . f50df) (make-record-constructor-descriptor . f50de) (record? . f50dd) (record-type-uid . f50dc) (record-type-sealed? . f50db) (record-type-parent . f50da) (record-type-opaque? . f50d9) (record-type-name . f50d8) (record-type-generative? . f50d7) (record-type-field-names . f50d6) (record-rtd . f50d5) (record-field-mutable? . f50d4) (delete-file . f50d3) (file-exists? . f50d2) (vector-sort! . f50d1) (vector-sort . f50d0) (list-sort . f50cf) (symbol-hash . f50ce) (string-ci-hash . f50cd) (string-hash . f50cc) (equal-hash . f50cb) (hashtable-equivalence-function . f50ca) (make-hashtable . f50c9) (hashtable-hash-function . f50c8) (make-eqv-hashtable . f50c7) (make-eq-hashtable . f50c6) (hashtable? . f50c5) (hashtable-update! . f50c4) (hashtable-size . f50c3) (hashtable-set! . f50c2) (hashtable-ref . f50c1) (hashtable-mutable? . f50c0) (hashtable-keys . f50bf) (hashtable-entries . f50be) (hashtable-delete! . f50bd) (hashtable-copy . f50bc) (hashtable-contains? . f50bb) (hashtable-clear! . f50ba) (call-with-output-file . f50b9) (call-with-input-file . f50b8) (write-char . f50b7) (write . f50b6) (with-output-to-file . f50b5) (with-input-from-file . f50b4) (read-char . f50b3) (read . f50b2) (peek-char . f50b1) (open-output-file . f50b0) (open-input-file . f50af) (newline . f50ae) (display . f50ad) (close-output-port . f50ac) (close-input-port . f50ab) (eof-object? . f50aa) (eof-object . f50a9) (current-error-port . f50a8) (current-output-port . f50a7) (current-input-port . f50a6) (output-port? . f50a5) (input-port? . f50a4) (utf-8-codec . f50a3) (utf-16-codec . f50a2) (transcoder-error-handling-mode . f50a1) (transcoder-eol-style . f50a0) (transcoder-codec . f509f) (transcoded-port . f509e) (textual-port? . f509d) (string->bytevector . f509c) (standard-output-port . f509b) (standard-input-port . f509a) (standard-error-port . f5099) (set-port-position! . f5098) (put-u8 . f5097) (put-string . f5096) (put-datum . f5095) (put-char . f5094) (put-bytevector . f5093) (port? . f5092) (port-transcoder . f5091) (port-position . f5090) (port-has-set-port-position!? . f508f) (port-has-port-position? . f508e) (port-eof? . f508d) (output-port-buffer-mode . f508c) (open-string-output-port . f508b) (open-string-input-port . f508a) (open-file-output-port . f5089) (open-file-input/output-port . f5088) (open-file-input-port . f5087) (open-bytevector-output-port . f5086) (open-bytevector-input-port . f5085) (native-transcoder . f5084) (native-eol-style . f5083) (make-transcoder . f5082) (latin-1-codec . f5081) (make-i/o-write-error . f5080) (make-i/o-read-error . f507f) (make-i/o-port-error . f507e) (make-i/o-invalid-position-error . f507d) (make-i/o-filename-error . f507c) (make-i/o-file-protection-error . f507b) (make-i/o-file-is-read-only-error . f507a) (make-i/o-file-does-not-exist-error . f5079) (make-i/o-file-already-exists-error . f5078) (make-i/o-error . f5077) (make-i/o-encoding-error . f5076) (make-i/o-decoding-error . f5075) (make-custom-textual-output-port . f5074) (make-custom-textual-input/output-port . f5073) (make-custom-textual-input-port . f5072) (make-custom-binary-output-port . f5071) (make-custom-binary-input/output-port . f5070) (make-custom-binary-input-port . f506f) (make-bytevector . f506e) (lookahead-u8 . f506d) (lookahead-char . f506c) (i/o-write-error? . f506b) (i/o-read-error? . f506a) (i/o-port-error? . f5069) (i/o-invalid-position-error? . f5068) (i/o-filename-error? . f5067) (i/o-file-protection-error? . f5066) (i/o-file-is-read-only-error? . f5065) (i/o-file-does-not-exist-error? . f5064) (i/o-file-already-exists-error? . f5063) (i/o-error? . f5062) (i/o-error-position . f5061) (i/o-error-port . f5060) (i/o-error-filename . f505f) (i/o-encoding-error? . f505e) (i/o-encoding-error-char . f505d) (i/o-decoding-error? . f505c) (get-u8 . f505b) (get-string-n! . f505a) (get-string-n . f5059) (get-string-all . f5058) (get-line . f5057) (get-datum . f5056) (get-char . f5055) (get-bytevector-some . f5054) (get-bytevector-n! . f5053) (get-bytevector-n . f5052) (get-bytevector-all . f5051) (flush-output-port . f5050) (close-port . f504f) (exit . f5047) (command-line . f4cd9) (remove . f5042) (remv . f5041) (remp . f5040) (remq . f503f) (partition . f503e) (memv . f503d) (memq . f503c) (memp . f503b) (member . f503a) (exists . f5039) (for-all . f5038) (fold-right . f5037) (fold-left . f5036) (find . f5035) (filter . f5034) (cons* . f5033) (assv . f5032) (assq . f5031) (assp . f5030) (assoc . f502f) (call-with-string-output-port . f502e) (call-with-port . f502d) (call-with-bytevector-output-port . f502c) (bytevector->string . f502b) (buffer-mode? . f502a) (binary-port? . f5029) (with-exception-handler . f5028) (raise-continuable . f5027) (raise . f5026) (make-enumeration . f5025) (enum-set=? . f5024) (enum-set-universe . f5023) (enum-set-union . f5022) (enum-set-subset? . f5021) (enum-set-projection . f5020) (enum-set-member? . f501f) (enum-set-intersection . f501e) (enum-set-indexer . f501d) (enum-set-difference . f501c) (enum-set-constructor . f501b) (enum-set-complement . f501a) (enum-set->list . f5019) (who-condition? . f5018) (warning? . f5017) (violation? . f5016) (undefined-violation? . f5015) (syntax-violation? . f5014) (syntax-violation-subform . f5013) (syntax-violation-form . f5012) (syntax-violation . f3200) (simple-conditions . f5011) (serious-condition? . f5010) (non-continuable-violation? . f500f) (message-condition? . f500e) (make-who-condition . f500d) (make-warning . f500c) (make-violation . f500b) (make-undefined-violation . f500a) (make-syntax-violation . f5009) (make-serious-condition . f5008) (make-non-continuable-violation . f5007) (make-message-condition . f5006) (make-lexical-violation . f5005) (make-irritants-condition . f5004) (make-implementation-restriction-violation . f5003) (make-error . f5002) (make-assertion-violation . f5001) (lexical-violation? . f5000) (irritants-condition? . f4fff) (implementation-restriction-violation? . f4ffe) (error? . f4ffd) (condition-who . f4ffc) (condition-predicate . f4ffb) (condition-message . f4ffa) (condition-irritants . f4ff9) (condition-accessor . f4ff8) (condition . f4ff7) (assertion-violation? . f4ff6) (condition? . f4ff5) (utf32->string . f4ff4) (utf16->string . f4ff3) (utf8->string . f4ff2) (uint-list->bytevector . f4ff1) (u8-list->bytevector . f4ff0) (string->utf8 . f4fef) (string->utf32 . f4fee) (string->utf16 . f4fed) (sint-list->bytevector . f4fec) (native-endianness . f4feb) (bytevector? . f4fea) (bytevector=? . f4fe9) (bytevector-uint-set! . f4fe8) (bytevector-uint-ref . f4fe7) (bytevector-u8-set! . f4fe6) (bytevector-u8-ref . f4fe5) (bytevector-u64-set! . f4fe4) (bytevector-u64-ref . f4fe3) (bytevector-u64-native-set! . f4fe2) (bytevector-u64-native-ref . f4fe1) (bytevector-u32-set! . f4fe0) (bytevector-u32-ref . f4fdf) (bytevector-u32-native-set! . f4fde) (bytevector-u32-native-ref . f4fdd) (bytevector-u16-set! . f4fdc) (bytevector-u16-ref . f4fdb) (bytevector-u16-native-set! . f4fda) (bytevector-u16-native-ref . f4fd9) (bytevector-sint-set! . f4fd8) (bytevector-sint-ref . f4fd7) (bytevector-s8-set! . f4fd6) (bytevector-s8-ref . f4fd5) (bytevector-s64-set! . f4fd4) (bytevector-s64-ref . f4fd3) (bytevector-s64-native-set! . f4fd2) (bytevector-s64-native-ref . f4fd1) (bytevector-s32-set! . f4fd0) (bytevector-s32-ref . f4fcf) (bytevector-s32-native-set! . f4fce) (bytevector-s32-native-ref . f4fcd) (bytevector-s16-set! . f4fcc) (bytevector-s16-ref . f4fcb) (bytevector-s16-native-set! . f4fca) (bytevector-s16-native-ref . f4fc9) (bytevector-length . f4fc8) (bytevector-ieee-single-ref . f4fc7) (bytevector-ieee-single-set! . f4fc6) (bytevector-ieee-single-native-set! . f4fc5) (bytevector-ieee-single-native-ref . f4fc4) (bytevector-ieee-double-set! . f4fc3) (bytevector-ieee-double-ref . f4fc2) (bytevector-ieee-double-native-set! . f4fc1) (bytevector-ieee-double-native-ref . f4fc0) (bytevector-fill! . f4fbf) (bytevector-copy! . f4fbe) (bytevector-copy . f4fbd) (bytevector->uint-list . f4fbc) (bytevector->u8-list . f4fbb) (bytevector->sint-list . f4fba) (no-nans-violation? . f4fb9) (no-infinities-violation? . f4fb8) (make-no-nans-violation . f4fb7) (make-no-infinities-violation . f4fb6) (real->flonum . f4fb5) (flzero? . f4fb4) (fltruncate . f4fb3) (fltan . f4fb2) (flsqrt . f4fb1) (flsin . f4fb0) (flround . f4faf) (flpositive? . f4fae) (flonum? . f4fad) (flodd? . f4fac) (flnumerator . f4fab) (flnegative? . f4faa) (flnan? . f4fa9) (flmod0 . f4fa8) (flmod . f4fa7) (flmin . f4fa6) (flmax . f4fa5) (fllog . f4fa4) (flinteger? . f4fa3) (flinfinite? . f4fa2) (flfloor . f4fa1) (flfinite? . f4fa0) (flexpt . f4f9f) (flexp . f4f9e) (fleven? . f4f9d) (fldiv0-and-mod0 . f4f9c) (fldiv0 . f4f9b) (fldiv-and-mod . f4f9a) (fldiv . f4f99) (fldenominator . f4f98) (flcos . f4f97) (flceiling . f4f96) (flatan . f4f95) (flasin . f4f94) (flacos . f4f93) (flabs . f4f92) (fl>? . f4f91) (fl>=? . f4f90) (fl=? . f4f8f) (fl<? . f4f8e) (fl<=? . f4f8d) (fl/ . f4f8c) (fl- . f4f8b) (fl+ . f4f8a) (fl* . f4f89) (fixnum->flonum . f4f88) (fxzero? . f4f87) (fxxor . f4f86) (fxrotate-bit-field . f4f85) (fxreverse-bit-field . f4f84) (fxpositive? . f4f83) (fxodd? . f4f82) (fxnot . f4f81) (fxnegative? . f4f80) (fxmod0 . f4f7f) (fxmod . f4f7e) (fxmin . f4f7d) (fxmax . f4f7c) (fxlength . f4f7b) (fxior . f4f7a) (fxif . f4f79) (fxfirst-bit-set . f4f78) (fxeven? . f4f77) (fxdiv0-and-mod0 . f4f76) (fxdiv0 . f4f75) (fxdiv-and-mod . f4f74) (fxdiv . f4f73) (fxcopy-bit-field . f4f72) (fxcopy-bit . f4f71) (fxbit-set? . f4f70) (fxbit-field . f4f6f) (fxbit-count . f4f6e) (fxarithmetic-shift-right . f4f6d) (fxarithmetic-shift-left . f4f6c) (fxarithmetic-shift . f4f6b) (fxand . f4f6a) (fx>? . f4f69) (fx>=? . f4f68) (fx=? . f4f67) (fx<? . f4f66) (fx<=? . f4f65) (fx-/carry . f4f64) (fx- . f4f63) (fx+/carry . f4f62) (fx+ . f4f61) (fx*/carry . f4f60) (fx* . f4f5f) (greatest-fixnum . f4f5e) (least-fixnum . f4f5d) (fixnum-width . f4f5c) (fixnum? . f4f5b) (bitwise-rotate-bit-field . f4f5a) (bitwise-reverse-bit-field . f4f59) (bitwise-length . f4f58) (bitwise-if . f4f57) (bitwise-first-bit-set . f4f56) (bitwise-copy-bit-field . f4f55) (bitwise-copy-bit . f4f54) (bitwise-bit-set? . f4f53) (bitwise-bit-field . f4f52) (bitwise-bit-count . f4f51) (bitwise-xor . f4f50) (bitwise-ior . f4f4f) (bitwise-and . f4f4e) (bitwise-not . f4f4d) (bitwise-arithmetic-shift-right . f4f4c) (bitwise-arithmetic-shift-left . f4f4b) (bitwise-arithmetic-shift . f4f4a) (zero? . f4f49) (vector? . f4f48) (vector-set! . f4f47) (vector-ref . f4f46) (vector-map . f4f45) (vector-length . f4f44) (vector-for-each . f4f43) (vector-fill! . f4f42) (vector->list . f4f41) (vector . f4f40) (values . f4f3f) (truncate . f4f3e) (tan . f4f3d) (symbol? . f4f3c) (symbol=? . f4f3b) (symbol->string . f4f3a) (substring . f4f39) (string? . f4f38) (string>? . f4f37) (string>=? . f4f36) (string=? . f4f35) (string<? . f4f34) (string<=? . f4f33) (string-ref . f4f32) (string-length . f4f31) (string-for-each . f4f30) (string-copy . f4f2f) (string-append . f4f2e) (string->symbol . f4f2d) (string->number . f4f2c) (string->list . f4f2b) (string . f4f2a) (sqrt . f4f29) (sin . f4f28) (round . f4f27) (reverse . f4f26) (real? . f4f25) (real-valued? . f4f24) (real-part . f4f23) (rationalize . f4f22) (rational? . f4f21) (rational-valued? . f4f20) (procedure? . f4f1f) (positive? . f4f1e) (pair? . f4f1d) (odd? . f4f1c) (numerator . f4f1b) (number? . f4f1a) (number->string . f4f19) (null? . f4f18) (not . f4f17) (negative? . f4f16) (nan? . f4f15) (min . f4f14) (max . f4f13) (map . f4f12) (make-vector . f4f11) (make-string . f4f10) (make-rectangular . f4f0f) (make-polar . f4f0e) (magnitude . f4f0d) (log . f4f0c) (list? . f4f0b) (list-tail . f4f0a) (list-ref . f4f09) (list->vector . f4f08) (list->string . f4f07) (list . f4f06) (length . f4f05) (lcm . f4f04) (integer? . f4f03) (integer-valued? . f4f02) (integer->char . f4f01) (infinite? . f4f00) (inexact? . f4eff) (inexact . f4efe) (imag-part . f4efd) (gcd . f4efc) (for-each . f4efb) (floor . f4efa) (finite? . f4ef9) (expt . f4ef8) (exp . f4ef7) (exact? . f4ef6) (exact-integer-sqrt . f4ef5) (exact . f4ef4) (even? . f4ef3) (error . f4ef2) (eqv? . f4ef1) (equal? . f4ef0) (eq? . f4eef) (dynamic-wind . f4eee) (div0-and-mod0 . f4eed) (mod0 . f4eec) (div0 . f4eeb) (div-and-mod . f4eea) (mod . f4ee9) (div . f4ee8) (denominator . f4ee7) (cos . f4ee6) (cons . f4ee5) (complex? . f4ee4) (char? . f4ee3) (char>? . f4ee2) (char>=? . f4ee1) (char=? . f4ee0) (char<? . f4edf) (char<=? . f4ede) (char->integer . f4edd) (ceiling . f4edc) (call-with-values . f4edb) (call/cc . f4eda) (call-with-current-continuation . f4ed9) (cddddr . f4ed8) (cdddar . f4ed7) (cddadr . f4ed6) (cddaar . f4ed5) (cdaddr . f4ed4) (cdadar . f4ed3) (cdaadr . f4ed2) (cdaaar . f4ed1) (cadddr . f4ed0) (caddar . f4ecf) (cadadr . f4ece) (cadaar . f4ecd) (caaddr . f4ecc) (caadar . f4ecb) (caaadr . f4eca) (caaaar . f4ec9) (cdddr . f4ec8) (cddar . f4ec7) (cdadr . f4ec6) (cdaar . f4ec5) (caddr . f4ec4) (cadar . f4ec3) (caadr . f4ec2) (caaar . f4ec1) (cddr . f4ec0) (cdar . f4ebf) (cadr . f4ebe) (caar . f4ebd) (cdr . f4ebc) (car . f4ebb) (boolean? . f4eba) (boolean=? . f4eb9) (atan . f4eb8) (assertion-violation . f4eb7) (asin . f4eb6) (apply . f4eb5) (append . f4eb4) (angle . f4eb3) (acos . f4eb2) (abs . f4eb1) (/ . f4eb0) (* . f4eaf) (- . f4eae) (+ . f4ead) (>= . f4eac) (> . f4eab) (= . f4eaa) (<= . f4ea9) (< . f4ea8) (&no-nans . f4ea6) (&no-infinities . f4ea5) (&i/o-encoding . f4ea4) (&i/o-decoding . f4ea3) (&i/o-port . f4ea2) (&i/o-file-does-not-exist . f4ea1) (&i/o-file-already-exists . f4ea0) (&i/o-file-is-read-only . f4e9f) (&i/o-file-protection . f4e9e) (&i/o-filename . f4e9d) (&i/o-invalid-position . f4e9c) (&i/o-write . f4e9b) (&i/o-read . f4e9a) (&i/o . f4e99) (&undefined . f4e98) (&syntax . f4e97) (&lexical . f4e96) (&implementation-restriction . f4e95) (&non-continuable . f4e94) (&who . f4e93) (&irritants . f4e92) (&assertion . f4e91) (&violation . f4e90) (&error . f4e8f) (&serious . f4e8e) (&warning . f4e8d) (&message . f4e8c) (&condition . f4e8b) (define-condition-type . f4e8a) (define-enumeration . f4e89) (define-record-type . f4e88) (parent-rtd . f4e87) (nongenerative . f4e86) (opaque . f4e85) (sealed . f4e84) (protocol . f4e83) (parent . f4e82) (immutable . f4e81) (mutable . f4e80) (fields . f4e7f) (error-handling-mode . f4e7e) (file-options . f4e7d) (buffer-mode . f4e7c) (eol-style . f4e7b) (guard . f4e7a) (unsyntax-splicing . f4e77) (unsyntax . f4e76) (unquote-splicing . f4e75) (unquote . f4e74) (_ . f4e73) (else . f4e72) (=> . f4e71) (... . f4e70) (assert . f4e6f) (endianness . f4e6e) (do . f4e6b) (cond . f4e6a) (let* . f4e69) (let*-values . f4e68) (let-values . f4e67) (identifier-syntax . f4e66) (with-syntax . f4e65) (quasisyntax . f4e64) (quasiquote . f4e63) (syntax-rules . f4e62) (record-constructor-descriptor . f4e5f) (record-type-descriptor . f4e5e) (case . f4e5d) (unless . f4e5b) (when . f4e5a) (or . f4e59) (and . f4e58) (if . f4e57) (let . f4e56) (letrec* . f4e55) (letrec . f4e54) (case-lambda . f4e52) (lambda . f4e51) (syntax . f4e50) (syntax-case . f4e4f) (quote . f4e4e) (letrec-syntax . f4e4c) (let-syntax . f4e4b) (set! . f4e4a) (begin . f4e48) (define-syntax . f4e46) (define . f4e45)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f51f2 '(rnrs r5rs) '(6) '() '() '() '((scheme-report-environment . f31dc) (quotient . f504e) (null-environment . f31da) (remainder . f504d) (modulo . f504c) (inexact->exact . f504b) (force . f504a) (exact->inexact . f5049) (make-promise . f5048) (delay . f4e6d)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f51f3 '(rnrs control) '(6) '() '() '() '((do . f4e6b) (unless . f4e5b) (when . f4e5a) (case-lambda . f4e52)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f51f4 '(rnrs eval) '(6) '() '() '() '((eval . f31e0) (environment . f31d8)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f51f5 '(rnrs mutable-pairs) '(6) '() '() '() '((set-cdr! . f5044) (set-car! . f5043)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f51f6 '(rnrs mutable-strings) '(6) '() '() '() '((string-fill! . f5046) (string-set! . f5045)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f51f7 '(rnrs programs) '(6) '() '() '() '((exit . f5047) (command-line . f4cd9)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f51f8 '(rnrs syntax-case) '(6) '() '() '() '((make-variable-transformer . f2f47) (identifier? . f3202) (generate-temporaries . f31ee) (free-identifier=? . f31f0) (syntax->datum . f3206) (datum->syntax . f3204) (bound-identifier=? . f31f2) (syntax-violation . f3200) (unsyntax-splicing . f4e77) (unsyntax . f4e76) (_ . f4e73) (... . f4e70) (with-syntax . f4e65) (quasisyntax . f4e64) (syntax . f4e50) (syntax-case . f4e4f)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f51f9 '(rnrs files) '(6) '() '() '() '((delete-file . f50d3) (file-exists? . f50d2) (make-i/o-write-error . f5080) (make-i/o-read-error . f507f) (make-i/o-port-error . f507e) (make-i/o-invalid-position-error . f507d) (make-i/o-filename-error . f507c) (make-i/o-file-protection-error . f507b) (make-i/o-file-is-read-only-error . f507a) (make-i/o-file-does-not-exist-error . f5079) (make-i/o-file-already-exists-error . f5078) (make-i/o-error . f5077) (i/o-write-error? . f506b) (i/o-read-error? . f506a) (i/o-port-error? . f5069) (i/o-invalid-position-error? . f5068) (i/o-filename-error? . f5067) (i/o-file-protection-error? . f5066) (i/o-file-is-read-only-error? . f5065) (i/o-file-does-not-exist-error? . f5064) (i/o-file-already-exists-error? . f5063) (i/o-error? . f5062) (i/o-error-position . f5061) (i/o-error-port . f5060) (i/o-error-filename . f505f) (&i/o-port . f4ea2) (&i/o-file-does-not-exist . f4ea1) (&i/o-file-already-exists . f4ea0) (&i/o-file-is-read-only . f4e9f) (&i/o-file-protection . f4e9e) (&i/o-filename . f4e9d) (&i/o-invalid-position . f4e9c) (&i/o-write . f4e9b) (&i/o-read . f4e9a) (&i/o . f4e99)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f51fa '(rnrs sorting) '(6) '() '() '() '((vector-sort! . f50d1) (vector-sort . f50d0) (list-sort . f50cf)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f51fb '(rnrs base) '(6) '() '() '() '((zero? . f4f49) (vector? . f4f48) (vector-set! . f4f47) (vector-ref . f4f46) (vector-map . f4f45) (vector-length . f4f44) (vector-for-each . f4f43) (vector-fill! . f4f42) (vector->list . f4f41) (vector . f4f40) (values . f4f3f) (truncate . f4f3e) (tan . f4f3d) (symbol? . f4f3c) (symbol=? . f4f3b) (symbol->string . f4f3a) (substring . f4f39) (string? . f4f38) (string>? . f4f37) (string>=? . f4f36) (string=? . f4f35) (string<? . f4f34) (string<=? . f4f33) (string-ref . f4f32) (string-length . f4f31) (string-for-each . f4f30) (string-copy . f4f2f) (string-append . f4f2e) (string->symbol . f4f2d) (string->number . f4f2c) (string->list . f4f2b) (string . f4f2a) (sqrt . f4f29) (sin . f4f28) (round . f4f27) (reverse . f4f26) (real? . f4f25) (real-valued? . f4f24) (real-part . f4f23) (rationalize . f4f22) (rational? . f4f21) (rational-valued? . f4f20) (procedure? . f4f1f) (positive? . f4f1e) (pair? . f4f1d) (odd? . f4f1c) (numerator . f4f1b) (number? . f4f1a) (number->string . f4f19) (null? . f4f18) (not . f4f17) (negative? . f4f16) (nan? . f4f15) (min . f4f14) (max . f4f13) (map . f4f12) (make-vector . f4f11) (make-string . f4f10) (make-rectangular . f4f0f) (make-polar . f4f0e) (magnitude . f4f0d) (log . f4f0c) (list? . f4f0b) (list-tail . f4f0a) (list-ref . f4f09) (list->vector . f4f08) (list->string . f4f07) (list . f4f06) (length . f4f05) (lcm . f4f04) (integer? . f4f03) (integer-valued? . f4f02) (integer->char . f4f01) (infinite? . f4f00) (inexact? . f4eff) (inexact . f4efe) (imag-part . f4efd) (gcd . f4efc) (for-each . f4efb) (floor . f4efa) (finite? . f4ef9) (expt . f4ef8) (exp . f4ef7) (exact? . f4ef6) (exact-integer-sqrt . f4ef5) (exact . f4ef4) (even? . f4ef3) (error . f4ef2) (eqv? . f4ef1) (equal? . f4ef0) (eq? . f4eef) (dynamic-wind . f4eee) (div0-and-mod0 . f4eed) (mod0 . f4eec) (div0 . f4eeb) (div-and-mod . f4eea) (mod . f4ee9) (div . f4ee8) (denominator . f4ee7) (cos . f4ee6) (cons . f4ee5) (complex? . f4ee4) (char? . f4ee3) (char>? . f4ee2) (char>=? . f4ee1) (char=? . f4ee0) (char<? . f4edf) (char<=? . f4ede) (char->integer . f4edd) (ceiling . f4edc) (call-with-values . f4edb) (call/cc . f4eda) (call-with-current-continuation . f4ed9) (cddddr . f4ed8) (cdddar . f4ed7) (cddadr . f4ed6) (cddaar . f4ed5) (cdaddr . f4ed4) (cdadar . f4ed3) (cdaadr . f4ed2) (cdaaar . f4ed1) (cadddr . f4ed0) (caddar . f4ecf) (cadadr . f4ece) (cadaar . f4ecd) (caaddr . f4ecc) (caadar . f4ecb) (caaadr . f4eca) (caaaar . f4ec9) (cdddr . f4ec8) (cddar . f4ec7) (cdadr . f4ec6) (cdaar . f4ec5) (caddr . f4ec4) (cadar . f4ec3) (caadr . f4ec2) (caaar . f4ec1) (cddr . f4ec0) (cdar . f4ebf) (cadr . f4ebe) (caar . f4ebd) (cdr . f4ebc) (car . f4ebb) (boolean? . f4eba) (boolean=? . f4eb9) (atan . f4eb8) (assertion-violation . f4eb7) (asin . f4eb6) (apply . f4eb5) (append . f4eb4) (angle . f4eb3) (acos . f4eb2) (abs . f4eb1) (/ . f4eb0) (* . f4eaf) (- . f4eae) (+ . f4ead) (>= . f4eac) (> . f4eab) (= . f4eaa) (<= . f4ea9) (< . f4ea8) (unquote-splicing . f4e75) (unquote . f4e74) (_ . f4e73) (else . f4e72) (=> . f4e71) (... . f4e70) (assert . f4e6f) (cond . f4e6a) (let* . f4e69) (let*-values . f4e68) (let-values . f4e67) (identifier-syntax . f4e66) (quasiquote . f4e63) (syntax-rules . f4e62) (case . f4e5d) (or . f4e59) (and . f4e58) (if . f4e57) (let . f4e56) (letrec* . f4e55) (letrec . f4e54) (lambda . f4e51) (quote . f4e4e) (letrec-syntax . f4e4c) (let-syntax . f4e4b) (set! . f4e4a) (begin . f4e48) (define-syntax . f4e46) (define . f4e45)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f51fc '(rnrs lists) '(6) '() '() '() '((remove . f5042) (remv . f5041) (remp . f5040) (remq . f503f) (partition . f503e) (memv . f503d) (memq . f503c) (memp . f503b) (member . f503a) (exists . f5039) (for-all . f5038) (fold-right . f5037) (fold-left . f5036) (find . f5035) (filter . f5034) (cons* . f5033) (assv . f5032) (assq . f5031) (assp . f5030) (assoc . f502f)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f51fd '(rnrs io simple) '(6) '() '() '() '((call-with-output-file . f50b9) (call-with-input-file . f50b8) (write-char . f50b7) (write . f50b6) (with-output-to-file . f50b5) (with-input-from-file . f50b4) (read-char . f50b3) (read . f50b2) (peek-char . f50b1) (open-output-file . f50b0) (open-input-file . f50af) (newline . f50ae) (display . f50ad) (close-output-port . f50ac) (close-input-port . f50ab) (eof-object? . f50aa) (eof-object . f50a9) (current-error-port . f50a8) (current-output-port . f50a7) (current-input-port . f50a6) (output-port? . f50a5) (input-port? . f50a4) (make-i/o-write-error . f5080) (make-i/o-read-error . f507f) (make-i/o-port-error . f507e) (make-i/o-invalid-position-error . f507d) (make-i/o-filename-error . f507c) (make-i/o-file-protection-error . f507b) (make-i/o-file-is-read-only-error . f507a) (make-i/o-file-does-not-exist-error . f5079) (make-i/o-file-already-exists-error . f5078) (make-i/o-error . f5077) (i/o-write-error? . f506b) (i/o-read-error? . f506a) (i/o-port-error? . f5069) (i/o-invalid-position-error? . f5068) (i/o-filename-error? . f5067) (i/o-file-protection-error? . f5066) (i/o-file-is-read-only-error? . f5065) (i/o-file-does-not-exist-error? . f5064) (i/o-file-already-exists-error? . f5063) (i/o-error? . f5062) (i/o-error-position . f5061) (i/o-error-port . f5060) (i/o-error-filename . f505f) (&i/o-port . f4ea2) (&i/o-file-does-not-exist . f4ea1) (&i/o-file-already-exists . f4ea0) (&i/o-file-is-read-only . f4e9f) (&i/o-file-protection . f4e9e) (&i/o-filename . f4e9d) (&i/o-invalid-position . f4e9c) (&i/o-write . f4e9b) (&i/o-read . f4e9a) (&i/o . f4e99)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f51fe '(rnrs bytevectors) '(6) '() '() '() '((make-bytevector . f506e) (utf32->string . f4ff4) (utf16->string . f4ff3) (utf8->string . f4ff2) (uint-list->bytevector . f4ff1) (u8-list->bytevector . f4ff0) (string->utf8 . f4fef) (string->utf32 . f4fee) (string->utf16 . f4fed) (sint-list->bytevector . f4fec) (native-endianness . f4feb) (bytevector? . f4fea) (bytevector=? . f4fe9) (bytevector-uint-set! . f4fe8) (bytevector-uint-ref . f4fe7) (bytevector-u8-set! . f4fe6) (bytevector-u8-ref . f4fe5) (bytevector-u64-set! . f4fe4) (bytevector-u64-ref . f4fe3) (bytevector-u64-native-set! . f4fe2) (bytevector-u64-native-ref . f4fe1) (bytevector-u32-set! . f4fe0) (bytevector-u32-ref . f4fdf) (bytevector-u32-native-set! . f4fde) (bytevector-u32-native-ref . f4fdd) (bytevector-u16-set! . f4fdc) (bytevector-u16-ref . f4fdb) (bytevector-u16-native-set! . f4fda) (bytevector-u16-native-ref . f4fd9) (bytevector-sint-set! . f4fd8) (bytevector-sint-ref . f4fd7) (bytevector-s8-set! . f4fd6) (bytevector-s8-ref . f4fd5) (bytevector-s64-set! . f4fd4) (bytevector-s64-ref . f4fd3) (bytevector-s64-native-set! . f4fd2) (bytevector-s64-native-ref . f4fd1) (bytevector-s32-set! . f4fd0) (bytevector-s32-ref . f4fcf) (bytevector-s32-native-set! . f4fce) (bytevector-s32-native-ref . f4fcd) (bytevector-s16-set! . f4fcc) (bytevector-s16-ref . f4fcb) (bytevector-s16-native-set! . f4fca) (bytevector-s16-native-ref . f4fc9) (bytevector-length . f4fc8) (bytevector-ieee-single-ref . f4fc7) (bytevector-ieee-single-set! . f4fc6) (bytevector-ieee-single-native-set! . f4fc5) (bytevector-ieee-single-native-ref . f4fc4) (bytevector-ieee-double-set! . f4fc3) (bytevector-ieee-double-ref . f4fc2) (bytevector-ieee-double-native-set! . f4fc1) (bytevector-ieee-double-native-ref . f4fc0) (bytevector-fill! . f4fbf) (bytevector-copy! . f4fbe) (bytevector-copy . f4fbd) (bytevector->uint-list . f4fbc) (bytevector->u8-list . f4fbb) (bytevector->sint-list . f4fba) (endianness . f4e6e)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f51ff '(rnrs unicode) '(6) '() '() '() '((string-upcase . f5101) (string-titlecase . f5100) (string-normalize-nfkd . f50ff) (string-normalize-nfkc . f50fe) (string-normalize-nfd . f50fd) (string-normalize-nfc . f50fc) (string-foldcase . f50fb) (string-downcase . f50fa) (string-ci>? . f50f9) (string-ci>=? . f50f8) (string-ci=? . f50f7) (string-ci<? . f50f6) (string-ci<=? . f50f5) (char-whitespace? . f50f4) (char-upper-case? . f50f3) (char-title-case? . f50f2) (char-numeric? . f50f1) (char-lower-case? . f50f0) (char-general-category . f50ef) (char-upcase . f50ee) (char-titlecase . f50ed) (char-foldcase . f50ec) (char-downcase . f50eb) (char-ci>? . f50ea) (char-ci>=? . f50e9) (char-ci=? . f50e8) (char-ci<? . f50e7) (char-ci<=? . f50e6) (char-alphabetic? . f50e5)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f5200 '(rnrs exceptions) '(6) '() '() '() '((with-exception-handler . f5028) (raise-continuable . f5027) (raise . f5026) (guard . f4e7a) (else . f4e72) (=> . f4e71)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f5201 '(rnrs arithmetic bitwise) '(6) '() '() '() '((bitwise-rotate-bit-field . f4f5a) (bitwise-reverse-bit-field . f4f59) (bitwise-length . f4f58) (bitwise-if . f4f57) (bitwise-first-bit-set . f4f56) (bitwise-copy-bit-field . f4f55) (bitwise-copy-bit . f4f54) (bitwise-bit-set? . f4f53) (bitwise-bit-field . f4f52) (bitwise-bit-count . f4f51) (bitwise-xor . f4f50) (bitwise-ior . f4f4f) (bitwise-and . f4f4e) (bitwise-not . f4f4d) (bitwise-arithmetic-shift-right . f4f4c) (bitwise-arithmetic-shift-left . f4f4b) (bitwise-arithmetic-shift . f4f4a)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f5202 '(rnrs arithmetic fixnums) '(6) '() '() '() '((fxzero? . f4f87) (fxxor . f4f86) (fxrotate-bit-field . f4f85) (fxreverse-bit-field . f4f84) (fxpositive? . f4f83) (fxodd? . f4f82) (fxnot . f4f81) (fxnegative? . f4f80) (fxmod0 . f4f7f) (fxmod . f4f7e) (fxmin . f4f7d) (fxmax . f4f7c) (fxlength . f4f7b) (fxior . f4f7a) (fxif . f4f79) (fxfirst-bit-set . f4f78) (fxeven? . f4f77) (fxdiv0-and-mod0 . f4f76) (fxdiv0 . f4f75) (fxdiv-and-mod . f4f74) (fxdiv . f4f73) (fxcopy-bit-field . f4f72) (fxcopy-bit . f4f71) (fxbit-set? . f4f70) (fxbit-field . f4f6f) (fxbit-count . f4f6e) (fxarithmetic-shift-right . f4f6d) (fxarithmetic-shift-left . f4f6c) (fxarithmetic-shift . f4f6b) (fxand . f4f6a) (fx>? . f4f69) (fx>=? . f4f68) (fx=? . f4f67) (fx<? . f4f66) (fx<=? . f4f65) (fx-/carry . f4f64) (fx- . f4f63) (fx+/carry . f4f62) (fx+ . f4f61) (fx*/carry . f4f60) (fx* . f4f5f) (greatest-fixnum . f4f5e) (least-fixnum . f4f5d) (fixnum-width . f4f5c) (fixnum? . f4f5b)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f5203 '(rnrs arithmetic flonums) '(6) '() '() '() '((no-nans-violation? . f4fb9) (no-infinities-violation? . f4fb8) (make-no-nans-violation . f4fb7) (make-no-infinities-violation . f4fb6) (real->flonum . f4fb5) (flzero? . f4fb4) (fltruncate . f4fb3) (fltan . f4fb2) (flsqrt . f4fb1) (flsin . f4fb0) (flround . f4faf) (flpositive? . f4fae) (flonum? . f4fad) (flodd? . f4fac) (flnumerator . f4fab) (flnegative? . f4faa) (flnan? . f4fa9) (flmod0 . f4fa8) (flmod . f4fa7) (flmin . f4fa6) (flmax . f4fa5) (fllog . f4fa4) (flinteger? . f4fa3) (flinfinite? . f4fa2) (flfloor . f4fa1) (flfinite? . f4fa0) (flexpt . f4f9f) (flexp . f4f9e) (fleven? . f4f9d) (fldiv0-and-mod0 . f4f9c) (fldiv0 . f4f9b) (fldiv-and-mod . f4f9a) (fldiv . f4f99) (fldenominator . f4f98) (flcos . f4f97) (flceiling . f4f96) (flatan . f4f95) (flasin . f4f94) (flacos . f4f93) (flabs . f4f92) (fl>? . f4f91) (fl>=? . f4f90) (fl=? . f4f8f) (fl<? . f4f8e) (fl<=? . f4f8d) (fl/ . f4f8c) (fl- . f4f8b) (fl+ . f4f8a) (fl* . f4f89) (fixnum->flonum . f4f88) (&no-nans . f4ea6) (&no-infinities . f4ea5)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f5204 '(rnrs hashtables) '(6) '() '() '() '((symbol-hash . f50ce) (string-ci-hash . f50cd) (string-hash . f50cc) (equal-hash . f50cb) (hashtable-equivalence-function . f50ca) (make-hashtable . f50c9) (hashtable-hash-function . f50c8) (make-eqv-hashtable . f50c7) (make-eq-hashtable . f50c6) (hashtable? . f50c5) (hashtable-update! . f50c4) (hashtable-size . f50c3) (hashtable-set! . f50c2) (hashtable-ref . f50c1) (hashtable-mutable? . f50c0) (hashtable-keys . f50bf) (hashtable-entries . f50be) (hashtable-delete! . f50bd) (hashtable-copy . f50bc) (hashtable-contains? . f50bb) (hashtable-clear! . f50ba)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f5205 '(rnrs io ports) '(6) '() '() '() '((eof-object? . f50aa) (eof-object . f50a9) (current-error-port . f50a8) (current-output-port . f50a7) (current-input-port . f50a6) (output-port? . f50a5) (input-port? . f50a4) (utf-8-codec . f50a3) (utf-16-codec . f50a2) (transcoder-error-handling-mode . f50a1) (transcoder-eol-style . f50a0) (transcoder-codec . f509f) (transcoded-port . f509e) (textual-port? . f509d) (string->bytevector . f509c) (standard-output-port . f509b) (standard-input-port . f509a) (standard-error-port . f5099) (set-port-position! . f5098) (put-u8 . f5097) (put-string . f5096) (put-datum . f5095) (put-char . f5094) (put-bytevector . f5093) (port? . f5092) (port-transcoder . f5091) (port-position . f5090) (port-has-set-port-position!? . f508f) (port-has-port-position? . f508e) (port-eof? . f508d) (output-port-buffer-mode . f508c) (open-string-output-port . f508b) (open-string-input-port . f508a) (open-file-output-port . f5089) (open-file-input/output-port . f5088) (open-file-input-port . f5087) (open-bytevector-output-port . f5086) (open-bytevector-input-port . f5085) (native-transcoder . f5084) (native-eol-style . f5083) (make-transcoder . f5082) (latin-1-codec . f5081) (make-i/o-write-error . f5080) (make-i/o-read-error . f507f) (make-i/o-port-error . f507e) (make-i/o-invalid-position-error . f507d) (make-i/o-filename-error . f507c) (make-i/o-file-protection-error . f507b) (make-i/o-file-is-read-only-error . f507a) (make-i/o-file-does-not-exist-error . f5079) (make-i/o-file-already-exists-error . f5078) (make-i/o-error . f5077) (make-i/o-encoding-error . f5076) (make-i/o-decoding-error . f5075) (make-custom-textual-output-port . f5074) (make-custom-textual-input/output-port . f5073) (make-custom-textual-input-port . f5072) (make-custom-binary-output-port . f5071) (make-custom-binary-input/output-port . f5070) (make-custom-binary-input-port . f506f) (lookahead-u8 . f506d) (lookahead-char . f506c) (i/o-write-error? . f506b) (i/o-read-error? . f506a) (i/o-port-error? . f5069) (i/o-invalid-position-error? . f5068) (i/o-filename-error? . f5067) (i/o-file-protection-error? . f5066) (i/o-file-is-read-only-error? . f5065) (i/o-file-does-not-exist-error? . f5064) (i/o-file-already-exists-error? . f5063) (i/o-error? . f5062) (i/o-error-position . f5061) (i/o-error-port . f5060) (i/o-error-filename . f505f) (i/o-encoding-error? . f505e) (i/o-encoding-error-char . f505d) (i/o-decoding-error? . f505c) (get-u8 . f505b) (get-string-n! . f505a) (get-string-n . f5059) (get-string-all . f5058) (get-line . f5057) (get-datum . f5056) (get-char . f5055) (get-bytevector-some . f5054) (get-bytevector-n! . f5053) (get-bytevector-n . f5052) (get-bytevector-all . f5051) (flush-output-port . f5050) (close-port . f504f) (call-with-string-output-port . f502e) (call-with-port . f502d) (call-with-bytevector-output-port . f502c) (bytevector->string . f502b) (buffer-mode? . f502a) (binary-port? . f5029) (&i/o-encoding . f4ea4) (&i/o-decoding . f4ea3) (&i/o-port . f4ea2) (&i/o-file-does-not-exist . f4ea1) (&i/o-file-already-exists . f4ea0) (&i/o-file-is-read-only . f4e9f) (&i/o-file-protection . f4e9e) (&i/o-filename . f4e9d) (&i/o-invalid-position . f4e9c) (&i/o-write . f4e9b) (&i/o-read . f4e9a) (&i/o . f4e99) (error-handling-mode . f4e7e) (file-options . f4e7d) (buffer-mode . f4e7c) (eol-style . f4e7b)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f5206 '(rnrs enums) '(6) '() '() '() '((make-enumeration . f5025) (enum-set=? . f5024) (enum-set-universe . f5023) (enum-set-union . f5022) (enum-set-subset? . f5021) (enum-set-projection . f5020) (enum-set-member? . f501f) (enum-set-intersection . f501e) (enum-set-indexer . f501d) (enum-set-difference . f501c) (enum-set-constructor . f501b) (enum-set-complement . f501a) (enum-set->list . f5019) (define-enumeration . f4e89)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f5207 '(rnrs conditions) '(6) '() '() '() '((who-condition? . f5018) (warning? . f5017) (violation? . f5016) (undefined-violation? . f5015) (syntax-violation? . f5014) (syntax-violation-subform . f5013) (syntax-violation-form . f5012) (syntax-violation . f3200) (simple-conditions . f5011) (serious-condition? . f5010) (non-continuable-violation? . f500f) (message-condition? . f500e) (make-who-condition . f500d) (make-warning . f500c) (make-violation . f500b) (make-undefined-violation . f500a) (make-syntax-violation . f5009) (make-serious-condition . f5008) (make-non-continuable-violation . f5007) (make-message-condition . f5006) (make-lexical-violation . f5005) (make-irritants-condition . f5004) (make-implementation-restriction-violation . f5003) (make-error . f5002) (make-assertion-violation . f5001) (lexical-violation? . f5000) (irritants-condition? . f4fff) (implementation-restriction-violation? . f4ffe) (error? . f4ffd) (condition-who . f4ffc) (condition-predicate . f4ffb) (condition-message . f4ffa) (condition-irritants . f4ff9) (condition-accessor . f4ff8) (condition . f4ff7) (assertion-violation? . f4ff6) (condition? . f4ff5) (&undefined . f4e98) (&syntax . f4e97) (&lexical . f4e96) (&implementation-restriction . f4e95) (&non-continuable . f4e94) (&who . f4e93) (&irritants . f4e92) (&assertion . f4e91) (&violation . f4e90) (&error . f4e8f) (&serious . f4e8e) (&warning . f4e8d) (&message . f4e8c) (&condition . f4e8b) (define-condition-type . f4e8a)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f5208 '(rnrs records inspection) '(6) '() '() '() '((record? . f50dd) (record-type-uid . f50dc) (record-type-sealed? . f50db) (record-type-parent . f50da) (record-type-opaque? . f50d9) (record-type-name . f50d8) (record-type-generative? . f50d7) (record-type-field-names . f50d6) (record-rtd . f50d5) (record-field-mutable? . f50d4)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f5209 '(rnrs records procedural) '(6) '() '() '() '((record-type-descriptor? . f50e4) (record-predicate . f50e3) (record-mutator . f50e2) (record-constructor . f50e1) (record-accessor . f50e0) (make-record-type-descriptor . f50df) (make-record-constructor-descriptor . f50de)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f520a '(rnrs records syntactic) '(6) '() '() '() '((define-record-type . f4e88) (parent-rtd . f4e87) (nongenerative . f4e86) (opaque . f4e85) (sealed . f4e84) (protocol . f4e83) (parent . f4e82) (immutable . f4e81) (mutable . f4e80) (fields . f4e7f) (record-constructor-descriptor . f4e5f) (record-type-descriptor . f4e5e)) '() values values '#f '#f '#t '#f) (f2d30@f2b7c@install-library 'f520b '(psyntax system $all) '() '() '() '() '((&no-nans-rcd . f51eb) (&no-nans-rtd . f51ea) (&no-infinities-rcd . f51e9) (&no-infinities-rtd . f51e8) (&i/o-encoding-rcd . f51e7) (&i/o-encoding-rtd . f51e6) (&i/o-decoding-rcd . f51e5) (&i/o-decoding-rtd . f51e4) (&i/o-port-rcd . f51e3) (&i/o-port-rtd . f51e2) (&i/o-file-does-not-exist-rcd . f51e1) (&i/o-file-does-not-exist-rtd . f51e0) (&i/o-file-already-exists-rcd . f51df) (&i/o-file-already-exists-rtd . f51de) (&i/o-file-is-read-only-rcd . f51dd) (&i/o-file-is-read-only-rtd . f51dc) (&i/o-file-protection-rcd . f51db) (&i/o-file-protection-rtd . f51da) (&i/o-filename-rcd . f51d9) (&i/o-filename-rtd . f51d8) (&i/o-invalid-position-rcd . f51d7) (&i/o-invalid-position-rtd . f51d6) (&i/o-write-rcd . f51d5) (&i/o-write-rtd . f51d4) (&i/o-read-rcd . f51d3) (&i/o-read-rtd . f51d2) (&i/o-rcd . f51d1) (&i/o-rtd . f51d0) (&undefined-rcd . f51cf) (&undefined-rtd . f51ce) (&syntax-rcd . f51cd) (&syntax-rtd . f51cc) (&lexical-rcd . f51cb) (&lexical-rtd . f51ca) (&implementation-restriction-rcd . f51c9) (&implementation-restriction-rtd . f51c8) (&non-continuable-rcd . f51c7) (&non-continuable-rtd . f51c6) (&who-rcd . f51c5) (&who-rtd . f51c4) (&irritants-rcd . f51c3) (&irritants-rtd . f51c2) (&assertion-rcd . f51c1) (&assertion-rtd . f51c0) (&violation-rcd . f51bf) (&violation-rtd . f51be) (&error-rcd . f51bd) (&error-rtd . f51bc) (&serious-rcd . f51bb) (&serious-rtd . f51ba) (&warning-rcd . f51b9) (&warning-rtd . f51b8) (&message-rcd . f51b7) (&message-rtd . f51b6) (&condition-rcd . f51b5) (&condition-rtd . f51b4) (syntax-error . f31fc) (syntax-dispatch . f311c) (pretty-print . f51b3) (eval-core . f51b2) (set-symbol-value! . f51b1) (symbol-value . f51b0) (gensym . f51af) (void . f51ae) (load . f4cdf) (interaction-environment . f320e) (char-ready? . f51ad) (regexp? . f51ac) (read-line . f51ab) (gensym-prefix-set! . f51aa) (ungensym . f51a9) (alist->eq-hash-table . f51a8) (assoc-ref . f51a7) (print . f51a6) (format . f51a5) (host-os . f51a4) (library-path . f2b5b) (standard-library-path . f51a3) (ssl-supported? . f51a2) (ssl-socket? . f51a1) (socket-sslize! . f51a0) (%monapi-name-whereis . f519f) (%monapi-message-send . f519e) (file-newer? . f519d) (stat-mtime . f519c) (write-to-file . f519b) (file->list . f519a) (file->string . f5199) (digit->integer . f5198) (call-with-string-input-port . f5197) (call-with-string-io . f5196) (string-split . f5195) (bytevector-for-each . f5194) (string->regexp . f5193) (rxmatch . f5192) (regexp-replace-all . f5191) (hashtable-fold-left . f5190) (hashtable-for-each . f518f) (mosh-cache-dir . f2945) (call-process . f518e) (local-tz-offset . f518d) (microseconds . f518c) (directory-list . f518b) (set-current-directory! . f518a) (expand-path . f5189) (current-directory . f5188) (%spawn . f5187) (%waitpid . f5186) (simple-struct-name . f5185) (simple-struct-set! . f5184) (simple-struct-ref . f5183) (make-simple-struct . f5182) (simple-struct? . f5181) (pointer-ref-c-int64 . f5180) (pointer-ref-c-int32 . f517f) (pointer-ref-c-int16 . f517e) (pointer-ref-c-int8 . f517d) (pointer-ref-c-uint64 . f517c) (pointer-ref-c-uint32 . f517b) (pointer-ref-c-uint16 . f517a) (pointer-ref-c-uint8 . f5179) (pointer-set-c-uint64! . f5178) (pointer-set-c-uint32! . f5177) (pointer-set-c-uint16! . f5176) (pointer-set-c-uint8! . f5175) (pointer-set-c-int64! . f5174) (pointer-set-c-int32! . f5173) (pointer-set-c-int16! . f5172) (pointer-set-c-int8! . f5171) (pointer-set-c-pointer! . f5170) (pointer-set-c-double! . f516f) (pointer-set-c-float! . f516e) (pointer-set-c-long-long! . f516d) (pointer-set-c-long! . f516c) (pointer-set-c-int! . f516b) (pointer-set-c-short! . f516a) (pointer-set-c-char! . f5169) (pointer-ref-c-pointer . f5168) (pointer-ref-c-double . f5167) (pointer-ref-c-float . f5166) (pointer-ref-c-unsigned-long-long . f5165) (pointer-ref-c-signed-long-long . f5164) (pointer-ref-c-unsigned-long . f5163) (pointer-ref-c-signed-long . f5162) (pointer-ref-c-unsigned-int . f5161) (pointer-ref-c-signed-int . f5160) (pointer-ref-c-unsigned-short . f515f) (pointer-ref-c-signed-short . f515e) (pointer-ref-c-unsigned-char . f515d) (pointer-ref-c-signed-char . f515c) (pointer->integer . f515b) (integer->pointer . f515a) (pointer? . f5159) (shared-errno . f5158) (%ffi-free-c-callback-trampoline . f5157) (%ffi-make-c-callback-trampoline . f5156) (%ffi-free . f5155) (%ffi-malloc . f5154) (%ffi-supported? . f5153) (%ffi-pointer->string . f5152) (%ffi-call . f5151) (%ffi-lookup . f5150) (%ffi-open . f514f) (null-terminated-utf8->string . f514e) (null-terminated-bytevector->string . f514d) (%exec . f514c) (%fork . f514b) (%pipe . f514a) (p . f5149) (open-output-string . f5148) (get-output-string . f5147) (file-stat-ctime . f5146) (file-stat-atime . f5145) (file-stat-mtime . f5144) (file-size-in-bytes . f5143) (file-writable? . f5142) (file-executable? . f5141) (file-readable? . f5140) (file-regular? . f513f) (file-symbolic-link? . f513e) (file-directory? . f513d) (create-symbolic-link . f513c) (rename-file . f513b) (delete-directory . f513a) (create-directory . f5139) (create-mosh-cache-dir . f5138) (get-environment-variables . f5137) (current-exception-handler . f5136) (get-environment-variable . f5135) (join-wraps . f5134) (id->real-label . f5133) (same-marks? . f5132) (same-marks*? . f5131) (get-timeofday . f5130) (get-command-line . f512f) (sys-display . f512e) (whereis . f512d) (register . f512c) (vm-join! . f512b) (vm-set-value! . f512a) (vm? . f5129) (main-vm? . f5128) (vm-eval . f5127) (vm-self . f5126) (vm-start! . f5125) (make-vm . f5124) (mutex-try-lock! . f5123) (mutex-unlock! . f5122) (mutex-lock! . f5121) (mutex? . f5120) (make-mutex . f511f) (condition-variable-notify-all! . f511e) (condition-variable-notify! . f511d) (condition-variable-wait! . f511c) (make-condition-variable . f511b) (write/ss . f511a) (mosh-executable-path . f5119) (make-file-options . f5118) (source-info . f5117) (make-compiler-instruction . f5116) (make-instruction . f5115) (set-source-info! . f5114) (bignum? . f5113) (fast-equal? . f5112) (fasl-read . f5111) (fasl-write . f5110) (time-usage . f510f) (os-constant . f510e) (condition-printer . f510d) (disasm . f510c) (make-parameter . f2943) (socket-port . f510b) (socket-shutdown . f510a) (socket-close . f5109) (socket-send . f5108) (socket-recv! . f5107) (socket-recv . f5106) (make-server-socket . f5105) (make-client-socket . f5104) (socket-accept . f5103) (socket? . f5102) (string-upcase . f5101) (string-titlecase . f5100) (string-normalize-nfkd . f50ff) (string-normalize-nfkc . f50fe) (string-normalize-nfd . f50fd) (string-normalize-nfc . f50fc) (string-foldcase . f50fb) (string-downcase . f50fa) (string-ci>? . f50f9) (string-ci>=? . f50f8) (string-ci=? . f50f7) (string-ci<? . f50f6) (string-ci<=? . f50f5) (char-whitespace? . f50f4) (char-upper-case? . f50f3) (char-title-case? . f50f2) (char-numeric? . f50f1) (char-lower-case? . f50f0) (char-general-category . f50ef) (char-upcase . f50ee) (char-titlecase . f50ed) (char-foldcase . f50ec) (char-downcase . f50eb) (char-ci>? . f50ea) (char-ci>=? . f50e9) (char-ci=? . f50e8) (char-ci<? . f50e7) (char-ci<=? . f50e6) (char-alphabetic? . f50e5) (make-variable-transformer . f2f47) (identifier? . f3202) (generate-temporaries . f31ee) (free-identifier=? . f31f0) (syntax->datum . f3206) (datum->syntax . f3204) (bound-identifier=? . f31f2) (record-type-descriptor? . f50e4) (record-predicate . f50e3) (record-mutator . f50e2) (record-constructor . f50e1) (record-accessor . f50e0) (make-record-type-descriptor . f50df) (make-record-constructor-descriptor . f50de) (record? . f50dd) (record-type-uid . f50dc) (record-type-sealed? . f50db) (record-type-parent . f50da) (record-type-opaque? . f50d9) (record-type-name . f50d8) (record-type-generative? . f50d7) (record-type-field-names . f50d6) (record-rtd . f50d5) (record-field-mutable? . f50d4) (delete-file . f50d3) (file-exists? . f50d2) (vector-sort! . f50d1) (vector-sort . f50d0) (list-sort . f50cf) (symbol-hash . f50ce) (string-ci-hash . f50cd) (string-hash . f50cc) (equal-hash . f50cb) (hashtable-equivalence-function . f50ca) (make-hashtable . f50c9) (hashtable-hash-function . f50c8) (make-eqv-hashtable . f50c7) (make-eq-hashtable . f50c6) (hashtable? . f50c5) (hashtable-update! . f50c4) (hashtable-size . f50c3) (hashtable-set! . f50c2) (hashtable-ref . f50c1) (hashtable-mutable? . f50c0) (hashtable-keys . f50bf) (hashtable-entries . f50be) (hashtable-delete! . f50bd) (hashtable-copy . f50bc) (hashtable-contains? . f50bb) (hashtable-clear! . f50ba) (call-with-output-file . f50b9) (call-with-input-file . f50b8) (write-char . f50b7) (write . f50b6) (with-output-to-file . f50b5) (with-input-from-file . f50b4) (read-char . f50b3) (read . f50b2) (peek-char . f50b1) (open-output-file . f50b0) (open-input-file . f50af) (newline . f50ae) (display . f50ad) (close-output-port . f50ac) (close-input-port . f50ab) (eof-object? . f50aa) (eof-object . f50a9) (current-error-port . f50a8) (current-output-port . f50a7) (current-input-port . f50a6) (output-port? . f50a5) (input-port? . f50a4) (utf-8-codec . f50a3) (utf-16-codec . f50a2) (transcoder-error-handling-mode . f50a1) (transcoder-eol-style . f50a0) (transcoder-codec . f509f) (transcoded-port . f509e) (textual-port? . f509d) (string->bytevector . f509c) (standard-output-port . f509b) (standard-input-port . f509a) (standard-error-port . f5099) (set-port-position! . f5098) (put-u8 . f5097) (put-string . f5096) (put-datum . f5095) (put-char . f5094) (put-bytevector . f5093) (port? . f5092) (port-transcoder . f5091) (port-position . f5090) (port-has-set-port-position!? . f508f) (port-has-port-position? . f508e) (port-eof? . f508d) (output-port-buffer-mode . f508c) (open-string-output-port . f508b) (open-string-input-port . f508a) (open-file-output-port . f5089) (open-file-input/output-port . f5088) (open-file-input-port . f5087) (open-bytevector-output-port . f5086) (open-bytevector-input-port . f5085) (native-transcoder . f5084) (native-eol-style . f5083) (make-transcoder . f5082) (latin-1-codec . f5081) (make-i/o-write-error . f5080) (make-i/o-read-error . f507f) (make-i/o-port-error . f507e) (make-i/o-invalid-position-error . f507d) (make-i/o-filename-error . f507c) (make-i/o-file-protection-error . f507b) (make-i/o-file-is-read-only-error . f507a) (make-i/o-file-does-not-exist-error . f5079) (make-i/o-file-already-exists-error . f5078) (make-i/o-error . f5077) (make-i/o-encoding-error . f5076) (make-i/o-decoding-error . f5075) (make-custom-textual-output-port . f5074) (make-custom-textual-input/output-port . f5073) (make-custom-textual-input-port . f5072) (make-custom-binary-output-port . f5071) (make-custom-binary-input/output-port . f5070) (make-custom-binary-input-port . f506f) (make-bytevector . f506e) (lookahead-u8 . f506d) (lookahead-char . f506c) (i/o-write-error? . f506b) (i/o-read-error? . f506a) (i/o-port-error? . f5069) (i/o-invalid-position-error? . f5068) (i/o-filename-error? . f5067) (i/o-file-protection-error? . f5066) (i/o-file-is-read-only-error? . f5065) (i/o-file-does-not-exist-error? . f5064) (i/o-file-already-exists-error? . f5063) (i/o-error? . f5062) (i/o-error-position . f5061) (i/o-error-port . f5060) (i/o-error-filename . f505f) (i/o-encoding-error? . f505e) (i/o-encoding-error-char . f505d) (i/o-decoding-error? . f505c) (get-u8 . f505b) (get-string-n! . f505a) (get-string-n . f5059) (get-string-all . f5058) (get-line . f5057) (get-datum . f5056) (get-char . f5055) (get-bytevector-some . f5054) (get-bytevector-n! . f5053) (get-bytevector-n . f5052) (get-bytevector-all . f5051) (flush-output-port . f5050) (close-port . f504f) (scheme-report-environment . f31dc) (quotient . f504e) (null-environment . f31da) (remainder . f504d) (modulo . f504c) (inexact->exact . f504b) (force . f504a) (exact->inexact . f5049) (make-promise . f5048) (exit . f5047) (command-line . f4cd9) (string-fill! . f5046) (string-set! . f5045) (set-cdr! . f5044) (set-car! . f5043) (remove . f5042) (remv . f5041) (remp . f5040) (remq . f503f) (partition . f503e) (memv . f503d) (memq . f503c) (memp . f503b) (member . f503a) (exists . f5039) (for-all . f5038) (fold-right . f5037) (fold-left . f5036) (find . f5035) (filter . f5034) (cons* . f5033) (assv . f5032) (assq . f5031) (assp . f5030) (assoc . f502f) (call-with-string-output-port . f502e) (call-with-port . f502d) (call-with-bytevector-output-port . f502c) (bytevector->string . f502b) (buffer-mode? . f502a) (binary-port? . f5029) (with-exception-handler . f5028) (raise-continuable . f5027) (raise . f5026) (eval . f31e0) (environment . f31d8) (make-enumeration . f5025) (enum-set=? . f5024) (enum-set-universe . f5023) (enum-set-union . f5022) (enum-set-subset? . f5021) (enum-set-projection . f5020) (enum-set-member? . f501f) (enum-set-intersection . f501e) (enum-set-indexer . f501d) (enum-set-difference . f501c) (enum-set-constructor . f501b) (enum-set-complement . f501a) (enum-set->list . f5019) (who-condition? . f5018) (warning? . f5017) (violation? . f5016) (undefined-violation? . f5015) (syntax-violation? . f5014) (syntax-violation-subform . f5013) (syntax-violation-form . f5012) (syntax-violation . f3200) (simple-conditions . f5011) (serious-condition? . f5010) (non-continuable-violation? . f500f) (message-condition? . f500e) (make-who-condition . f500d) (make-warning . f500c) (make-violation . f500b) (make-undefined-violation . f500a) (make-syntax-violation . f5009) (make-serious-condition . f5008) (make-non-continuable-violation . f5007) (make-message-condition . f5006) (make-lexical-violation . f5005) (make-irritants-condition . f5004) (make-implementation-restriction-violation . f5003) (make-error . f5002) (make-assertion-violation . f5001) (lexical-violation? . f5000) (irritants-condition? . f4fff) (implementation-restriction-violation? . f4ffe) (error? . f4ffd) (condition-who . f4ffc) (condition-predicate . f4ffb) (condition-message . f4ffa) (condition-irritants . f4ff9) (condition-accessor . f4ff8) (condition . f4ff7) (assertion-violation? . f4ff6) (condition? . f4ff5) (utf32->string . f4ff4) (utf16->string . f4ff3) (utf8->string . f4ff2) (uint-list->bytevector . f4ff1) (u8-list->bytevector . f4ff0) (string->utf8 . f4fef) (string->utf32 . f4fee) (string->utf16 . f4fed) (sint-list->bytevector . f4fec) (native-endianness . f4feb) (bytevector? . f4fea) (bytevector=? . f4fe9) (bytevector-uint-set! . f4fe8) (bytevector-uint-ref . f4fe7) (bytevector-u8-set! . f4fe6) (bytevector-u8-ref . f4fe5) (bytevector-u64-set! . f4fe4) (bytevector-u64-ref . f4fe3) (bytevector-u64-native-set! . f4fe2) (bytevector-u64-native-ref . f4fe1) (bytevector-u32-set! . f4fe0) (bytevector-u32-ref . f4fdf) (bytevector-u32-native-set! . f4fde) (bytevector-u32-native-ref . f4fdd) (bytevector-u16-set! . f4fdc) (bytevector-u16-ref . f4fdb) (bytevector-u16-native-set! . f4fda) (bytevector-u16-native-ref . f4fd9) (bytevector-sint-set! . f4fd8) (bytevector-sint-ref . f4fd7) (bytevector-s8-set! . f4fd6) (bytevector-s8-ref . f4fd5) (bytevector-s64-set! . f4fd4) (bytevector-s64-ref . f4fd3) (bytevector-s64-native-set! . f4fd2) (bytevector-s64-native-ref . f4fd1) (bytevector-s32-set! . f4fd0) (bytevector-s32-ref . f4fcf) (bytevector-s32-native-set! . f4fce) (bytevector-s32-native-ref . f4fcd) (bytevector-s16-set! . f4fcc) (bytevector-s16-ref . f4fcb) (bytevector-s16-native-set! . f4fca) (bytevector-s16-native-ref . f4fc9) (bytevector-length . f4fc8) (bytevector-ieee-single-ref . f4fc7) (bytevector-ieee-single-set! . f4fc6) (bytevector-ieee-single-native-set! . f4fc5) (bytevector-ieee-single-native-ref . f4fc4) (bytevector-ieee-double-set! . f4fc3) (bytevector-ieee-double-ref . f4fc2) (bytevector-ieee-double-native-set! . f4fc1) (bytevector-ieee-double-native-ref . f4fc0) (bytevector-fill! . f4fbf) (bytevector-copy! . f4fbe) (bytevector-copy . f4fbd) (bytevector->uint-list . f4fbc) (bytevector->u8-list . f4fbb) (bytevector->sint-list . f4fba) (no-nans-violation? . f4fb9) (no-infinities-violation? . f4fb8) (make-no-nans-violation . f4fb7) (make-no-infinities-violation . f4fb6) (real->flonum . f4fb5) (flzero? . f4fb4) (fltruncate . f4fb3) (fltan . f4fb2) (flsqrt . f4fb1) (flsin . f4fb0) (flround . f4faf) (flpositive? . f4fae) (flonum? . f4fad) (flodd? . f4fac) (flnumerator . f4fab) (flnegative? . f4faa) (flnan? . f4fa9) (flmod0 . f4fa8) (flmod . f4fa7) (flmin . f4fa6) (flmax . f4fa5) (fllog . f4fa4) (flinteger? . f4fa3) (flinfinite? . f4fa2) (flfloor . f4fa1) (flfinite? . f4fa0) (flexpt . f4f9f) (flexp . f4f9e) (fleven? . f4f9d) (fldiv0-and-mod0 . f4f9c) (fldiv0 . f4f9b) (fldiv-and-mod . f4f9a) (fldiv . f4f99) (fldenominator . f4f98) (flcos . f4f97) (flceiling . f4f96) (flatan . f4f95) (flasin . f4f94) (flacos . f4f93) (flabs . f4f92) (fl>? . f4f91) (fl>=? . f4f90) (fl=? . f4f8f) (fl<? . f4f8e) (fl<=? . f4f8d) (fl/ . f4f8c) (fl- . f4f8b) (fl+ . f4f8a) (fl* . f4f89) (fixnum->flonum . f4f88) (fxzero? . f4f87) (fxxor . f4f86) (fxrotate-bit-field . f4f85) (fxreverse-bit-field . f4f84) (fxpositive? . f4f83) (fxodd? . f4f82) (fxnot . f4f81) (fxnegative? . f4f80) (fxmod0 . f4f7f) (fxmod . f4f7e) (fxmin . f4f7d) (fxmax . f4f7c) (fxlength . f4f7b) (fxior . f4f7a) (fxif . f4f79) (fxfirst-bit-set . f4f78) (fxeven? . f4f77) (fxdiv0-and-mod0 . f4f76) (fxdiv0 . f4f75) (fxdiv-and-mod . f4f74) (fxdiv . f4f73) (fxcopy-bit-field . f4f72) (fxcopy-bit . f4f71) (fxbit-set? . f4f70) (fxbit-field . f4f6f) (fxbit-count . f4f6e) (fxarithmetic-shift-right . f4f6d) (fxarithmetic-shift-left . f4f6c) (fxarithmetic-shift . f4f6b) (fxand . f4f6a) (fx>? . f4f69) (fx>=? . f4f68) (fx=? . f4f67) (fx<? . f4f66) (fx<=? . f4f65) (fx-/carry . f4f64) (fx- . f4f63) (fx+/carry . f4f62) (fx+ . f4f61) (fx*/carry . f4f60) (fx* . f4f5f) (greatest-fixnum . f4f5e) (least-fixnum . f4f5d) (fixnum-width . f4f5c) (fixnum? . f4f5b) (bitwise-rotate-bit-field . f4f5a) (bitwise-reverse-bit-field . f4f59) (bitwise-length . f4f58) (bitwise-if . f4f57) (bitwise-first-bit-set . f4f56) (bitwise-copy-bit-field . f4f55) (bitwise-copy-bit . f4f54) (bitwise-bit-set? . f4f53) (bitwise-bit-field . f4f52) (bitwise-bit-count . f4f51) (bitwise-xor . f4f50) (bitwise-ior . f4f4f) (bitwise-and . f4f4e) (bitwise-not . f4f4d) (bitwise-arithmetic-shift-right . f4f4c) (bitwise-arithmetic-shift-left . f4f4b) (bitwise-arithmetic-shift . f4f4a) (zero? . f4f49) (vector? . f4f48) (vector-set! . f4f47) (vector-ref . f4f46) (vector-map . f4f45) (vector-length . f4f44) (vector-for-each . f4f43) (vector-fill! . f4f42) (vector->list . f4f41) (vector . f4f40) (values . f4f3f) (truncate . f4f3e) (tan . f4f3d) (symbol? . f4f3c) (symbol=? . f4f3b) (symbol->string . f4f3a) (substring . f4f39) (string? . f4f38) (string>? . f4f37) (string>=? . f4f36) (string=? . f4f35) (string<? . f4f34) (string<=? . f4f33) (string-ref . f4f32) (string-length . f4f31) (string-for-each . f4f30) (string-copy . f4f2f) (string-append . f4f2e) (string->symbol . f4f2d) (string->number . f4f2c) (string->list . f4f2b) (string . f4f2a) (sqrt . f4f29) (sin . f4f28) (round . f4f27) (reverse . f4f26) (real? . f4f25) (real-valued? . f4f24) (real-part . f4f23) (rationalize . f4f22) (rational? . f4f21) (rational-valued? . f4f20) (procedure? . f4f1f) (positive? . f4f1e) (pair? . f4f1d) (odd? . f4f1c) (numerator . f4f1b) (number? . f4f1a) (number->string . f4f19) (null? . f4f18) (not . f4f17) (negative? . f4f16) (nan? . f4f15) (min . f4f14) (max . f4f13) (map . f4f12) (make-vector . f4f11) (make-string . f4f10) (make-rectangular . f4f0f) (make-polar . f4f0e) (magnitude . f4f0d) (log . f4f0c) (list? . f4f0b) (list-tail . f4f0a) (list-ref . f4f09) (list->vector . f4f08) (list->string . f4f07) (list . f4f06) (length . f4f05) (lcm . f4f04) (integer? . f4f03) (integer-valued? . f4f02) (integer->char . f4f01) (infinite? . f4f00) (inexact? . f4eff) (inexact . f4efe) (imag-part . f4efd) (gcd . f4efc) (for-each . f4efb) (floor . f4efa) (finite? . f4ef9) (expt . f4ef8) (exp . f4ef7) (exact? . f4ef6) (exact-integer-sqrt . f4ef5) (exact . f4ef4) (even? . f4ef3) (error . f4ef2) (eqv? . f4ef1) (equal? . f4ef0) (eq? . f4eef) (dynamic-wind . f4eee) (div0-and-mod0 . f4eed) (mod0 . f4eec) (div0 . f4eeb) (div-and-mod . f4eea) (mod . f4ee9) (div . f4ee8) (denominator . f4ee7) (cos . f4ee6) (cons . f4ee5) (complex? . f4ee4) (char? . f4ee3) (char>? . f4ee2) (char>=? . f4ee1) (char=? . f4ee0) (char<? . f4edf) (char<=? . f4ede) (char->integer . f4edd) (ceiling . f4edc) (call-with-values . f4edb) (call/cc . f4eda) (call-with-current-continuation . f4ed9) (cddddr . f4ed8) (cdddar . f4ed7) (cddadr . f4ed6) (cddaar . f4ed5) (cdaddr . f4ed4) (cdadar . f4ed3) (cdaadr . f4ed2) (cdaaar . f4ed1) (cadddr . f4ed0) (caddar . f4ecf) (cadadr . f4ece) (cadaar . f4ecd) (caaddr . f4ecc) (caadar . f4ecb) (caaadr . f4eca) (caaaar . f4ec9) (cdddr . f4ec8) (cddar . f4ec7) (cdadr . f4ec6) (cdaar . f4ec5) (caddr . f4ec4) (cadar . f4ec3) (caadr . f4ec2) (caaar . f4ec1) (cddr . f4ec0) (cdar . f4ebf) (cadr . f4ebe) (caar . f4ebd) (cdr . f4ebc) (car . f4ebb) (boolean? . f4eba) (boolean=? . f4eb9) (atan . f4eb8) (assertion-violation . f4eb7) (assertion-error . f31fa) (asin . f4eb6) (apply . f4eb5) (append . f4eb4) (angle . f4eb3) (acos . f4eb2) (abs . f4eb1) (/ . f4eb0) (* . f4eaf) (- . f4eae) (+ . f4ead) (>= . f4eac) (> . f4eab) (= . f4eaa) (<= . f4ea9) (< . f4ea8) (library . f4ea7) (&no-nans . f4ea6) (&no-infinities . f4ea5) (&i/o-encoding . f4ea4) (&i/o-decoding . f4ea3) (&i/o-port . f4ea2) (&i/o-file-does-not-exist . f4ea1) (&i/o-file-already-exists . f4ea0) (&i/o-file-is-read-only . f4e9f) (&i/o-file-protection . f4e9e) (&i/o-filename . f4e9d) (&i/o-invalid-position . f4e9c) (&i/o-write . f4e9b) (&i/o-read . f4e9a) (&i/o . f4e99) (&undefined . f4e98) (&syntax . f4e97) (&lexical . f4e96) (&implementation-restriction . f4e95) (&non-continuable . f4e94) (&who . f4e93) (&irritants . f4e92) (&assertion . f4e91) (&violation . f4e90) (&error . f4e8f) (&serious . f4e8e) (&warning . f4e8d) (&message . f4e8c) (&condition . f4e8b) (define-condition-type . f4e8a) (define-enumeration . f4e89) (define-record-type . f4e88) (parent-rtd . f4e87) (nongenerative . f4e86) (opaque . f4e85) (sealed . f4e84) (protocol . f4e83) (parent . f4e82) (immutable . f4e81) (mutable . f4e80) (fields . f4e7f) (error-handling-mode . f4e7e) (file-options . f4e7d) (buffer-mode . f4e7c) (eol-style . f4e7b) (guard . f4e7a) (trace-define . f4e79) (trace-lambda . f4e78) (unsyntax-splicing . f4e77) (unsyntax . f4e76) (unquote-splicing . f4e75) (unquote . f4e74) (_ . f4e73) (else . f4e72) (=> . f4e71) (... . f4e70) (assert . f4e6f) (endianness . f4e6e) (delay . f4e6d) (time . f4e6c) (do . f4e6b) (cond . f4e6a) (let* . f4e69) (let*-values . f4e68) (let-values . f4e67) (identifier-syntax . f4e66) (with-syntax . f4e65) (quasisyntax . f4e64) (quasiquote . f4e63) (syntax-rules . f4e62) (include . f4e61) (define-struct . f4e60) (record-constructor-descriptor . f4e5f) (record-type-descriptor . f4e5e) (case . f4e5d) (parameterize . f4e5c) (unless . f4e5b) (when . f4e5a) (or . f4e59) (and . f4e58) (if . f4e57) (let . f4e56) (letrec* . f4e55) (letrec . f4e54) (type-descriptor . f4e53) (case-lambda . f4e52) (lambda . f4e51) (syntax . f4e50) (syntax-case . f4e4f) (quote . f4e4e) (foreign-call . f4e4d) (letrec-syntax . f4e4c) (let-syntax . f4e4b) (set! . f4e4a) (import . f4e49) (begin . f4e48) (module . f4e47) (define-syntax . f4e46) (define . f4e45)) '((f51eb core-prim . &no-nans-rcd) (f51ea core-prim . &no-nans-rtd) (f51e9 core-prim . &no-infinities-rcd) (f51e8 core-prim . &no-infinities-rtd) (f51e7 core-prim . &i/o-encoding-rcd) (f51e6 core-prim . &i/o-encoding-rtd) (f51e5 core-prim . &i/o-decoding-rcd) (f51e4 core-prim . &i/o-decoding-rtd) (f51e3 core-prim . &i/o-port-rcd) (f51e2 core-prim . &i/o-port-rtd) (f51e1 core-prim . &i/o-file-does-not-exist-rcd) (f51e0 core-prim . &i/o-file-does-not-exist-rtd) (f51df core-prim . &i/o-file-already-exists-rcd) (f51de core-prim . &i/o-file-already-exists-rtd) (f51dd core-prim . &i/o-file-is-read-only-rcd) (f51dc core-prim . &i/o-file-is-read-only-rtd) (f51db core-prim . &i/o-file-protection-rcd) (f51da core-prim . &i/o-file-protection-rtd) (f51d9 core-prim . &i/o-filename-rcd) (f51d8 core-prim . &i/o-filename-rtd) (f51d7 core-prim . &i/o-invalid-position-rcd) (f51d6 core-prim . &i/o-invalid-position-rtd) (f51d5 core-prim . &i/o-write-rcd) (f51d4 core-prim . &i/o-write-rtd) (f51d3 core-prim . &i/o-read-rcd) (f51d2 core-prim . &i/o-read-rtd) (f51d1 core-prim . &i/o-rcd) (f51d0 core-prim . &i/o-rtd) (f51cf core-prim . &undefined-rcd) (f51ce core-prim . &undefined-rtd) (f51cd core-prim . &syntax-rcd) (f51cc core-prim . &syntax-rtd) (f51cb core-prim . &lexical-rcd) (f51ca core-prim . &lexical-rtd) (f51c9 core-prim . &implementation-restriction-rcd) (f51c8 core-prim . &implementation-restriction-rtd) (f51c7 core-prim . &non-continuable-rcd) (f51c6 core-prim . &non-continuable-rtd) (f51c5 core-prim . &who-rcd) (f51c4 core-prim . &who-rtd) (f51c3 core-prim . &irritants-rcd) (f51c2 core-prim . &irritants-rtd) (f51c1 core-prim . &assertion-rcd) (f51c0 core-prim . &assertion-rtd) (f51bf core-prim . &violation-rcd) (f51be core-prim . &violation-rtd) (f51bd core-prim . &error-rcd) (f51bc core-prim . &error-rtd) (f51bb core-prim . &serious-rcd) (f51ba core-prim . &serious-rtd) (f51b9 core-prim . &warning-rcd) (f51b8 core-prim . &warning-rtd) (f51b7 core-prim . &message-rcd) (f51b6 core-prim . &message-rtd) (f51b5 core-prim . &condition-rcd) (f51b4 core-prim . &condition-rtd) (f31fc core-prim . syntax-error) (f311c core-prim . syntax-dispatch) (f51b3 core-prim . pretty-print) (f51b2 core-prim . eval-core) (f51b1 core-prim . set-symbol-value!) (f51b0 core-prim . symbol-value) (f51af core-prim . gensym) (f51ae core-prim . void) (f4cdf core-prim . load) (f320e core-prim . interaction-environment) (f51ad core-prim . char-ready?) (f51ac core-prim . regexp?) (f51ab core-prim . read-line) (f51aa core-prim . gensym-prefix-set!) (f51a9 core-prim . ungensym) (f51a8 core-prim . alist->eq-hash-table) (f51a7 core-prim . assoc-ref) (f51a6 core-prim . print) (f51a5 core-prim . format) (f51a4 core-prim . host-os) (f2b5b core-prim . library-path) (f51a3 core-prim . standard-library-path) (f51a2 core-prim . ssl-supported?) (f51a1 core-prim . ssl-socket?) (f51a0 core-prim . socket-sslize!) (f519f core-prim . %monapi-name-whereis) (f519e core-prim . %monapi-message-send) (f519d core-prim . file-newer?) (f519c core-prim . stat-mtime) (f519b core-prim . write-to-file) (f519a core-prim . file->list) (f5199 core-prim . file->string) (f5198 core-prim . digit->integer) (f5197 core-prim . call-with-string-input-port) (f5196 core-prim . call-with-string-io) (f5195 core-prim . string-split) (f5194 core-prim . bytevector-for-each) (f5193 core-prim . string->regexp) (f5192 core-prim . rxmatch) (f5191 core-prim . regexp-replace-all) (f5190 core-prim . hashtable-fold-left) (f518f core-prim . hashtable-for-each) (f2945 core-prim . mosh-cache-dir) (f518e core-prim . call-process) (f518d core-prim . local-tz-offset) (f518c core-prim . microseconds) (f518b core-prim . directory-list) (f518a core-prim . set-current-directory!) (f5189 core-prim . expand-path) (f5188 core-prim . current-directory) (f5187 core-prim . %spawn) (f5186 core-prim . %waitpid) (f5185 core-prim . simple-struct-name) (f5184 core-prim . simple-struct-set!) (f5183 core-prim . simple-struct-ref) (f5182 core-prim . make-simple-struct) (f5181 core-prim . simple-struct?) (f5180 core-prim . pointer-ref-c-int64) (f517f core-prim . pointer-ref-c-int32) (f517e core-prim . pointer-ref-c-int16) (f517d core-prim . pointer-ref-c-int8) (f517c core-prim . pointer-ref-c-uint64) (f517b core-prim . pointer-ref-c-uint32) (f517a core-prim . pointer-ref-c-uint16) (f5179 core-prim . pointer-ref-c-uint8) (f5178 core-prim . pointer-set-c-uint64!) (f5177 core-prim . pointer-set-c-uint32!) (f5176 core-prim . pointer-set-c-uint16!) (f5175 core-prim . pointer-set-c-uint8!) (f5174 core-prim . pointer-set-c-int64!) (f5173 core-prim . pointer-set-c-int32!) (f5172 core-prim . pointer-set-c-int16!) (f5171 core-prim . pointer-set-c-int8!) (f5170 core-prim . pointer-set-c-pointer!) (f516f core-prim . pointer-set-c-double!) (f516e core-prim . pointer-set-c-float!) (f516d core-prim . pointer-set-c-long-long!) (f516c core-prim . pointer-set-c-long!) (f516b core-prim . pointer-set-c-int!) (f516a core-prim . pointer-set-c-short!) (f5169 core-prim . pointer-set-c-char!) (f5168 core-prim . pointer-ref-c-pointer) (f5167 core-prim . pointer-ref-c-double) (f5166 core-prim . pointer-ref-c-float) (f5165 core-prim . pointer-ref-c-unsigned-long-long) (f5164 core-prim . pointer-ref-c-signed-long-long) (f5163 core-prim . pointer-ref-c-unsigned-long) (f5162 core-prim . pointer-ref-c-signed-long) (f5161 core-prim . pointer-ref-c-unsigned-int) (f5160 core-prim . pointer-ref-c-signed-int) (f515f core-prim . pointer-ref-c-unsigned-short) (f515e core-prim . pointer-ref-c-signed-short) (f515d core-prim . pointer-ref-c-unsigned-char) (f515c core-prim . pointer-ref-c-signed-char) (f515b core-prim . pointer->integer) (f515a core-prim . integer->pointer) (f5159 core-prim . pointer?) (f5158 core-prim . shared-errno) (f5157 core-prim . %ffi-free-c-callback-trampoline) (f5156 core-prim . %ffi-make-c-callback-trampoline) (f5155 core-prim . %ffi-free) (f5154 core-prim . %ffi-malloc) (f5153 core-prim . %ffi-supported?) (f5152 core-prim . %ffi-pointer->string) (f5151 core-prim . %ffi-call) (f5150 core-prim . %ffi-lookup) (f514f core-prim . %ffi-open) (f514e core-prim . null-terminated-utf8->string) (f514d core-prim . null-terminated-bytevector->string) (f514c core-prim . %exec) (f514b core-prim . %fork) (f514a core-prim . %pipe) (f5149 core-prim . p) (f5148 core-prim . open-output-string) (f5147 core-prim . get-output-string) (f5146 core-prim . file-stat-ctime) (f5145 core-prim . file-stat-atime) (f5144 core-prim . file-stat-mtime) (f5143 core-prim . file-size-in-bytes) (f5142 core-prim . file-writable?) (f5141 core-prim . file-executable?) (f5140 core-prim . file-readable?) (f513f core-prim . file-regular?) (f513e core-prim . file-symbolic-link?) (f513d core-prim . file-directory?) (f513c core-prim . create-symbolic-link) (f513b core-prim . rename-file) (f513a core-prim . delete-directory) (f5139 core-prim . create-directory) (f5138 core-prim . create-mosh-cache-dir) (f5137 core-prim . get-environment-variables) (f5136 core-prim . current-exception-handler) (f5135 core-prim . get-environment-variable) (f5134 core-prim . join-wraps) (f5133 core-prim . id->real-label) (f5132 core-prim . same-marks?) (f5131 core-prim . same-marks*?) (f5130 core-prim . get-timeofday) (f512f core-prim . get-command-line) (f512e core-prim . sys-display) (f512d core-prim . whereis) (f512c core-prim . register) (f512b core-prim . vm-join!) (f512a core-prim . vm-set-value!) (f5129 core-prim . vm?) (f5128 core-prim . main-vm?) (f5127 core-prim . vm-eval) (f5126 core-prim . vm-self) (f5125 core-prim . vm-start!) (f5124 core-prim . make-vm) (f5123 core-prim . mutex-try-lock!) (f5122 core-prim . mutex-unlock!) (f5121 core-prim . mutex-lock!) (f5120 core-prim . mutex?) (f511f core-prim . make-mutex) (f511e core-prim . condition-variable-notify-all!) (f511d core-prim . condition-variable-notify!) (f511c core-prim . condition-variable-wait!) (f511b core-prim . make-condition-variable) (f511a core-prim . write/ss) (f5119 core-prim . mosh-executable-path) (f5118 core-prim . make-file-options) (f5117 core-prim . source-info) (f5116 core-prim . make-compiler-instruction) (f5115 core-prim . make-instruction) (f5114 core-prim . set-source-info!) (f5113 core-prim . bignum?) (f5112 core-prim . fast-equal?) (f5111 core-prim . fasl-read) (f5110 core-prim . fasl-write) (f510f core-prim . time-usage) (f510e core-prim . os-constant) (f510d core-prim . condition-printer) (f510c core-prim . disasm) (f2943 core-prim . make-parameter) (f510b core-prim . socket-port) (f510a core-prim . socket-shutdown) (f5109 core-prim . socket-close) (f5108 core-prim . socket-send) (f5107 core-prim . socket-recv!) (f5106 core-prim . socket-recv) (f5105 core-prim . make-server-socket) (f5104 core-prim . make-client-socket) (f5103 core-prim . socket-accept) (f5102 core-prim . socket?) (f5101 core-prim . string-upcase) (f5100 core-prim . string-titlecase) (f50ff core-prim . string-normalize-nfkd) (f50fe core-prim . string-normalize-nfkc) (f50fd core-prim . string-normalize-nfd) (f50fc core-prim . string-normalize-nfc) (f50fb core-prim . string-foldcase) (f50fa core-prim . string-downcase) (f50f9 core-prim . string-ci>?) (f50f8 core-prim . string-ci>=?) (f50f7 core-prim . string-ci=?) (f50f6 core-prim . string-ci<?) (f50f5 core-prim . string-ci<=?) (f50f4 core-prim . char-whitespace?) (f50f3 core-prim . char-upper-case?) (f50f2 core-prim . char-title-case?) (f50f1 core-prim . char-numeric?) (f50f0 core-prim . char-lower-case?) (f50ef core-prim . char-general-category) (f50ee core-prim . char-upcase) (f50ed core-prim . char-titlecase) (f50ec core-prim . char-foldcase) (f50eb core-prim . char-downcase) (f50ea core-prim . char-ci>?) (f50e9 core-prim . char-ci>=?) (f50e8 core-prim . char-ci=?) (f50e7 core-prim . char-ci<?) (f50e6 core-prim . char-ci<=?) (f50e5 core-prim . char-alphabetic?) (f2f47 core-prim . make-variable-transformer) (f3202 core-prim . identifier?) (f31ee core-prim . generate-temporaries) (f31f0 core-prim . free-identifier=?) (f3206 core-prim . syntax->datum) (f3204 core-prim . datum->syntax) (f31f2 core-prim . bound-identifier=?) (f50e4 core-prim . record-type-descriptor?) (f50e3 core-prim . record-predicate) (f50e2 core-prim . record-mutator) (f50e1 core-prim . record-constructor) (f50e0 core-prim . record-accessor) (f50df core-prim . make-record-type-descriptor) (f50de core-prim . make-record-constructor-descriptor) (f50dd core-prim . record?) (f50dc core-prim . record-type-uid) (f50db core-prim . record-type-sealed?) (f50da core-prim . record-type-parent) (f50d9 core-prim . record-type-opaque?) (f50d8 core-prim . record-type-name) (f50d7 core-prim . record-type-generative?) (f50d6 core-prim . record-type-field-names) (f50d5 core-prim . record-rtd) (f50d4 core-prim . record-field-mutable?) (f50d3 core-prim . delete-file) (f50d2 core-prim . file-exists?) (f50d1 core-prim . vector-sort!) (f50d0 core-prim . vector-sort) (f50cf core-prim . list-sort) (f50ce core-prim . symbol-hash) (f50cd core-prim . string-ci-hash) (f50cc core-prim . string-hash) (f50cb core-prim . equal-hash) (f50ca core-prim . hashtable-equivalence-function) (f50c9 core-prim . make-hashtable) (f50c8 core-prim . hashtable-hash-function) (f50c7 core-prim . make-eqv-hashtable) (f50c6 core-prim . make-eq-hashtable) (f50c5 core-prim . hashtable?) (f50c4 core-prim . hashtable-update!) (f50c3 core-prim . hashtable-size) (f50c2 core-prim . hashtable-set!) (f50c1 core-prim . hashtable-ref) (f50c0 core-prim . hashtable-mutable?) (f50bf core-prim . hashtable-keys) (f50be core-prim . hashtable-entries) (f50bd core-prim . hashtable-delete!) (f50bc core-prim . hashtable-copy) (f50bb core-prim . hashtable-contains?) (f50ba core-prim . hashtable-clear!) (f50b9 core-prim . call-with-output-file) (f50b8 core-prim . call-with-input-file) (f50b7 core-prim . write-char) (f50b6 core-prim . write) (f50b5 core-prim . with-output-to-file) (f50b4 core-prim . with-input-from-file) (f50b3 core-prim . read-char) (f50b2 core-prim . read) (f50b1 core-prim . peek-char) (f50b0 core-prim . open-output-file) (f50af core-prim . open-input-file) (f50ae core-prim . newline) (f50ad core-prim . display) (f50ac core-prim . close-output-port) (f50ab core-prim . close-input-port) (f50aa core-prim . eof-object?) (f50a9 core-prim . eof-object) (f50a8 core-prim . current-error-port) (f50a7 core-prim . current-output-port) (f50a6 core-prim . current-input-port) (f50a5 core-prim . output-port?) (f50a4 core-prim . input-port?) (f50a3 core-prim . utf-8-codec) (f50a2 core-prim . utf-16-codec) (f50a1 core-prim . transcoder-error-handling-mode) (f50a0 core-prim . transcoder-eol-style) (f509f core-prim . transcoder-codec) (f509e core-prim . transcoded-port) (f509d core-prim . textual-port?) (f509c core-prim . string->bytevector) (f509b core-prim . standard-output-port) (f509a core-prim . standard-input-port) (f5099 core-prim . standard-error-port) (f5098 core-prim . set-port-position!) (f5097 core-prim . put-u8) (f5096 core-prim . put-string) (f5095 core-prim . put-datum) (f5094 core-prim . put-char) (f5093 core-prim . put-bytevector) (f5092 core-prim . port?) (f5091 core-prim . port-transcoder) (f5090 core-prim . port-position) (f508f core-prim . port-has-set-port-position!?) (f508e core-prim . port-has-port-position?) (f508d core-prim . port-eof?) (f508c core-prim . output-port-buffer-mode) (f508b core-prim . open-string-output-port) (f508a core-prim . open-string-input-port) (f5089 core-prim . open-file-output-port) (f5088 core-prim . open-file-input/output-port) (f5087 core-prim . open-file-input-port) (f5086 core-prim . open-bytevector-output-port) (f5085 core-prim . open-bytevector-input-port) (f5084 core-prim . native-transcoder) (f5083 core-prim . native-eol-style) (f5082 core-prim . make-transcoder) (f5081 core-prim . latin-1-codec) (f5080 core-prim . make-i/o-write-error) (f507f core-prim . make-i/o-read-error) (f507e core-prim . make-i/o-port-error) (f507d core-prim . make-i/o-invalid-position-error) (f507c core-prim . make-i/o-filename-error) (f507b core-prim . make-i/o-file-protection-error) (f507a core-prim . make-i/o-file-is-read-only-error) (f5079 core-prim . make-i/o-file-does-not-exist-error) (f5078 core-prim . make-i/o-file-already-exists-error) (f5077 core-prim . make-i/o-error) (f5076 core-prim . make-i/o-encoding-error) (f5075 core-prim . make-i/o-decoding-error) (f5074 core-prim . make-custom-textual-output-port) (f5073 core-prim . make-custom-textual-input/output-port) (f5072 core-prim . make-custom-textual-input-port) (f5071 core-prim . make-custom-binary-output-port) (f5070 core-prim . make-custom-binary-input/output-port) (f506f core-prim . make-custom-binary-input-port) (f506e core-prim . make-bytevector) (f506d core-prim . lookahead-u8) (f506c core-prim . lookahead-char) (f506b core-prim . i/o-write-error?) (f506a core-prim . i/o-read-error?) (f5069 core-prim . i/o-port-error?) (f5068 core-prim . i/o-invalid-position-error?) (f5067 core-prim . i/o-filename-error?) (f5066 core-prim . i/o-file-protection-error?) (f5065 core-prim . i/o-file-is-read-only-error?) (f5064 core-prim . i/o-file-does-not-exist-error?) (f5063 core-prim . i/o-file-already-exists-error?) (f5062 core-prim . i/o-error?) (f5061 core-prim . i/o-error-position) (f5060 core-prim . i/o-error-port) (f505f core-prim . i/o-error-filename) (f505e core-prim . i/o-encoding-error?) (f505d core-prim . i/o-encoding-error-char) (f505c core-prim . i/o-decoding-error?) (f505b core-prim . get-u8) (f505a core-prim . get-string-n!) (f5059 core-prim . get-string-n) (f5058 core-prim . get-string-all) (f5057 core-prim . get-line) (f5056 core-prim . get-datum) (f5055 core-prim . get-char) (f5054 core-prim . get-bytevector-some) (f5053 core-prim . get-bytevector-n!) (f5052 core-prim . get-bytevector-n) (f5051 core-prim . get-bytevector-all) (f5050 core-prim . flush-output-port) (f504f core-prim . close-port) (f31dc core-prim . scheme-report-environment) (f504e core-prim . quotient) (f31da core-prim . null-environment) (f504d core-prim . remainder) (f504c core-prim . modulo) (f504b core-prim . inexact->exact) (f504a core-prim . force) (f5049 core-prim . exact->inexact) (f5048 core-prim . make-promise) (f5047 core-prim . exit) (f4cd9 core-prim . command-line) (f5046 core-prim . string-fill!) (f5045 core-prim . string-set!) (f5044 core-prim . set-cdr!) (f5043 core-prim . set-car!) (f5042 core-prim . remove) (f5041 core-prim . remv) (f5040 core-prim . remp) (f503f core-prim . remq) (f503e core-prim . partition) (f503d core-prim . memv) (f503c core-prim . memq) (f503b core-prim . memp) (f503a core-prim . member) (f5039 core-prim . exists) (f5038 core-prim . for-all) (f5037 core-prim . fold-right) (f5036 core-prim . fold-left) (f5035 core-prim . find) (f5034 core-prim . filter) (f5033 core-prim . cons*) (f5032 core-prim . assv) (f5031 core-prim . assq) (f5030 core-prim . assp) (f502f core-prim . assoc) (f502e core-prim . call-with-string-output-port) (f502d core-prim . call-with-port) (f502c core-prim . call-with-bytevector-output-port) (f502b core-prim . bytevector->string) (f502a core-prim . buffer-mode?) (f5029 core-prim . binary-port?) (f5028 core-prim . with-exception-handler) (f5027 core-prim . raise-continuable) (f5026 core-prim . raise) (f31e0 core-prim . eval) (f31d8 core-prim . environment) (f5025 core-prim . make-enumeration) (f5024 core-prim . enum-set=?) (f5023 core-prim . enum-set-universe) (f5022 core-prim . enum-set-union) (f5021 core-prim . enum-set-subset?) (f5020 core-prim . enum-set-projection) (f501f core-prim . enum-set-member?) (f501e core-prim . enum-set-intersection) (f501d core-prim . enum-set-indexer) (f501c core-prim . enum-set-difference) (f501b core-prim . enum-set-constructor) (f501a core-prim . enum-set-complement) (f5019 core-prim . enum-set->list) (f5018 core-prim . who-condition?) (f5017 core-prim . warning?) (f5016 core-prim . violation?) (f5015 core-prim . undefined-violation?) (f5014 core-prim . syntax-violation?) (f5013 core-prim . syntax-violation-subform) (f5012 core-prim . syntax-violation-form) (f3200 core-prim . syntax-violation) (f5011 core-prim . simple-conditions) (f5010 core-prim . serious-condition?) (f500f core-prim . non-continuable-violation?) (f500e core-prim . message-condition?) (f500d core-prim . make-who-condition) (f500c core-prim . make-warning) (f500b core-prim . make-violation) (f500a core-prim . make-undefined-violation) (f5009 core-prim . make-syntax-violation) (f5008 core-prim . make-serious-condition) (f5007 core-prim . make-non-continuable-violation) (f5006 core-prim . make-message-condition) (f5005 core-prim . make-lexical-violation) (f5004 core-prim . make-irritants-condition) (f5003 core-prim . make-implementation-restriction-violation) (f5002 core-prim . make-error) (f5001 core-prim . make-assertion-violation) (f5000 core-prim . lexical-violation?) (f4fff core-prim . irritants-condition?) (f4ffe core-prim . implementation-restriction-violation?) (f4ffd core-prim . error?) (f4ffc core-prim . condition-who) (f4ffb core-prim . condition-predicate) (f4ffa core-prim . condition-message) (f4ff9 core-prim . condition-irritants) (f4ff8 core-prim . condition-accessor) (f4ff7 core-prim . condition) (f4ff6 core-prim . assertion-violation?) (f4ff5 core-prim . condition?) (f4ff4 core-prim . utf32->string) (f4ff3 core-prim . utf16->string) (f4ff2 core-prim . utf8->string) (f4ff1 core-prim . uint-list->bytevector) (f4ff0 core-prim . u8-list->bytevector) (f4fef core-prim . string->utf8) (f4fee core-prim . string->utf32) (f4fed core-prim . string->utf16) (f4fec core-prim . sint-list->bytevector) (f4feb core-prim . native-endianness) (f4fea core-prim . bytevector?) (f4fe9 core-prim . bytevector=?) (f4fe8 core-prim . bytevector-uint-set!) (f4fe7 core-prim . bytevector-uint-ref) (f4fe6 core-prim . bytevector-u8-set!) (f4fe5 core-prim . bytevector-u8-ref) (f4fe4 core-prim . bytevector-u64-set!) (f4fe3 core-prim . bytevector-u64-ref) (f4fe2 core-prim . bytevector-u64-native-set!) (f4fe1 core-prim . bytevector-u64-native-ref) (f4fe0 core-prim . bytevector-u32-set!) (f4fdf core-prim . bytevector-u32-ref) (f4fde core-prim . bytevector-u32-native-set!) (f4fdd core-prim . bytevector-u32-native-ref) (f4fdc core-prim . bytevector-u16-set!) (f4fdb core-prim . bytevector-u16-ref) (f4fda core-prim . bytevector-u16-native-set!) (f4fd9 core-prim . bytevector-u16-native-ref) (f4fd8 core-prim . bytevector-sint-set!) (f4fd7 core-prim . bytevector-sint-ref) (f4fd6 core-prim . bytevector-s8-set!) (f4fd5 core-prim . bytevector-s8-ref) (f4fd4 core-prim . bytevector-s64-set!) (f4fd3 core-prim . bytevector-s64-ref) (f4fd2 core-prim . bytevector-s64-native-set!) (f4fd1 core-prim . bytevector-s64-native-ref) (f4fd0 core-prim . bytevector-s32-set!) (f4fcf core-prim . bytevector-s32-ref) (f4fce core-prim . bytevector-s32-native-set!) (f4fcd core-prim . bytevector-s32-native-ref) (f4fcc core-prim . bytevector-s16-set!) (f4fcb core-prim . bytevector-s16-ref) (f4fca core-prim . bytevector-s16-native-set!) (f4fc9 core-prim . bytevector-s16-native-ref) (f4fc8 core-prim . bytevector-length) (f4fc7 core-prim . bytevector-ieee-single-ref) (f4fc6 core-prim . bytevector-ieee-single-set!) (f4fc5 core-prim . bytevector-ieee-single-native-set!) (f4fc4 core-prim . bytevector-ieee-single-native-ref) (f4fc3 core-prim . bytevector-ieee-double-set!) (f4fc2 core-prim . bytevector-ieee-double-ref) (f4fc1 core-prim . bytevector-ieee-double-native-set!) (f4fc0 core-prim . bytevector-ieee-double-native-ref) (f4fbf core-prim . bytevector-fill!) (f4fbe core-prim . bytevector-copy!) (f4fbd core-prim . bytevector-copy) (f4fbc core-prim . bytevector->uint-list) (f4fbb core-prim . bytevector->u8-list) (f4fba core-prim . bytevector->sint-list) (f4fb9 core-prim . no-nans-violation?) (f4fb8 core-prim . no-infinities-violation?) (f4fb7 core-prim . make-no-nans-violation) (f4fb6 core-prim . make-no-infinities-violation) (f4fb5 core-prim . real->flonum) (f4fb4 core-prim . flzero?) (f4fb3 core-prim . fltruncate) (f4fb2 core-prim . fltan) (f4fb1 core-prim . flsqrt) (f4fb0 core-prim . flsin) (f4faf core-prim . flround) (f4fae core-prim . flpositive?) (f4fad core-prim . flonum?) (f4fac core-prim . flodd?) (f4fab core-prim . flnumerator) (f4faa core-prim . flnegative?) (f4fa9 core-prim . flnan?) (f4fa8 core-prim . flmod0) (f4fa7 core-prim . flmod) (f4fa6 core-prim . flmin) (f4fa5 core-prim . flmax) (f4fa4 core-prim . fllog) (f4fa3 core-prim . flinteger?) (f4fa2 core-prim . flinfinite?) (f4fa1 core-prim . flfloor) (f4fa0 core-prim . flfinite?) (f4f9f core-prim . flexpt) (f4f9e core-prim . flexp) (f4f9d core-prim . fleven?) (f4f9c core-prim . fldiv0-and-mod0) (f4f9b core-prim . fldiv0) (f4f9a core-prim . fldiv-and-mod) (f4f99 core-prim . fldiv) (f4f98 core-prim . fldenominator) (f4f97 core-prim . flcos) (f4f96 core-prim . flceiling) (f4f95 core-prim . flatan) (f4f94 core-prim . flasin) (f4f93 core-prim . flacos) (f4f92 core-prim . flabs) (f4f91 core-prim . fl>?) (f4f90 core-prim . fl>=?) (f4f8f core-prim . fl=?) (f4f8e core-prim . fl<?) (f4f8d core-prim . fl<=?) (f4f8c core-prim . fl/) (f4f8b core-prim . fl-) (f4f8a core-prim . fl+) (f4f89 core-prim . fl*) (f4f88 core-prim . fixnum->flonum) (f4f87 core-prim . fxzero?) (f4f86 core-prim . fxxor) (f4f85 core-prim . fxrotate-bit-field) (f4f84 core-prim . fxreverse-bit-field) (f4f83 core-prim . fxpositive?) (f4f82 core-prim . fxodd?) (f4f81 core-prim . fxnot) (f4f80 core-prim . fxnegative?) (f4f7f core-prim . fxmod0) (f4f7e core-prim . fxmod) (f4f7d core-prim . fxmin) (f4f7c core-prim . fxmax) (f4f7b core-prim . fxlength) (f4f7a core-prim . fxior) (f4f79 core-prim . fxif) (f4f78 core-prim . fxfirst-bit-set) (f4f77 core-prim . fxeven?) (f4f76 core-prim . fxdiv0-and-mod0) (f4f75 core-prim . fxdiv0) (f4f74 core-prim . fxdiv-and-mod) (f4f73 core-prim . fxdiv) (f4f72 core-prim . fxcopy-bit-field) (f4f71 core-prim . fxcopy-bit) (f4f70 core-prim . fxbit-set?) (f4f6f core-prim . fxbit-field) (f4f6e core-prim . fxbit-count) (f4f6d core-prim . fxarithmetic-shift-right) (f4f6c core-prim . fxarithmetic-shift-left) (f4f6b core-prim . fxarithmetic-shift) (f4f6a core-prim . fxand) (f4f69 core-prim . fx>?) (f4f68 core-prim . fx>=?) (f4f67 core-prim . fx=?) (f4f66 core-prim . fx<?) (f4f65 core-prim . fx<=?) (f4f64 core-prim . fx-/carry) (f4f63 core-prim . fx-) (f4f62 core-prim . fx+/carry) (f4f61 core-prim . fx+) (f4f60 core-prim . fx*/carry) (f4f5f core-prim . fx*) (f4f5e core-prim . greatest-fixnum) (f4f5d core-prim . least-fixnum) (f4f5c core-prim . fixnum-width) (f4f5b core-prim . fixnum?) (f4f5a core-prim . bitwise-rotate-bit-field) (f4f59 core-prim . bitwise-reverse-bit-field) (f4f58 core-prim . bitwise-length) (f4f57 core-prim . bitwise-if) (f4f56 core-prim . bitwise-first-bit-set) (f4f55 core-prim . bitwise-copy-bit-field) (f4f54 core-prim . bitwise-copy-bit) (f4f53 core-prim . bitwise-bit-set?) (f4f52 core-prim . bitwise-bit-field) (f4f51 core-prim . bitwise-bit-count) (f4f50 core-prim . bitwise-xor) (f4f4f core-prim . bitwise-ior) (f4f4e core-prim . bitwise-and) (f4f4d core-prim . bitwise-not) (f4f4c core-prim . bitwise-arithmetic-shift-right) (f4f4b core-prim . bitwise-arithmetic-shift-left) (f4f4a core-prim . bitwise-arithmetic-shift) (f4f49 core-prim . zero?) (f4f48 core-prim . vector?) (f4f47 core-prim . vector-set!) (f4f46 core-prim . vector-ref) (f4f45 core-prim . vector-map) (f4f44 core-prim . vector-length) (f4f43 core-prim . vector-for-each) (f4f42 core-prim . vector-fill!) (f4f41 core-prim . vector->list) (f4f40 core-prim . vector) (f4f3f core-prim . values) (f4f3e core-prim . truncate) (f4f3d core-prim . tan) (f4f3c core-prim . symbol?) (f4f3b core-prim . symbol=?) (f4f3a core-prim . symbol->string) (f4f39 core-prim . substring) (f4f38 core-prim . string?) (f4f37 core-prim . string>?) (f4f36 core-prim . string>=?) (f4f35 core-prim . string=?) (f4f34 core-prim . string<?) (f4f33 core-prim . string<=?) (f4f32 core-prim . string-ref) (f4f31 core-prim . string-length) (f4f30 core-prim . string-for-each) (f4f2f core-prim . string-copy) (f4f2e core-prim . string-append) (f4f2d core-prim . string->symbol) (f4f2c core-prim . string->number) (f4f2b core-prim . string->list) (f4f2a core-prim . string) (f4f29 core-prim . sqrt) (f4f28 core-prim . sin) (f4f27 core-prim . round) (f4f26 core-prim . reverse) (f4f25 core-prim . real?) (f4f24 core-prim . real-valued?) (f4f23 core-prim . real-part) (f4f22 core-prim . rationalize) (f4f21 core-prim . rational?) (f4f20 core-prim . rational-valued?) (f4f1f core-prim . procedure?) (f4f1e core-prim . positive?) (f4f1d core-prim . pair?) (f4f1c core-prim . odd?) (f4f1b core-prim . numerator) (f4f1a core-prim . number?) (f4f19 core-prim . number->string) (f4f18 core-prim . null?) (f4f17 core-prim . not) (f4f16 core-prim . negative?) (f4f15 core-prim . nan?) (f4f14 core-prim . min) (f4f13 core-prim . max) (f4f12 core-prim . map) (f4f11 core-prim . make-vector) (f4f10 core-prim . make-string) (f4f0f core-prim . make-rectangular) (f4f0e core-prim . make-polar) (f4f0d core-prim . magnitude) (f4f0c core-prim . log) (f4f0b core-prim . list?) (f4f0a core-prim . list-tail) (f4f09 core-prim . list-ref) (f4f08 core-prim . list->vector) (f4f07 core-prim . list->string) (f4f06 core-prim . list) (f4f05 core-prim . length) (f4f04 core-prim . lcm) (f4f03 core-prim . integer?) (f4f02 core-prim . integer-valued?) (f4f01 core-prim . integer->char) (f4f00 core-prim . infinite?) (f4eff core-prim . inexact?) (f4efe core-prim . inexact) (f4efd core-prim . imag-part) (f4efc core-prim . gcd) (f4efb core-prim . for-each) (f4efa core-prim . floor) (f4ef9 core-prim . finite?) (f4ef8 core-prim . expt) (f4ef7 core-prim . exp) (f4ef6 core-prim . exact?) (f4ef5 core-prim . exact-integer-sqrt) (f4ef4 core-prim . exact) (f4ef3 core-prim . even?) (f4ef2 core-prim . error) (f4ef1 core-prim . eqv?) (f4ef0 core-prim . equal?) (f4eef core-prim . eq?) (f4eee core-prim . dynamic-wind) (f4eed core-prim . div0-and-mod0) (f4eec core-prim . mod0) (f4eeb core-prim . div0) (f4eea core-prim . div-and-mod) (f4ee9 core-prim . mod) (f4ee8 core-prim . div) (f4ee7 core-prim . denominator) (f4ee6 core-prim . cos) (f4ee5 core-prim . cons) (f4ee4 core-prim . complex?) (f4ee3 core-prim . char?) (f4ee2 core-prim . char>?) (f4ee1 core-prim . char>=?) (f4ee0 core-prim . char=?) (f4edf core-prim . char<?) (f4ede core-prim . char<=?) (f4edd core-prim . char->integer) (f4edc core-prim . ceiling) (f4edb core-prim . call-with-values) (f4eda core-prim . call/cc) (f4ed9 core-prim . call-with-current-continuation) (f4ed8 core-prim . cddddr) (f4ed7 core-prim . cdddar) (f4ed6 core-prim . cddadr) (f4ed5 core-prim . cddaar) (f4ed4 core-prim . cdaddr) (f4ed3 core-prim . cdadar) (f4ed2 core-prim . cdaadr) (f4ed1 core-prim . cdaaar) (f4ed0 core-prim . cadddr) (f4ecf core-prim . caddar) (f4ece core-prim . cadadr) (f4ecd core-prim . cadaar) (f4ecc core-prim . caaddr) (f4ecb core-prim . caadar) (f4eca core-prim . caaadr) (f4ec9 core-prim . caaaar) (f4ec8 core-prim . cdddr) (f4ec7 core-prim . cddar) (f4ec6 core-prim . cdadr) (f4ec5 core-prim . cdaar) (f4ec4 core-prim . caddr) (f4ec3 core-prim . cadar) (f4ec2 core-prim . caadr) (f4ec1 core-prim . caaar) (f4ec0 core-prim . cddr) (f4ebf core-prim . cdar) (f4ebe core-prim . cadr) (f4ebd core-prim . caar) (f4ebc core-prim . cdr) (f4ebb core-prim . car) (f4eba core-prim . boolean?) (f4eb9 core-prim . boolean=?) (f4eb8 core-prim . atan) (f4eb7 core-prim . assertion-violation) (f31fa core-prim . assertion-error) (f4eb6 core-prim . asin) (f4eb5 core-prim . apply) (f4eb4 core-prim . append) (f4eb3 core-prim . angle) (f4eb2 core-prim . acos) (f4eb1 core-prim . abs) (f4eb0 core-prim . /) (f4eaf core-prim . *) (f4eae core-prim . -) (f4ead core-prim . +) (f4eac core-prim . >=) (f4eab core-prim . >) (f4eaa core-prim . =) (f4ea9 core-prim . <=) (f4ea8 core-prim . <) (f4ea7 core-prim . library) (f4ea6 $core-rtd &no-nans-rtd &no-nans-rcd) (f4ea5 $core-rtd &no-infinities-rtd &no-infinities-rcd) (f4ea4 $core-rtd &i/o-encoding-rtd &i/o-encoding-rcd) (f4ea3 $core-rtd &i/o-decoding-rtd &i/o-decoding-rcd) (f4ea2 $core-rtd &i/o-port-rtd &i/o-port-rcd) (f4ea1 $core-rtd &i/o-file-does-not-exist-rtd &i/o-file-does-not-exist-rcd) (f4ea0 $core-rtd &i/o-file-already-exists-rtd &i/o-file-already-exists-rcd) (f4e9f $core-rtd &i/o-file-is-read-only-rtd &i/o-fie-is-read-only-rcd) (f4e9e $core-rtd &i/o-file-protection-rtd &i/o-file-protection-rcd) (f4e9d $core-rtd &i/o-filename-rtd &i/o-filename-rcd) (f4e9c $core-rtd &i/o-invalid-position-rtd &i/o-invalid-position-rcd) (f4e9b $core-rtd &i/o-write-rtd &i/o-write-rcd) (f4e9a $core-rtd &i/o-read-rtd &i/o-read-rcd) (f4e99 $core-rtd &i/o-rtd &i/o-rcd) (f4e98 $core-rtd &undefined-rtd &undefined-rcd) (f4e97 $core-rtd &syntax-rtd &syntax-rcd) (f4e96 $core-rtd &lexical-rtd &lexical-rcd) (f4e95 $core-rtd &implementation-restriction-rtd &implementation-restriction-rcd) (f4e94 $core-rtd &non-continuable-rtd &non-continuable-rcd) (f4e93 $core-rtd &who-rtd &who-rcd) (f4e92 $core-rtd &irritants-rtd &irritants-rcd) (f4e91 $core-rtd &assertion-rtd &assertion-rcd) (f4e90 $core-rtd &violation-rtd &violation-rcd) (f4e8f $core-rtd &error-rtd &error-rcd) (f4e8e $core-rtd &serious-rtd &serious-rcd) (f4e8d $core-rtd &warning-rtd &warning-rcd) (f4e8c $core-rtd &message-rtd &message-rcd) (f4e8b $core-rtd &condition-rtd &condition-rcd) (f4e8a macro . define-condition-type) (f4e89 macro . define-enumeration) (f4e88 macro . define-record-type) (f4e87 macro . parent-rtd) (f4e86 macro . nongenerative) (f4e85 macro . opaque) (f4e84 macro . sealed) (f4e83 macro . protocol) (f4e82 macro . parent) (f4e81 macro . immutable) (f4e80 macro . mutable) (f4e7f macro . fields) (f4e7e macro . error-handling-mode) (f4e7d macro . file-options) (f4e7c macro . buffer-mode) (f4e7b macro . eol-style) (f4e7a macro . guard) (f4e79 macro . trace-define) (f4e78 macro . trace-lambda) (f4e77 macro . unsyntax-splicing) (f4e76 macro . unsyntax) (f4e75 macro . unquote-splicing) (f4e74 macro . unquote) (f4e73 macro . _) (f4e72 macro . else) (f4e71 macro . =>) (f4e70 macro . ...) (f4e6f macro . assert) (f4e6e macro . endianness) (f4e6d macro . delay) (f4e6c macro . time) (f4e6b macro . do) (f4e6a macro . cond) (f4e69 macro . let*) (f4e68 macro . let*-values) (f4e67 macro . let-values) (f4e66 macro . identifier-syntax) (f4e65 macro . with-syntax) (f4e64 macro . quasisyntax) (f4e63 macro . quasiquote) (f4e62 macro . syntax-rules) (f4e61 macro . include) (f4e60 macro . define-struct) (f4e5f core-macro . record-constructor-descriptor) (f4e5e core-macro . record-type-descriptor) (f4e5d macro . case) (f4e5c macro . parameterize) (f4e5b macro . unless) (f4e5a macro . when) (f4e59 core-macro . or) (f4e58 core-macro . and) (f4e57 core-macro . if) (f4e56 core-macro . let) (f4e55 core-macro . letrec*) (f4e54 core-macro . letrec) (f4e53 core-macro . type-descriptor) (f4e52 core-macro . case-lambda) (f4e51 core-macro . lambda) (f4e50 core-macro . syntax) (f4e4f core-macro . syntax-case) (f4e4e core-macro . quote) (f4e4d core-macro . foreign-call) (f4e4c letrec-syntax) (f4e4b let-syntax) (f4e4a set!) (f4e49 import) (f4e48 begin) (f4e47 module) (f4e46 define-syntax) (f4e45 define)) values values '#f '#f '#f '#f) (f2d30@f2b7c@install-library 'f520c '(psyntax system $bootstrap) '() '() '() '() '((pretty-print . f51b3) (eval-core . f51b2) (set-symbol-value! . f51b1) (symbol-value . f51b0) (gensym . f51af) (void . f51ae)) '() values values '#f '#f '#f '#f) (f2d30@f2b7c@install-library 'f520d '(mosh) '() '() '() '() '((set-symbol-value! . f51b1) (symbol-value . f51b0) (regexp? . f51ac) (read-line . f51ab) (ungensym . f51a9) (alist->eq-hash-table . f51a8) (assoc-ref . f51a7) (print . f51a6) (format . f51a5) (host-os . f51a4) (library-path . f2b5b) (standard-library-path . f51a3) (file-newer? . f519d) (stat-mtime . f519c) (digit->integer . f5198) (call-with-string-input-port . f5197) (call-with-string-io . f5196) (string-split . f5195) (bytevector-for-each . f5194) (string->regexp . f5193) (rxmatch . f5192) (regexp-replace-all . f5191) (hashtable-fold-left . f5190) (hashtable-for-each . f518f) (set-current-directory! . f518a) (expand-path . f5189) (current-directory . f5188) (p . f5149) (get-timeofday . f5130) (get-command-line . f512f) (sys-display . f512e) (whereis . f512d) (register . f512c) (vm-join! . f512b) (vm-set-value! . f512a) (vm? . f5129) (main-vm? . f5128) (vm-eval . f5127) (vm-self . f5126) (vm-start! . f5125) (make-vm . f5124) (mutex-try-lock! . f5123) (mutex-unlock! . f5122) (mutex-lock! . f5121) (mutex? . f5120) (make-mutex . f511f) (condition-variable-notify-all! . f511e) (condition-variable-notify! . f511d) (condition-variable-wait! . f511c) (make-condition-variable . f511b) (write/ss . f511a) (mosh-executable-path . f5119) (make-file-options . f5118) (source-info . f5117) (make-compiler-instruction . f5116) (make-instruction . f5115) (set-source-info! . f5114) (bignum? . f5113) (fast-equal? . f5112) (fasl-read . f5111) (fasl-write . f5110) (time-usage . f510f) (os-constant . f510e) (condition-printer . f510d) (time . f4e6c) (include . f4e61)) '() values values '#f '#f '#f '#f) (f2d30@f2b7c@install-library 'f520e '(system) '() '() '() '() '((gensym-prefix-set! . f51aa) (ssl-supported? . f51a2) (ssl-socket? . f51a1) (socket-sslize! . f51a0) (%monapi-name-whereis . f519f) (%monapi-message-send . f519e) (write-to-file . f519b) (file->list . f519a) (file->string . f5199) (mosh-cache-dir . f2945) (call-process . f518e) (local-tz-offset . f518d) (microseconds . f518c) (directory-list . f518b) (expand-path . f5189) (%spawn . f5187) (%waitpid . f5186) (simple-struct-name . f5185) (simple-struct-set! . f5184) (simple-struct-ref . f5183) (make-simple-struct . f5182) (simple-struct? . f5181) (pointer-ref-c-int64 . f5180) (pointer-ref-c-int32 . f517f) (pointer-ref-c-int16 . f517e) (pointer-ref-c-int8 . f517d) (pointer-ref-c-uint64 . f517c) (pointer-ref-c-uint32 . f517b) (pointer-ref-c-uint16 . f517a) (pointer-ref-c-uint8 . f5179) (pointer-set-c-uint64! . f5178) (pointer-set-c-uint32! . f5177) (pointer-set-c-uint16! . f5176) (pointer-set-c-uint8! . f5175) (pointer-set-c-int64! . f5174) (pointer-set-c-int32! . f5173) (pointer-set-c-int16! . f5172) (pointer-set-c-int8! . f5171) (pointer-set-c-pointer! . f5170) (pointer-set-c-double! . f516f) (pointer-set-c-float! . f516e) (pointer-set-c-long-long! . f516d) (pointer-set-c-long! . f516c) (pointer-set-c-int! . f516b) (pointer-set-c-short! . f516a) (pointer-set-c-char! . f5169) (pointer-ref-c-pointer . f5168) (pointer-ref-c-double . f5167) (pointer-ref-c-float . f5166) (pointer-ref-c-unsigned-long-long . f5165) (pointer-ref-c-signed-long-long . f5164) (pointer-ref-c-unsigned-long . f5163) (pointer-ref-c-signed-long . f5162) (pointer-ref-c-unsigned-int . f5161) (pointer-ref-c-signed-int . f5160) (pointer-ref-c-unsigned-short . f515f) (pointer-ref-c-signed-short . f515e) (pointer-ref-c-unsigned-char . f515d) (pointer-ref-c-signed-char . f515c) (pointer->integer . f515b) (integer->pointer . f515a) (pointer? . f5159) (shared-errno . f5158) (%ffi-free-c-callback-trampoline . f5157) (%ffi-make-c-callback-trampoline . f5156) (%ffi-free . f5155) (%ffi-malloc . f5154) (%ffi-supported? . f5153) (%ffi-pointer->string . f5152) (%ffi-call . f5151) (%ffi-lookup . f5150) (%ffi-open . f514f) (null-terminated-utf8->string . f514e) (null-terminated-bytevector->string . f514d) (%exec . f514c) (%fork . f514b) (%pipe . f514a) (open-output-string . f5148) (get-output-string . f5147) (file-stat-ctime . f5146) (file-stat-atime . f5145) (file-stat-mtime . f5144) (file-size-in-bytes . f5143) (file-writable? . f5142) (file-executable? . f5141) (file-readable? . f5140) (file-regular? . f513f) (file-symbolic-link? . f513e) (file-directory? . f513d) (create-symbolic-link . f513c) (rename-file . f513b) (delete-directory . f513a) (create-directory . f5139) (create-mosh-cache-dir . f5138) (get-environment-variables . f5137) (current-exception-handler . f5136) (get-environment-variable . f5135) (join-wraps . f5134) (id->real-label . f5133) (same-marks? . f5132) (same-marks*? . f5131) (disasm . f510c) (make-parameter . f2943) (socket-port . f510b) (socket-shutdown . f510a) (socket-close . f5109) (socket-send . f5108) (socket-recv! . f5107) (socket-recv . f5106) (make-server-socket . f5105) (make-client-socket . f5104) (socket-accept . f5103) (socket? . f5102) (parameterize . f4e5c)) '() values values '#f '#f '#f '#f)))
(begin (set! f4cc4@ref (unspecified)) (set! f4cc6@x* (unspecified)) (set! f4cc8@add-library-path! (unspecified)) (set! f4cca@parse-and-add-library-path (unspecified)) (set! f4ccc@for-each-with-index (unspecified)) (set! f4cce@rpad (unspecified)) (set! f4cd0@condition-printer/p (unspecified)) (set! f4cd2@record->field-alist (unspecified)) (set! f4cd4@map-with-index (unspecified)) (set! f4cd6@repl (unspecified)) (set! f4cd8@trace-printer (unspecified)) (set! f4cda@command-line (unspecified)) (set! f4cdc@local-library-path (unspecified)) (set! f4cde@load/args (unspecified)) (set! f4ce0@load (unspecified)) (set! f4ce2@ironscheme-build (unspecified)) (set! f4ce4@eval-top-level (unspecified)) (set! f4ce6@compile-system-libraries (unspecified)) (set! f4ce8@compile (unspecified)) (set! f4cea@compile->closure (unspecified)) (set! f4cec@pre-compile-r6rs-file (unspecified)) (set! f4cee@load-r6rs-top-level (unspecified)) (set! f4cf0@load-r6rs-top-level-sexp (unspecified)) (set! f4cf2@prefix-inc (unspecified)) (set! f4cf4@prefix-inc! (unspecified)) (set! f4cc4@ref (lambda (f4d2f@rtd f4d30@i f4d31@x) (let ((f4d35@val ((record-accessor f4d2f@rtd f4d30@i) f4d31@x))) (if (symbol? f4d35@val) (ungensym f4d35@val) f4d35@val)))) (set! f4e2b@f4cc4@ref f4cc4@ref) (set! f4cc6@x* '()) (set! f4e2c@f4cc6@x* f4cc6@x*) (set! f4cc8@add-library-path! (lambda (f4d37@path) (f2d20@f2b5c@library-path (append (f2d20@f2b5c@library-path) (list f4d37@path))))) (set! f4e2d@f4cc8@add-library-path! f4cc8@add-library-path!) (set! f4cca@parse-and-add-library-path (lambda (f4d39@paths f4d3a@message) (letrec* ((f4d3e@separator (if (string=? (host-os) '"win32") '#\; '#\:))) (let ((f4d3f@t f4d39@paths)) (if f4d3f@t ((lambda (f4d41@paths) (for-each (lambda (f4d43@path) (if (file-exists? f4d43@path) (f4cc8@add-library-path! (expand-path f4d43@path)) (format (current-error-port) f4d3a@message f4d43@path))) (string-split f4d41@paths f4d3e@separator))) f4d3f@t) (void)))))) (set! f4e2e@f4cca@parse-and-add-library-path f4cca@parse-and-add-library-path) (set! f4ccc@for-each-with-index (lambda (f4d45@proc f4d46@lst) (letrec ((f4d49@loop (lambda (f4d4b@i f4d4c@lst) (if (null? f4d4c@lst) (if '#f '#f (void)) (begin (f4d45@proc f4d4b@i (car f4d4c@lst)) (f4d49@loop (+ f4d4b@i '1) (cdr f4d4c@lst))))))) (f4d49@loop '1 f4d46@lst)))) (set! f4e2f@f4ccc@for-each-with-index f4ccc@for-each-with-index) (set! f4cce@rpad (lambda (f4d4f@str f4d50@pad f4d51@n) (let ((f4d55@rest (- f4d51@n (string-length (format '"~a" f4d4f@str))))) (let f4d5b@loop ((f4d57@rest f4d55@rest) (f4d58@ret (format '"~a" f4d4f@str))) (if (<= f4d57@rest '0) f4d58@ret (f4d5b@loop (- f4d57@rest '1) (string-append f4d58@ret f4d50@pad))))))) (set! f4e30@f4cce@rpad f4cce@rpad) (set! f4cd0@condition-printer/p (lambda (f4d5d@e f4d5e@port) (letrec* ((f4d62@max-condition-len (apply max (map (lambda (f4d73@c) (string-length (symbol->string (record-type-name (record-rtd f4d73@c))))) (simple-conditions f4d5d@e))))) (begin (display '" Condition components:\n" f4d5e@port) (f4ccc@for-each-with-index (lambda (f4d63@i f4d64@x) (let ((f4d67@rtd (record-rtd f4d64@x)) (f4d68@fields-alist (f4cd2@record->field-alist f4d64@x))) (begin (format f4d5e@port '" ~d. ~a" f4d63@i (f4cce@rpad (symbol->string (record-type-name f4d67@rtd)) '" " f4d62@max-condition-len)) (if (null? f4d68@fields-alist) (newline f4d5e@port) (void)) (let f4d6f@loop ((f4d6b@first '#t) (f4d6c@fields-alist f4d68@fields-alist)) (if (null? f4d6c@fields-alist) '() (let ((f4d71@field (car f4d6c@fields-alist))) (begin (if (not f4d6b@first) (display (f4cce@rpad '"" '" " (+ '4 f4d62@max-condition-len)) f4d5e@port) (void)) (display '"       " f4d5e@port) (display (car f4d71@field) f4d5e@port) (display '": " f4d5e@port) (write (cdr f4d71@field) f4d5e@port) (newline f4d5e@port) (f4d6f@loop '#f (cdr f4d6c@fields-alist))))))))) (simple-conditions f4d5d@e)))))) (set! f4e31@f4cd0@condition-printer/p f4cd0@condition-printer/p) (set! f4cd2@record->field-alist (lambda (f4d75@r) (letrec* ((f4d78@ref (lambda (f4d83@rtd f4d84@i f4d85@x) (let ((f4d89@val ((record-accessor f4d83@rtd f4d84@i) f4d85@x))) (if (symbol? f4d89@val) (ungensym f4d89@val) f4d89@val))))) (let f4d7d@loop ((f4d79@ret '()) (f4d7a@rtd (record-rtd f4d75@r))) (if f4d7a@rtd (f4d7d@loop (append f4d79@ret (f4cd4@map-with-index (lambda (f4d7f@i f4d80@field) (cons f4d80@field (f4d78@ref f4d7a@rtd f4d7f@i f4d75@r))) (vector->list (record-type-field-names f4d7a@rtd)))) (record-type-parent f4d7a@rtd)) f4d79@ret))))) (set! f4e32@f4cd2@record->field-alist f4cd2@record->field-alist) (set! f4cd4@map-with-index (lambda (f4d8b@proc f4d8c@lst) (let f4d95@loop ((f4d8f@i '0) (f4d90@lst f4d8c@lst) (f4d91@ret '())) (if (null? f4d90@lst) (reverse f4d91@ret) (f4d95@loop (+ f4d8f@i '1) (cdr f4d90@lst) (cons (f4d8b@proc f4d8f@i (car f4d90@lst)) f4d91@ret)))))) (set! f4e33@f4cd4@map-with-index f4cd4@map-with-index) (set! f4cd6@repl (lambda f4d97@x (letrec* ((f4d9a@rec (lambda () (begin (display '"mosh> ") ((call/cc (lambda (f4d9d@f4d9b) (lambda () (with-exception-handler (lambda (f4d9f@e) ((call/cc (lambda (f4da1@f4d9c) (f4d9d@f4d9b (lambda () (if '#t (begin (display '"\nUnhandled exception:\n\n" (current-error-port)) (if (condition? f4d9f@e) (f4cd0@condition-printer/p f4d9f@e (current-error-port)) (format (current-error-port) '"  Non-condition object:\n     ~a\n" f4d9f@e))) (f4da1@f4d9c (lambda () (raise-continuable f4d9f@e)))))))))) (lambda () (let f4da7@loop ((f4da3@line (get-line (current-input-port))) (f4da4@accum '"")) (letrec* ((f4daa@parentheses-ok? (lambda (f4db5@text) (let f4dbd@loop ((f4db7@chars (string->list f4db5@text)) (f4db8@p0 '0) (f4db9@p1 '0)) (if (null? f4db7@chars) (= '0 f4db8@p0 f4db9@p1) (let ((f4dbf@t (car f4db7@chars))) (if (memv f4dbf@t '(#\()) (f4dbd@loop (cdr f4db7@chars) (+ f4db8@p0 '1) f4db9@p1) (if (memv f4dbf@t '(#\))) (f4dbd@loop (cdr f4db7@chars) (- f4db8@p0 '1) f4db9@p1) (if (memv f4dbf@t '(#\[)) (f4dbd@loop (cdr f4db7@chars) f4db8@p0 (+ f4db9@p1 '1)) (if (memv f4dbf@t '(#\])) (f4dbd@loop (cdr f4db7@chars) f4db8@p0 (- f4db9@p1 '1)) (f4dbd@loop (cdr f4db7@chars) f4db8@p0 f4db9@p1)))))))))) (f4dac@eval-string-print (lambda (f4daf@text) (if (not (or (string=? '"\n" f4daf@text) (= '0 (string-length f4daf@text)))) (call-with-values (lambda () (f4ce4@eval-top-level (call-with-port (open-string-input-port f4daf@text) read))) (lambda f4db1@out* (for-each (lambda (f4db3@out) (begin (write f4db3@out) (newline))) f4db1@out*))) (void))))) (if (eof-object? f4da3@line) (begin (f4dac@eval-string-print f4da4@accum) (exit)) (let ((f4dad@current (string-append f4da4@accum f4da3@line))) (if (f4daa@parentheses-ok? f4dad@current) (f4dac@eval-string-print f4dad@current) (f4da7@loop (get-line (current-input-port)) f4dad@current)))))))))))) (newline) (f4d9a@rec))))) (f4d9a@rec)))) (set! f4e34@f4cd6@repl f4cd6@repl) (set! f4cd8@trace-printer (f2a66@f2944@make-parameter write)) (set! f4e35@f4cd8@trace-printer f4cd8@trace-printer) (set! f4cda@command-line (f2a66@f2944@make-parameter (get-command-line))) (set! f4e36@f4cda@command-line f4cda@command-line) (set! f4cdc@local-library-path (lambda (f4dc1@filename) (f2d20@f2b5c@library-path))) (set! f4e37@f4cdc@local-library-path f4cdc@local-library-path) (set! f4cde@load/args (lambda (f4dc3@filename . f4dc5@args) (begin (apply f4cee@load-r6rs-top-level f4dc3@filename 'load f4dc5@args) (void)))) (set! f4e38@f4cde@load/args f4cde@load/args) (set! f4ce0@load (lambda (f4dc7@filename) (begin (apply f4cee@load-r6rs-top-level f4dc7@filename 'load (f4cda@command-line)) (void)))) (set! f4e39@f4ce0@load f4ce0@load) (set! f4ce2@ironscheme-build (lambda () (f4ce0@load '"ironscheme-buildscript.ss"))) (set! f4e3a@f4ce2@ironscheme-build f4ce2@ironscheme-build) (set! f4ce4@eval-top-level (lambda (f4dc9@x) (f4ca1@f31e1@eval f4dc9@x (f4cb8@f320f@interaction-environment)))) (set! f4e3b@f4ce4@eval-top-level f4ce4@eval-top-level) (set! f4ce6@compile-system-libraries (lambda () (f4ce4@eval-top-level '(begin (include "system-libraries.ss") (compile "system-libraries.ss"))))) (set! f4e3c@f4ce6@compile-system-libraries f4ce6@compile-system-libraries) (set! f4ce8@compile (lambda (f4dcb@filename) (f4cee@load-r6rs-top-level f4dcb@filename 'compile))) (set! f4e3d@f4ce8@compile f4ce8@compile) (set! f4cea@compile->closure (lambda (f4dcd@filename) (f4cee@load-r6rs-top-level f4dcd@filename 'closure))) (set! f4e3e@f4cea@compile->closure f4cea@compile->closure) (set! f4cec@pre-compile-r6rs-file (lambda (f4dcf@filename) (f4cee@load-r6rs-top-level f4dcf@filename 'compile))) (set! f4e3f@f4cec@pre-compile-r6rs-file f4cec@pre-compile-r6rs-file) (set! f4cee@load-r6rs-top-level (lambda (f4dd1@filename f4dd2@how . f4dd5@args) (begin (f2d20@f2b5c@library-path (f4cdc@local-library-path f4dd1@filename)) (let ((f4dd7@x* (with-input-from-file f4dd1@filename (lambda () (let f4dd9@f () (let ((f4ddb@x (f2a58@f2928@read-annotated))) (if (eof-object? f4ddb@x) '() (cons f4ddb@x (f4dd9@f))))))))) (let ((f4ddd@t f4dd2@how)) (if (memv f4ddd@t '(closure)) (f4cb7@f320d@pre-compile-r6rs-top-level f4dd7@x*) (if (memv f4ddd@t '(load)) (begin (f4cda@command-line (cons f4dd1@filename (car f4dd5@args))) (f2a67@f2946@mosh-cache-dir (create-mosh-cache-dir)) (if (f2a67@f2946@mosh-cache-dir) (gensym-prefix-set! (f4cf4@prefix-inc! (string-append (f2a67@f2946@mosh-cache-dir) '"/prefix.txt"))) (void)) (if (symbol-value '%clean-acc) (for-each (lambda (f4ddf@file) ((call/cc (lambda (f4de3@f4de1) (lambda () (with-exception-handler (lambda (f4de5@c) ((call/cc (lambda (f4de7@f4de2) (f4de3@f4de1 (lambda () (if '#t '#t (f4de7@f4de2 (lambda () (raise-continuable f4de5@c)))))))))) (lambda () (delete-file (string-append (f2a67@f2946@mosh-cache-dir) '"/" f4ddf@file))))))))) (directory-list (f2a67@f2946@mosh-cache-dir))) (void)) (let ((f4de9@compiled (f4cb6@f320b@compile-r6rs-top-level f4dd7@x*))) (begin (if (and (f2a67@f2946@mosh-cache-dir) (not (symbol-value '%disable-acc))) (f2d24@f2b64@serialize-all f2a61@f293a@serialize-library f2abd@f2a76@compile-core-expr) (void)) (f4de9@compiled)))) (if (memv f4ddd@t '(compile)) (begin (f4cb6@f320b@compile-r6rs-top-level f4dd7@x*) (f2d24@f2b64@serialize-all f2a61@f293a@serialize-library f2abd@f2a76@compile-core-expr)) (if '#f '#f (void)))))))))) (set! f4e40@f4cee@load-r6rs-top-level f4cee@load-r6rs-top-level) (set! f4cf0@load-r6rs-top-level-sexp (lambda (f4deb@import-spec f4dec@thunk) (let ((f4df7@f4df0 f2d20@f2b5c@library-path) (f4df8@f4df2 f2a67@f2946@mosh-cache-dir) (f4df9@f4df4 (f4cdc@local-library-path '"")) (f4dfa@f4df6 (create-mosh-cache-dir))) (let ((f4dff@swap (lambda () (begin (let ((f4e01@t (f4df7@f4df0))) (begin (f4df7@f4df0 f4df9@f4df4) (set! f4df9@f4df4 f4e01@t))) (let ((f4e03@t (f4df8@f4df2))) (begin (f4df8@f4df2 f4dfa@f4df6) (set! f4dfa@f4df6 f4e03@t))))))) (dynamic-wind f4dff@swap (lambda () (begin (if (f2a67@f2946@mosh-cache-dir) (gensym-prefix-set! (f4cf4@prefix-inc! (string-append (f2a67@f2946@mosh-cache-dir) '"/prefix.txt"))) (void)) (let ((f4e09@f4e06 f4cda@command-line) (f4e0a@f4e08 '())) (let ((f4e0d@swap (lambda () (let ((f4e0f@t (f4e09@f4e06))) (begin (f4e09@f4e06 f4e0a@f4e08) (set! f4e0a@f4e08 f4e0f@t)))))) (dynamic-wind f4e0d@swap (lambda () ((f4cb6@f320b@compile-r6rs-top-level (list (cons 'import f4deb@import-spec) (list f4dec@thunk))))) f4e0d@swap))))) f4dff@swap))))) (set! f4e41@f4cf0@load-r6rs-top-level-sexp f4cf0@load-r6rs-top-level-sexp) (set! f4cf2@prefix-inc (lambda (f4e11@prefix-string) (let ((f4e13@prefix (symbol->string f4e11@prefix-string))) (let ((f4e15@len (string-length f4e13@prefix))) (let f4e1d@loop ((f4e17@i (- f4e15@len '1)) (f4e18@carry? '#t) (f4e19@accum '())) (if (< f4e17@i '0) (string->symbol (list->string (if f4e18@carry? (cons '#\a f4e19@accum) f4e19@accum))) (if f4e18@carry? (let ((f4e1f@next-integer (+ '1 (char->integer (string-ref f4e13@prefix f4e17@i))))) (if (= f4e1f@next-integer '123) (f4e1d@loop (- f4e17@i '1) '#f (cons '#\A f4e19@accum)) (if (= f4e1f@next-integer '91) (f4e1d@loop (- f4e17@i '1) '#t (cons '#\a f4e19@accum)) (f4e1d@loop (- f4e17@i '1) '#f (cons (integer->char f4e1f@next-integer) f4e19@accum))))) (f4e1d@loop (- f4e17@i '1) '#f (cons (string-ref f4e13@prefix f4e17@i) f4e19@accum))))))))) (set! f4e42@f4cf2@prefix-inc f4cf2@prefix-inc) (set! f4cf4@prefix-inc! (lambda (f4e21@file) (begin (if (not (file-exists? f4e21@file)) (call-with-output-file f4e21@file (lambda (f4e23@port) (write 'd f4e23@port))) (void)) (let ((f4e25@prefix (call-with-input-file f4e21@file read))) (if (main-vm?) (let ((f4e27@next-prefix (f4cf2@prefix-inc f4e25@prefix))) (begin (call-with-port (open-file-output-port f4e21@file (make-file-options '(no-fail)) 'block (native-transcoder)) (lambda (f4e29@port) (write f4e27@next-prefix f4e29@port))) f4e25@prefix)) f4e25@prefix))))) (set! f4e43@f4cf4@prefix-inc! f4cf4@prefix-inc!) (begin (f2d25@f2b66@current-precompiled-library-loader f2a62@f293c@load-serialized-library) (set-symbol-value! 'load f4ce0@load) (set-symbol-value! 'pre-compile-r6rs-file f4cec@pre-compile-r6rs-file) (set-symbol-value! 'eval-r6rs f4ce4@eval-top-level) (set-symbol-value! 'int-env-syms f4c98@f31cf@interaction-environment-symbols) (set-symbol-value! 'expanded2core f2abc@f2a74@expanded->core) (set-symbol-value! 'trace-printer f4cd8@trace-printer) (set-symbol-value! 'compile-r6rs-top-level 'compile-r6rs-top-level) (set-symbol-value! 'create-non-continuable-violation (lambda (f4cf5@c) (condition (make-non-continuable-violation) (make-who-condition 'raise) (make-message-condition '"returned from non-continuable exception") (make-irritants-condition (list f4cf5@c))))) (f4cca@parse-and-add-library-path (get-environment-variable '"MOSH_LOADPATH") '"** WARN in environment variable 'MOSH_LOADPATH': directory ~s not exist\n") (f4cca@parse-and-add-library-path (symbol-value '%loadpath) '"** WARN in command-line option '--loadpath': directory ~s not exist\n") (if (mosh-executable-path) (if (file-exists? (string-append (mosh-executable-path) '"/lib")) (f4cc8@add-library-path! (string-append (mosh-executable-path) '"/lib")) (void)) (if (file-exists? (string-append (current-directory) '"/lib")) (f4cc8@add-library-path! (string-append (current-directory) '"/lib")) (void))) (if (file-exists? (string-append (standard-library-path) '"/lib")) (f4cc8@add-library-path! (string-append (standard-library-path) '"/lib")) (void)) (let ((f4cf7@prefix (lambda (f4cf9@ext f4cfa@ls) (append (map (lambda (f4cfd@x) (string-append f4cf9@ext f4cfd@x)) f4cfa@ls) f4cfa@ls)))) (f2d21@f2b5e@library-extensions (f4cf7@prefix '".mosh" (f2d21@f2b5e@library-extensions)))) (current-exception-handler (lambda (f4cff@c) (begin (if (condition? f4cff@c) (f4cd0@condition-printer/p f4cff@c (current-error-port)) (format (current-error-port) '"\n Non-condition object:\n     ~a\n" f4cff@c)) f4cff@c))) (if ((call/cc (lambda (f4d03@f4d01) (lambda () (with-exception-handler (lambda (f4d05@c) ((call/cc (lambda (f4d07@f4d02) (f4d03@f4d01 (lambda () (if '#t '#f (f4d07@f4d02 (lambda () (raise-continuable f4d05@c)))))))))) (lambda () (symbol-value '%vm-import-spec))))))) (f4cf0@load-r6rs-top-level-sexp (symbol-value '%vm-import-spec) (symbol-value '%vm-thunk)) (if (null? (f4cda@command-line)) (let ((f4d11@f4d0a f4cda@command-line) (f4d12@f4d0c f2a67@f2946@mosh-cache-dir) (f4d13@f4d0e '()) (f4d14@f4d10 (create-mosh-cache-dir))) (let ((f4d19@swap (lambda () (begin (let ((f4d1b@t (f4d11@f4d0a))) (begin (f4d11@f4d0a f4d13@f4d0e) (set! f4d13@f4d0e f4d1b@t))) (let ((f4d1d@t (f4d12@f4d0c))) (begin (f4d12@f4d0c f4d14@f4d10) (set! f4d14@f4d10 f4d1d@t))))))) (dynamic-wind f4d19@swap (lambda () (begin (if (f2a67@f2946@mosh-cache-dir) (gensym-prefix-set! (f4cf4@prefix-inc! (string-append (f2a67@f2946@mosh-cache-dir) '"/prefix.txt"))) (void)) (f4cd6@repl))) f4d19@swap))) (begin (f2d20@f2b5c@library-path (f4cdc@local-library-path (car (f4cda@command-line)))) (set! f4cc6@x* (with-input-from-file (car (f4cda@command-line)) (lambda () (let f4d1f@f () (let ((f4d21@x (f2a58@f2928@read-annotated))) (if (eof-object? f4d21@x) '() (cons f4d21@x (f4d1f@f)))))))) (f4cda@command-line (cons (car (f4cda@command-line)) (cdr (f4cda@command-line)))) (f2a67@f2946@mosh-cache-dir (create-mosh-cache-dir)) (if (f2a67@f2946@mosh-cache-dir) (gensym-prefix-set! (f4cf4@prefix-inc! (string-append (f2a67@f2946@mosh-cache-dir) '"/prefix.txt"))) (void)) (if (symbol-value '%clean-acc) (for-each (lambda (f4d23@file) ((call/cc (lambda (f4d27@f4d25) (lambda () (with-exception-handler (lambda (f4d29@c) ((call/cc (lambda (f4d2b@f4d26) (f4d27@f4d25 (lambda () (if '#t '#t (f4d2b@f4d26 (lambda () (raise-continuable f4d29@c)))))))))) (lambda () (delete-file (string-append (f2a67@f2946@mosh-cache-dir) '"/" f4d23@file))))))))) (directory-list (f2a67@f2946@mosh-cache-dir))) (void)) (let ((f4d2d@compiled (f4cb6@f320b@compile-r6rs-top-level f4cc6@x*))) (begin (if (and (f2a67@f2946@mosh-cache-dir) (not (symbol-value '%disable-acc))) (f2d24@f2b64@serialize-all f2a61@f293a@serialize-library f2abd@f2a76@compile-core-expr) (void)) (f4d2d@compiled))))))))
