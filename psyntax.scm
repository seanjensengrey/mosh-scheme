;;; Copyright (c) 2006, 2007 Abdulaziz Ghuloum and Kent Dybvig
;;; automatically generated from psyntax sources
;;; for copyright details, see psyntax/main.ss

(begin (set! to598@library-file-path->cache-path (unspecified)) (set! to59a@read-annotated (unspecified)) (set! to59c@annotation-stripped (unspecified)) (set! to59e@annotation? (unspecified)) (set! to5a0@annotation-source (unspecified)) (set! to5a2@annotation-expression (unspecified)) (set! to5a4@scm->fasl (unspecified)) (set! to5a6@fasl-save (unspecified)) (set! to5a8@fasl-load (unspecified)) (set! to5aa@verbose? (unspecified)) (set! to5ac@serialize-library (unspecified)) (set! to5ae@load-serialized-library (unspecified)) (set! to5b0@make-record-printer (unspecified)) (set! to5b2@compile-core (unspecified)) (set! to5b4@read-library-source-file (unspecified)) (set! to5b6@make-parameter (unspecified)) (set! to5b8@mosh-cache-dir (unspecified)) (set! to64e@file-options-spec (unspecified)) (set! to598@library-file-path->cache-path (lambda (to64f@x) (call-with-values (lambda () (open-string-output-port)) (lambda (to655@to652 to656@to654) (let ((to659@extract to656@to654) (to65a@p to655@to652)) (letrec* ((to65e@display-hex (lambda (to667@n) (if (<= '0 to667@n '9) (display to667@n to65a@p) (display (integer->char (+ (char->integer '#\a) (- to667@n '10))) to65a@p))))) (begin (let to661@f ((to65f@ls (string-split to64f@x '#\/))) (if (not (null? to65f@ls)) (begin (display '"_" to65a@p) (for-each (lambda (to663@c) (if (or (char<=? '#\a to663@c '#\z) (char<=? '#\A to663@c '#\Z) (char<=? '#\0 to663@c '#\9) (memv to663@c '(#\- #\. #\_ #\~))) (display to663@c to65a@p) (begin (display '"%" to65a@p) (let ((to665@n (char->integer to663@c))) (begin (to65e@display-hex (quotient to665@n '16)) (to65e@display-hex (remainder to665@n '16))))))) (string->list (car to65f@ls))) (to661@f (cdr to65f@ls))) (void))) (to659@extract)))))))) (set! to6c9@to598@library-file-path->cache-path to598@library-file-path->cache-path) (set! to59a@read-annotated read) (set! to6ca@to59a@read-annotated to59a@read-annotated) (set! to59c@annotation-stripped (lambda (to669@x) (if (pair? to669@x) (cons (to59c@annotation-stripped (car to669@x)) (to59c@annotation-stripped (cdr to669@x))) (if (procedure? to669@x) (set-source-info! to669@x '#f) to669@x)))) (set! to6cb@to59c@annotation-stripped to59c@annotation-stripped) (set! to59e@annotation? (lambda (to66b@x) (or (and (annotated-pair? to66b@x) (source-info to66b@x)) (and (procedure? to66b@x) (source-info to66b@x))))) (set! to6cc@to59e@annotation? to59e@annotation?) (set! to5a0@annotation-source (lambda (to66d@x) (source-info to66d@x))) (set! to6cd@to5a0@annotation-source to5a0@annotation-source) (set! to5a2@annotation-expression (lambda (to66f@x) (if (annotated-pair? to66f@x) (cons (car to66f@x) (cdr to66f@x)) (if (procedure? to66f@x) (set-source-info! to66f@x '#f) to66f@x)))) (set! to6ce@to5a2@annotation-expression to5a2@annotation-expression) (set! to5a4@scm->fasl (lambda (to671@filename) (string-append (to5b8@mosh-cache-dir) '"/" (to598@library-file-path->cache-path to671@filename) '".mosh-fasl"))) (set! to6cf@to5a4@scm->fasl to5a4@scm->fasl) (set! to5a6@fasl-save (lambda (to673@filename to674@obj) (call-with-port (open-file-output-port to673@filename) (lambda (to677@port) ((symbol-value 'fasl-write!) to674@obj to677@port))))) (set! to6d0@to5a6@fasl-save to5a6@fasl-save) (set! to5a8@fasl-load (lambda (to679@filename) (call-with-port (open-file-input-port to679@filename) (symbol-value 'fasl-read!)))) (set! to6d1@to5a8@fasl-load to5a8@fasl-load) (set! to5aa@verbose? (symbol-value '%verbose)) (set! to6d2@to5aa@verbose? to5aa@verbose?) (set! to5ac@serialize-library (lambda (to67b@filename to67c@obj) (begin (if to5aa@verbose? (format (current-error-port) '"serialize-library ~a\n..." to67b@filename) (void)) (let ((to67f@expanded2core (symbol-value 'expanded2core))) (let ((to681@compile (symbol-value 'compile-w/o-halt))) (let ((to683@code to67c@obj)) (let ((to685@pivot (cddddr (cddddr to683@code)))) (let ((to687@visit (to681@compile (to67f@expanded2core (car to685@pivot))))) (begin (set-car! to685@pivot to687@visit) (let ((to689@pivot (cdr to685@pivot))) (let ((to68b@invoke (to681@compile (to67f@expanded2core (car to689@pivot))))) (set-car! to689@pivot to68b@invoke))))))))) (let ((to68d@fasl-file (to5a4@scm->fasl to67b@filename))) (begin (if (file-exists? to68d@fasl-file) (delete-file to68d@fasl-file) (void)) ((call/cc (lambda (to691@to68f) (lambda () (with-exception-handler (lambda (to693@c) ((call/cc (lambda (to695@to690) (to691@to68f (lambda () (if '#t (begin (if to5aa@verbose? (format (current-error-port) '"Warning:serialize-library failed ~a\n" to67b@filename) (void)) (if (file-exists? to68d@fasl-file) (delete-file to68d@fasl-file) (void)) '#f) (to695@to690 (lambda () (raise-continuable to693@c)))))))))) (lambda () (to5a6@fasl-save to68d@fasl-file to67c@obj)))))))))))) (set! to6d3@to5ac@serialize-library to5ac@serialize-library) (set! to5ae@load-serialized-library (lambda (to697@filename to698@obj) (and (to5b8@mosh-cache-dir) (let ((to69b@fasl-file (to5a4@scm->fasl to697@filename))) (if (and (file-exists? to69b@fasl-file) ((symbol-value 'file-newer?) to69b@fasl-file to697@filename)) (let ((to69d@expanded2core (symbol-value 'expanded2core))) (let ((to69f@eval-compiled-core (symbol-value 'eval-compiled!))) (let ((to6a1@code (to5a8@fasl-load to69b@fasl-file))) (let ((to6a3@pivot (cddddr (cddddr to6a1@code)))) (let ((to6a5@visit (car to6a3@pivot))) (let ((to6a7@visit-proc (lambda () (to69f@eval-compiled-core to6a5@visit)))) (begin (set-car! to6a3@pivot to6a7@visit-proc) (let ((to6a9@pivot (cdr to6a3@pivot))) (let ((to6ab@invoke (car to6a9@pivot))) (begin (set-car! to6a9@pivot (lambda () (to69f@eval-compiled-core to6ab@invoke))) (apply to698@obj to6a1@code))))))))))) '#f))))) (set! to6d4@to5ae@load-serialized-library to5ae@load-serialized-library) (set! to5b0@make-record-printer (lambda (to6ad@name to6ae@printer) (lambda to6b1@x (begin (display '"record printer") (for-each display to6b1@x))))) (set! to6d5@to5b0@make-record-printer to5b0@make-record-printer) (set! to5b2@compile-core (lambda to6b3@x (apply error 'comile-core '"not implementated" to6b3@x))) (set! to6d6@to5b2@compile-core to5b2@compile-core) (set! to5b4@read-library-source-file (lambda (to6b5@file-name) (with-input-from-file to6b5@file-name to59a@read-annotated))) (set! to6d7@to5b4@read-library-source-file to5b4@read-library-source-file) (set! to5b6@make-parameter (lambda to6c5 (let ((to6c6 (length to6c5))) (if (= to6c6 '1) (apply (lambda (to6b7@x) (to5b6@make-parameter to6b7@x (lambda (to6b9@x) to6b9@x))) to6c5) (if (= to6c6 '2) (apply (lambda (to6bb@x to6bc@fender) (let ((to6bf@x (to6bc@fender to6bb@x))) (lambda to6c3 (let ((to6c4 (length to6c3))) (if (= to6c4 '0) (apply (lambda () to6bf@x) to6c3) (if (= to6c4 '1) (apply (lambda (to6c1@v) (set! to6bf@x (to6bc@fender to6c1@v))) to6c3) (error 'apply '"invalid arg count"))))))) to6c5) (error 'apply '"invalid arg count")))))) (set! to6d8@to5b6@make-parameter to5b6@make-parameter) (set! to5b8@mosh-cache-dir (to5b6@make-parameter '#f)) (set! to6d9@to5b8@mosh-cache-dir to5b8@mosh-cache-dir) (set! to64e@file-options-spec (lambda (to6c7@x) to6c7@x)) (set! to6da@to64e@file-options-spec to64e@file-options-spec) (void))
(begin (set! to6e0@current-primitive-locations (unspecified)) (set! to6e2@mutable? (unspecified)) (set! to6e4@rewriter (unspecified)) (set! to6e6@expanded->core (unspecified)) (set! to6e8@compile-core-expr (unspecified)) (set! to6ea@pretty-print (unspecified)) (set! to6ec@compile-core-expr-to-port (unspecified)) (set! to6e0@current-primitive-locations (to6d8@to5b6@make-parameter (lambda (to6ed@x) '#f) (lambda (to6ef@p) to6ef@p))) (set! to72b@to6e0@current-primitive-locations to6e0@current-primitive-locations) (set! to6e2@mutable? (lambda (to6f1@x) (or (pair? to6f1@x) (vector? to6f1@x) (hashtable? to6f1@x)))) (set! to72c@to6e2@mutable? to6e2@mutable?) (set! to6e4@rewriter (lambda (to6f3@quote-hack?) (letrec* ((to6f6@f (lambda (to6f7@x) (if (pair? to6f7@x) (let ((to6f9@t (car to6f7@x))) (if (memv to6f9@t '(quote)) (if (and to6f3@quote-hack? (to6e2@mutable? (cadr to6f7@x))) (let ((to6fb@g (gensym))) (begin (set-symbol-value! to6fb@g (cadr to6f7@x)) to6fb@g)) to6f7@x) (if (memv to6f9@t '(case-lambda)) (cons 'case-lambda (map (lambda (to6fd@x) (cons (car to6fd@x) (map to6f6@f (cdr to6fd@x)))) (cdr to6f7@x))) (if (memv to6f9@t '(lambda)) (cons* 'lambda (cadr to6f7@x) (map to6f6@f (cddr to6f7@x))) (if (memv to6f9@t '(letrec)) (let ((to6ff@bindings (cadr to6f7@x)) (to700@body* (cddr to6f7@x))) (let ((to703@lhs* (map car to6ff@bindings)) (to704@rhs* (map cadr to6ff@bindings))) (cons* 'letrec (map list to703@lhs* (map to6f6@f to704@rhs*)) (map to6f6@f to700@body*)))) (if (memv to6f9@t '(letrec*)) (let ((to707@bindings (cadr to6f7@x)) (to708@body* (cddr to6f7@x))) (let ((to70b@lhs* (map car to707@bindings)) (to70c@rhs* (map cadr to707@bindings))) (cons* 'letrec* (map list to70b@lhs* (map to6f6@f to70c@rhs*)) (map to6f6@f to708@body*)))) (if (memv to6f9@t '(library-letrec*)) (let ((to70f@name (cadr to6f7@x)) (to710@x (cdr to6f7@x))) (let ((to713@bindings (cadr to710@x)) (to714@body* (cddr to710@x))) (let ((to717@lhs* (map car to713@bindings)) (to718@lhs** (map cadr to713@bindings)) (to719@rhs* (map caddr to713@bindings))) (cons* 'library-letrec* to70f@name (map list to717@lhs* to718@lhs** (map to6f6@f to719@rhs*)) (map to6f6@f to714@body*))))) (if (memv to6f9@t '(begin)) (cons 'begin (map to6f6@f (cdr to6f7@x))) (if (memv to6f9@t '(set!)) (list 'set! (cadr to6f7@x) (to6f6@f (caddr to6f7@x))) (if (memv to6f9@t '(primitive)) (let ((to71d@op (cadr to6f7@x))) (let ((to71f@t ((to6e0@current-primitive-locations) to71d@op))) (if to71f@t ((lambda (to721@loc) to721@loc) to71f@t) to71d@op))) (if (memv to6f9@t '(define)) to6f7@x (if (list? to6f7@x) (map to6f6@f to6f7@x) (error 'rewrite '"invalid form ~s ~s" to6f7@x (list? to6f7@x)))))))))))))) to6f7@x)))) to6f6@f))) (set! to72d@to6e4@rewriter to6e4@rewriter) (set! to6e6@expanded->core (lambda (to723@x) ((to6e4@rewriter '#f) to723@x))) (set! to72e@to6e6@expanded->core to6e6@expanded->core) (set! to6e8@compile-core-expr (lambda (to725@x) ((to6e4@rewriter '#f) to725@x))) (set! to72f@to6e8@compile-core-expr to6e8@compile-core-expr) (set! to6ea@pretty-print write) (set! to730@to6ea@pretty-print to6ea@pretty-print) (set! to6ec@compile-core-expr-to-port (lambda (to727@x to728@p) (to6ea@pretty-print ((to6e4@rewriter '#f) to727@x) to728@p))) (set! to731@to6ec@compile-core-expr-to-port to6ec@compile-core-expr-to-port) (void))
(begin (void))
(begin (set! to780@make-collection (unspecified)) (set! to782@current-library-collection (unspecified)) (set! to784@rp (unspecified)) (set! to78e@library? (unspecified)) (set! to790@library-id (unspecified)) (set! to792@set-library-id! (unspecified)) (set! to794@library-name (unspecified)) (set! to796@set-library-name! (unspecified)) (set! to798@library-version (unspecified)) (set! to79a@set-library-version! (unspecified)) (set! to79c@library-imp* (unspecified)) (set! to79e@set-library-imp*! (unspecified)) (set! to7a0@library-vis* (unspecified)) (set! to7a2@set-library-vis*! (unspecified)) (set! to7a4@library-inv* (unspecified)) (set! to7a6@set-library-inv*! (unspecified)) (set! to7a8@library-subst (unspecified)) (set! to7aa@set-library-subst! (unspecified)) (set! to7ac@library-env (unspecified)) (set! to7ae@set-library-env! (unspecified)) (set! to7b0@library-visit-state (unspecified)) (set! to7b2@set-library-visit-state! (unspecified)) (set! to7b4@library-invoke-state (unspecified)) (set! to7b6@set-library-invoke-state! (unspecified)) (set! to7b8@library-visit-code (unspecified)) (set! to7ba@set-library-visit-code! (unspecified)) (set! to7bc@library-invoke-code (unspecified)) (set! to7be@set-library-invoke-code! (unspecified)) (set! to7c0@library-visible? (unspecified)) (set! to7c2@set-library-visible?! (unspecified)) (set! to7c4@library-source-file-name (unspecified)) (set! to7c6@set-library-source-file-name! (unspecified)) (set! to7c8@dummy (unspecified)) (set! to7ca@find-dependencies (unspecified)) (set! to7cc@find-library-by (unspecified)) (set! to7ce@library-path (unspecified)) (set! to7d0@library-extensions (unspecified)) (set! to7d2@library-name->file-name (unspecified)) (set! to7d4@file-locator (unspecified)) (set! to7d6@serialize-all (unspecified)) (set! to7d8@current-precompiled-library-loader (unspecified)) (set! to7da@try-load-from-file (unspecified)) (set! to7dc@library-loader (unspecified)) (set! to7de@current-library-expander (unspecified)) (set! to7e0@external-pending-libraries (unspecified)) (set! to7e2@find-external-library (unspecified)) (set! to7e4@find-library-by-name (unspecified)) (set! to7e6@library-exists? (unspecified)) (set! to7e8@find-library-by-spec/die (unspecified)) (set! to7ea@label->binding-table (unspecified)) (set! to7ec@install-library-record (unspecified)) (set! to7ee@install-library (unspecified)) (set! to7f0@imported-label->binding (unspecified)) (set! to7f2@invoke-library (unspecified)) (set! to7f4@visit-library (unspecified)) (set! to7f6@invoke-library-by-spec (unspecified)) (set! to7f8@installed-libraries (unspecified)) (set! to7fa@library-spec (unspecified)) (set! to780@make-collection (lambda () (let ((to7fb@set '())) (letrec* ((to7fe@set-cons (lambda (to803@x to804@ls) (if (memq to803@x to804@ls) to804@ls (cons to803@x to804@ls))))) (lambda to801 (let ((to802 (length to801))) (if (= to802 '0) (apply (lambda () to7fb@set) to801) (if (= to802 '1) (apply (lambda (to7ff@x) (set! to7fb@set (to7fe@set-cons to7ff@x to7fb@set))) to801) (error 'apply '"invalid arg count"))))))))) (set! to96f@to780@make-collection to780@make-collection) (set! to782@current-library-collection (to6d8@to5b6@make-parameter (to780@make-collection) (lambda (to807@x) (begin (if (not (procedure? to807@x)) (assertion-violation 'current-library-collection '"not a procedure" to807@x) (void)) to807@x)))) (set! to970@to782@current-library-collection to782@current-library-collection) (set! to784@rp (to6d5@to5b0@make-record-printer 'library (lambda (to809@x to80a@p to80b@wr) (begin (if (not (to78e@library? to809@x)) (assertion-violation 'record-type-printer '"not a library") (void)) (display (format '"#<library ~s>" (if (null? (to798@library-version to809@x)) (to794@library-name to809@x) (append (to794@library-name to809@x) (list (to798@library-version to809@x))))) to80a@p))))) (set! to971@to784@rp to784@rp) (set! to78e@library? (lambda (to80f@x) (and (simple-struct? to80f@x) (eq? (simple-struct-name to80f@x) 'library)))) (set! to972@to78e@library? to78e@library?) (set! to790@library-id (lambda (to811@x) (simple-struct-ref to811@x '0))) (set! to973@to790@library-id to790@library-id) (set! to792@set-library-id! (lambda (to813@x to814@val) (simple-struct-set! to813@x '0 to814@val))) (set! to974@to792@set-library-id! to792@set-library-id!) (set! to794@library-name (lambda (to817@x) (simple-struct-ref to817@x '1))) (set! to975@to794@library-name to794@library-name) (set! to796@set-library-name! (lambda (to819@x to81a@val) (simple-struct-set! to819@x '1 to81a@val))) (set! to976@to796@set-library-name! to796@set-library-name!) (set! to798@library-version (lambda (to81d@x) (simple-struct-ref to81d@x '2))) (set! to977@to798@library-version to798@library-version) (set! to79a@set-library-version! (lambda (to81f@x to820@val) (simple-struct-set! to81f@x '2 to820@val))) (set! to978@to79a@set-library-version! to79a@set-library-version!) (set! to79c@library-imp* (lambda (to823@x) (simple-struct-ref to823@x '3))) (set! to979@to79c@library-imp* to79c@library-imp*) (set! to79e@set-library-imp*! (lambda (to825@x to826@val) (simple-struct-set! to825@x '3 to826@val))) (set! to97a@to79e@set-library-imp*! to79e@set-library-imp*!) (set! to7a0@library-vis* (lambda (to829@x) (simple-struct-ref to829@x '4))) (set! to97b@to7a0@library-vis* to7a0@library-vis*) (set! to7a2@set-library-vis*! (lambda (to82b@x to82c@val) (simple-struct-set! to82b@x '4 to82c@val))) (set! to97c@to7a2@set-library-vis*! to7a2@set-library-vis*!) (set! to7a4@library-inv* (lambda (to82f@x) (simple-struct-ref to82f@x '5))) (set! to97d@to7a4@library-inv* to7a4@library-inv*) (set! to7a6@set-library-inv*! (lambda (to831@x to832@val) (simple-struct-set! to831@x '5 to832@val))) (set! to97e@to7a6@set-library-inv*! to7a6@set-library-inv*!) (set! to7a8@library-subst (lambda (to835@x) (simple-struct-ref to835@x '6))) (set! to97f@to7a8@library-subst to7a8@library-subst) (set! to7aa@set-library-subst! (lambda (to837@x to838@val) (simple-struct-set! to837@x '6 to838@val))) (set! to980@to7aa@set-library-subst! to7aa@set-library-subst!) (set! to7ac@library-env (lambda (to83b@x) (simple-struct-ref to83b@x '7))) (set! to981@to7ac@library-env to7ac@library-env) (set! to7ae@set-library-env! (lambda (to83d@x to83e@val) (simple-struct-set! to83d@x '7 to83e@val))) (set! to982@to7ae@set-library-env! to7ae@set-library-env!) (set! to7b0@library-visit-state (lambda (to841@x) (simple-struct-ref to841@x '8))) (set! to983@to7b0@library-visit-state to7b0@library-visit-state) (set! to7b2@set-library-visit-state! (lambda (to843@x to844@val) (simple-struct-set! to843@x '8 to844@val))) (set! to984@to7b2@set-library-visit-state! to7b2@set-library-visit-state!) (set! to7b4@library-invoke-state (lambda (to847@x) (simple-struct-ref to847@x '9))) (set! to985@to7b4@library-invoke-state to7b4@library-invoke-state) (set! to7b6@set-library-invoke-state! (lambda (to849@x to84a@val) (simple-struct-set! to849@x '9 to84a@val))) (set! to986@to7b6@set-library-invoke-state! to7b6@set-library-invoke-state!) (set! to7b8@library-visit-code (lambda (to84d@x) (simple-struct-ref to84d@x '10))) (set! to987@to7b8@library-visit-code to7b8@library-visit-code) (set! to7ba@set-library-visit-code! (lambda (to84f@x to850@val) (simple-struct-set! to84f@x '10 to850@val))) (set! to988@to7ba@set-library-visit-code! to7ba@set-library-visit-code!) (set! to7bc@library-invoke-code (lambda (to853@x) (simple-struct-ref to853@x '11))) (set! to989@to7bc@library-invoke-code to7bc@library-invoke-code) (set! to7be@set-library-invoke-code! (lambda (to855@x to856@val) (simple-struct-set! to855@x '11 to856@val))) (set! to98a@to7be@set-library-invoke-code! to7be@set-library-invoke-code!) (set! to7c0@library-visible? (lambda (to859@x) (simple-struct-ref to859@x '12))) (set! to98b@to7c0@library-visible? to7c0@library-visible?) (set! to7c2@set-library-visible?! (lambda (to85b@x to85c@val) (simple-struct-set! to85b@x '12 to85c@val))) (set! to98c@to7c2@set-library-visible?! to7c2@set-library-visible?!) (set! to7c4@library-source-file-name (lambda (to85f@x) (simple-struct-ref to85f@x '13))) (set! to98d@to7c4@library-source-file-name to7c4@library-source-file-name) (set! to7c6@set-library-source-file-name! (lambda (to861@x to862@val) (simple-struct-set! to861@x '13 to862@val))) (set! to98e@to7c6@set-library-source-file-name! to7c6@set-library-source-file-name!) (set! to7c8@dummy '3) (set! to98f@to7c8@dummy to7c8@dummy) (set! to7ca@find-dependencies (lambda (to865@ls) (if (null? to865@ls) '() (assertion-violation 'find-dependencies '"cannot handle deps yet")))) (set! to990@to7ca@find-dependencies to7ca@find-dependencies) (set! to7cc@find-library-by (lambda (to867@pred) (let to86b@f ((to869@ls ((to782@current-library-collection)))) (if (null? to869@ls) '#f (if (to867@pred (car to869@ls)) (car to869@ls) (to86b@f (cdr to869@ls))))))) (set! to991@to7cc@find-library-by to7cc@find-library-by) (set! to7ce@library-path (to6d8@to5b6@make-parameter '(".") (lambda (to86d@x) (if (and (list? to86d@x) (for-all string? to86d@x)) (map (lambda (to86f@x) to86f@x) to86d@x) (assertion-violation 'library-path '"not a list of strings" to86d@x))))) (set! to992@to7ce@library-path to7ce@library-path) (set! to7d0@library-extensions (to6d8@to5b6@make-parameter '(".sls" ".ss" ".scm") (lambda (to871@x) (if (and (list? to871@x) (for-all string? to871@x)) (map (lambda (to873@x) to873@x) to871@x) (assertion-violation 'library-extensions '"not a list of strings" to871@x))))) (set! to993@to7d0@library-extensions to7d0@library-extensions) (set! to7d2@library-name->file-name (lambda (to875@x) (call-with-values (lambda () (open-string-output-port)) (lambda (to87b@to878 to87c@to87a) (let ((to87f@extract to87c@to87a) (to880@p to87b@to878)) (letrec* ((to884@display-hex (lambda (to88d@n) (if (<= '0 to88d@n '9) (display to88d@n to880@p) (display (integer->char (+ (char->integer '#\a) (- to88d@n '10))) to880@p))))) (begin (let to887@f ((to885@ls to875@x)) (if (not (null? to885@ls)) (begin (display '"/" to880@p) (for-each (lambda (to889@c) (if (or (char<=? '#\a to889@c '#\z) (char<=? '#\A to889@c '#\Z) (char<=? '#\0 to889@c '#\9) (memv to889@c '(#\- #\. #\_ #\~))) (display to889@c to880@p) (begin (display '"%" to880@p) (let ((to88b@n (char->integer to889@c))) (begin (to884@display-hex (quotient to88b@n '16)) (to884@display-hex (remainder to88b@n '16))))))) (string->list (symbol->string (car to885@ls)))) (to887@f (cdr to885@ls))) (void))) (to87f@extract)))))))) (set! to994@to7d2@library-name->file-name to7d2@library-name->file-name) (set! to7d4@file-locator (to6d8@to5b6@make-parameter (lambda (to88f@x) (let ((to891@str (to7d2@library-name->file-name to88f@x))) (let to899@f ((to893@ls (to7ce@library-path)) (to894@exts (to7d0@library-extensions)) (to895@failed-list '())) (if (null? to893@ls) (letrec* ((to8a3@to89e (make-record-type-descriptor '&library-resolution &condition-rtd 'to8a1 '#f '#f '#((immutable library) (immutable files)))) (to8a5@to8a0 '#f) (to8a7@to89f (make-record-constructor-descriptor to8a3@to89e &condition-rcd to8a5@to8a0)) (to8aa@to89d (record-predicate to8a3@to89e)) (to8ac@make-library-resolution-condition (record-constructor to8a7@to89f)) (to8ae@to89b (record-accessor to8a3@to89e '0)) (to8b0@to89c (record-accessor to8a3@to89e '1)) (to8b2@library-resolution-condition? (condition-predicate to8a3@to89e)) (to8b4@condition-library (condition-accessor to8a3@to89e to8ae@to89b)) (to8b6@condition-files (condition-accessor to8a3@to89e to8b0@to89c))) (raise (condition (make-error) (make-who-condition 'expander) (make-message-condition '"cannot locate library in library-path") (to8ac@make-library-resolution-condition to88f@x (reverse to895@failed-list))))) (if (null? to894@exts) (to899@f (cdr to893@ls) (to7d0@library-extensions) to895@failed-list) (let ((to8b7@name (string-append (car to893@ls) to891@str (car to894@exts)))) (if (file-exists? to8b7@name) to8b7@name (to899@f to893@ls (cdr to894@exts) (cons to8b7@name to895@failed-list))))))))) (lambda (to8b9@f) (if (procedure? to8b9@f) to8b9@f (assertion-violation 'file-locator '"not a procedure" to8b9@f))))) (set! to995@to7d4@file-locator to7d4@file-locator) (set! to7d6@serialize-all (lambda (to8bb@serialize to8bc@compile) (letrec* ((to8c0@library-desc (lambda (to8c3@x) (list (to790@library-id to8c3@x) (to794@library-name to8c3@x))))) (for-each (lambda (to8c1@x) (if (to7c4@library-source-file-name to8c1@x) (to8bb@serialize (to7c4@library-source-file-name to8c1@x) (list (to790@library-id to8c1@x) (to794@library-name to8c1@x) (to798@library-version to8c1@x) (map to8c0@library-desc (to79c@library-imp* to8c1@x)) (map to8c0@library-desc (to7a0@library-vis* to8c1@x)) (map to8c0@library-desc (to7a4@library-inv* to8c1@x)) (to7a8@library-subst to8c1@x) (to7ac@library-env to8c1@x) (to8bc@compile (to7b8@library-visit-code to8c1@x)) (to8bc@compile (to7bc@library-invoke-code to8c1@x)) (to7c0@library-visible? to8c1@x))) (void))) ((to782@current-library-collection)))))) (set! to996@to7d6@serialize-all to7d6@serialize-all) (set! to7d8@current-precompiled-library-loader (to6d8@to5b6@make-parameter (lambda (to8c5@filename to8c6@sk) '#f))) (set! to997@to7d8@current-precompiled-library-loader to7d8@current-precompiled-library-loader) (set! to7da@try-load-from-file (lambda (to8c9@filename) ((to7d8@current-precompiled-library-loader) to8c9@filename (lambda to8ef (let ((to8f0 (length to8ef))) (if (= to8f0 '11) (apply (lambda (to8cb@id to8cc@name to8cd@ver to8ce@imp* to8cf@vis* to8d0@inv* to8d1@exp-subst to8d2@exp-env to8d3@visit-proc to8d4@invoke-proc to8d5@visible?) (let to8e3@f ((to8e1@deps (append to8ce@imp* to8cf@vis* to8d0@inv*))) (if (null? to8e1@deps) (begin (to7ee@install-library to8cb@id to8cc@name to8cd@ver to8ce@imp* to8cf@vis* to8d0@inv* to8d1@exp-subst to8d2@exp-env to8d3@visit-proc to8d4@invoke-proc '#f '#f to8d5@visible? '#f) '#t) (let ((to8e5@d (car to8e1@deps))) (let ((to8e7@label (car to8e5@d)) (to8e8@dname (cadr to8e5@d))) (let ((to8eb@l (to7e4@find-library-by-name to8e8@dname))) (if (and (to78e@library? to8eb@l) (eq? to8e7@label (to790@library-id to8eb@l))) (to8e3@f (cdr to8e1@deps)) (begin (if to6d2@to5aa@verbose? (format (current-error-port) '"WARNING: library ~e has an inconsistent dependency on library ~e; file ~e will be recompiled from source. \n" to8cc@name to8e8@dname to8c9@filename) (void)) '#f)))))))) to8ef) (if (>= to8f0 '0) (apply (lambda to8ed@others '#f) to8ef) (error 'apply '"invalid arg count")))))))) (set! to998@to7da@try-load-from-file to7da@try-load-from-file) (set! to7dc@library-loader (to6d8@to5b6@make-parameter (lambda (to8f1@x) (let ((to8f3@file-name ((to7d4@file-locator) to8f1@x))) (if (not to8f3@file-name) (assertion-violation '#f '"cannot file library" to8f1@x) (or (to7da@try-load-from-file to8f3@file-name) ((to7de@current-library-expander) (to6d7@to5b4@read-library-source-file to8f3@file-name) to8f3@file-name (lambda (to8f5@name) (if (not (fast-equal? to8f5@name to8f1@x)) (assertion-violation 'import (call-with-values (lambda () (open-string-output-port)) (lambda (to8fb@to8f8 to8fc@to8fa) (let ((to8ff@e to8fc@to8fa) (to900@p to8fb@to8f8)) (begin (display '"expected to find library " to900@p) (write to8f1@x to900@p) (display '" in file " to900@p) (display to8f3@file-name to900@p) (display '", found " to900@p) (write to8f5@name to900@p) (display '" instead" to900@p) (to8ff@e)))))) (void)))))))) (lambda (to903@f) (if (procedure? to903@f) to903@f (assertion-violation 'library-locator '"not a procedure" to903@f))))) (set! to999@to7dc@library-loader to7dc@library-loader) (set! to7de@current-library-expander (to6d8@to5b6@make-parameter (lambda (to905@x) (assertion-violation 'library-expander '"not initialized")) (lambda (to907@f) (if (procedure? to907@f) to907@f (assertion-violation 'library-expander '"not a procedure" to907@f))))) (set! to99a@to7de@current-library-expander to7de@current-library-expander) (set! to7e0@external-pending-libraries (to6d8@to5b6@make-parameter '())) (set! to99b@to7e0@external-pending-libraries to7e0@external-pending-libraries) (set! to7e2@find-external-library (lambda (to909@name) (begin (if (member to909@name (to7e0@external-pending-libraries)) (assertion-violation '#f '"circular attempt to import library was detected" to909@name) (void)) (let ((to90f@to90c to7e0@external-pending-libraries) (to910@to90e (cons to909@name (to7e0@external-pending-libraries)))) (let ((to913@swap (lambda () (let ((to915@t (to90f@to90c))) (begin (to90f@to90c to910@to90e) (set! to910@to90e to915@t)))))) (dynamic-wind to913@swap (lambda () (begin ((to7dc@library-loader) to909@name) (or (to7cc@find-library-by (lambda (to917@x) (fast-equal? (to794@library-name to917@x) to909@name))) (assertion-violation '#f '"handling external library did not yield the correct library" to909@name)))) to913@swap)))))) (set! to99c@to7e2@find-external-library to7e2@find-external-library) (set! to7e4@find-library-by-name (lambda (to919@name) (or (to7cc@find-library-by (lambda (to91b@x) (fast-equal? (to794@library-name to91b@x) to919@name))) (to7e2@find-external-library to919@name)))) (set! to99d@to7e4@find-library-by-name to7e4@find-library-by-name) (set! to7e6@library-exists? (lambda (to91d@name) (and (to7cc@find-library-by (lambda (to91f@x) (fast-equal? (to794@library-name to91f@x) to91d@name))) '#t))) (set! to99e@to7e6@library-exists? to7e6@library-exists?) (set! to7e8@find-library-by-spec/die (lambda (to921@spec) (let ((to923@id (car to921@spec))) (or (to7cc@find-library-by (lambda (to925@x) (eq? to923@id (to790@library-id to925@x)))) (assertion-violation '#f '"cannot find library with required spec" to921@spec))))) (set! to99f@to7e8@find-library-by-spec/die to7e8@find-library-by-spec/die) (set! to7ea@label->binding-table (make-eq-hashtable)) (set! to9a0@to7ea@label->binding-table to7ea@label->binding-table) (set! to7ec@install-library-record (lambda (to927@lib) (begin (let ((to929@exp-env (to7ac@library-env to927@lib))) (for-each (lambda (to92b@x) (let ((to92d@label (car to92b@x)) (to92e@binding (cdr to92b@x))) (let ((to931@binding (let ((to933@t (car to92e@binding))) (if (memv to933@t '(global)) (cons 'global (cons to927@lib (cdr to92e@binding))) (if (memv to933@t '(global-macro)) (cons 'global-macro (cons to927@lib (cdr to92e@binding))) (if (memv to933@t '(global-macro!)) (cons 'global-macro! (cons to927@lib (cdr to92e@binding))) to92e@binding)))))) (begin (if (hashtable-ref to7ea@label->binding-table to92d@label '#f) (begin (format (current-error-port) '"FATAL overwrite !! key=~a value=~a to ~a\n" to92d@label (hashtable-ref to7ea@label->binding-table to92d@label '#f) to931@binding) (exit)) (void)) (hashtable-set! to7ea@label->binding-table to92d@label to931@binding))))) to929@exp-env)) ((to782@current-library-collection) to927@lib)))) (set! to9a1@to7ec@install-library-record to7ec@install-library-record) (set! to7ee@install-library (lambda (to935@id to936@name to937@ver to938@imp* to939@vis* to93a@inv* to93b@exp-subst to93c@exp-env to93d@visit-proc to93e@invoke-proc to93f@visit-code to940@invoke-code to941@visible? to942@source-file-name) (let ((to951@imp-lib* (map to7e8@find-library-by-spec/die to938@imp*)) (to952@vis-lib* (map to7e8@find-library-by-spec/die to939@vis*)) (to953@inv-lib* (map to7e8@find-library-by-spec/die to93a@inv*))) (begin (if (not (and (symbol? to935@id) (list? to936@name) (list? to937@ver))) (assertion-violation 'install-library '"invalid spec with id/name/ver" to935@id to936@name to937@ver) (void)) (if (to7e6@library-exists? to936@name) (assertion-violation 'install-library '"library is already installed" to936@name) (void)) (let ((to957@lib (make-simple-struct 'library '15 (list to935@id to936@name to937@ver to951@imp-lib* to952@vis-lib* to953@inv-lib* to93b@exp-subst to93c@exp-env to93d@visit-proc to93e@invoke-proc to93f@visit-code to940@invoke-code to941@visible? to942@source-file-name)))) (to7ec@install-library-record to957@lib)))))) (set! to9a2@to7ee@install-library to7ee@install-library) (set! to7f0@imported-label->binding (lambda (to959@lab) (hashtable-ref to7ea@label->binding-table to959@lab '#f))) (set! to9a3@to7f0@imported-label->binding to7f0@imported-label->binding) (set! to7f2@invoke-library (lambda (to95b@lib) (let ((to95d@invoke (to7b4@library-invoke-state to95b@lib))) (if (procedure? to95d@invoke) (begin (to7b6@set-library-invoke-state! to95b@lib (lambda () (assertion-violation 'invoke '"circularity detected" to95b@lib))) (for-each to7f2@invoke-library (to7a4@library-inv* to95b@lib)) (to7b6@set-library-invoke-state! to95b@lib (lambda () (assertion-violation 'invoke '"first invoke did not return" to95b@lib))) (to95d@invoke) (to7b6@set-library-invoke-state! to95b@lib '#t)) (void))))) (set! to9a4@to7f2@invoke-library to7f2@invoke-library) (set! to7f4@visit-library (lambda (to95f@lib) (let ((to961@visit (to7b0@library-visit-state to95f@lib))) (if (procedure? to961@visit) (begin (to7b2@set-library-visit-state! to95f@lib (lambda () (assertion-violation 'visit '"circularity detected" to95f@lib))) (for-each to7f2@invoke-library (to7a0@library-vis* to95f@lib)) (to7b2@set-library-visit-state! to95f@lib (lambda () (assertion-violation 'invoke '"first visit did not return" to95f@lib))) (to961@visit) (to7b2@set-library-visit-state! to95f@lib '#t)) (void))))) (set! to9a5@to7f4@visit-library to7f4@visit-library) (set! to7f6@invoke-library-by-spec (lambda (to963@spec) (to7f2@invoke-library (to7e8@find-library-by-spec/die to963@spec)))) (set! to9a6@to7f6@invoke-library-by-spec to7f6@invoke-library-by-spec) (set! to7f8@installed-libraries (lambda to96b (let ((to96c (length to96b))) (if (= to96c '1) (apply (lambda (to965@all?) (let to969@f ((to967@ls ((to782@current-library-collection)))) (if (null? to967@ls) '() (if (or to965@all? (to7c0@library-visible? (car to967@ls))) (cons (car to967@ls) (to969@f (cdr to967@ls))) (to969@f (cdr to967@ls)))))) to96b) (if (= to96c '0) (apply (lambda () (to7f8@installed-libraries '#f)) to96b) (error 'apply '"invalid arg count")))))) (set! to9a7@to7f8@installed-libraries to7f8@installed-libraries) (set! to7fa@library-spec (lambda (to96d@x) (begin (if (not (to78e@library? to96d@x)) (assertion-violation 'library-spec '"not a library" to96d@x) (void)) (list (to790@library-id to96d@x) (to794@library-name to96d@x) (to798@library-version to96d@x))))) (set! to9a8@to7fa@library-spec to7fa@library-spec) (void))
(begin (set! to9ac@build-global-define (unspecified)) (set! toa1d@build-lambda (unspecified)) (set! toa1f@build-case-lambda (unspecified)) (set! toa4d@build-sequence (unspecified)) (set! toa4f@build-void (unspecified)) (set! toa51@build-letrec (unspecified)) (set! toa53@build-let (unspecified)) (set! toa55@build-named-let (unspecified)) (set! toa57@build-letrec* (unspecified)) (set! toa59@build-library-letrec* (unspecified)) (set! toa5b@build-receive (unspecified)) (set! to9ac@build-global-define (lambda (toa5c@x) (toa4f@build-void))) (set! toaea@to9ac@build-global-define to9ac@build-global-define) (set! toa1d@build-lambda (lambda (toa5e@ae toa5f@vars toa60@exp) (list 'lambda toa5f@vars toa60@exp))) (set! toaeb@toa1d@build-lambda toa1d@build-lambda) (set! toa1f@build-case-lambda (lambda (toa64@ae toa65@vars* toa66@exp*) (letrec* ((toa6b@build-error (lambda (toaa2@ae) (list '(primitive error) ''apply (list 'quote '"invalid arg count")))) (toa6d@build-pred (lambda (toa8a@ae toa8b@n toa8c@vars) (call-with-values (lambda () (let toa98@f ((toa94@vars toa8c@vars) (toa95@count '0)) (if (pair? toa94@vars) (toa98@f (cdr toa94@vars) (+ toa95@count '1)) (if (null? toa94@vars) (values toa95@count '=) (values toa95@count '>=))))) (lambda (toa9a@toa91 toa9b@toa93) (let ((toa9e@pred toa9b@toa93) (toa9f@count toa9a@toa91)) (list (list 'primitive toa9e@pred) toa8b@n (list 'quote toa9f@count))))))) (toa6f@build-apply (lambda (toa82@ae toa83@g toa84@vars toa85@exp) (list '(primitive apply) (toa1d@build-lambda toa82@ae toa84@vars toa85@exp) toa83@g))) (toa71@expand-case-lambda (lambda (toa72@ae toa73@vars toa74@exp*) (let ((toa78@g (gensym)) (toa79@n (gensym))) (list 'lambda toa78@g (toa53@build-let toa72@ae (list toa79@n) (list (list '(primitive length) toa78@g)) (let toa80@f ((toa7c@vars* toa65@vars*) (toa7d@exp* toa74@exp*)) (if (null? toa7c@vars*) (toa6b@build-error toa72@ae) (list 'if (toa6d@build-pred toa72@ae toa79@n (car toa7c@vars*)) (toa6f@build-apply toa72@ae toa78@g (car toa7c@vars*) (car toa7d@exp*)) (toa80@f (cdr toa7c@vars*) (cdr toa7d@exp*))))))))))) (if (= (length toa66@exp*) '1) (toa1d@build-lambda toa64@ae (car toa65@vars*) (car toa66@exp*)) (toa71@expand-case-lambda toa64@ae toa65@vars* toa66@exp*))))) (set! toaec@toa1f@build-case-lambda toa1f@build-case-lambda) (set! toa4d@build-sequence (lambda (toaa4@ae toaa5@exps) (let toaaa@loop ((toaa8@exps toaa5@exps)) (if (null? (cdr toaa8@exps)) (car toaa8@exps) (if (equal? (car toaa8@exps) (toa4f@build-void)) (toaaa@loop (cdr toaa8@exps)) (cons 'begin toaa8@exps)))))) (set! toaed@toa4d@build-sequence toa4d@build-sequence) (set! toa4f@build-void (lambda () '((primitive void)))) (set! toaee@toa4f@build-void toa4f@build-void) (set! toa51@build-letrec (lambda (toaac@ae toaad@vars toaae@val-exps toaaf@body-exp) (if (null? toaad@vars) toaaf@body-exp (list 'letrec (map list toaad@vars toaae@val-exps) toaaf@body-exp)))) (set! toaef@toa51@build-letrec toa51@build-letrec) (set! toa53@build-let (lambda (toab4@ae toab5@vars toab6@val-exps toab7@body-exp) (if (null? toab5@vars) toab7@body-exp (list 'let (map list toab5@vars toab6@val-exps) toab7@body-exp)))) (set! toaf0@toa53@build-let toa53@build-let) (set! toa55@build-named-let (lambda (toabc@ae toabd@name toabe@vars toabf@val-exps toac0@body-exp) (list 'let toabd@name (map list toabe@vars toabf@val-exps) toac0@body-exp))) (set! toaf1@toa55@build-named-let toa55@build-named-let) (set! toa57@build-letrec* (lambda (toac6@ae toac7@vars toac8@val-exps toac9@body-exp) (if (null? toac7@vars) toac9@body-exp (list 'letrec* (map list toac7@vars toac8@val-exps) toac9@body-exp)))) (set! toaf2@toa57@build-letrec* toa57@build-letrec*) (set! toa59@build-library-letrec* (lambda (toace@ae toacf@name toad0@vars toad1@locs toad2@val-exps toad3@body-exp) (cons 'begin (append (map (lambda (toada@var) (cons 'set! (cons toada@var '((unspecified))))) toad0@vars) (append (apply append (map (lambda (toadc@var toadd@loc toade@val-exp) (list (list 'set! toadc@var toade@val-exp) (list 'set! toadd@loc toadc@var))) toad0@vars toad1@locs toad2@val-exps)) (list toad3@body-exp)))))) (set! toaf3@toa59@build-library-letrec* toa59@build-library-letrec*) (set! toa5b@build-receive (lambda (toae2@ae toae3@vars toae4@producer toae5@body*) (begin (display '"************** in ") (cons 'receive (cons toae3@vars (cons toae4@producer toae5@body*)))))) (set! toaf4@toa5b@build-receive toa5b@build-receive) (void))
(begin (set! tob03@file-options-macro (unspecified)) (set! tob05@set-cons (unspecified)) (set! tob07@set-union (unspecified)) (set! tob0c@top-mark* (unspecified)) (set! tob0e@top-marked? (unspecified)) (set! tob10@gen-lexical (unspecified)) (set! tob12@gen-global (unspecified)) (set! tob14@gen-label (unspecified)) (set! tob16@gen-top-level-label (unspecified)) (set! tob18@gen-define-label+loc (unspecified)) (set! tob1a@gen-define-label (unspecified)) (set! tob24@rib? (unspecified)) (set! tob26@rib-sym* (unspecified)) (set! tob28@set-rib-sym*! (unspecified)) (set! tob2a@rib-mark** (unspecified)) (set! tob2c@set-rib-mark**! (unspecified)) (set! tob2e@rib-label* (unspecified)) (set! tob30@set-rib-label*! (unspecified)) (set! tob32@rib-sealed/freq (unspecified)) (set! tob34@set-rib-sealed/freq! (unspecified)) (set! tob36@rib-cache (unspecified)) (set! tob38@set-rib-cache! (unspecified)) (set! tob3a@dummy (unspecified)) (set! tob3c@make-empty-rib (unspecified)) (set! tob3e@extend-rib! (unspecified)) (set! tob40@extend-rib/nc! (unspecified)) (set! tob42@make-rib-map (unspecified)) (set! tob44@seal-rib! (unspecified)) (set! tob46@unseal-rib! (unspecified)) (set! tob48@make-full-rib (unspecified)) (set! tob4a@rp (unspecified)) (set! tob54@stx? (unspecified)) (set! tob56@stx-expr (unspecified)) (set! tob58@set-stx-expr! (unspecified)) (set! tob5a@stx-mark* (unspecified)) (set! tob5c@set-stx-mark*! (unspecified)) (set! tob5e@stx-subst* (unspecified)) (set! tob60@set-stx-subst*! (unspecified)) (set! tob62@stx-ae* (unspecified)) (set! tob64@set-stx-ae*! (unspecified)) (set! tob66@dummy (unspecified)) (set! tob68@datum->stx (unspecified)) (set! tob6a@gen-mark (unspecified)) (set! tob6c@anti-mark (unspecified)) (set! tob6e@anti-mark? (unspecified)) (set! tob70@mkstx (unspecified)) (set! tob72@add-subst (unspecified)) (set! tob74@add-mark (unspecified)) (set! tob76@syntax-kind? (unspecified)) (set! tob78@syntax-vector->list (unspecified)) (set! tob7a@syntax-pair? (unspecified)) (set! tob7c@syntax-vector? (unspecified)) (set! tob7e@syntax-null? (unspecified)) (set! tob80@syntax-list? (unspecified)) (set! tob82@syntax-car (unspecified)) (set! tob84@syntax-cdr (unspecified)) (set! tob86@syntax->list (unspecified)) (set! tob88@id? (unspecified)) (set! tob8a@id->sym (unspecified)) (set! tob8c@bound-id=? (unspecified)) (set! tob8e@free-id=? (unspecified)) (set! tob90@valid-bound-ids? (unspecified)) (set! tob92@distinct-bound-ids? (unspecified)) (set! tob94@bound-id-member? (unspecified)) (set! tob96@self-evaluating? (unspecified)) (set! tob98@strip-annotations (unspecified)) (set! tob9a@strip (unspecified)) (set! tob9c@stx->datum (unspecified)) (set! tob9e@id->label (unspecified)) (set! toba0@label->binding (unspecified)) (set! toba2@make-binding (unspecified)) (set! toba4@binding-type (unspecified)) (set! toba6@binding-value (unspecified)) (set! toba8@raise-unbound-error (unspecified)) (set! tobaa@syntax-type (unspecified)) (set! tobb8@sanitize-binding (unspecified)) (set! tobba@make-variable-transformer (unspecified)) (set! tobbc@variable-transformer? (unspecified)) (set! tobbe@variable-transformer-procedure (unspecified)) (set! tobc0@make-eval-transformer (unspecified)) (set! tod11@parse-define (unspecified)) (set! tod13@parse-define-syntax (unspecified)) (set! tod15@scheme-stx-hashtable (unspecified)) (set! tod17@scheme-stx (unspecified)) (set! tod19@lexical-var (unspecified)) (set! tod1b@lexical-mutable? (unspecified)) (set! tod1d@set-lexical-mutable! (unspecified)) (set! tod1f@add-lexical (unspecified)) (set! tod21@add-lexicals (unspecified)) (set! tod23@letrec-helper (unspecified)) (set! tod25@let-transformer (unspecified)) (set! tod27@letrec-transformer (unspecified)) (set! tod29@letrec*-transformer (unspecified)) (set! tod2b@fluid-let-syntax-transformer (unspecified)) (set! tod2d@type-descriptor-transformer (unspecified)) (set! tod2f@record-type-descriptor-transformer (unspecified)) (set! tod31@record-constructor-descriptor-transformer (unspecified)) (set! tod33@when-macro (unspecified)) (set! tod35@unless-macro (unspecified)) (set! tod37@if-transformer (unspecified)) (set! tod39@and-transformer (unspecified)) (set! tod3b@or-transformer (unspecified)) (set! tod3d@case-macro (unspecified)) (set! tod3f@quote-transformer (unspecified)) (set! tod41@case-lambda-transformer (unspecified)) (set! tod43@lambda-transformer (unspecified)) (set! tod45@bless (unspecified)) (set! tod47@with-syntax-macro (unspecified)) (set! tod49@invalid-fmls-error (unspecified)) (set! tod4b@let-macro (unspecified)) (set! tod4d@let-values-macro (unspecified)) (set! tod4f@let*-values-macro (unspecified)) (set! tod51@trace-lambda-macro (unspecified)) (set! tod53@trace-define-macro (unspecified)) (set! tod55@trace-define-syntax-macro (unspecified)) (set! tod57@trace-let/rec-syntax (unspecified)) (set! tod59@trace-let-syntax-macro (unspecified)) (set! tod5b@trace-letrec-syntax-macro (unspecified)) (set! tod5d@guard-macro (unspecified)) (set! tod5f@define-enumeration-macro (unspecified)) (set! tod61@time-macro (unspecified)) (set! tod63@delay-macro (unspecified)) (set! tod65@assert-macro (unspecified)) (set! tod67@endianness-macro (unspecified)) (set! tod69@identifier-syntax-macro (unspecified)) (set! tod6b@do-macro (unspecified)) (set! tod6d@let*-macro (unspecified)) (set! tod6f@or-macro (unspecified)) (set! tod71@and-macro (unspecified)) (set! tod73@cond-macro (unspecified)) (set! tod75@do-include (unspecified)) (set! tod77@include-macro (unspecified)) (set! tod79@include-into-macro (unspecified)) (set! tod7b@syntax-rules-macro (unspecified)) (set! tod7d@quasiquote-macro (unspecified)) (set! tod7f@quasisyntax-macro (unspecified)) (set! tod81@define-struct-macro (unspecified)) (set! tod83@define-record-type-macro (unspecified)) (set! tod85@define-condition-type-macro (unspecified)) (set! tod87@incorrect-usage-macro (unspecified)) (set! tod89@parameterize-macro (unspecified)) (set! tod8b@foreign-call-transformer (unspecified)) (set! tod8d@convert-pattern (unspecified)) (set! tod8f@syntax-dispatch (unspecified)) (set! tod91@ellipsis? (unspecified)) (set! tod93@underscore? (unspecified)) (set! tod95@verify-literals (unspecified)) (set! tod97@syntax-case-transformer (unspecified)) (set! tod99@ellipsis-map (unspecified)) (set! tod9b@syntax-transformer (unspecified)) (set! tod9d@core-macro-transformer (unspecified)) (set! tod9f@symbol-macro (unspecified)) (set! toda1@macro-transformer (unspecified)) (set! toda3@local-macro-transformer (unspecified)) (set! toda5@do-macro-call (unspecified)) (set! toda7@chi-macro (unspecified)) (set! toda9@chi-local-macro (unspecified)) (set! todab@chi-global-macro (unspecified)) (set! todad@chi-expr* (unspecified)) (set! todaf@chi-application (unspecified)) (set! todb1@chi-expr (unspecified)) (set! todb3@chi-set! (unspecified)) (set! todb5@verify-formals (unspecified)) (set! todb7@chi-lambda-clause (unspecified)) (set! todb9@chi-lambda-clause* (unspecified)) (set! todbb@chi-defun (unspecified)) (set! todbd@chi-rhs (unspecified)) (set! todbf@expand-interaction-rhs*/init* (unspecified)) (set! todc1@chi-rhs* (unspecified)) (set! todc3@find-bound=? (unspecified)) (set! todc5@find-dups (unspecified)) (set! todc7@chi-internal (unspecified)) (set! todc9@parse-module (unspecified)) (set! todd3@module-interface? (unspecified)) (set! todd5@module-interface-first-mark (unspecified)) (set! todd7@set-module-interface-first-mark! (unspecified)) (set! todd9@module-interface-exp-id-vec (unspecified)) (set! toddb@set-module-interface-exp-id-vec! (unspecified)) (set! toddd@module-interface-exp-lab-vec (unspecified)) (set! toddf@set-module-interface-exp-lab-vec! (unspecified)) (set! tode1@dummy (unspecified)) (set! tode3@module-interface-exp-id* (unspecified)) (set! tode5@chi-internal-module (unspecified)) (set! tode7@chi-body* (unspecified)) (set! tode9@expand-transformer (unspecified)) (set! todeb@parse-exports (unspecified)) (set! toded@parse-library-name (unspecified)) (set! todef@parse-library (unspecified)) (set! todf1@parse-import-spec* (unspecified)) (set! todf3@make-top-rib (unspecified)) (set! todf5@make-collector (unspecified)) (set! todf7@inv-collector (unspecified)) (set! todf9@vis-collector (unspecified)) (set! todfb@imp-collector (unspecified)) (set! todfd@chi-library-internal (unspecified)) (set! todff@chi-interaction-expr (unspecified)) (set! toe01@library-body-expander (unspecified)) (set! toe03@core-library-expander (unspecified)) (set! toe05@parse-top-level-program (unspecified)) (set! toe07@top-level-expander (unspecified)) (set! toe09@rp (unspecified)) (set! toe13@env? (unspecified)) (set! toe15@env-names (unspecified)) (set! toe17@set-env-names! (unspecified)) (set! toe19@env-labels (unspecified)) (set! toe1b@set-env-labels! (unspecified)) (set! toe1d@env-itc (unspecified)) (set! toe1f@set-env-itc! (unspecified)) (set! toe21@dummy (unspecified)) (set! toe23@rp (unspecified)) (set! toe2d@interaction-env? (unspecified)) (set! toe2f@interaction-env-rib (unspecified)) (set! toe31@set-interaction-env-rib! (unspecified)) (set! toe33@interaction-env-r (unspecified)) (set! toe35@set-interaction-env-r! (unspecified)) (set! toe37@interaction-env-locs (unspecified)) (set! toe39@set-interaction-env-locs! (unspecified)) (set! toe3b@dummy (unspecified)) (set! toe3d@interaction-environment-symbols (unspecified)) (set! toe3f@environment-bindings (unspecified)) (set! toe41@parse-binding (unspecified)) (set! toe43@environment? (unspecified)) (set! toe45@environment-symbols (unspecified)) (set! toe47@environment (unspecified)) (set! toe49@null-environment (unspecified)) (set! toe4b@scheme-report-environment (unspecified)) (set! toe4d@expand (unspecified)) (set! toe4f@eval (unspecified)) (set! toe51@library-expander (unspecified)) (set! toe53@boot-library-expand (unspecified)) (set! toe55@rev-map-append (unspecified)) (set! toe57@build-exports (unspecified)) (set! toe59@make-export-subst (unspecified)) (set! toe5b@make-export-env/macros (unspecified)) (set! toe5d@generate-temporaries (unspecified)) (set! toe5f@free-identifier=? (unspecified)) (set! toe61@bound-identifier=? (unspecified)) (set! toe63@make-source-condition (unspecified)) (set! toe65@extract-position-condition (unspecified)) (set! toe67@expression-position (unspecified)) (set! toe69@assertion-error (unspecified)) (set! toe6b@syntax-error (unspecified)) (set! toe6d@syntax-violation* (unspecified)) (set! toe6f@syntax-violation (unspecified)) (set! toe71@identifier? (unspecified)) (set! toe73@datum->syntax (unspecified)) (set! toe75@syntax->datum (unspecified)) (set! toe77@ungensym-all (unspecified)) (set! toe79@compile-r6rs-top-level (unspecified)) (set! toe7b@pre-compile-r6rs-top-level (unspecified)) (set! toe7d@interaction-environment (unspecified)) (set! toe7f@top-level-context (unspecified)) (set! tob03@file-options-macro (lambda (toe80@x) (letrec* ((toe83@valid-option? (lambda (toe8c@x) (and (tob88@id? toe8c@x) (memq (tob8a@id->sym toe8c@x) '(no-fail no-create no-truncate)))))) (let ((toe84@t toe80@x)) (let ((toe86@ls/false (tod8f@syntax-dispatch toe84@t '(_ . each-any)))) (if (and toe86@ls/false (apply (lambda (toe88@opt*) (for-all toe83@valid-option? toe88@opt*)) toe86@ls/false)) (apply (lambda (toe8a@opt*) (tod45@bless (list 'make-file-options (list 'quote toe8a@opt*)))) toe86@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" toe84@t))))))) (set! to280c@tob03@file-options-macro tob03@file-options-macro) (set! tob05@set-cons (lambda (toe8e@x toe8f@ls) (if (memq toe8e@x toe8f@ls) toe8f@ls (cons toe8e@x toe8f@ls)))) (set! to280d@tob05@set-cons tob05@set-cons) (set! tob07@set-union (lambda (toe92@ls1 toe93@ls2) (if (null? toe92@ls1) toe93@ls2 (if (memq (car toe92@ls1) toe93@ls2) (tob07@set-union (cdr toe92@ls1) toe93@ls2) (cons (car toe92@ls1) (tob07@set-union (cdr toe92@ls1) toe93@ls2)))))) (set! to280e@tob07@set-union tob07@set-union) (set! tob0c@top-mark* '(top)) (set! to280f@tob0c@top-mark* tob0c@top-mark*) (set! tob0e@top-marked? (lambda (toe96@m*) (memq 'top toe96@m*))) (set! to2810@tob0e@top-marked? tob0e@top-marked?) (set! tob10@gen-lexical (lambda (toe98@sym) (if (symbol? toe98@sym) (gensym toe98@sym) (if (tob54@stx? toe98@sym) (tob10@gen-lexical (tob8a@id->sym toe98@sym)) (assertion-violation 'gen-lexical '"BUG: invalid arg" toe98@sym))))) (set! to2811@tob10@gen-lexical tob10@gen-lexical) (set! tob12@gen-global (lambda (toe9a@x) (tob10@gen-lexical toe9a@x))) (set! to2812@tob12@gen-global tob12@gen-global) (set! tob14@gen-label (lambda (toe9c@_) (gensym))) (set! to2813@tob14@gen-label tob14@gen-label) (set! tob16@gen-top-level-label (lambda (toe9e@id toe9f@rib) (letrec* ((toea3@find (lambda (toeae@sym toeaf@mark* toeb0@sym* toeb1@mark** toeb2@label*) (and (pair? toeb0@sym*) (if (and (eq? toeae@sym (car toeb0@sym*)) (same-marks? toeaf@mark* (car toeb1@mark**))) (car toeb2@label*) (toea3@find toeae@sym toeaf@mark* (cdr toeb0@sym*) (cdr toeb1@mark**) (cdr toeb2@label*))))))) (let ((toea4@sym (tob8a@id->sym toe9e@id)) (toea5@mark* (tob5a@stx-mark* toe9e@id))) (let ((toea8@sym* (tob26@rib-sym* toe9f@rib))) (let ((toeaa@t (and (memq toea4@sym (tob26@rib-sym* toe9f@rib)) (toea3@find toea4@sym toea5@mark* toea8@sym* (tob2a@rib-mark** toe9f@rib) (tob2e@rib-label* toe9f@rib))))) (if toeaa@t ((lambda (toeac@label) (if (to9a3@to7f0@imported-label->binding toeac@label) (gensym) toeac@label)) toeaa@t) (gensym)))))))) (set! to2814@tob16@gen-top-level-label tob16@gen-top-level-label) (set! tob18@gen-define-label+loc (lambda (toeb8@id toeb9@rib) (let ((toebc@t (toe7f@top-level-context))) (if toebc@t ((lambda (toebe@env) (let ((toec0@label (tob16@gen-top-level-label toeb8@id toeb9@rib)) (toec1@locs (toe37@interaction-env-locs toebe@env))) (values toec0@label (let ((toec4@t (assq toec0@label toec1@locs))) (if toec4@t (cdr toec4@t) (let ((toec6@loc (tob10@gen-lexical toeb8@id))) (begin (toe39@set-interaction-env-locs! toebe@env (cons (cons toec0@label toec6@loc) toec1@locs)) toec6@loc))))))) toebc@t) (values (gensym) (tob10@gen-lexical toeb8@id)))))) (set! to2815@tob18@gen-define-label+loc tob18@gen-define-label+loc) (set! tob1a@gen-define-label (lambda (toec8@id toec9@rib) (if (toe7f@top-level-context) (tob16@gen-top-level-label toec8@id toec9@rib) (gensym)))) (set! to2816@tob1a@gen-define-label tob1a@gen-define-label) (set! tob24@rib? (lambda (toecc@x) (and (simple-struct? toecc@x) (eq? (simple-struct-name toecc@x) 'rib)))) (set! to2817@tob24@rib? tob24@rib?) (set! tob26@rib-sym* (lambda (toece@x) (simple-struct-ref toece@x '0))) (set! to2818@tob26@rib-sym* tob26@rib-sym*) (set! tob28@set-rib-sym*! (lambda (toed0@x toed1@val) (simple-struct-set! toed0@x '0 toed1@val))) (set! to2819@tob28@set-rib-sym*! tob28@set-rib-sym*!) (set! tob2a@rib-mark** (lambda (toed4@x) (simple-struct-ref toed4@x '1))) (set! to281a@tob2a@rib-mark** tob2a@rib-mark**) (set! tob2c@set-rib-mark**! (lambda (toed6@x toed7@val) (simple-struct-set! toed6@x '1 toed7@val))) (set! to281b@tob2c@set-rib-mark**! tob2c@set-rib-mark**!) (set! tob2e@rib-label* (lambda (toeda@x) (simple-struct-ref toeda@x '2))) (set! to281c@tob2e@rib-label* tob2e@rib-label*) (set! tob30@set-rib-label*! (lambda (toedc@x toedd@val) (simple-struct-set! toedc@x '2 toedd@val))) (set! to281d@tob30@set-rib-label*! tob30@set-rib-label*!) (set! tob32@rib-sealed/freq (lambda (toee0@x) (simple-struct-ref toee0@x '3))) (set! to281e@tob32@rib-sealed/freq tob32@rib-sealed/freq) (set! tob34@set-rib-sealed/freq! (lambda (toee2@x toee3@val) (simple-struct-set! toee2@x '3 toee3@val))) (set! to281f@tob34@set-rib-sealed/freq! tob34@set-rib-sealed/freq!) (set! tob36@rib-cache (lambda (toee6@x) (simple-struct-ref toee6@x '4))) (set! to2820@tob36@rib-cache tob36@rib-cache) (set! tob38@set-rib-cache! (lambda (toee8@x toee9@val) (simple-struct-set! toee8@x '4 toee9@val))) (set! to2821@tob38@set-rib-cache! tob38@set-rib-cache!) (set! tob3a@dummy '3) (set! to2822@tob3a@dummy tob3a@dummy) (set! tob3c@make-empty-rib (lambda () (make-simple-struct 'rib '6 (list '() '() '() '#f '#f)))) (set! to2823@tob3c@make-empty-rib tob3c@make-empty-rib) (set! tob3e@extend-rib! (lambda (toeec@rib toeed@id toeee@label) (letrec* ((toef3@find (lambda (tof00@sym tof01@mark* tof02@sym* tof03@mark** tof04@label*) (and (pair? tof02@sym*) (if (and (eq? tof00@sym (car tof02@sym*)) (same-marks? tof01@mark* (car tof03@mark**))) tof04@label* (toef3@find tof00@sym tof01@mark* (cdr tof02@sym*) (cdr tof03@mark**) (cdr tof04@label*))))))) (begin (if (tob32@rib-sealed/freq toeec@rib) (assertion-violation 'extend-rib! '"BUG: rib is sealed" toeec@rib) (void)) (let ((toef4@sym (tob8a@id->sym toeed@id)) (toef5@mark* (tob5a@stx-mark* toeed@id))) (let ((toef8@sym* (tob26@rib-sym* toeec@rib))) (let ((toefa@t (and (memq toef4@sym (tob26@rib-sym* toeec@rib)) (toef3@find toef4@sym toef5@mark* toef8@sym* (tob2a@rib-mark** toeec@rib) (tob2e@rib-label* toeec@rib))))) (if toefa@t ((lambda (toefc@p) (if (not (eq? toeee@label (car toefc@p))) (if (toe7f@top-level-context) (set-car! toefc@p toeee@label) (toe6f@syntax-violation '#f '"multiple definitions of identifier" toeed@id)) (void))) toefa@t) (begin (if (tob36@rib-cache toeec@rib) (hashtable-update! (tob36@rib-cache toeec@rib) toef4@sym (lambda (toefe@e) (cons (cons toef5@mark* toeee@label) toefe@e)) '()) (void)) (tob28@set-rib-sym*! toeec@rib (cons toef4@sym toef8@sym*)) (tob2c@set-rib-mark**! toeec@rib (cons toef5@mark* (tob2a@rib-mark** toeec@rib))) (tob30@set-rib-label*! toeec@rib (cons toeee@label (tob2e@rib-label* toeec@rib)))))))))))) (set! to2824@tob3e@extend-rib! tob3e@extend-rib!) (set! tob40@extend-rib/nc! (lambda (tof0a@rib tof0b@id tof0c@label) (let ((tof10@sym (tob8a@id->sym tof0b@id)) (tof11@mark* (tob5a@stx-mark* tof0b@id))) (let ((tof14@sym* (tob26@rib-sym* tof0a@rib))) (begin (if (tob36@rib-cache tof0a@rib) (hashtable-update! (tob36@rib-cache tof0a@rib) tof10@sym (lambda (tof16@e) (cons (cons tof11@mark* tof0c@label) tof16@e)) '()) (void)) (tob28@set-rib-sym*! tof0a@rib (cons tof10@sym tof14@sym*)) (tob2c@set-rib-mark**! tof0a@rib (cons tof11@mark* (tob2a@rib-mark** tof0a@rib))) (tob30@set-rib-label*! tof0a@rib (cons tof0c@label (tob2e@rib-label* tof0a@rib)))))))) (set! to2825@tob40@extend-rib/nc! tob40@extend-rib/nc!) (set! tob42@make-rib-map (lambda (tof18@sym*) (let ((tof1a@ht (make-eq-hashtable))) (let tof20@f ((tof1c@i '0) (tof1d@sym* tof18@sym*)) (if (null? tof1d@sym*) tof1a@ht (begin (hashtable-update! tof1a@ht (car tof1d@sym*) (lambda (tof22@x) (cons tof1c@i tof22@x)) '()) (tof20@f (+ tof1c@i '1) (cdr tof1d@sym*)))))))) (set! to2826@tob42@make-rib-map tob42@make-rib-map) (set! tob44@seal-rib! (lambda (tof24@rib) (let ((tof26@sym* (tob26@rib-sym* tof24@rib))) (if (not (null? tof26@sym*)) (begin (tob28@set-rib-sym*! tof24@rib (list->vector tof26@sym*)) (tob2c@set-rib-mark**! tof24@rib (list->vector (tob2a@rib-mark** tof24@rib))) (tob30@set-rib-label*! tof24@rib (list->vector (tob2e@rib-label* tof24@rib))) (tob34@set-rib-sealed/freq! tof24@rib (tob42@make-rib-map tof26@sym*))) (void))))) (set! to2827@tob44@seal-rib! tob44@seal-rib!) (set! tob46@unseal-rib! (lambda (tof28@rib) (if (tob32@rib-sealed/freq tof28@rib) (begin (tob34@set-rib-sealed/freq! tof28@rib '#f) (tob28@set-rib-sym*! tof28@rib (vector->list (tob26@rib-sym* tof28@rib))) (tob2c@set-rib-mark**! tof28@rib (vector->list (tob2a@rib-mark** tof28@rib))) (tob30@set-rib-label*! tof28@rib (vector->list (tob2e@rib-label* tof28@rib)))) (void)))) (set! to2828@tob46@unseal-rib! tob46@unseal-rib!) (set! tob48@make-full-rib (lambda (tof2a@id* tof2b@label*) (let ((tof2e@r (make-simple-struct 'rib '6 (list (map tob8a@id->sym tof2a@id*) (map tob5a@stx-mark* tof2a@id*) tof2b@label* '#f '#f)))) (begin (tob44@seal-rib! tof2e@r) tof2e@r)))) (set! to2829@tob48@make-full-rib tob48@make-full-rib) (set! tob4a@rp (to6d5@to5b0@make-record-printer 'stx (lambda (tof30@x tof31@p tof32@wr) (begin (display '"#<syntax " tof31@p) (write (tob9c@stx->datum tof30@x) tof31@p) (let ((tof36@expr (tob56@stx-expr tof30@x))) (if (to6cc@to59e@annotation? tof36@expr) (let ((tof38@src (to6cd@to5a0@annotation-source tof36@expr))) (if (pair? tof38@src) (begin (display '" [" tof31@p) (display (cdr tof38@src) tof31@p) (display '" of " tof31@p) (display (car tof38@src) tof31@p) (display '"]" tof31@p)) (void))) (void))) (display '">" tof31@p))))) (set! to282a@tob4a@rp tob4a@rp) (set! tob54@stx? (lambda (tof3a@x) (and (simple-struct? tof3a@x) (eq? (simple-struct-name tof3a@x) 'stx)))) (set! to282b@tob54@stx? tob54@stx?) (set! tob56@stx-expr (lambda (tof3c@x) (simple-struct-ref tof3c@x '0))) (set! to282c@tob56@stx-expr tob56@stx-expr) (set! tob58@set-stx-expr! (lambda (tof3e@x tof3f@val) (simple-struct-set! tof3e@x '0 tof3f@val))) (set! to282d@tob58@set-stx-expr! tob58@set-stx-expr!) (set! tob5a@stx-mark* (lambda (tof42@x) (simple-struct-ref tof42@x '1))) (set! to282e@tob5a@stx-mark* tob5a@stx-mark*) (set! tob5c@set-stx-mark*! (lambda (tof44@x tof45@val) (simple-struct-set! tof44@x '1 tof45@val))) (set! to282f@tob5c@set-stx-mark*! tob5c@set-stx-mark*!) (set! tob5e@stx-subst* (lambda (tof48@x) (simple-struct-ref tof48@x '2))) (set! to2830@tob5e@stx-subst* tob5e@stx-subst*) (set! tob60@set-stx-subst*! (lambda (tof4a@x tof4b@val) (simple-struct-set! tof4a@x '2 tof4b@val))) (set! to2831@tob60@set-stx-subst*! tob60@set-stx-subst*!) (set! tob62@stx-ae* (lambda (tof4e@x) (simple-struct-ref tof4e@x '3))) (set! to2832@tob62@stx-ae* tob62@stx-ae*) (set! tob64@set-stx-ae*! (lambda (tof50@x tof51@val) (simple-struct-set! tof50@x '3 tof51@val))) (set! to2833@tob64@set-stx-ae*! tob64@set-stx-ae*!) (set! tob66@dummy '3) (set! to2834@tob66@dummy tob66@dummy) (set! tob68@datum->stx (lambda (tof54@id tof55@datum) (make-simple-struct 'stx '5 (list tof55@datum (tob5a@stx-mark* tof54@id) (tob5e@stx-subst* tof54@id) (tob62@stx-ae* tof54@id))))) (set! to2835@tob68@datum->stx tob68@datum->stx) (set! tob6a@gen-mark (lambda () (string '#\m))) (set! to2836@tob6a@gen-mark tob6a@gen-mark) (set! tob6c@anti-mark '#f) (set! to2837@tob6c@anti-mark tob6c@anti-mark) (set! tob6e@anti-mark? not) (set! to2838@tob6e@anti-mark? tob6e@anti-mark?) (set! tob70@mkstx (lambda (tof58@e tof59@m* tof5a@s* tof5b@ae*) (if (and (tob54@stx? tof58@e) (not (tob0e@top-marked? tof59@m*))) (call-with-values (lambda () (join-wraps tof59@m* tof5a@s* tof5b@ae* tof58@e)) (lambda (tof66@tof61 tof67@tof63 tof68@tof65) (let ((tof6c@ae* tof68@tof65) (tof6d@s* tof67@tof63) (tof6e@m* tof66@tof61)) (make-simple-struct 'stx '5 (list (tob56@stx-expr tof58@e) tof6e@m* tof6d@s* tof6c@ae*))))) (make-simple-struct 'stx '5 (list tof58@e tof59@m* tof5a@s* tof5b@ae*))))) (set! to2839@tob70@mkstx tob70@mkstx) (set! tob72@add-subst (lambda (tof72@subst tof73@e) (tob70@mkstx tof73@e '() (list tof72@subst) '()))) (set! to283a@tob72@add-subst tob72@add-subst) (set! tob74@add-mark (lambda (tof76@mark tof77@subst tof78@expr tof79@ae) (letrec* ((tof7f@merge-ae* (lambda (tofa6@ls1 tofa7@ls2) (if (and (pair? tofa6@ls1) (pair? tofa7@ls2) (not (car tofa7@ls2))) (tof81@cancel tofa6@ls1 tofa7@ls2) (append tofa6@ls1 tofa7@ls2)))) (tof81@cancel (lambda (tof9c@ls1 tof9d@ls2) (let tofa4@f ((tofa0@x (car tof9c@ls1)) (tofa1@ls1 (cdr tof9c@ls1))) (if (null? tofa1@ls1) (cdr tof9d@ls2) (cons tofa0@x (tofa4@f (car tofa1@ls1) (cdr tofa1@ls1))))))) (tof83@f (lambda (tof84@e tof85@m tof86@s1* tof87@ae*) (if (pair? tof84@e) (let ((tof8c@a (tof83@f (car tof84@e) tof85@m tof86@s1* tof87@ae*)) (tof8d@d (tof83@f (cdr tof84@e) tof85@m tof86@s1* tof87@ae*))) (if (eq? tof8c@a tof8d@d) tof84@e (cons tof8c@a tof8d@d))) (if (vector? tof84@e) (let ((tof90@ls1 (vector->list tof84@e))) (let ((tof92@ls2 (map (lambda (tof94@x) (tof83@f tof94@x tof85@m tof86@s1* tof87@ae*)) tof90@ls1))) (if (for-all eq? tof90@ls1 tof92@ls2) tof84@e (list->vector tof92@ls2)))) (if (tob54@stx? tof84@e) (let ((tof96@m* (tob5a@stx-mark* tof84@e)) (tof97@s2* (tob5e@stx-subst* tof84@e))) (if (null? tof96@m*) (tof83@f (tob56@stx-expr tof84@e) tof85@m (append tof86@s1* tof97@s2*) (tof7f@merge-ae* tof87@ae* (tob62@stx-ae* tof84@e))) (if (eq? (car tof96@m*) tob6c@anti-mark) (make-simple-struct 'stx '5 (list (tob56@stx-expr tof84@e) (cdr tof96@m*) (cdr (append tof86@s1* tof97@s2*)) (tof7f@merge-ae* tof87@ae* (tob62@stx-ae* tof84@e)))) (make-simple-struct 'stx '5 (list (tob56@stx-expr tof84@e) (cons tof85@m tof96@m*) (let ((tof9a@s* (cons 'shift (append tof86@s1* tof97@s2*)))) (if tof77@subst (cons tof77@subst tof9a@s*) tof9a@s*)) (tof7f@merge-ae* tof87@ae* (tob62@stx-ae* tof84@e))))))) (if (symbol? tof84@e) (toe6f@syntax-violation '#f '"raw symbol encountered in output of macro" tof78@expr tof84@e) (make-simple-struct 'stx '5 (list tof84@e (list tof85@m) tof86@s1* tof87@ae*))))))))) (tob70@mkstx (tof83@f tof78@expr tof76@mark '() '()) '() '() (list tof79@ae))))) (set! to283b@tob74@add-mark tob74@add-mark) (set! tob76@syntax-kind? (lambda (tofaa@x tofab@p?) (if (tob54@stx? tofaa@x) (tob76@syntax-kind? (tob56@stx-expr tofaa@x) tofab@p?) (if (to6cc@to59e@annotation? tofaa@x) (tob76@syntax-kind? (to6ce@to5a2@annotation-expression tofaa@x) tofab@p?) (tofab@p? tofaa@x))))) (set! to283c@tob76@syntax-kind? tob76@syntax-kind?) (set! tob78@syntax-vector->list (lambda (tofae@x) (if (tob54@stx? tofae@x) (let ((tofb0@ls (tob78@syntax-vector->list (tob56@stx-expr tofae@x))) (tofb1@m* (tob5a@stx-mark* tofae@x)) (tofb2@s* (tob5e@stx-subst* tofae@x)) (tofb3@ae* (tob62@stx-ae* tofae@x))) (map (lambda (tofb8@x) (tob70@mkstx tofb8@x tofb1@m* tofb2@s* tofb3@ae*)) tofb0@ls)) (if (to6cc@to59e@annotation? tofae@x) (tob78@syntax-vector->list (to6ce@to5a2@annotation-expression tofae@x)) (if (vector? tofae@x) (vector->list tofae@x) (assertion-violation 'syntax-vector->list '"BUG: not a syntax vector" tofae@x)))))) (set! to283d@tob78@syntax-vector->list tob78@syntax-vector->list) (set! tob7a@syntax-pair? (lambda (tofba@x) (tob76@syntax-kind? tofba@x pair?))) (set! to283e@tob7a@syntax-pair? tob7a@syntax-pair?) (set! tob7c@syntax-vector? (lambda (tofbc@x) (tob76@syntax-kind? tofbc@x vector?))) (set! to283f@tob7c@syntax-vector? tob7c@syntax-vector?) (set! tob7e@syntax-null? (lambda (tofbe@x) (tob76@syntax-kind? tofbe@x null?))) (set! to2840@tob7e@syntax-null? tob7e@syntax-null?) (set! tob80@syntax-list? (lambda (tofc0@x) (or (tob7e@syntax-null? tofc0@x) (and (tob7a@syntax-pair? tofc0@x) (tob80@syntax-list? (tob84@syntax-cdr tofc0@x)))))) (set! to2841@tob80@syntax-list? tob80@syntax-list?) (set! tob82@syntax-car (lambda (tofc2@x) (if (tob54@stx? tofc2@x) (tob70@mkstx (tob82@syntax-car (tob56@stx-expr tofc2@x)) (tob5a@stx-mark* tofc2@x) (tob5e@stx-subst* tofc2@x) (tob62@stx-ae* tofc2@x)) (if (to6cc@to59e@annotation? tofc2@x) (tob82@syntax-car (to6ce@to5a2@annotation-expression tofc2@x)) (if (pair? tofc2@x) (car tofc2@x) (assertion-violation 'syntax-car '"BUG: not a pair" tofc2@x)))))) (set! to2842@tob82@syntax-car tob82@syntax-car) (set! tob84@syntax-cdr (lambda (tofc4@x) (if (tob54@stx? tofc4@x) (tob70@mkstx (tob84@syntax-cdr (tob56@stx-expr tofc4@x)) (tob5a@stx-mark* tofc4@x) (tob5e@stx-subst* tofc4@x) (tob62@stx-ae* tofc4@x)) (if (to6cc@to59e@annotation? tofc4@x) (tob84@syntax-cdr (to6ce@to5a2@annotation-expression tofc4@x)) (if (pair? tofc4@x) (cdr tofc4@x) (assertion-violation 'syntax-cdr '"BUG: not a pair" tofc4@x)))))) (set! to2843@tob84@syntax-cdr tob84@syntax-cdr) (set! tob86@syntax->list (lambda (tofc6@x) (if (tob7a@syntax-pair? tofc6@x) (cons (tob82@syntax-car tofc6@x) (tob86@syntax->list (tob84@syntax-cdr tofc6@x))) (if (tob7e@syntax-null? tofc6@x) '() (assertion-violation 'syntax->list '"BUG: invalid argument" tofc6@x))))) (set! to2844@tob86@syntax->list tob86@syntax->list) (set! tob88@id? (lambda (tofc8@x) (and (tob54@stx? tofc8@x) (symbol? (tob56@stx-expr tofc8@x))))) (set! to2845@tob88@id? tob88@id?) (set! tob8a@id->sym (lambda (tofca@x) (tob56@stx-expr tofca@x))) (set! to2846@tob8a@id->sym tob8a@id->sym) (set! tob8c@bound-id=? (lambda (tofcc@x tofcd@y) (and (eq? (tob8a@id->sym tofcc@x) (tob8a@id->sym tofcd@y)) (same-marks? (tob5a@stx-mark* tofcc@x) (tob5a@stx-mark* tofcd@y))))) (set! to2847@tob8c@bound-id=? tob8c@bound-id=?) (set! tob8e@free-id=? (lambda (tofd0@i tofd1@j) (let ((tofd4@t0 (id->real-label tofd0@i)) (tofd5@t1 (id->real-label tofd1@j))) (if (or tofd4@t0 tofd5@t1) (eq? tofd4@t0 tofd5@t1) (eq? (tob8a@id->sym tofd0@i) (tob8a@id->sym tofd1@j)))))) (set! to2848@tob8e@free-id=? tob8e@free-id=?) (set! tob90@valid-bound-ids? (lambda (tofd8@id*) (and (for-all tob88@id? tofd8@id*) (tob92@distinct-bound-ids? tofd8@id*)))) (set! to2849@tob90@valid-bound-ids? tob90@valid-bound-ids?) (set! tob92@distinct-bound-ids? (lambda (tofda@id*) (or (null? tofda@id*) (and (not (tob94@bound-id-member? (car tofda@id*) (cdr tofda@id*))) (tob92@distinct-bound-ids? (cdr tofda@id*)))))) (set! to284a@tob92@distinct-bound-ids? tob92@distinct-bound-ids?) (set! tob94@bound-id-member? (lambda (tofdc@id tofdd@id*) (and (pair? tofdd@id*) (or (tob8c@bound-id=? tofdc@id (car tofdd@id*)) (tob94@bound-id-member? tofdc@id (cdr tofdd@id*)))))) (set! to284b@tob94@bound-id-member? tob94@bound-id-member?) (set! tob96@self-evaluating? (lambda (tofe0@x) (or (number? tofe0@x) (string? tofe0@x) (char? tofe0@x) (boolean? tofe0@x) (regexp? tofe0@x) (bytevector? tofe0@x)))) (set! to284c@tob96@self-evaluating? tob96@self-evaluating?) (set! tob98@strip-annotations (lambda (tofe2@x) (if (pair? tofe2@x) (cons (tob98@strip-annotations (car tofe2@x)) (tob98@strip-annotations (cdr tofe2@x))) (if (vector? tofe2@x) (vector-map tob98@strip-annotations tofe2@x) (if (to6cc@to59e@annotation? tofe2@x) (to6cb@to59c@annotation-stripped tofe2@x) tofe2@x))))) (set! to284d@tob98@strip-annotations tob98@strip-annotations) (set! tob9a@strip (lambda (tofe4@x tofe5@m*) (if (tob0e@top-marked? tofe5@m*) (if (or (to6cc@to59e@annotation? tofe4@x) (and (pair? tofe4@x) (to6cc@to59e@annotation? (car tofe4@x))) (and (vector? tofe4@x) (> (vector-length tofe4@x) '0) (to6cc@to59e@annotation? (vector-ref tofe4@x '0)))) (tob98@strip-annotations tofe4@x) tofe4@x) (let tofea@f ((tofe8@x tofe4@x)) (if (tob54@stx? tofe8@x) (begin (if (pair? (tob56@stx-expr tofe8@x)) (begin (set-source-info! (tob56@stx-expr tofe8@x) '#f) (set-source-info! (cdr (tob56@stx-expr tofe8@x)) '#f) (set-source-info! (car (tob56@stx-expr tofe8@x)) '#f)) (void)) (tob9a@strip (tob56@stx-expr tofe8@x) (tob5a@stx-mark* tofe8@x))) (if (to6cc@to59e@annotation? tofe8@x) (to6cb@to59c@annotation-stripped tofe8@x) (if (pair? tofe8@x) (let ((tofec@a (tofea@f (car tofe8@x))) (tofed@d (tofea@f (cdr tofe8@x)))) (if (and (eq? tofec@a (car tofe8@x)) (eq? tofed@d (cdr tofe8@x))) tofe8@x (cons tofec@a tofed@d))) (if (vector? tofe8@x) (let ((toff0@old (vector->list tofe8@x))) (let ((toff2@new (map tofea@f toff0@old))) (if (for-all eq? toff0@old toff2@new) tofe8@x (list->vector toff2@new)))) tofe8@x)))))))) (set! to284e@tob9a@strip tob9a@strip) (set! tob9c@stx->datum (lambda (toff4@x) (tob9a@strip toff4@x '()))) (set! to284f@tob9c@stx->datum tob9c@stx->datum) (set! tob9e@id->label (lambda (toff6@id) (or (id->real-label toff6@id) (let ((toff8@t (toe7f@top-level-context))) (if toff8@t ((lambda (toffa@env) (let ((toffc@rib (toe2f@interaction-env-rib toffa@env))) (call-with-values (lambda () (tob18@gen-define-label+loc toff6@id toffc@rib)) (lambda (to1002@tofff to1003@to1001) (let ((to1006@loc_ to1003@to1001) (to1007@lab to1002@tofff)) (begin (tob3e@extend-rib! toffc@rib toff6@id to1007@lab) to1007@lab)))))) toff8@t) '#f))))) (set! to2850@tob9e@id->label tob9e@id->label) (set! toba0@label->binding (lambda (to100a@x to100b@r) (let ((to100e@t (to9a3@to7f0@imported-label->binding to100a@x))) (if to100e@t ((lambda (to1010@b) (if (and (pair? to1010@b) (eq? (car to1010@b) '$core-rtd)) (cons '$rtd (map tod45@bless (cdr to1010@b))) (if (and (pair? to1010@b) (eq? (car to1010@b) 'global-rtd)) (let ((to1012@lib (cadr to1010@b)) (to1013@loc (cddr to1010@b))) (cons '$rtd (symbol-value to1013@loc))) to1010@b))) to100e@t) (let ((to1016@t (assq to100a@x to100b@r))) (if to1016@t (cdr to1016@t) (let ((to1018@t (toe7f@top-level-context))) (if to1018@t ((lambda (to101a@env) (let ((to101c@t (assq to100a@x (toe37@interaction-env-locs to101a@env)))) (if to101c@t ((lambda (to101e@p) (cons* 'lexical (cdr to101e@p) '#f)) to101c@t) '(displaced-lexical . #f)))) to1018@t) '(displaced-lexical . #f))))))))) (set! to2851@toba0@label->binding toba0@label->binding) (set! toba2@make-binding cons) (set! to2852@toba2@make-binding toba2@make-binding) (set! toba4@binding-type car) (set! to2853@toba4@binding-type toba4@binding-type) (set! toba6@binding-value cdr) (set! to2854@toba6@binding-value toba6@binding-value) (set! toba8@raise-unbound-error (lambda (to1020@id) (toe6d@syntax-violation* '#f '"unbound identifier" to1020@id (make-undefined-violation)))) (set! to2855@toba8@raise-unbound-error toba8@raise-unbound-error) (set! tobaa@syntax-type (lambda (to1022@e to1023@r) (if (tob88@id? to1022@e) (let ((to1026@id to1022@e)) (let ((to1028@label (tob9e@id->label to1026@id))) (let ((to102a@b (toba0@label->binding to1028@label to1023@r))) (let ((to102c@type (toba4@binding-type to102a@b))) (begin (if (not to1028@label) (toba8@raise-unbound-error to1026@id) (void)) (let ((to102e@t to102c@type)) (if (memv to102e@t '(lexical core-prim macro macro! global local-macro local-macro! global-macro global-macro! displaced-lexical syntax import export $module $core-rtd library mutable)) (values to102c@type (toba6@binding-value to102a@b) to1026@id) (values 'other '#f '#f)))))))) (if (tob7a@syntax-pair? to1022@e) (let ((to1030@id (tob82@syntax-car to1022@e))) (if (tob88@id? to1030@id) (let ((to1032@label (tob9e@id->label to1030@id))) (let ((to1034@b (toba0@label->binding to1032@label to1023@r))) (let ((to1036@type (toba4@binding-type to1034@b))) (begin (if (not to1032@label) (toba8@raise-unbound-error to1030@id) (void)) (let ((to1038@t to1036@type)) (if (memv to1038@t '(define define-syntax core-macro begin macro macro! local-macro local-macro! global-macro global-macro! module library set! let-syntax letrec-syntax import export $core-rtd)) (values to1036@type (toba6@binding-value to1034@b) to1030@id) (values 'call '#f '#f))))))) (values 'call '#f '#f))) (let ((to103a@d (tob9c@stx->datum to1022@e))) (if (tob96@self-evaluating? to103a@d) (values 'constant to103a@d '#f) (values 'other '#f '#f))))))) (set! to2856@tobaa@syntax-type tobaa@syntax-type) (set! tobb8@sanitize-binding (lambda (to103c@x to103d@src) (if (procedure? to103c@x) (cons* 'local-macro to103c@x to103d@src) (if (and (pair? to103c@x) (eq? (car to103c@x) 'macro!) (procedure? (cdr to103c@x))) (cons* 'local-macro! (cdr to103c@x) to103d@src) (if (and (pair? to103c@x) (eq? (car to103c@x) '$rtd)) to103c@x (assertion-violation 'expand '"invalid transformer" to103c@x)))))) (set! to2857@tobb8@sanitize-binding tobb8@sanitize-binding) (set! tobba@make-variable-transformer (lambda (to1040@x) (if (procedure? to1040@x) (cons 'macro! to1040@x) (assertion-violation 'make-variable-transformer '"not a procedure" to1040@x)))) (set! to2858@tobba@make-variable-transformer tobba@make-variable-transformer) (set! tobbc@variable-transformer? (lambda (to1042@x) (and (pair? to1042@x) (eq? (car to1042@x) 'macro!) (procedure? (cdr to1042@x))))) (set! to2859@tobbc@variable-transformer? tobbc@variable-transformer?) (set! tobbe@variable-transformer-procedure (lambda (to1044@x) (if (tobbc@variable-transformer? to1044@x) (cdr to1044@x) (assertion-violation 'variable-transformer-procedure '"not a variable transformer" to1044@x)))) (set! to285a@tobbe@variable-transformer-procedure tobbe@variable-transformer-procedure) (set! tobc0@make-eval-transformer (lambda (to1046@x) (tobb8@sanitize-binding (eval-core (to72e@to6e6@expanded->core to1046@x)) to1046@x))) (set! to285b@tobc0@make-eval-transformer tobc0@make-eval-transformer) (set! tod11@parse-define (lambda (to1048@x) (let ((to104a@t to1048@x)) (let ((to104c@ls/false (tod8f@syntax-dispatch to104a@t '(_ (any . any) any . each-any)))) (if (and to104c@ls/false (apply (lambda (to104e@id to104f@fmls to1050@b to1051@b*) (tob88@id? to104e@id)) to104c@ls/false)) (apply (lambda (to1056@id to1057@fmls to1058@b to1059@b*) (begin (todb5@verify-formals to1057@fmls to1048@x) (values to1056@id (cons 'defun (cons to1057@fmls (cons to1058@b to1059@b*)))))) to104c@ls/false) (let ((to105e@t to104a@t)) (let ((to1060@ls/false (tod8f@syntax-dispatch to105e@t '(_ any any)))) (if (and to1060@ls/false (apply (lambda (to1062@id to1063@val) (tob88@id? to1062@id)) to1060@ls/false)) (apply (lambda (to1066@id to1067@val) (values to1066@id (cons 'expr to1067@val))) to1060@ls/false) (let ((to106a@t to105e@t)) (let ((to106c@ls/false (tod8f@syntax-dispatch to106a@t '(_ any)))) (if (and to106c@ls/false (apply (lambda (to106e@id) (tob88@id? to106e@id)) to106c@ls/false)) (apply (lambda (to1070@id) (values to1070@id (cons 'expr (tod45@bless '(void))))) to106c@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to106a@t)))))))))))) (set! to285c@tod11@parse-define tod11@parse-define) (set! tod13@parse-define-syntax (lambda (to1072@x) (let ((to1074@t to1072@x)) (let ((to1076@ls/false (tod8f@syntax-dispatch to1074@t '(_ any any)))) (if (and to1076@ls/false (apply (lambda (to1078@id to1079@val) (tob88@id? to1078@id)) to1076@ls/false)) (apply (lambda (to107c@id to107d@val) (values to107c@id to107d@val)) to1076@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1074@t)))))) (set! to285d@tod13@parse-define-syntax tod13@parse-define-syntax) (set! tod15@scheme-stx-hashtable (make-eq-hashtable)) (set! to285e@tod15@scheme-stx-hashtable tod15@scheme-stx-hashtable) (set! tod17@scheme-stx (lambda (to1080@sym) (or (hashtable-ref tod15@scheme-stx-hashtable to1080@sym '#f) (let ((to1082@subst (to97f@to7a8@library-subst (to99d@to7e4@find-library-by-name '(psyntax system $all))))) (let ((to1084@stx (make-simple-struct 'stx '5 (list to1080@sym tob0c@top-mark* '() '())))) (let ((to1086@stx (let ((to1088@t (assq to1080@sym to1082@subst))) (if to1088@t ((lambda (to108a@x) (let ((to108c@name (car to108a@x)) (to108d@label (cdr to108a@x))) (tob72@add-subst (make-simple-struct 'rib '6 (list (list to108c@name) (list tob0c@top-mark*) (list to108d@label) '#f '#f)) to1084@stx))) to1088@t) to1084@stx)))) (begin (hashtable-set! tod15@scheme-stx-hashtable to1080@sym to1086@stx) to1086@stx))))))) (set! to285f@tod17@scheme-stx tod17@scheme-stx) (set! tod19@lexical-var car) (set! to2860@tod19@lexical-var tod19@lexical-var) (set! tod1b@lexical-mutable? cdr) (set! to2861@tod1b@lexical-mutable? tod1b@lexical-mutable?) (set! tod1d@set-lexical-mutable! set-cdr!) (set! to2862@tod1d@set-lexical-mutable! tod1d@set-lexical-mutable!) (set! tod1f@add-lexical (lambda (to1090@lab to1091@lex to1092@r) (cons (cons* to1090@lab 'lexical to1091@lex '#f) to1092@r))) (set! to2863@tod1f@add-lexical tod1f@add-lexical) (set! tod21@add-lexicals (lambda (to1096@lab* to1097@lex* to1098@r) (if (null? to1096@lab*) to1098@r (tod21@add-lexicals (cdr to1096@lab*) (cdr to1097@lex*) (tod1f@add-lexical (car to1096@lab*) (car to1097@lex*) to1098@r))))) (set! to2864@tod21@add-lexicals tod21@add-lexicals) (set! tod23@letrec-helper (lambda (to109c@e to109d@r to109e@mr to109f@build) (let ((to10a4@t to109c@e)) (let ((to10a6@ls/false (tod8f@syntax-dispatch to10a4@t '(_ #(each (any any)) any . each-any)))) (if to10a6@ls/false (apply (lambda (to10a8@lhs* to10a9@rhs* to10aa@b to10ab@b*) (if (not (tob90@valid-bound-ids? to10a8@lhs*)) (tod49@invalid-fmls-error to109c@e to10a8@lhs*) (let ((to10b0@lex* (map tob10@gen-lexical to10a8@lhs*)) (to10b1@lab* (map tob14@gen-label to10a8@lhs*))) (let ((to10b4@rib (tob48@make-full-rib to10a8@lhs* to10b1@lab*)) (to10b5@r (tod21@add-lexicals to10b1@lab* to10b0@lex* to109d@r))) (let ((to10b8@body (todc7@chi-internal (tob72@add-subst to10b4@rib (cons to10aa@b to10ab@b*)) to10b5@r to109e@mr)) (to10b9@rhs* (todad@chi-expr* (map (lambda (to10bc@x) (tob72@add-subst to10b4@rib to10bc@x)) to10a9@rhs*) to10b5@r to109e@mr))) (to109f@build '#f to10b0@lex* to10b9@rhs* to10b8@body)))))) to10a6@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to10a4@t)))))) (set! to2865@tod23@letrec-helper tod23@letrec-helper) (set! tod25@let-transformer (lambda (to10be@e to10bf@r to10c0@mr) (let ((to10c4@t to10be@e)) (let ((to10c6@ls/false (tod8f@syntax-dispatch to10c4@t '(_ #(each (any any)) any . each-any)))) (if to10c6@ls/false (apply (lambda (to10c8@lhs* to10c9@rhs* to10ca@b to10cb@b*) (if (not (tob90@valid-bound-ids? to10c8@lhs*)) (tod49@invalid-fmls-error to10be@e to10c8@lhs*) (let ((to10d0@lex* (map tob10@gen-lexical to10c8@lhs*)) (to10d1@lab* (map tob14@gen-label to10c8@lhs*)) (to10d2@rhs* (todad@chi-expr* to10c9@rhs* to10bf@r to10c0@mr))) (let ((to10d6@rib (tob48@make-full-rib to10c8@lhs* to10d1@lab*)) (to10d7@r (tod21@add-lexicals to10d1@lab* to10d0@lex* to10bf@r))) (let ((to10da@body (todc7@chi-internal (tob72@add-subst to10d6@rib (cons to10ca@b to10cb@b*)) to10d7@r to10c0@mr))) (toaf0@toa53@build-let '#f to10d0@lex* to10d2@rhs* to10da@body)))))) to10c6@ls/false) (let ((to10dc@t to10c4@t)) (let ((to10de@ls/false (tod8f@syntax-dispatch to10dc@t '(_ any #(each (any any)) any . each-any)))) (if to10de@ls/false (apply (lambda (to10e0@loop to10e1@lhs* to10e2@rhs* to10e3@b to10e4@b*) (if (not (tob90@valid-bound-ids? to10e1@lhs*)) (tod49@invalid-fmls-error to10be@e to10e1@lhs*) (let ((to10ea@lex* (map tob10@gen-lexical to10e1@lhs*)) (to10eb@lab* (map tob14@gen-label to10e1@lhs*)) (to10ec@rhs* (todad@chi-expr* to10e2@rhs* to10bf@r to10c0@mr)) (to10ed@loop-lex (tob10@gen-lexical to10e0@loop)) (to10ee@loop-lab (tob14@gen-label to10e0@loop))) (let ((to10f4@loop-rib (tob48@make-full-rib (list to10e0@loop) (list to10ee@loop-lab))) (to10f5@rib (tob48@make-full-rib to10e1@lhs* to10eb@lab*)) (to10f6@r (tod21@add-lexicals (cons to10ee@loop-lab to10eb@lab*) (cons to10ed@loop-lex to10ea@lex*) to10bf@r))) (let ((to10fa@body (todc7@chi-internal (tob72@add-subst to10f4@loop-rib (tob72@add-subst to10f5@rib (cons to10e3@b to10e4@b*))) to10f6@r to10c0@mr))) (toaf1@toa55@build-named-let '#f to10ed@loop-lex to10ea@lex* to10ec@rhs* to10fa@body)))))) to10de@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to10dc@t))))))))) (set! to2866@tod25@let-transformer tod25@let-transformer) (set! tod27@letrec-transformer (lambda (to10fc@e to10fd@r to10fe@mr) (tod23@letrec-helper to10fc@e to10fd@r to10fe@mr toaef@toa51@build-letrec))) (set! to2867@tod27@letrec-transformer tod27@letrec-transformer) (set! tod29@letrec*-transformer (lambda (to1102@e to1103@r to1104@mr) (tod23@letrec-helper to1102@e to1103@r to1104@mr toaf2@toa57@build-letrec*))) (set! to2868@tod29@letrec*-transformer tod29@letrec*-transformer) (set! tod2b@fluid-let-syntax-transformer (lambda (to1108@e to1109@r to110a@mr) (letrec* ((to110f@lookup (lambda (to1122@x) (or (tob9e@id->label to1122@x) (toe6f@syntax-violation '#f '"unbound identifier" to1108@e to1122@x))))) (let ((to1110@t to1108@e)) (let ((to1112@ls/false (tod8f@syntax-dispatch to1110@t '(_ #(each (any any)) any . each-any)))) (if to1112@ls/false (apply (lambda (to1114@lhs* to1115@rhs* to1116@b to1117@b*) (if (not (tob90@valid-bound-ids? to1114@lhs*)) (tod49@invalid-fmls-error to1108@e to1114@lhs*) (let ((to111c@lab* (map to110f@lookup to1114@lhs*)) (to111d@rhs* (map (lambda (to1120@x) (tobc0@make-eval-transformer (tode9@expand-transformer to1120@x to110a@mr))) to1115@rhs*))) (todc7@chi-internal (cons to1116@b to1117@b*) (append (map cons to111c@lab* to111d@rhs*) to1109@r) (append (map cons to111c@lab* to111d@rhs*) to110a@mr))))) to1112@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1110@t))))))) (set! to2869@tod2b@fluid-let-syntax-transformer tod2b@fluid-let-syntax-transformer) (set! tod2d@type-descriptor-transformer (lambda (to1124@e to1125@r to1126@mr) (let ((to112a@t to1124@e)) (let ((to112c@ls/false (tod8f@syntax-dispatch to112a@t '(_ any)))) (if (and to112c@ls/false (apply (lambda (to112e@id) (tob88@id? to112e@id)) to112c@ls/false)) (apply (lambda (to1130@id) (let ((to1132@lab (tob9e@id->label to1130@id))) (let ((to1134@b (toba0@label->binding to1132@lab to1125@r))) (let ((to1136@type (toba4@binding-type to1134@b))) (begin (if (not to1132@lab) (toba8@raise-unbound-error to1130@id) (void)) (if (not (and (eq? to1136@type '$rtd) (not (list? (toba6@binding-value to1134@b))))) (toe6f@syntax-violation '#f '"not a record type" to1124@e) (void)) (list 'quote (toba6@binding-value to1134@b))))))) to112c@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to112a@t)))))) (set! to286a@tod2d@type-descriptor-transformer tod2d@type-descriptor-transformer) (set! tod2f@record-type-descriptor-transformer (lambda (to1138@e to1139@r to113a@mr) (let ((to113e@t to1138@e)) (let ((to1140@ls/false (tod8f@syntax-dispatch to113e@t '(_ any)))) (if (and to1140@ls/false (apply (lambda (to1142@id) (tob88@id? to1142@id)) to1140@ls/false)) (apply (lambda (to1144@id) (let ((to1146@lab (tob9e@id->label to1144@id))) (let ((to1148@b (toba0@label->binding to1146@lab to1139@r))) (let ((to114a@type (toba4@binding-type to1148@b))) (begin (if (not to1146@lab) (toba8@raise-unbound-error to1144@id) (void)) (if (not (and (eq? to114a@type '$rtd) (list? (toba6@binding-value to1148@b)))) (toe6f@syntax-violation '#f '"not a record type" to1138@e) (void)) (todb1@chi-expr (car (toba6@binding-value to1148@b)) to1139@r to113a@mr)))))) to1140@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to113e@t)))))) (set! to286b@tod2f@record-type-descriptor-transformer tod2f@record-type-descriptor-transformer) (set! tod31@record-constructor-descriptor-transformer (lambda (to114c@e to114d@r to114e@mr) (let ((to1152@t to114c@e)) (let ((to1154@ls/false (tod8f@syntax-dispatch to1152@t '(_ any)))) (if (and to1154@ls/false (apply (lambda (to1156@id) (tob88@id? to1156@id)) to1154@ls/false)) (apply (lambda (to1158@id) (let ((to115a@lab (tob9e@id->label to1158@id))) (let ((to115c@b (toba0@label->binding to115a@lab to114d@r))) (let ((to115e@type (toba4@binding-type to115c@b))) (begin (if (not to115a@lab) (toba8@raise-unbound-error to1158@id) (void)) (if (not (and (eq? to115e@type '$rtd) (list? (toba6@binding-value to115c@b)))) (toe6f@syntax-violation '#f '"invalid type" to114c@e) (void)) (todb1@chi-expr (cadr (toba6@binding-value to115c@b)) to114d@r to114e@mr)))))) to1154@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1152@t)))))) (set! to286c@tod31@record-constructor-descriptor-transformer tod31@record-constructor-descriptor-transformer) (set! tod33@when-macro (lambda (to1160@e) (let ((to1162@t to1160@e)) (let ((to1164@ls/false (tod8f@syntax-dispatch to1162@t '(_ any any . each-any)))) (if to1164@ls/false (apply (lambda (to1166@test to1167@e to1168@e*) (tod45@bless (list 'if to1166@test (cons 'begin (cons to1167@e to1168@e*))))) to1164@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1162@t)))))) (set! to286d@tod33@when-macro tod33@when-macro) (set! tod35@unless-macro (lambda (to116c@e) (let ((to116e@t to116c@e)) (let ((to1170@ls/false (tod8f@syntax-dispatch to116e@t '(_ any any . each-any)))) (if to1170@ls/false (apply (lambda (to1172@test to1173@e to1174@e*) (tod45@bless (list 'if (list 'not to1172@test) (cons 'begin (cons to1173@e to1174@e*))))) to1170@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to116e@t)))))) (set! to286e@tod35@unless-macro tod35@unless-macro) (set! tod37@if-transformer (lambda (to1178@e to1179@r to117a@mr) (let ((to117e@t to1178@e)) (let ((to1180@ls/false (tod8f@syntax-dispatch to117e@t '(_ any any any)))) (if to1180@ls/false (apply (lambda (to1182@e0 to1183@e1 to1184@e2) (list 'if (todb1@chi-expr to1182@e0 to1179@r to117a@mr) (todb1@chi-expr to1183@e1 to1179@r to117a@mr) (todb1@chi-expr to1184@e2 to1179@r to117a@mr))) to1180@ls/false) (let ((to1188@t to117e@t)) (let ((to118a@ls/false (tod8f@syntax-dispatch to1188@t '(_ any any)))) (if to118a@ls/false (apply (lambda (to118c@e0 to118d@e1) (list 'if (todb1@chi-expr to118c@e0 to1179@r to117a@mr) (todb1@chi-expr to118d@e1 to1179@r to117a@mr) (toaee@toa4f@build-void))) to118a@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1188@t))))))))) (set! to286f@tod37@if-transformer tod37@if-transformer) (set! tod39@and-transformer (lambda (to1190@e to1191@r to1192@mr) (let ((to1196@t to1190@e)) (let ((to1198@ls/false (tod8f@syntax-dispatch to1196@t '(_ . each-any)))) (if to1198@ls/false (apply (lambda (to119a@e*) (cons 'and (todad@chi-expr* to119a@e* to1191@r to1192@mr))) to1198@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1196@t)))))) (set! to2870@tod39@and-transformer tod39@and-transformer) (set! tod3b@or-transformer (lambda (to119c@e to119d@r to119e@mr) (let ((to11a2@t to119c@e)) (let ((to11a4@ls/false (tod8f@syntax-dispatch to11a2@t '(_ . each-any)))) (if to11a4@ls/false (apply (lambda (to11a6@e*) (cons 'or (todad@chi-expr* to11a6@e* to119d@r to119e@mr))) to11a4@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to11a2@t)))))) (set! to2871@tod3b@or-transformer tod3b@or-transformer) (set! tod3d@case-macro (lambda (to11a8@e) (letrec* ((to11ab@build-last (lambda (to11d2@cls) (let ((to11d4@t to11d2@cls)) (let ((to11d6@ls/false (tod8f@syntax-dispatch to11d4@t '(#(scheme-id else) any . each-any)))) (if to11d6@ls/false (apply (lambda (to11d8@e to11d9@e*) (cons 'begin (cons to11d8@e to11d9@e*))) to11d6@ls/false) (let ((to11dc@t to11d4@t)) (let ((to11de@ls/false (tod8f@syntax-dispatch to11dc@t '_))) (if to11de@ls/false (apply (lambda () (to11ad@build-one to11d2@cls '(if #f #f))) to11de@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to11dc@t))))))))) (to11ad@build-one (lambda (to11c4@cls to11c5@k) (let ((to11c8@t to11c4@cls)) (let ((to11ca@ls/false (tod8f@syntax-dispatch to11c8@t '(each-any any . each-any)))) (if to11ca@ls/false (apply (lambda (to11cc@d* to11cd@e to11ce@e*) (list 'if (list 'memv 't (list 'quote to11cc@d*)) (cons 'begin (cons to11cd@e to11ce@e*)) to11c5@k)) to11ca@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to11c8@t))))))) (let ((to11ae@t to11a8@e)) (let ((to11b0@ls/false (tod8f@syntax-dispatch to11ae@t '(_ any)))) (if to11b0@ls/false (apply (lambda (to11b2@expr) (tod45@bless (cons 'let (cons (list (list 't to11b2@expr)) '((if #f #f)))))) to11b0@ls/false) (let ((to11b4@t to11ae@t)) (let ((to11b6@ls/false (tod8f@syntax-dispatch to11b4@t '(_ any any . each-any)))) (if to11b6@ls/false (apply (lambda (to11b8@expr to11b9@cls to11ba@cls*) (tod45@bless (list 'let (list (list 't to11b8@expr)) (let to11c2@f ((to11be@cls to11b9@cls) (to11bf@cls* to11ba@cls*)) (if (null? to11bf@cls*) (to11ab@build-last to11be@cls) (to11ad@build-one to11be@cls (to11c2@f (car to11bf@cls*) (cdr to11bf@cls*)))))))) to11b6@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to11b4@t)))))))))) (set! to2872@tod3d@case-macro tod3d@case-macro) (set! tod3f@quote-transformer (lambda (to11e0@e to11e1@r to11e2@mr) (let ((to11e6@t to11e0@e)) (let ((to11e8@ls/false (tod8f@syntax-dispatch to11e6@t '(_ any)))) (if to11e8@ls/false (apply (lambda (to11ea@datum) (list 'quote (tob9c@stx->datum to11ea@datum))) to11e8@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to11e6@t)))))) (set! to2873@tod3f@quote-transformer tod3f@quote-transformer) (set! tod41@case-lambda-transformer (lambda (to11ec@e to11ed@r to11ee@mr) (let ((to11f2@t to11ec@e)) (let ((to11f4@ls/false (tod8f@syntax-dispatch to11f2@t '(_ . #(each (any any . each-any)))))) (if to11f4@ls/false (apply (lambda (to11f6@fmls* to11f7@b* to11f8@b**) (call-with-values (lambda () (todb9@chi-lambda-clause* to11ec@e to11f6@fmls* (map cons to11f7@b* to11f8@b**) to11ed@r to11ee@mr)) (lambda (to1200@to11fd to1201@to11ff) (let ((to1204@body* to1201@to11ff) (to1205@fmls* to1200@to11fd)) (toaec@toa1f@build-case-lambda '#f to1205@fmls* to1204@body*))))) to11f4@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to11f2@t)))))) (set! to2874@tod41@case-lambda-transformer tod41@case-lambda-transformer) (set! tod43@lambda-transformer (lambda (to1208@e to1209@r to120a@mr) (let ((to120e@t to1208@e)) (let ((to1210@ls/false (tod8f@syntax-dispatch to120e@t '(_ any any . each-any)))) (if to1210@ls/false (apply (lambda (to1212@fmls to1213@b to1214@b*) (call-with-values (lambda () (todb7@chi-lambda-clause to1208@e to1212@fmls (cons to1213@b to1214@b*) to1209@r to120a@mr)) (lambda (to121c@to1219 to121d@to121b) (let ((to1220@body to121d@to121b) (to1221@fmls to121c@to1219)) (toaeb@toa1d@build-lambda '#f to1221@fmls to1220@body))))) to1210@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to120e@t)))))) (set! to2875@tod43@lambda-transformer tod43@lambda-transformer) (set! tod45@bless (lambda (to1224@x) (tob70@mkstx (let to1228@f ((to1226@x to1224@x)) (if (tob54@stx? to1226@x) to1226@x (if (pair? to1226@x) (cons (to1228@f (car to1226@x)) (to1228@f (cdr to1226@x))) (if (symbol? to1226@x) (tod17@scheme-stx to1226@x) (if (vector? to1226@x) (vector-map to1228@f to1226@x) to1226@x))))) '() '() '()))) (set! to2876@tod45@bless tod45@bless) (set! tod47@with-syntax-macro (lambda (to122a@e) (let ((to122c@t to122a@e)) (let ((to122e@ls/false (tod8f@syntax-dispatch to122c@t '(_ #(each (any any)) any . each-any)))) (if to122e@ls/false (apply (lambda (to1230@pat* to1231@expr* to1232@b to1233@b*) (let ((to1238@idn* (let to123c@f ((to123a@pat* to1230@pat*)) (if (null? to123a@pat*) '() (call-with-values (lambda () (tod8d@convert-pattern (car to123a@pat*) '())) (lambda (to1242@to123f to1243@to1241) (let ((to1246@idn* to1243@to1241) (to1247@pat to1242@to123f)) (append to1246@idn* (to123c@f (cdr to123a@pat*)))))))))) (begin (todb5@verify-formals (map car to1238@idn*) to122a@e) (let ((to124a@t* (toe5d@generate-temporaries to1231@expr*))) (tod45@bless (list 'let (map list to124a@t* to1231@expr*) (let to1250@f ((to124c@pat* to1230@pat*) (to124d@t* to124a@t*)) (if (null? to124c@pat*) (cons 'let (cons '() (cons to1232@b to1233@b*))) (list 'syntax-case (car to124d@t*) '() (list (car to124c@pat*) (to1250@f (cdr to124c@pat*) (cdr to124d@t*))) (list '_ (list 'assertion-violation ''with-syntax '"pattern does not match value" (list 'quote (car to124c@pat*)) (car to124d@t*)))))))))))) to122e@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to122c@t)))))) (set! to2877@tod47@with-syntax-macro tod47@with-syntax-macro) (set! tod49@invalid-fmls-error (lambda (to1252@stx to1253@fmls) (let ((to1256@t to1253@fmls)) (let ((to1258@ls/false (tod8f@syntax-dispatch to1256@t '#(each+ any () any)))) (if to1258@ls/false (apply (lambda (to125a@id* to125b@last) (let to1260@f ((to125e@id* (if (tob88@id? to125b@last) (cons to125b@last to125a@id*) (if (tob7e@syntax-null? to125b@last) to125a@id* (toe6f@syntax-violation '#f '"not an identifier" to1252@stx to125b@last))))) (if (null? to125e@id*) (values) (if (not (tob88@id? (car to125e@id*))) (toe6f@syntax-violation '#f '"not an identifier" to1252@stx (car to125e@id*)) (begin (to1260@f (cdr to125e@id*)) (if (tob94@bound-id-member? (car to125e@id*) (cdr to125e@id*)) (toe6f@syntax-violation '#f '"duplicate binding" to1252@stx (car to125e@id*)) (void))))))) to1258@ls/false) (let ((to1262@t to1256@t)) (let ((to1264@ls/false (tod8f@syntax-dispatch to1262@t '_))) (if to1264@ls/false (apply (lambda () (toe6f@syntax-violation '#f '"malformed binding form" to1252@stx to1253@fmls)) to1264@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1262@t))))))))) (set! to2878@tod49@invalid-fmls-error tod49@invalid-fmls-error) (set! tod4b@let-macro (lambda (to1266@stx) (let ((to1268@t to1266@stx)) (let ((to126a@ls/false (tod8f@syntax-dispatch to1268@t '(_ #(each (any any)) any . each-any)))) (if to126a@ls/false (apply (lambda (to126c@lhs* to126d@rhs* to126e@b to126f@b*) (if (tob90@valid-bound-ids? to126c@lhs*) (tod45@bless (cons (cons 'lambda (cons to126c@lhs* (cons to126e@b to126f@b*))) to126d@rhs*)) (tod49@invalid-fmls-error to1266@stx to126c@lhs*))) to126a@ls/false) (let ((to1274@t to1268@t)) (let ((to1276@ls/false (tod8f@syntax-dispatch to1274@t '(_ any #(each (any any)) any . each-any)))) (if (and to1276@ls/false (apply (lambda (to1278@f to1279@lhs* to127a@rhs* to127b@b to127c@b*) (tob88@id? to1278@f)) to1276@ls/false)) (apply (lambda (to1282@f to1283@lhs* to1284@rhs* to1285@b to1286@b*) (if (tob90@valid-bound-ids? to1283@lhs*) (tod45@bless (cons (list 'letrec (list (list to1282@f (cons 'lambda (cons to1283@lhs* (cons to1285@b to1286@b*))))) to1282@f) to1284@rhs*)) (tod49@invalid-fmls-error to1266@stx to1283@lhs*))) to1276@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1274@t))))))))) (set! to2879@tod4b@let-macro tod4b@let-macro) (set! tod4d@let-values-macro (lambda (to128c@stx) (letrec* ((to128f@rename (lambda (to12f4@x to12f5@old* to12f6@new*) (begin (if (not (tob88@id? to12f4@x)) (toe6f@syntax-violation '#f '"not an indentifier" to128c@stx to12f4@x) (void)) (if (tob94@bound-id-member? to12f4@x to12f5@old*) (toe6f@syntax-violation '#f '"duplicate binding" to128c@stx to12f4@x) (void)) (let ((to12fa@y (gensym (toe75@syntax->datum to12f4@x)))) (values to12fa@y (cons to12f4@x to12f5@old*) (cons to12fa@y to12f6@new*)))))) (to1291@rename* (lambda (to12e2@x* to12e3@old* to12e4@new*) (if (null? to12e2@x*) (values '() to12e3@old* to12e4@new*) (call-with-values (lambda () (to128f@rename (car to12e2@x*) to12e3@old* to12e4@new*)) (lambda (to12e8@x to12e9@old* to12ea@new*) (call-with-values (lambda () (to1291@rename* (cdr to12e2@x*) to12e9@old* to12ea@new*)) (lambda (to12ee@x* to12ef@old* to12f0@new*) (values (cons to12e8@x to12ee@x*) to12ef@old* to12f0@new*))))))))) (let ((to1292@t to128c@stx)) (let ((to1294@ls/false (tod8f@syntax-dispatch to1292@t '(_ () any . each-any)))) (if to1294@ls/false (apply (lambda (to1296@b to1297@b*) (cons* (tod45@bless 'let) '() to1296@b to1297@b*)) to1294@ls/false) (let ((to129a@t to1292@t)) (let ((to129c@ls/false (tod8f@syntax-dispatch to129a@t '(_ #(each (any any)) any . each-any)))) (if to129c@ls/false (apply (lambda (to129e@lhs* to129f@rhs* to12a0@b to12a1@b*) (tod45@bless (let to12ae@f ((to12a6@lhs* to129e@lhs*) (to12a7@rhs* to129f@rhs*) (to12a8@old* '()) (to12a9@new* '())) (if (null? to12a6@lhs*) (cons 'let (cons (map list to12a8@old* to12a9@new*) (cons to12a0@b to12a1@b*))) (let ((to12b0@t (car to12a6@lhs*))) (let ((to12b2@ls/false (tod8f@syntax-dispatch to12b0@t 'each-any))) (if to12b2@ls/false (apply (lambda (to12b4@x*) (call-with-values (lambda () (to1291@rename* to12b4@x* to12a8@old* to12a9@new*)) (lambda (to12bc@to12b7 to12bd@to12b9 to12be@to12bb) (let ((to12c2@new* to12be@to12bb) (to12c3@old* to12bd@to12b9) (to12c4@y* to12bc@to12b7)) (list 'call-with-values (list 'lambda '() (car to12a7@rhs*)) (list 'lambda to12c4@y* (to12ae@f (cdr to12a6@lhs*) (cdr to12a7@rhs*) to12c3@old* to12c2@new*))))))) to12b2@ls/false) (let ((to12c8@t to12b0@t)) (let ((to12ca@ls/false (tod8f@syntax-dispatch to12c8@t '#(each+ any () any)))) (if to12ca@ls/false (apply (lambda (to12cc@x* to12cd@x) (call-with-values (lambda () (to128f@rename to12cd@x to12a8@old* to12a9@new*)) (lambda (to12d0@y to12d1@old* to12d2@new*) (call-with-values (lambda () (to1291@rename* to12cc@x* to12d1@old* to12d2@new*)) (lambda (to12d6@y* to12d7@old* to12d8@new*) (list 'call-with-values (list 'lambda '() (car to12a7@rhs*)) (list 'lambda (append to12d6@y* to12d0@y) (to12ae@f (cdr to12a6@lhs*) (cdr to12a7@rhs*) to12d7@old* to12d8@new*)))))))) to12ca@ls/false) (let ((to12dc@t to12c8@t)) (let ((to12de@ls/false (tod8f@syntax-dispatch to12dc@t 'any))) (if to12de@ls/false (apply (lambda (to12e0@others) (toe6f@syntax-violation '#f '"malformed bindings" to128c@stx to12e0@others)) to12de@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to12dc@t)))))))))))))) to129c@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to129a@t)))))))))) (set! to287a@tod4d@let-values-macro tod4d@let-values-macro) (set! tod4f@let*-values-macro (lambda (to12fc@stx) (letrec* ((to12ff@check (lambda (to132e@x*) (if (not (null? to132e@x*)) (let ((to1330@x (car to132e@x*))) (begin (if (not (tob88@id? to1330@x)) (toe6f@syntax-violation '#f '"not an identifier" to12fc@stx to1330@x) (void)) (to12ff@check (cdr to132e@x*)) (if (tob94@bound-id-member? to1330@x (cdr to132e@x*)) (toe6f@syntax-violation '#f '"duplicate identifier" to12fc@stx to1330@x) (void)))) (void))))) (let ((to1300@t to12fc@stx)) (let ((to1302@ls/false (tod8f@syntax-dispatch to1300@t '(_ () any . each-any)))) (if to1302@ls/false (apply (lambda (to1304@b to1305@b*) (cons* (tod45@bless 'let) '() to1304@b to1305@b*)) to1302@ls/false) (let ((to1308@t to1300@t)) (let ((to130a@ls/false (tod8f@syntax-dispatch to1308@t '(_ #(each (any any)) any . each-any)))) (if to130a@ls/false (apply (lambda (to130c@lhs* to130d@rhs* to130e@b to130f@b*) (tod45@bless (let to1318@f ((to1314@lhs* to130c@lhs*) (to1315@rhs* to130d@rhs*)) (if (null? to1314@lhs*) (cons 'begin (cons to130e@b to130f@b*)) (let ((to131a@t (car to1314@lhs*))) (let ((to131c@ls/false (tod8f@syntax-dispatch to131a@t 'each-any))) (if to131c@ls/false (apply (lambda (to131e@x*) (begin (to12ff@check to131e@x*) (list 'call-with-values (list 'lambda '() (car to1315@rhs*)) (list 'lambda to131e@x* (to1318@f (cdr to1314@lhs*) (cdr to1315@rhs*)))))) to131c@ls/false) (let ((to1320@t to131a@t)) (let ((to1322@ls/false (tod8f@syntax-dispatch to1320@t '#(each+ any () any)))) (if to1322@ls/false (apply (lambda (to1324@x* to1325@x) (begin (to12ff@check (cons to1325@x to1324@x*)) (list 'call-with-values (list 'lambda '() (car to1315@rhs*)) (list 'lambda (append to1324@x* to1325@x) (to1318@f (cdr to1314@lhs*) (cdr to1315@rhs*)))))) to1322@ls/false) (let ((to1328@t to1320@t)) (let ((to132a@ls/false (tod8f@syntax-dispatch to1328@t 'any))) (if to132a@ls/false (apply (lambda (to132c@others) (toe6f@syntax-violation '#f '"malformed bindings" to12fc@stx to132c@others)) to132a@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1328@t)))))))))))))) to130a@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1308@t)))))))))) (set! to287b@tod4f@let*-values-macro tod4f@let*-values-macro) (set! tod51@trace-lambda-macro (lambda (to1332@stx) (let ((to1334@t to1332@stx)) (let ((to1336@ls/false (tod8f@syntax-dispatch to1334@t '(_ any each-any any . each-any)))) (if to1336@ls/false (apply (lambda (to1338@who to1339@fmls to133a@b to133b@b*) (if (tob90@valid-bound-ids? to1339@fmls) (tod45@bless (list 'make-traced-procedure (list 'quote to1338@who) (cons 'lambda (cons to1339@fmls (cons to133a@b to133b@b*))))) (tod49@invalid-fmls-error to1332@stx to1339@fmls))) to1336@ls/false) (let ((to1340@t to1334@t)) (let ((to1342@ls/false (tod8f@syntax-dispatch to1340@t '(_ any #(each+ any () any) any . each-any)))) (if to1342@ls/false (apply (lambda (to1344@who to1345@fmls to1346@last to1347@b to1348@b*) (if (tob90@valid-bound-ids? (cons to1346@last to1345@fmls)) (tod45@bless (list 'make-traced-procedure (list 'quote to1344@who) (cons 'lambda (cons (append to1345@fmls to1346@last) (cons to1347@b to1348@b*))))) (tod49@invalid-fmls-error to1332@stx (append to1345@fmls to1346@last)))) to1342@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1340@t))))))))) (set! to287c@tod51@trace-lambda-macro tod51@trace-lambda-macro) (set! tod53@trace-define-macro (lambda (to134e@stx) (let ((to1350@t to134e@stx)) (let ((to1352@ls/false (tod8f@syntax-dispatch to1350@t '(_ (any . each-any) any . each-any)))) (if to1352@ls/false (apply (lambda (to1354@who to1355@fmls to1356@b to1357@b*) (if (tob90@valid-bound-ids? to1355@fmls) (tod45@bless (list 'define to1354@who (list 'make-traced-procedure (list 'quote to1354@who) (cons 'lambda (cons to1355@fmls (cons to1356@b to1357@b*)))))) (tod49@invalid-fmls-error to134e@stx to1355@fmls))) to1352@ls/false) (let ((to135c@t to1350@t)) (let ((to135e@ls/false (tod8f@syntax-dispatch to135c@t '(_ (any . #(each+ any () any)) any . each-any)))) (if to135e@ls/false (apply (lambda (to1360@who to1361@fmls to1362@last to1363@b to1364@b*) (if (tob90@valid-bound-ids? (cons to1362@last to1361@fmls)) (tod45@bless (list 'define to1360@who (list 'make-traced-procedure (list 'quote to1360@who) (cons 'lambda (cons (append to1361@fmls to1362@last) (cons to1363@b to1364@b*)))))) (tod49@invalid-fmls-error to134e@stx (append to1361@fmls to1362@last)))) to135e@ls/false) (let ((to136a@t to135c@t)) (let ((to136c@ls/false (tod8f@syntax-dispatch to136a@t '(_ any any)))) (if to136c@ls/false (apply (lambda (to136e@who to136f@expr) (if (tob88@id? to136e@who) (tod45@bless (list 'define to136e@who (list 'let (list (list 'v to136f@expr)) (cons 'if (cons '(procedure? v) (cons (cons 'make-traced-procedure (cons (list 'quote to136e@who) '(v))) '((assertion-violation 'trace-define "not a procedure" v)))))))) (toe6f@syntax-violation '#f '"invalid name" to134e@stx))) to136c@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to136a@t)))))))))))) (set! to287d@tod53@trace-define-macro tod53@trace-define-macro) (set! tod55@trace-define-syntax-macro (lambda (to1372@stx) (let ((to1374@t to1372@stx)) (let ((to1376@ls/false (tod8f@syntax-dispatch to1374@t '(_ any any)))) (if to1376@ls/false (apply (lambda (to1378@who to1379@expr) (if (tob88@id? to1378@who) (tod45@bless (list 'define-syntax to1378@who (list 'make-traced-macro (list 'quote to1378@who) to1379@expr))) (toe6f@syntax-violation '#f '"invalid name" to1372@stx))) to1376@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1374@t)))))) (set! to287e@tod55@trace-define-syntax-macro tod55@trace-define-syntax-macro) (set! tod57@trace-let/rec-syntax (lambda (to137c@who) (lambda (to137e@stx) (let ((to1380@t to137e@stx)) (let ((to1382@ls/false (tod8f@syntax-dispatch to1380@t '(_ #(each (any any)) any . each-any)))) (if to1382@ls/false (apply (lambda (to1384@lhs* to1385@rhs* to1386@b to1387@b*) (if (tob90@valid-bound-ids? to1384@lhs*) (let ((to138c@rhs* (map (lambda (to138e@lhs to138f@rhs) (list 'make-traced-macro (list 'quote to138e@lhs) to138f@rhs)) to1384@lhs* to1385@rhs*))) (tod45@bless (cons to137c@who (cons (map list to1384@lhs* to138c@rhs*) (cons to1386@b to1387@b*))))) (tod49@invalid-fmls-error to137e@stx to1384@lhs*))) to1382@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1380@t))))))) (set! to287f@tod57@trace-let/rec-syntax tod57@trace-let/rec-syntax) (set! tod59@trace-let-syntax-macro (tod57@trace-let/rec-syntax 'let-syntax)) (set! to2880@tod59@trace-let-syntax-macro tod59@trace-let-syntax-macro) (set! tod5b@trace-letrec-syntax-macro (tod57@trace-let/rec-syntax 'letrec-syntax)) (set! to2881@tod5b@trace-letrec-syntax-macro tod5b@trace-letrec-syntax-macro) (set! tod5d@guard-macro (lambda (to1392@x) (letrec* ((to1395@gen-clauses (lambda (to13ac@con to13ad@outerk to13ae@clause*) (letrec* ((to13b3@f (lambda (to13ec@x to13ed@k) (let ((to13f0@t to13ec@x)) (let ((to13f2@ls/false (tod8f@syntax-dispatch to13f0@t '(any #(scheme-id =>) any)))) (if to13f2@ls/false (apply (lambda (to13f4@e to13f5@p) (let ((to13f8@t (gensym))) (list 'let (list (list to13f8@t to13f4@e)) (list 'if to13f8@t (list to13f5@p to13f8@t) to13ed@k)))) to13f2@ls/false) (let ((to13fa@t to13f0@t)) (let ((to13fc@ls/false (tod8f@syntax-dispatch to13fa@t '(any)))) (if to13fc@ls/false (apply (lambda (to13fe@e) (let ((to1400@t (gensym))) (list 'let (list (list to1400@t to13fe@e)) (list 'if to1400@t to1400@t to13ed@k)))) to13fc@ls/false) (let ((to1402@t to13fa@t)) (let ((to1404@ls/false (tod8f@syntax-dispatch to1402@t '(any any . each-any)))) (if to1404@ls/false (apply (lambda (to1406@e to1407@v to1408@v*) (list 'if to1406@e (cons 'begin (cons to1407@v to1408@v*)) to13ed@k)) to1404@ls/false) (let ((to140c@t to1402@t)) (let ((to140e@ls/false (tod8f@syntax-dispatch to140c@t '_))) (if to140e@ls/false (apply (lambda () (toe6f@syntax-violation '#f '"invalid guard clause" to13ec@x)) to140e@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to140c@t))))))))))))))) (to13b5@f* (lambda (to13c2@x*) (let ((to13c4@t to13c2@x*)) (let ((to13c6@ls/false (tod8f@syntax-dispatch to13c4@t '()))) (if to13c6@ls/false (apply (lambda () (let ((to13c8@g (gensym))) (values (list to13c8@g (list 'lambda '() (list 'raise-continuable to13ac@con))) to13c8@g))) to13c6@ls/false) (let ((to13ca@t to13c4@t)) (let ((to13cc@ls/false (tod8f@syntax-dispatch to13ca@t '((#(scheme-id else) any . each-any))))) (if to13cc@ls/false (apply (lambda (to13ce@e to13cf@e*) (values (cons 'begin (cons to13ce@e to13cf@e*)) '#f)) to13cc@ls/false) (let ((to13d2@t to13ca@t)) (let ((to13d4@ls/false (tod8f@syntax-dispatch to13d2@t '(any . any)))) (if to13d4@ls/false (apply (lambda (to13d6@cls to13d7@cls*) (call-with-values (lambda () (to13b5@f* to13d7@cls*)) (lambda (to13de@to13db to13df@to13dd) (let ((to13e2@g to13df@to13dd) (to13e3@e to13de@to13db)) (values (to13b3@f to13d6@cls to13e3@e) to13e2@g))))) to13d4@ls/false) (let ((to13e6@t to13d2@t)) (let ((to13e8@ls/false (tod8f@syntax-dispatch to13e6@t 'any))) (if to13e8@ls/false (apply (lambda (to13ea@others) (toe6f@syntax-violation '#f '"invalid guard clause" to13ea@others)) to13e8@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to13e6@t)))))))))))))))) (call-with-values (lambda () (to13b5@f* to13ae@clause*)) (lambda (to13ba@to13b7 to13bb@to13b9) (let ((to13be@raisek to13bb@to13b9) (to13bf@code to13ba@to13b7)) (if to13be@raisek (list (list 'call/cc (list 'lambda (list to13be@raisek) (list to13ad@outerk (list 'lambda '() to13bf@code))))) (list to13ad@outerk (list 'lambda '() to13bf@code)))))))))) (let ((to1396@t to1392@x)) (let ((to1398@ls/false (tod8f@syntax-dispatch to1396@t '(_ (any . each-any) any . each-any)))) (if (and to1398@ls/false (apply (lambda (to139a@con to139b@clause* to139c@b to139d@b*) (tob88@id? to139a@con)) to1398@ls/false)) (apply (lambda (to13a2@con to13a3@clause* to13a4@b to13a5@b*) (let ((to13aa@outerk (gensym))) (tod45@bless (list (list 'call/cc (list 'lambda (list to13aa@outerk) (list 'lambda '() (list 'with-exception-handler (list 'lambda (list to13a2@con) (to1395@gen-clauses to13a2@con to13aa@outerk to13a3@clause*)) (cons 'lambda (cons '() (cons to13a4@b to13a5@b*))))))))))) to1398@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1396@t))))))) (set! to2882@tod5d@guard-macro tod5d@guard-macro) (set! tod5f@define-enumeration-macro (lambda (to1410@stx) (letrec* ((to1413@set? (lambda (to142c@x) (or (null? to142c@x) (and (not (memq (car to142c@x) (cdr to142c@x))) (to1413@set? (cdr to142c@x)))))) (to1415@remove-dups (lambda (to142a@ls) (if (null? to142a@ls) '() (cons (car to142a@ls) (to1415@remove-dups (remq (car to142a@ls) (cdr to142a@ls)))))))) (let ((to1416@t to1410@stx)) (let ((to1418@ls/false (tod8f@syntax-dispatch to1416@t '(_ any each-any any)))) (if (and to1418@ls/false (apply (lambda (to141a@name to141b@id* to141c@maker) (and (tob88@id? to141a@name) (tob88@id? to141c@maker) (for-all tob88@id? to141b@id*))) to1418@ls/false)) (apply (lambda (to1420@name to1421@id* to1422@maker) (let ((to1426@name* (to1415@remove-dups (toe75@syntax->datum to1421@id*))) (to1427@mk (gensym))) (tod45@bless (list 'begin (list 'define to1427@mk (list 'enum-set-constructor (list 'make-enumeration (list 'quote to1426@name*)))) (list 'define-syntax to1420@name (list 'lambda '(x) (list 'syntax-case 'x '() (list '(_ n) '(identifier? (syntax n)) (list 'if (list 'memq '(syntax->datum (syntax n)) (list 'quote to1426@name*)) '(syntax 'n) (cons 'syntax-violation (cons (list 'quote to1420@name) '("not a member of set" x (syntax n))))))))) (list 'define-syntax to1422@maker (list 'lambda '(x) (list 'syntax-case 'x '() (list '(_ n* ...) (list 'begin (cons 'for-each (cons (list 'lambda '(n) (list 'unless '(identifier? n) (cons 'syntax-violation (cons (list 'quote to1422@maker) '("non-identifier argument" x n)))) (list 'unless (list 'memq '(syntax->datum n) (list 'quote to1426@name*)) (cons 'syntax-violation (cons (list 'quote to1422@maker) '("not a member of set" x n))))) '((syntax (n* ...))))) (list 'syntax (cons to1427@mk '('(n* ...))))))))))))) to1418@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1416@t))))))) (set! to2883@tod5f@define-enumeration-macro tod5f@define-enumeration-macro) (set! tod61@time-macro (lambda (to142e@stx) (let ((to1430@t to142e@stx)) (let ((to1432@ls/false (tod8f@syntax-dispatch to1430@t '(_ any)))) (if to1432@ls/false (apply (lambda (to1434@expr) (tod45@bless (cons 'let* (cons (cons '(start (time-usage)) (cons (list 'result (list (list 'lambda '() to1434@expr))) '((end (time-usage)) (used (map - end start)) (real (car used)) (user (cadr used)) (sys (caddr used))))) '((format #t "~%;;~a real ~a user ~a sys~%~!" real user sys) result))))) to1432@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1430@t)))))) (set! to2884@tod61@time-macro tod61@time-macro) (set! tod63@delay-macro (lambda (to1436@stx) (let ((to1438@t to1436@stx)) (let ((to143a@ls/false (tod8f@syntax-dispatch to1438@t '(_ any)))) (if to143a@ls/false (apply (lambda (to143c@expr) (tod45@bless (list 'make-promise (list 'lambda '() to143c@expr)))) to143a@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1438@t)))))) (set! to2885@tod63@delay-macro tod63@delay-macro) (set! tod65@assert-macro (lambda (to143e@stx) (let ((to1440@t to143e@stx)) (let ((to1442@ls/false (tod8f@syntax-dispatch to1440@t '(_ any)))) (if to1442@ls/false (apply (lambda (to1444@expr) (let ((to1446@pos (or (toe67@expression-position to143e@stx) (toe67@expression-position to1444@expr)))) (tod45@bless (list 'let (list (list 'x to1444@expr)) (list 'if 'x 'x (list 'assertion-error (list 'quote to1444@expr) (list 'quote to1446@pos))))))) to1442@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1440@t)))))) (set! to2886@tod65@assert-macro tod65@assert-macro) (set! tod67@endianness-macro (lambda (to1448@stx) (let ((to144a@t to1448@stx)) (let ((to144c@ls/false (tod8f@syntax-dispatch to144a@t '(_ any)))) (if to144c@ls/false (apply (lambda (to144e@e) (let ((to1450@t (toe75@syntax->datum to144e@e))) (if (memv to1450@t '(little)) (tod45@bless ''little) (if (memv to1450@t '(big)) (tod45@bless ''big) (toe6f@syntax-violation '#f '"endianness must be big or little" to1448@stx))))) to144c@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to144a@t)))))) (set! to2887@tod67@endianness-macro tod67@endianness-macro) (set! tod69@identifier-syntax-macro (lambda (to1452@stx) (let ((to1454@t to1452@stx)) (let ((to1456@ls/false (tod8f@syntax-dispatch to1454@t '(_ any)))) (if to1456@ls/false (apply (lambda (to1458@expr) (tod45@bless (list 'lambda '(x) (list 'syntax-case 'x '() (list 'id '(identifier? (syntax id)) (list 'syntax to1458@expr)) (list '(id e* ...) '(identifier? (syntax id)) (cons 'cons (cons (list 'syntax to1458@expr) '((syntax (e* ...)))))))))) to1456@ls/false) (let ((to145a@t to1454@t)) (let ((to145c@ls/false (tod8f@syntax-dispatch to145a@t '(_ (any any) ((#(scheme-id set!) any any) any))))) (if (and to145c@ls/false (apply (lambda (to145e@id1 to145f@expr1 to1460@id2 to1461@expr2 to1462@expr3) (and (tob88@id? to145e@id1) (tob88@id? to1460@id2) (tob88@id? to1461@expr2))) to145c@ls/false)) (apply (lambda (to1468@id1 to1469@expr1 to146a@id2 to146b@expr2 to146c@expr3) (tod45@bless (list 'cons ''macro! (list 'lambda '(x) (list 'syntax-case 'x '(set!) (list 'id '(identifier? (syntax id)) (list 'syntax to1469@expr1)) (list (list 'set! 'id to146b@expr2) (list 'syntax to146c@expr3)) (list '(id e* ...) '(identifier? (syntax id)) (list 'syntax (cons to1469@expr1 '(e* ...))))))))) to145c@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to145a@t))))))))) (set! to2888@tod69@identifier-syntax-macro tod69@identifier-syntax-macro) (set! tod6b@do-macro (lambda (to1472@stx) (letrec* ((to1475@bind (lambda (to148c@x) (let ((to148e@t to148c@x)) (let ((to1490@ls/false (tod8f@syntax-dispatch to148e@t '(any any)))) (if to1490@ls/false (apply (lambda (to1492@x to1493@init) (list to1492@x to1493@init to1492@x)) to1490@ls/false) (let ((to1496@t to148e@t)) (let ((to1498@ls/false (tod8f@syntax-dispatch to1496@t '(any any any)))) (if to1498@ls/false (apply (lambda (to149a@x to149b@init to149c@step) (list to149a@x to149b@init to149c@step)) to1498@ls/false) (let ((to14a0@t to1496@t)) (let ((to14a2@ls/false (tod8f@syntax-dispatch to14a0@t '_))) (if to14a2@ls/false (apply (lambda () (toe6f@syntax-violation '#f '"invalid binding" to1472@stx)) to14a2@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to14a0@t))))))))))))) (let ((to1476@t to1472@stx)) (let ((to1478@ls/false (tod8f@syntax-dispatch to1476@t '(_ each-any (any . each-any) . each-any)))) (if to1478@ls/false (apply (lambda (to147a@binding* to147b@test to147c@expr* to147d@command*) (let ((to1482@t (map to1475@bind to147a@binding*))) (let ((to1484@ls/false (tod8f@syntax-dispatch to1482@t '#(each (any any any))))) (if to1484@ls/false (apply (lambda (to1486@x* to1487@init* to1488@step*) (if (tob90@valid-bound-ids? to1486@x*) (tod45@bless (list 'letrec (list (list 'loop (list 'lambda to1486@x* (list 'if to147b@test (cons 'begin (cons '(if #f #f) to147c@expr*)) (cons 'begin (append to147d@command* (list (cons 'loop to1488@step*)))))))) (cons 'loop to1487@init*))) (toe6f@syntax-violation '#f '"invalid bindings" to1472@stx))) to1484@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1482@t))))) to1478@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1476@t))))))) (set! to2889@tod6b@do-macro tod6b@do-macro) (set! tod6d@let*-macro (lambda (to14a4@stx) (let ((to14a6@t to14a4@stx)) (let ((to14a8@ls/false (tod8f@syntax-dispatch to14a6@t '(_ #(each (any any)) any . each-any)))) (if (and to14a8@ls/false (apply (lambda (to14aa@lhs* to14ab@rhs* to14ac@b to14ad@b*) (for-all tob88@id? to14aa@lhs*)) to14a8@ls/false)) (apply (lambda (to14b2@lhs* to14b3@rhs* to14b4@b to14b5@b*) (tod45@bless (let to14bc@f ((to14ba@x* (map list to14b2@lhs* to14b3@rhs*))) (if (null? to14ba@x*) (cons 'let (cons '() (cons to14b4@b to14b5@b*))) (list 'let (list (car to14ba@x*)) (to14bc@f (cdr to14ba@x*))))))) to14a8@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to14a6@t)))))) (set! to288a@tod6d@let*-macro tod6d@let*-macro) (set! tod6f@or-macro (lambda (to14be@stx) (let ((to14c0@t to14be@stx)) (let ((to14c2@ls/false (tod8f@syntax-dispatch to14c0@t '(_)))) (if to14c2@ls/false (apply (lambda () '#f) to14c2@ls/false) (let ((to14c4@t to14c0@t)) (let ((to14c6@ls/false (tod8f@syntax-dispatch to14c4@t '(_ any . each-any)))) (if to14c6@ls/false (apply (lambda (to14c8@e to14c9@e*) (tod45@bless (let to14d0@f ((to14cc@e to14c8@e) (to14cd@e* to14c9@e*)) (if (null? to14cd@e*) (list 'begin '#f to14cc@e) (list 'let (list (list 't to14cc@e)) (list 'if 't 't (to14d0@f (car to14cd@e*) (cdr to14cd@e*)))))))) to14c6@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to14c4@t))))))))) (set! to288b@tod6f@or-macro tod6f@or-macro) (set! tod71@and-macro (lambda (to14d2@stx) (let ((to14d4@t to14d2@stx)) (let ((to14d6@ls/false (tod8f@syntax-dispatch to14d4@t '(_)))) (if to14d6@ls/false (apply (lambda () '#t) to14d6@ls/false) (let ((to14d8@t to14d4@t)) (let ((to14da@ls/false (tod8f@syntax-dispatch to14d8@t '(_ any . each-any)))) (if to14da@ls/false (apply (lambda (to14dc@e to14dd@e*) (tod45@bless (let to14e4@f ((to14e0@e to14dc@e) (to14e1@e* to14dd@e*)) (if (null? to14e1@e*) (list 'begin '#f to14e0@e) (cons 'if (cons to14e0@e (cons (to14e4@f (car to14e1@e*) (cdr to14e1@e*)) '(#f)))))))) to14da@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to14d8@t))))))))) (set! to288c@tod71@and-macro tod71@and-macro) (set! tod73@cond-macro (lambda (to14e6@stx) (let ((to14e8@t to14e6@stx)) (let ((to14ea@ls/false (tod8f@syntax-dispatch to14e8@t '(_ any . each-any)))) (if to14ea@ls/false (apply (lambda (to14ec@cls to14ed@cls*) (tod45@bless (let to14f4@f ((to14f0@cls to14ec@cls) (to14f1@cls* to14ed@cls*)) (if (null? to14f1@cls*) (let ((to14f6@t to14f0@cls)) (let ((to14f8@ls/false (tod8f@syntax-dispatch to14f6@t '(#(scheme-id else) any . each-any)))) (if to14f8@ls/false (apply (lambda (to14fa@e to14fb@e*) (cons 'begin (cons to14fa@e to14fb@e*))) to14f8@ls/false) (let ((to14fe@t to14f6@t)) (let ((to1500@ls/false (tod8f@syntax-dispatch to14fe@t '(any #(scheme-id =>) any)))) (if to1500@ls/false (apply (lambda (to1502@e to1503@p) (list 'let (list (list 't to1502@e)) (list 'if 't (cons to1503@p '(t))))) to1500@ls/false) (let ((to1506@t to14fe@t)) (let ((to1508@ls/false (tod8f@syntax-dispatch to1506@t '(any)))) (if to1508@ls/false (apply (lambda (to150a@e) (cons 'or (cons to150a@e '((if #f #f))))) to1508@ls/false) (let ((to150c@t to1506@t)) (let ((to150e@ls/false (tod8f@syntax-dispatch to150c@t '(any . each-any)))) (if to150e@ls/false (apply (lambda (to1510@e to1511@e*) (list 'if to1510@e (cons 'begin to1511@e*))) to150e@ls/false) (let ((to1514@t to150c@t)) (let ((to1516@ls/false (tod8f@syntax-dispatch to1514@t '_))) (if to1516@ls/false (apply (lambda () (toe6f@syntax-violation '#f '"invalid last clause" to14e6@stx)) to1516@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1514@t)))))))))))))))) (let ((to1518@t to14f0@cls)) (let ((to151a@ls/false (tod8f@syntax-dispatch to1518@t '(#(scheme-id else) any . each-any)))) (if to151a@ls/false (apply (lambda (to151c@e to151d@e*) (toe6f@syntax-violation '#f '"incorrect position of keyword else" to14e6@stx)) to151a@ls/false) (let ((to1520@t to1518@t)) (let ((to1522@ls/false (tod8f@syntax-dispatch to1520@t '(any #(scheme-id =>) any)))) (if to1522@ls/false (apply (lambda (to1524@e to1525@p) (list 'let (list (list 't to1524@e)) (list 'if 't (cons to1525@p '(t)) (to14f4@f (car to14f1@cls*) (cdr to14f1@cls*))))) to1522@ls/false) (let ((to1528@t to1520@t)) (let ((to152a@ls/false (tod8f@syntax-dispatch to1528@t '(any)))) (if to152a@ls/false (apply (lambda (to152c@e) (list 'or to152c@e (to14f4@f (car to14f1@cls*) (cdr to14f1@cls*)))) to152a@ls/false) (let ((to152e@t to1528@t)) (let ((to1530@ls/false (tod8f@syntax-dispatch to152e@t '(any . each-any)))) (if to1530@ls/false (apply (lambda (to1532@e to1533@e*) (list 'if to1532@e (cons 'begin to1533@e*) (to14f4@f (car to14f1@cls*) (cdr to14f1@cls*)))) to1530@ls/false) (let ((to1536@t to152e@t)) (let ((to1538@ls/false (tod8f@syntax-dispatch to1536@t '_))) (if to1538@ls/false (apply (lambda () (toe6f@syntax-violation '#f '"invalid last clause" to14e6@stx)) to1538@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1536@t)))))))))))))))))))) to14ea@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to14e8@t)))))) (set! to288d@tod73@cond-macro tod73@cond-macro) (set! tod75@do-include (lambda (to153a@stx to153b@id to153c@filename) (let ((to1540@filename (tob9c@stx->datum to153c@filename))) (begin (if (not (and (string? to1540@filename) (tob88@id? to153b@id))) (toe6f@syntax-violation '#f '"invalid syntax" to153a@stx) (void)) (cons (tod45@bless 'begin) (with-input-from-file to1540@filename (lambda () (let to1544@f ((to1542@ls '())) (let ((to1546@x (to6ca@to59a@read-annotated))) (if (eof-object? to1546@x) (reverse to1542@ls) (to1544@f (cons (tob68@datum->stx to153b@id to1546@x) to1542@ls)))))))))))) (set! to288e@tod75@do-include tod75@do-include) (set! tod77@include-macro (lambda (to1548@e) (let ((to154a@t to1548@e)) (let ((to154c@ls/false (tod8f@syntax-dispatch to154a@t '(any any)))) (if to154c@ls/false (apply (lambda (to154e@id to154f@filename) (tod75@do-include to1548@e to154e@id to154f@filename)) to154c@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to154a@t)))))) (set! to288f@tod77@include-macro tod77@include-macro) (set! tod79@include-into-macro (lambda (to1552@e) (let ((to1554@t to1552@e)) (let ((to1556@ls/false (tod8f@syntax-dispatch to1554@t '(_ any any)))) (if to1556@ls/false (apply (lambda (to1558@id to1559@filename) (tod75@do-include to1552@e to1558@id to1559@filename)) to1556@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1554@t)))))) (set! to2890@tod79@include-into-macro tod79@include-into-macro) (set! tod7b@syntax-rules-macro (lambda (to155c@e) (let ((to155e@t to155c@e)) (let ((to1560@ls/false (tod8f@syntax-dispatch to155e@t '(_ each-any . #(each (any any)))))) (if to1560@ls/false (apply (lambda (to1562@lits to1563@pat* to1564@tmp*) (begin (tod95@verify-literals to1562@lits to155c@e) (tod45@bless (list 'lambda '(x) (cons 'syntax-case (cons 'x (cons to1562@lits (map (lambda (to1568@pat to1569@tmp) (let ((to156c@t to1568@pat)) (let ((to156e@ls/false (tod8f@syntax-dispatch to156c@t '(_ . any)))) (if to156e@ls/false (apply (lambda (to1570@rest) (list (cons 'g to1570@rest) (list 'syntax to1569@tmp))) to156e@ls/false) (let ((to1572@t to156c@t)) (let ((to1574@ls/false (tod8f@syntax-dispatch to1572@t '_))) (if to1574@ls/false (apply (lambda () (toe6f@syntax-violation '#f '"invalid syntax-rules pattern" to155c@e to1568@pat)) to1574@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1572@t)))))))) to1563@pat* to1564@tmp*)))))))) to1560@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to155e@t)))))) (set! to2891@tod7b@syntax-rules-macro tod7b@syntax-rules-macro) (set! tod7d@quasiquote-macro (letrec* ((to1577@datum (lambda (to1678@x) (list (tod17@scheme-stx 'quote) (tob70@mkstx to1678@x tob0c@top-mark* '() '())))) (to1593@quasicons* (lambda (to1670@x to1671@y) (let to1676@f ((to1674@x to1670@x)) (if (null? to1674@x) to1671@y (to1595@quasicons (car to1674@x) (to1676@f (cdr to1674@x))))))) (to1595@quasicons (lambda (to164a@x to164b@y) (let ((to164e@t to164b@y)) (let ((to1650@ls/false (tod8f@syntax-dispatch to164e@t '(#(scheme-id quote) any)))) (if to1650@ls/false (apply (lambda (to1652@dy) (let ((to1654@t to164a@x)) (let ((to1656@ls/false (tod8f@syntax-dispatch to1654@t '(#(scheme-id quote) any)))) (if to1656@ls/false (apply (lambda (to1658@dx) (list (tod17@scheme-stx 'quote) (cons to1658@dx to1652@dy))) to1656@ls/false) (let ((to165a@t to1654@t)) (let ((to165c@ls/false (tod8f@syntax-dispatch to165a@t '_))) (if to165c@ls/false (apply (lambda () (let ((to165e@t to1652@dy)) (let ((to1660@ls/false (tod8f@syntax-dispatch to165e@t '()))) (if to1660@ls/false (apply (lambda () (list (tod17@scheme-stx 'list) to164a@x)) to1660@ls/false) (let ((to1662@t to165e@t)) (let ((to1664@ls/false (tod8f@syntax-dispatch to1662@t '_))) (if to1664@ls/false (apply (lambda () (list (tod17@scheme-stx 'cons) to164a@x to164b@y)) to1664@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1662@t)))))))) to165c@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to165a@t)))))))) to1650@ls/false) (let ((to1666@t to164e@t)) (let ((to1668@ls/false (tod8f@syntax-dispatch to1666@t '(#(scheme-id list) . each-any)))) (if to1668@ls/false (apply (lambda (to166a@stuff) (cons* (tod17@scheme-stx 'list) to164a@x to166a@stuff)) to1668@ls/false) (let ((to166c@t to1666@t)) (let ((to166e@ls/false (tod8f@syntax-dispatch to166c@t '_))) (if to166e@ls/false (apply (lambda () (list (tod17@scheme-stx 'cons) to164a@x to164b@y)) to166e@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to166c@t)))))))))))) (to1597@quasiappend (lambda (to1630@x to1631@y) (let ((to1634@ls (let to1638@f ((to1636@x to1630@x)) (if (null? to1636@x) (let ((to163a@t to1631@y)) (let ((to163c@ls/false (tod8f@syntax-dispatch to163a@t '(#(scheme-id quote) ())))) (if to163c@ls/false (apply (lambda () '()) to163c@ls/false) (let ((to163e@t to163a@t)) (let ((to1640@ls/false (tod8f@syntax-dispatch to163e@t '_))) (if to1640@ls/false (apply (lambda () (list to1631@y)) to1640@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to163e@t))))))) (let ((to1642@t (car to1636@x))) (let ((to1644@ls/false (tod8f@syntax-dispatch to1642@t '(#(scheme-id quote) ())))) (if to1644@ls/false (apply (lambda () (to1638@f (cdr to1636@x))) to1644@ls/false) (let ((to1646@t to1642@t)) (let ((to1648@ls/false (tod8f@syntax-dispatch to1646@t '_))) (if to1648@ls/false (apply (lambda () (cons (car to1636@x) (to1638@f (cdr to1636@x)))) to1648@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1646@t))))))))))) (if (null? to1634@ls) (list (tod17@scheme-stx 'quote) '()) (if (null? (cdr to1634@ls)) (car to1634@ls) (cons* (tod17@scheme-stx 'append) to1634@ls)))))) (to1599@quasivector (lambda (to15fe@x) (let ((to1600@pat-x to15fe@x)) (let ((to1602@t to1600@pat-x)) (let ((to1604@ls/false (tod8f@syntax-dispatch to1602@t '(#(scheme-id quote) each-any)))) (if to1604@ls/false (apply (lambda (to1606@x*) (list (tod17@scheme-stx 'quote) (list->vector to1606@x*))) to1604@ls/false) (let ((to1608@t to1602@t)) (let ((to160a@ls/false (tod8f@syntax-dispatch to1608@t '_))) (if to160a@ls/false (apply (lambda () (let to1612@f ((to160c@x to15fe@x) (to160d@k (lambda (to1610@ls) (cons* (tod17@scheme-stx 'vector) to1610@ls)))) (let ((to1614@t to160c@x)) (let ((to1616@ls/false (tod8f@syntax-dispatch to1614@t '(#(scheme-id quote) each-any)))) (if to1616@ls/false (apply (lambda (to1618@x*) (to160d@k (map (lambda (to161a@x) (list (tod17@scheme-stx 'quote) to161a@x)) to1618@x*))) to1616@ls/false) (let ((to161c@t to1614@t)) (let ((to161e@ls/false (tod8f@syntax-dispatch to161c@t '(#(scheme-id list) . each-any)))) (if to161e@ls/false (apply (lambda (to1620@x*) (to160d@k to1620@x*)) to161e@ls/false) (let ((to1622@t to161c@t)) (let ((to1624@ls/false (tod8f@syntax-dispatch to1622@t '(#(scheme-id cons) any any)))) (if to1624@ls/false (apply (lambda (to1626@x to1627@y) (to1612@f to1627@y (lambda (to162a@ls) (to160d@k (cons to1626@x to162a@ls))))) to1624@ls/false) (let ((to162c@t to1622@t)) (let ((to162e@ls/false (tod8f@syntax-dispatch to162c@t '_))) (if to162e@ls/false (apply (lambda () (list (tod17@scheme-stx 'list->vector) to1600@pat-x)) to162e@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to162c@t))))))))))))))) to160a@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1608@t)))))))))) (to159b@vquasi (lambda (to15dc@p to15dd@lev) (let ((to15e0@t to15dc@p)) (let ((to15e2@ls/false (tod8f@syntax-dispatch to15e0@t '(any . any)))) (if to15e2@ls/false (apply (lambda (to15e4@p to15e5@q) (let ((to15e8@t to15e4@p)) (let ((to15ea@ls/false (tod8f@syntax-dispatch to15e8@t '(#(scheme-id unquote) . each-any)))) (if to15ea@ls/false (apply (lambda (to15ec@p) (if (= to15dd@lev '0) (to1593@quasicons* to15ec@p (to159b@vquasi to15e5@q to15dd@lev)) (to1595@quasicons (to1595@quasicons (to1577@datum 'unquote) (to159d@quasi to15ec@p (- to15dd@lev '1))) (to159b@vquasi to15e5@q to15dd@lev)))) to15ea@ls/false) (let ((to15ee@t to15e8@t)) (let ((to15f0@ls/false (tod8f@syntax-dispatch to15ee@t '(#(scheme-id unquote-splicing) . each-any)))) (if to15f0@ls/false (apply (lambda (to15f2@p) (if (= to15dd@lev '0) (to1597@quasiappend to15f2@p (to159b@vquasi to15e5@q to15dd@lev)) (to1595@quasicons (to1595@quasicons (to1577@datum 'unquote-splicing) (to159d@quasi to15f2@p (- to15dd@lev '1))) (to159b@vquasi to15e5@q to15dd@lev)))) to15f0@ls/false) (let ((to15f4@t to15ee@t)) (let ((to15f6@ls/false (tod8f@syntax-dispatch to15f4@t 'any))) (if to15f6@ls/false (apply (lambda (to15f8@p) (to1595@quasicons (to159d@quasi to15f8@p to15dd@lev) (to159b@vquasi to15e5@q to15dd@lev))) to15f6@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to15f4@t))))))))))) to15e2@ls/false) (let ((to15fa@t to15e0@t)) (let ((to15fc@ls/false (tod8f@syntax-dispatch to15fa@t '()))) (if to15fc@ls/false (apply (lambda () (list (tod17@scheme-stx 'quote) '())) to15fc@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to15fa@t))))))))) (to159d@quasi (lambda (to15a6@p to15a7@lev) (let ((to15aa@t to15a6@p)) (let ((to15ac@ls/false (tod8f@syntax-dispatch to15aa@t '(#(scheme-id unquote) any)))) (if to15ac@ls/false (apply (lambda (to15ae@p) (if (= to15a7@lev '0) to15ae@p (to1595@quasicons (to1577@datum 'unquote) (to159d@quasi (list to15ae@p) (- to15a7@lev '1))))) to15ac@ls/false) (let ((to15b0@t to15aa@t)) (let ((to15b2@ls/false (tod8f@syntax-dispatch to15b0@t '((#(scheme-id unquote) . each-any) . any)))) (if to15b2@ls/false (apply (lambda (to15b4@p to15b5@q) (if (= to15a7@lev '0) (to1593@quasicons* to15b4@p (to159d@quasi to15b5@q to15a7@lev)) (to1595@quasicons (to1595@quasicons (to1577@datum 'unquote) (to159d@quasi to15b4@p (- to15a7@lev '1))) (to159d@quasi to15b5@q to15a7@lev)))) to15b2@ls/false) (let ((to15b8@t to15b0@t)) (let ((to15ba@ls/false (tod8f@syntax-dispatch to15b8@t '((#(scheme-id unquote-splicing) . each-any) . any)))) (if to15ba@ls/false (apply (lambda (to15bc@p to15bd@q) (if (= to15a7@lev '0) (to1597@quasiappend to15bc@p (to159d@quasi to15bd@q to15a7@lev)) (to1595@quasicons (to1595@quasicons (to1577@datum 'unquote-splicing) (to159d@quasi to15bc@p (- to15a7@lev '1))) (to159d@quasi to15bd@q to15a7@lev)))) to15ba@ls/false) (let ((to15c0@t to15b8@t)) (let ((to15c2@ls/false (tod8f@syntax-dispatch to15c0@t '(#(scheme-id quasiquote) any)))) (if to15c2@ls/false (apply (lambda (to15c4@p) (to1595@quasicons (to1577@datum 'quasiquote) (to159d@quasi (list to15c4@p) (+ to15a7@lev '1)))) to15c2@ls/false) (let ((to15c6@t to15c0@t)) (let ((to15c8@ls/false (tod8f@syntax-dispatch to15c6@t '(any . any)))) (if to15c8@ls/false (apply (lambda (to15ca@p to15cb@q) (to1595@quasicons (to159d@quasi to15ca@p to15a7@lev) (to159d@quasi to15cb@q to15a7@lev))) to15c8@ls/false) (let ((to15ce@t to15c6@t)) (let ((to15d0@ls/false (tod8f@syntax-dispatch to15ce@t '#(vector each-any)))) (if (and to15d0@ls/false (apply (lambda (to15d2@x) (not (tob54@stx? to15d2@x))) to15d0@ls/false)) (apply (lambda (to15d4@x) (to1599@quasivector (to159b@vquasi to15d4@x to15a7@lev))) to15d0@ls/false) (let ((to15d6@t to15ce@t)) (let ((to15d8@ls/false (tod8f@syntax-dispatch to15d6@t 'any))) (if to15d8@ls/false (apply (lambda (to15da@p) (list (tod17@scheme-stx 'quote) to15da@p)) to15d8@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to15d6@t))))))))))))))))))))))))) (lambda (to159e@x) (let ((to15a0@t to159e@x)) (let ((to15a2@ls/false (tod8f@syntax-dispatch to15a0@t '(_ any)))) (if to15a2@ls/false (apply (lambda (to15a4@e) (to159d@quasi to15a4@e '0)) to15a2@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to15a0@t))))))) (set! to2892@tod7d@quasiquote-macro tod7d@quasiquote-macro) (set! tod7f@quasisyntax-macro (letrec* ((to167b@quasi (lambda (to1696@p to1697@lev) (let ((to169a@t to1696@p)) (let ((to169c@ls/false (tod8f@syntax-dispatch to169a@t '(#(scheme-id unsyntax) any)))) (if to169c@ls/false (apply (lambda (to169e@p) (if (= to1697@lev '0) (let ((to16a0@g (gensym))) (values (list to16a0@g) (list to169e@p) to16a0@g)) (call-with-values (lambda () (to167b@quasi to169e@p (- to1697@lev '1))) (lambda (to16a8@to16a3 to16a9@to16a5 to16aa@to16a7) (let ((to16ae@p to16aa@to16a7) (to16af@rhs* to16a9@to16a5) (to16b0@lhs* to16a8@to16a3)) (values to16b0@lhs* to16af@rhs* (list 'unsyntax to16ae@p))))))) to169c@ls/false) (let ((to16b4@t to169a@t)) (let ((to16b6@ls/false (tod8f@syntax-dispatch to16b4@t '#(scheme-id unsyntax)))) (if (and to16b6@ls/false (apply (lambda () (= to1697@lev '0)) to16b6@ls/false)) (apply (lambda () (toe6f@syntax-violation '#f '"incorrect use of unsyntax" to1696@p)) to16b6@ls/false) (let ((to16b8@t to16b4@t)) (let ((to16ba@ls/false (tod8f@syntax-dispatch to16b8@t '((#(scheme-id unsyntax) . each-any) . any)))) (if to16ba@ls/false (apply (lambda (to16bc@p* to16bd@q) (call-with-values (lambda () (to167b@quasi to16bd@q to1697@lev)) (lambda (to16c6@to16c1 to16c7@to16c3 to16c8@to16c5) (let ((to16cc@q to16c8@to16c5) (to16cd@rhs* to16c7@to16c3) (to16ce@lhs* to16c6@to16c1)) (if (= to1697@lev '0) (let ((to16d2@g* (map (lambda (to16d4@x) (gensym)) to16bc@p*))) (values (append to16d2@g* to16ce@lhs*) (append to16bc@p* to16cd@rhs*) (append to16d2@g* to16cc@q))) (call-with-values (lambda () (to167b@quasi to16bc@p* (- to1697@lev '1))) (lambda (to16dc@to16d7 to16dd@to16d9 to16de@to16db) (let ((to16e2@p* to16de@to16db) (to16e3@rhs2* to16dd@to16d9) (to16e4@lhs2* to16dc@to16d7)) (values (append to16e4@lhs2* to16ce@lhs*) (append to16e3@rhs2* to16cd@rhs*) (cons (cons 'unsyntax to16e2@p*) to16cc@q)))))))))) to16ba@ls/false) (let ((to16e8@t to16b8@t)) (let ((to16ea@ls/false (tod8f@syntax-dispatch to16e8@t '((#(scheme-id unsyntax-splicing) . each-any) . any)))) (if to16ea@ls/false (apply (lambda (to16ec@p* to16ed@q) (call-with-values (lambda () (to167b@quasi to16ed@q to1697@lev)) (lambda (to16f6@to16f1 to16f7@to16f3 to16f8@to16f5) (let ((to16fc@q to16f8@to16f5) (to16fd@rhs* to16f7@to16f3) (to16fe@lhs* to16f6@to16f1)) (if (= to1697@lev '0) (let ((to1702@g* (map (lambda (to1704@x) (gensym)) to16ec@p*))) (values (append (map (lambda (to1706@g) (cons to1706@g '(...))) to1702@g*) to16fe@lhs*) (append to16ec@p* to16fd@rhs*) (append (apply append (map (lambda (to1708@g) (cons to1708@g '(...))) to1702@g*)) to16fc@q))) (call-with-values (lambda () (to167b@quasi to16ec@p* (- to1697@lev '1))) (lambda (to1710@to170b to1711@to170d to1712@to170f) (let ((to1716@p* to1712@to170f) (to1717@rhs2* to1711@to170d) (to1718@lhs2* to1710@to170b)) (values (append to1718@lhs2* to16fe@lhs*) (append to1717@rhs2* to16fd@rhs*) (cons (cons 'unsyntax-splicing to1716@p*) to16fc@q)))))))))) to16ea@ls/false) (let ((to171c@t to16e8@t)) (let ((to171e@ls/false (tod8f@syntax-dispatch to171c@t '#(scheme-id unsyntax-splicing)))) (if (and to171e@ls/false (apply (lambda () (= to1697@lev '0)) to171e@ls/false)) (apply (lambda () (toe6f@syntax-violation '#f '"incorrect use of unsyntax-splicing" to1696@p)) to171e@ls/false) (let ((to1720@t to171c@t)) (let ((to1722@ls/false (tod8f@syntax-dispatch to1720@t '(#(scheme-id quasisyntax) any)))) (if to1722@ls/false (apply (lambda (to1724@p) (call-with-values (lambda () (to167b@quasi to1724@p (+ to1697@lev '1))) (lambda (to172c@to1727 to172d@to1729 to172e@to172b) (let ((to1732@p to172e@to172b) (to1733@rhs* to172d@to1729) (to1734@lhs* to172c@to1727)) (values to1734@lhs* to1733@rhs* (list 'quasisyntax to1732@p)))))) to1722@ls/false) (let ((to1738@t to1720@t)) (let ((to173a@ls/false (tod8f@syntax-dispatch to1738@t '(any . any)))) (if to173a@ls/false (apply (lambda (to173c@p to173d@q) (call-with-values (lambda () (to167b@quasi to173c@p to1697@lev)) (lambda (to174c@to1741 to174d@to1743 to174e@to1745) (call-with-values (lambda () (to167b@quasi to173d@q to1697@lev)) (lambda (to1752@to1747 to1753@to1749 to1754@to174b) (let ((to1758@q to1754@to174b) (to1759@rhs2* to1753@to1749) (to175a@lhs2* to1752@to1747) (to175b@p to174e@to1745) (to175c@rhs* to174d@to1743) (to175d@lhs* to174c@to1741)) (values (append to175a@lhs2* to175d@lhs*) (append to1759@rhs2* to175c@rhs*) (cons to175b@p to1758@q)))))))) to173a@ls/false) (let ((to1764@t to1738@t)) (let ((to1766@ls/false (tod8f@syntax-dispatch to1764@t '#(vector each-any)))) (if to1766@ls/false (apply (lambda (to1768@x*) (call-with-values (lambda () (to167b@quasi to1768@x* to1697@lev)) (lambda (to1770@to176b to1771@to176d to1772@to176f) (let ((to1776@x* to1772@to176f) (to1777@rhs* to1771@to176d) (to1778@lhs* to1770@to176b)) (values to1778@lhs* to1777@rhs* (list->vector to1776@x*)))))) to1766@ls/false) (let ((to177c@t to1764@t)) (let ((to177e@ls/false (tod8f@syntax-dispatch to177c@t '_))) (if to177e@ls/false (apply (lambda () (values '() '() to1696@p)) to177e@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to177c@t))))))))))))))))))))))))))))))) (lambda (to167c@x) (let ((to167e@t to167c@x)) (let ((to1680@ls/false (tod8f@syntax-dispatch to167e@t '(_ any)))) (if to1680@ls/false (apply (lambda (to1682@e) (call-with-values (lambda () (to167b@quasi to1682@e '0)) (lambda (to168a@to1685 to168b@to1687 to168c@to1689) (let ((to1690@v to168c@to1689) (to1691@rhs* to168b@to1687) (to1692@lhs* to168a@to1685)) (tod45@bless (list 'syntax-case (cons 'list to1691@rhs*) '() (list to1692@lhs* (list 'syntax to1690@v)))))))) to1680@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to167e@t))))))) (set! to2893@tod7f@quasisyntax-macro tod7f@quasisyntax-macro) (set! tod81@define-struct-macro (lambda (to1780@stx) (toe6f@syntax-violation '#f '"define-struct not supported" to1780@stx))) (set! to2894@tod81@define-struct-macro tod81@define-struct-macro) (set! tod83@define-record-type-macro (lambda (to1782@x) (letrec* ((to1785@id (lambda (to1978@ctxt . to197a@str*) (toe73@datum->syntax to1978@ctxt (string->symbol (apply string-append (map (lambda (to197c@x) (if (symbol? to197c@x) (symbol->string to197c@x) (if (string? to197c@x) to197c@x (assertion-violation 'define-record-type '"BUG")))) to197a@str*)))))) (to1787@get-record-name (lambda (to1966@spec) (let ((to1968@t to1966@spec)) (let ((to196a@ls/false (tod8f@syntax-dispatch to1968@t '(any any any)))) (if to196a@ls/false (apply (lambda (to196c@foo to196d@make-foo to196e@foo?) to196c@foo) to196a@ls/false) (let ((to1972@t to1968@t)) (let ((to1974@ls/false (tod8f@syntax-dispatch to1972@t 'any))) (if to1974@ls/false (apply (lambda (to1976@foo) to1976@foo) to1974@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1972@t))))))))) (to1789@get-record-constructor-name (lambda (to1952@spec) (let ((to1954@t to1952@spec)) (let ((to1956@ls/false (tod8f@syntax-dispatch to1954@t '(any any any)))) (if to1956@ls/false (apply (lambda (to1958@foo to1959@make-foo to195a@foo?) to1959@make-foo) to1956@ls/false) (let ((to195e@t to1954@t)) (let ((to1960@ls/false (tod8f@syntax-dispatch to195e@t 'any))) (if (and to1960@ls/false (apply (lambda (to1962@foo) (tob88@id? to1962@foo)) to1960@ls/false)) (apply (lambda (to1964@foo) (to1785@id to1964@foo '"make-" (tob9c@stx->datum to1964@foo))) to1960@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to195e@t))))))))) (to178b@get-record-predicate-name (lambda (to193e@spec) (let ((to1940@t to193e@spec)) (let ((to1942@ls/false (tod8f@syntax-dispatch to1940@t '(any any any)))) (if to1942@ls/false (apply (lambda (to1944@foo to1945@make-foo to1946@foo?) to1946@foo?) to1942@ls/false) (let ((to194a@t to1940@t)) (let ((to194c@ls/false (tod8f@syntax-dispatch to194a@t 'any))) (if (and to194c@ls/false (apply (lambda (to194e@foo) (tob88@id? to194e@foo)) to194c@ls/false)) (apply (lambda (to1950@foo) (to1785@id to1950@foo (tob9c@stx->datum to1950@foo) '"?")) to194c@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to194a@t))))))))) (to178d@get-clause (lambda (to192c@id to192d@ls) (let ((to1930@t to192d@ls)) (let ((to1932@ls/false (tod8f@syntax-dispatch to1930@t '()))) (if to1932@ls/false (apply (lambda () '#f) to1932@ls/false) (let ((to1934@t to1930@t)) (let ((to1936@ls/false (tod8f@syntax-dispatch to1934@t '((any . any) . any)))) (if to1936@ls/false (apply (lambda (to1938@x to1939@rest to193a@ls) (if (tob8e@free-id=? (tod45@bless to192c@id) to1938@x) (cons to1938@x to1939@rest) (to178d@get-clause to192c@id to193a@ls))) to1936@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1934@t))))))))) (to178f@foo-rtd-code (lambda (to18da@name to18db@clause* to18dc@parent-rtd-code) (letrec* ((to18e1@convert-field-spec* (lambda (to1912@ls) (list->vector (map (lambda (to1914@x) (let ((to1916@t to1914@x)) (let ((to1918@ls/false (tod8f@syntax-dispatch to1916@t '(#(scheme-id mutable) any . any)))) (if to1918@ls/false (apply (lambda (to191a@name to191b@rest) (list 'mutable to191a@name)) to1918@ls/false) (let ((to191e@t to1916@t)) (let ((to1920@ls/false (tod8f@syntax-dispatch to191e@t '(#(scheme-id immutable) any . any)))) (if to1920@ls/false (apply (lambda (to1922@name to1923@rest) (list 'immutable to1922@name)) to1920@ls/false) (let ((to1926@t to191e@t)) (let ((to1928@ls/false (tod8f@syntax-dispatch to1926@t 'any))) (if to1928@ls/false (apply (lambda (to192a@name) (list 'immutable to192a@name)) to1928@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1926@t))))))))))) to1912@ls))))) (let ((to18e2@uid-code (let ((to18ea@t (to178d@get-clause 'nongenerative to18db@clause*))) (let ((to18ec@ls/false (tod8f@syntax-dispatch to18ea@t '(_)))) (if to18ec@ls/false (apply (lambda () (list 'quote (gensym))) to18ec@ls/false) (let ((to18ee@t to18ea@t)) (let ((to18f0@ls/false (tod8f@syntax-dispatch to18ee@t '(_ any)))) (if to18f0@ls/false (apply (lambda (to18f2@uid) (list 'quote to18f2@uid)) to18f0@ls/false) (let ((to18f4@t to18ee@t)) (let ((to18f6@ls/false (tod8f@syntax-dispatch to18f4@t '_))) (if to18f6@ls/false (apply (lambda () '#f) to18f6@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to18f4@t))))))))))) (to18e3@sealed? (let ((to18f8@t (to178d@get-clause 'sealed to18db@clause*))) (let ((to18fa@ls/false (tod8f@syntax-dispatch to18f8@t '(_ #(atom #t))))) (if to18fa@ls/false (apply (lambda () '#t) to18fa@ls/false) (let ((to18fc@t to18f8@t)) (let ((to18fe@ls/false (tod8f@syntax-dispatch to18fc@t '_))) (if to18fe@ls/false (apply (lambda () '#f) to18fe@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to18fc@t)))))))) (to18e4@opaque? (let ((to1900@t (to178d@get-clause 'opaque to18db@clause*))) (let ((to1902@ls/false (tod8f@syntax-dispatch to1900@t '(_ #(atom #t))))) (if to1902@ls/false (apply (lambda () '#t) to1902@ls/false) (let ((to1904@t to1900@t)) (let ((to1906@ls/false (tod8f@syntax-dispatch to1904@t '_))) (if to1906@ls/false (apply (lambda () '#f) to1906@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1904@t)))))))) (to18e5@fields (let ((to1908@t (to178d@get-clause 'fields to18db@clause*))) (let ((to190a@ls/false (tod8f@syntax-dispatch to1908@t '(_ . each-any)))) (if to190a@ls/false (apply (lambda (to190c@field-spec*) (list 'quote (to18e1@convert-field-spec* to190c@field-spec*))) to190a@ls/false) (let ((to190e@t to1908@t)) (let ((to1910@ls/false (tod8f@syntax-dispatch to190e@t '_))) (if to1910@ls/false (apply (lambda () ''#()) to1910@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to190e@t))))))))) (tod45@bless (list 'make-record-type-descriptor (list 'quote to18da@name) to18dc@parent-rtd-code to18e2@uid-code to18e3@sealed? to18e4@opaque? to18e5@fields)))))) (to1791@parent-rtd-code (lambda (to18c2@clause*) (let ((to18c4@t (to178d@get-clause 'parent to18c2@clause*))) (let ((to18c6@ls/false (tod8f@syntax-dispatch to18c4@t '(_ any)))) (if to18c6@ls/false (apply (lambda (to18c8@name) (list 'record-type-descriptor to18c8@name)) to18c6@ls/false) (let ((to18ca@t to18c4@t)) (let ((to18cc@ls/false (tod8f@syntax-dispatch to18ca@t '#(atom #f)))) (if to18cc@ls/false (apply (lambda () (let ((to18ce@t (to178d@get-clause 'parent-rtd to18c2@clause*))) (let ((to18d0@ls/false (tod8f@syntax-dispatch to18ce@t '(_ any any)))) (if to18d0@ls/false (apply (lambda (to18d2@rtd to18d3@rcd) to18d2@rtd) to18d0@ls/false) (let ((to18d6@t to18ce@t)) (let ((to18d8@ls/false (tod8f@syntax-dispatch to18d6@t '#(atom #f)))) (if to18d8@ls/false (apply (lambda () '#f) to18d8@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to18d6@t)))))))) to18cc@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to18ca@t))))))))) (to1793@parent-rcd-code (lambda (to18aa@clause*) (let ((to18ac@t (to178d@get-clause 'parent to18aa@clause*))) (let ((to18ae@ls/false (tod8f@syntax-dispatch to18ac@t '(_ any)))) (if to18ae@ls/false (apply (lambda (to18b0@name) (list 'record-constructor-descriptor to18b0@name)) to18ae@ls/false) (let ((to18b2@t to18ac@t)) (let ((to18b4@ls/false (tod8f@syntax-dispatch to18b2@t '#(atom #f)))) (if to18b4@ls/false (apply (lambda () (let ((to18b6@t (to178d@get-clause 'parent-rtd to18aa@clause*))) (let ((to18b8@ls/false (tod8f@syntax-dispatch to18b6@t '(_ any any)))) (if to18b8@ls/false (apply (lambda (to18ba@rtd to18bb@rcd) to18bb@rcd) to18b8@ls/false) (let ((to18be@t to18b6@t)) (let ((to18c0@ls/false (tod8f@syntax-dispatch to18be@t '#(atom #f)))) (if to18c0@ls/false (apply (lambda () '#f) to18c0@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to18be@t)))))))) to18b4@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to18b2@t))))))))) (to1795@foo-rcd-code (lambda (to18a2@clause* to18a3@foo-rtd to18a4@protocol to18a5@parent-rcd-code) (list 'make-record-constructor-descriptor to18a3@foo-rtd to18a5@parent-rcd-code to18a4@protocol))) (to1797@get-protocol-code (lambda (to1896@clause*) (let ((to1898@t (to178d@get-clause 'protocol to1896@clause*))) (let ((to189a@ls/false (tod8f@syntax-dispatch to1898@t '(_ any)))) (if to189a@ls/false (apply (lambda (to189c@expr) to189c@expr) to189a@ls/false) (let ((to189e@t to1898@t)) (let ((to18a0@ls/false (tod8f@syntax-dispatch to189e@t '_))) (if to18a0@ls/false (apply (lambda () '#f) to18a0@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to189e@t))))))))) (to1799@get-fields (lambda (to1884@clause*) (let ((to1886@t to1884@clause*)) (let ((to1888@ls/false (tod8f@syntax-dispatch to1886@t '()))) (if to1888@ls/false (apply (lambda () '()) to1888@ls/false) (let ((to188a@t to1886@t)) (let ((to188c@ls/false (tod8f@syntax-dispatch to188a@t '((#(scheme-id fields) . each-any) . _)))) (if to188c@ls/false (apply (lambda (to188e@f*) to188e@f*) to188c@ls/false) (let ((to1890@t to188a@t)) (let ((to1892@ls/false (tod8f@syntax-dispatch to1890@t '(_ . any)))) (if to1892@ls/false (apply (lambda (to1894@rest) (to1799@get-fields to1894@rest)) to1892@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1890@t)))))))))))) (to179b@get-mutator-indices (lambda (to186c@fields) (let to1872@f ((to186e@fields to186c@fields) (to186f@i '0)) (let ((to1874@t to186e@fields)) (let ((to1876@ls/false (tod8f@syntax-dispatch to1874@t '()))) (if to1876@ls/false (apply (lambda () '()) to1876@ls/false) (let ((to1878@t to1874@t)) (let ((to187a@ls/false (tod8f@syntax-dispatch to1878@t '((#(scheme-id mutable) . _) . any)))) (if to187a@ls/false (apply (lambda (to187c@rest) (cons to186f@i (to1872@f to187c@rest (+ to186f@i '1)))) to187a@ls/false) (let ((to187e@t to1878@t)) (let ((to1880@ls/false (tod8f@syntax-dispatch to187e@t '(_ . any)))) (if to1880@ls/false (apply (lambda (to1882@rest) (to1872@f to1882@rest (+ to186f@i '1))) to1880@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to187e@t))))))))))))) (to179d@get-mutators (lambda (to1842@foo to1843@fields) (letrec* ((to1847@gen-name (lambda (to186a@x) (toe73@datum->syntax to1842@foo (string->symbol (string-append (symbol->string (toe75@syntax->datum to1842@foo)) '"-" (symbol->string (toe75@syntax->datum to186a@x)) '"-set!")))))) (let to184a@f ((to1848@fields to1843@fields)) (let ((to184c@t to1848@fields)) (let ((to184e@ls/false (tod8f@syntax-dispatch to184c@t '()))) (if to184e@ls/false (apply (lambda () '()) to184e@ls/false) (let ((to1850@t to184c@t)) (let ((to1852@ls/false (tod8f@syntax-dispatch to1850@t '((#(scheme-id mutable) any any any) . any)))) (if to1852@ls/false (apply (lambda (to1854@name to1855@accessor to1856@mutator to1857@rest) (cons to1856@mutator (to184a@f to1857@rest))) to1852@ls/false) (let ((to185c@t to1850@t)) (let ((to185e@ls/false (tod8f@syntax-dispatch to185c@t '((#(scheme-id mutable) any) . any)))) (if to185e@ls/false (apply (lambda (to1860@name to1861@rest) (cons (to1847@gen-name to1860@name) (to184a@f to1861@rest))) to185e@ls/false) (let ((to1864@t to185c@t)) (let ((to1866@ls/false (tod8f@syntax-dispatch to1864@t '(_ . any)))) (if to1866@ls/false (apply (lambda (to1868@rest) (to184a@f to1868@rest)) to1866@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1864@t))))))))))))))))) (to179f@get-accessors (lambda (to17fe@foo to17ff@fields) (letrec* ((to1803@gen-name (lambda (to1840@x) (toe73@datum->syntax to17fe@foo (string->symbol (string-append (symbol->string (toe75@syntax->datum to17fe@foo)) '"-" (symbol->string (toe75@syntax->datum to1840@x)))))))) (map (lambda (to1804@field) (let ((to1806@t to1804@field)) (let ((to1808@ls/false (tod8f@syntax-dispatch to1806@t '(#(scheme-id mutable) any any any)))) (if (and to1808@ls/false (apply (lambda (to180a@name to180b@accessor to180c@mutator) (tob88@id? to180b@accessor)) to1808@ls/false)) (apply (lambda (to1810@name to1811@accessor to1812@mutator) to1811@accessor) to1808@ls/false) (let ((to1816@t to1806@t)) (let ((to1818@ls/false (tod8f@syntax-dispatch to1816@t '(#(scheme-id immutable) any any)))) (if (and to1818@ls/false (apply (lambda (to181a@name to181b@accessor) (tob88@id? to181b@accessor)) to1818@ls/false)) (apply (lambda (to181e@name to181f@accessor) to181f@accessor) to1818@ls/false) (let ((to1822@t to1816@t)) (let ((to1824@ls/false (tod8f@syntax-dispatch to1822@t '(#(scheme-id mutable) any)))) (if (and to1824@ls/false (apply (lambda (to1826@name) (tob88@id? to1826@name)) to1824@ls/false)) (apply (lambda (to1828@name) (to1803@gen-name to1828@name)) to1824@ls/false) (let ((to182a@t to1822@t)) (let ((to182c@ls/false (tod8f@syntax-dispatch to182a@t '(#(scheme-id immutable) any)))) (if (and to182c@ls/false (apply (lambda (to182e@name) (tob88@id? to182e@name)) to182c@ls/false)) (apply (lambda (to1830@name) (to1803@gen-name to1830@name)) to182c@ls/false) (let ((to1832@t to182a@t)) (let ((to1834@ls/false (tod8f@syntax-dispatch to1832@t 'any))) (if (and to1834@ls/false (apply (lambda (to1836@name) (tob88@id? to1836@name)) to1834@ls/false)) (apply (lambda (to1838@name) (to1803@gen-name to1838@name)) to1834@ls/false) (let ((to183a@t to1832@t)) (let ((to183c@ls/false (tod8f@syntax-dispatch to183a@t 'any))) (if to183c@ls/false (apply (lambda (to183e@others) (toe6f@syntax-violation '#f '"invalid field spec" to1804@field)) to183c@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to183a@t)))))))))))))))))))) to17ff@fields)))) (to17a1@enumerate (lambda (to17f6@ls) (let to17fc@f ((to17f8@ls to17f6@ls) (to17f9@i '0)) (if (null? to17f8@ls) '() (cons to17f9@i (to17fc@f (cdr to17f8@ls) (+ to17f9@i '1))))))) (to17a3@do-define-record (lambda (to17ce@namespec to17cf@clause*) (let ((to17d2@foo (to1787@get-record-name to17ce@namespec))) (let ((to17d4@foo-rtd (gensym))) (let ((to17d6@foo-rcd (gensym))) (let ((to17d8@protocol (gensym))) (let ((to17da@make-foo (to1789@get-record-constructor-name to17ce@namespec))) (let ((to17dc@fields (to1799@get-fields to17cf@clause*))) (let ((to17de@idx* (to17a1@enumerate to17dc@fields))) (let ((to17e0@foo-x* (to179f@get-accessors to17d2@foo to17dc@fields))) (let ((to17e2@set-foo-x!* (to179d@get-mutators to17d2@foo to17dc@fields))) (let ((to17e4@set-foo-idx* (to179b@get-mutator-indices to17dc@fields))) (let ((to17e6@foo? (to178b@get-record-predicate-name to17ce@namespec))) (let ((to17e8@foo-rtd-code (to178f@foo-rtd-code to17d2@foo to17cf@clause* (to1791@parent-rtd-code to17cf@clause*)))) (let ((to17ea@foo-rcd-code (to1795@foo-rcd-code to17cf@clause* to17d4@foo-rtd to17d8@protocol (to1793@parent-rcd-code to17cf@clause*)))) (let ((to17ec@protocol-code (to1797@get-protocol-code to17cf@clause*))) (tod45@bless (cons 'begin (cons (list 'define to17d4@foo-rtd to17e8@foo-rtd-code) (cons (list 'define to17d8@protocol to17ec@protocol-code) (cons (list 'define to17d6@foo-rcd to17ea@foo-rcd-code) (cons (list 'define-syntax to17d2@foo (list 'list ''$rtd (list 'syntax to17d4@foo-rtd) (list 'syntax to17d6@foo-rcd))) (cons (list 'define to17e6@foo? (list 'record-predicate to17d4@foo-rtd)) (cons (list 'define to17da@make-foo (list 'record-constructor to17d6@foo-rcd)) (append (map (lambda (to17ee@foo-x to17ef@idx) (list 'define to17ee@foo-x (list 'record-accessor to17d4@foo-rtd to17ef@idx))) to17e0@foo-x* to17de@idx*) (map (lambda (to17f2@set-foo-x! to17f3@idx) (list 'define to17f2@set-foo-x! (list 'record-mutator to17d4@foo-rtd to17f3@idx))) to17e2@set-foo-x!* to17e4@set-foo-idx*)))))))))))))))))))))))))) (to17a5@verify-clauses (lambda (to17ae@x to17af@cls*) (letrec* ((to17b3@valid-kwds (map tod45@bless '(fields parent parent-rtd protocol sealed opaque nongenerative))) (to17b5@free-id-member? (lambda (to17ca@x to17cb@ls) (and (pair? to17cb@ls) (or (tob8e@free-id=? to17ca@x (car to17cb@ls)) (to17b5@free-id-member? to17ca@x (cdr to17cb@ls))))))) (let to17ba@f ((to17b6@cls* to17af@cls*) (to17b7@seen* '())) (if (not (null? to17b6@cls*)) (let ((to17bc@t (car to17b6@cls*))) (let ((to17be@ls/false (tod8f@syntax-dispatch to17bc@t '(any . any)))) (if to17be@ls/false (apply (lambda (to17c0@kwd to17c1@rest) (if (or (not (tob88@id? to17c0@kwd)) (not (to17b5@free-id-member? to17c0@kwd to17b3@valid-kwds))) (toe6f@syntax-violation '#f '"not a valid define-record-type keyword" to17c0@kwd) (if (tob94@bound-id-member? to17c0@kwd to17b7@seen*) (toe6f@syntax-violation '#f '"duplicate use of keyword " to17ae@x to17c0@kwd) (to17ba@f (cdr to17b6@cls*) (cons to17c0@kwd to17b7@seen*))))) to17be@ls/false) (let ((to17c4@t to17bc@t)) (let ((to17c6@ls/false (tod8f@syntax-dispatch to17c4@t 'any))) (if to17c6@ls/false (apply (lambda (to17c8@cls) (toe6f@syntax-violation '#f '"malformed define-record-type clause" to17c8@cls)) to17c6@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to17c4@t))))))) (void))))))) (let ((to17a6@t to1782@x)) (let ((to17a8@ls/false (tod8f@syntax-dispatch to17a6@t '(_ any . each-any)))) (if to17a8@ls/false (apply (lambda (to17aa@namespec to17ab@clause*) (begin (to17a5@verify-clauses to1782@x to17ab@clause*) (to17a3@do-define-record to17aa@namespec to17ab@clause*))) to17a8@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to17a6@t))))))) (set! to2895@tod83@define-record-type-macro tod83@define-record-type-macro) (set! tod85@define-condition-type-macro (lambda (to197e@x) (letrec* ((to1981@mkname (lambda (to19ae@name to19af@suffix) (toe73@datum->syntax to19ae@name (string->symbol (string-append (symbol->string (toe75@syntax->datum to19ae@name)) to19af@suffix)))))) (let ((to1982@t to197e@x)) (let ((to1984@ls/false (tod8f@syntax-dispatch to1982@t '(any any any any any . #(each (any any)))))) (if (and to1984@ls/false (apply (lambda (to1986@ctxt to1987@name to1988@super to1989@constructor to198a@predicate to198b@field* to198c@accessor*) (and (tob88@id? to1987@name) (tob88@id? to1988@super) (tob88@id? to1989@constructor) (tob88@id? to198a@predicate) (for-all tob88@id? to198b@field*) (for-all tob88@id? to198c@accessor*))) to1984@ls/false)) (apply (lambda (to1994@ctxt to1995@name to1996@super to1997@constructor to1998@predicate to1999@field* to199a@accessor*) (let ((to19a2@aux-accessor* (map (lambda (to19a4@x) (gensym)) to199a@accessor*))) (tod45@bless (cons 'begin (cons (cons 'define-record-type (cons (list to1995@name to1997@constructor (gensym)) (cons (list 'parent to1996@super) (cons (cons 'fields (map (lambda (to19a6@field to19a7@aux) (list 'immutable to19a6@field to19a7@aux)) to1999@field* to19a2@aux-accessor*)) '((nongenerative) (sealed #f) (opaque #f)))))) (cons (list 'define to1998@predicate (list 'condition-predicate (list 'record-type-descriptor to1995@name))) (map (lambda (to19aa@accessor to19ab@aux) (list 'define to19aa@accessor (list 'condition-accessor (list 'record-type-descriptor to1995@name) to19ab@aux))) to199a@accessor* to19a2@aux-accessor*))))))) to1984@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1982@t))))))) (set! to2896@tod85@define-condition-type-macro tod85@define-condition-type-macro) (set! tod87@incorrect-usage-macro (lambda (to19b2@e) (toe6f@syntax-violation '#f '"incorrect usage of auxiliary keyword" to19b2@e))) (set! to2897@tod87@incorrect-usage-macro tod87@incorrect-usage-macro) (set! tod89@parameterize-macro (lambda (to19b4@e) (let ((to19b6@t to19b4@e)) (let ((to19b8@ls/false (tod8f@syntax-dispatch to19b6@t '(_ () any . each-any)))) (if to19b8@ls/false (apply (lambda (to19ba@b to19bb@b*) (tod45@bless (cons 'let (cons '() (cons to19ba@b to19bb@b*))))) to19b8@ls/false) (let ((to19be@t to19b6@t)) (let ((to19c0@ls/false (tod8f@syntax-dispatch to19be@t '(_ #(each (any any)) any . each-any)))) (if to19c0@ls/false (apply (lambda (to19c2@olhs* to19c3@orhs* to19c4@b to19c5@b*) (let ((to19ca@lhs* (toe5d@generate-temporaries to19c2@olhs*)) (to19cb@rhs* (toe5d@generate-temporaries to19c3@orhs*))) (tod45@bless (cons (list 'lambda (append to19ca@lhs* to19cb@rhs*) (list 'let (list (list 'swap (cons 'lambda (cons '() (map (lambda (to19ce@lhs to19cf@rhs) (list 'let (list (list 't (list to19ce@lhs))) (list to19ce@lhs to19cf@rhs) (cons 'set! (cons to19cf@rhs '(t))))) to19ca@lhs* to19cb@rhs*))))) (cons 'dynamic-wind (cons 'swap (cons (cons 'lambda (cons '() (cons to19c4@b to19c5@b*))) '(swap)))))) (append to19c2@olhs* to19c3@orhs*))))) to19c0@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to19be@t))))))))) (set! to2898@tod89@parameterize-macro tod89@parameterize-macro) (set! tod8b@foreign-call-transformer (lambda (to19d2@e to19d3@r to19d4@mr) (let ((to19d8@t to19d2@e)) (let ((to19da@ls/false (tod8f@syntax-dispatch to19d8@t '(_ any . each-any)))) (if to19da@ls/false (apply (lambda (to19dc@name to19dd@arg*) (cons 'foreign-call (cons (todb1@chi-expr to19dc@name to19d3@r to19d4@mr) (todad@chi-expr* to19dd@arg* to19d3@r to19d4@mr)))) to19da@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to19d8@t)))))) (set! to2899@tod8b@foreign-call-transformer tod8b@foreign-call-transformer) (set! tod8d@convert-pattern (lambda (to19e0@pattern to19e1@keys) (letrec* ((to19e5@cvt* (lambda (to1a84@p* to1a85@n to1a86@ids) (if (null? to1a84@p*) (values '() to1a86@ids) (call-with-values (lambda () (to19e5@cvt* (cdr to1a84@p*) to1a85@n to1a86@ids)) (lambda (to1a8e@to1a8b to1a8f@to1a8d) (let ((to1a92@ids to1a8f@to1a8d) (to1a93@y to1a8e@to1a8b)) (call-with-values (lambda () (to19e7@cvt (car to1a84@p*) to1a85@n to1a92@ids)) (lambda (to1a9a@to1a97 to1a9b@to1a99) (let ((to1a9e@ids to1a9b@to1a99) (to1a9f@x to1a9a@to1a97)) (values (cons to1a9f@x to1a93@y) to1a9e@ids)))))))))) (to19e7@cvt (lambda (to19e8@p to19e9@n to19ea@ids) (let ((to19ee@t to19e8@p)) (let ((to19f0@ls/false (tod8f@syntax-dispatch to19ee@t 'any))) (if (and to19f0@ls/false (apply (lambda (to19f2@id) (tob88@id? to19f2@id)) to19f0@ls/false)) (apply (lambda (to19f4@id) (if (tob94@bound-id-member? to19e8@p to19e1@keys) (values (vector 'free-id to19e8@p) to19ea@ids) (if (tob8e@free-id=? to19e8@p (tod17@scheme-stx '_)) (values '_ to19ea@ids) (values 'any (cons (cons to19e8@p to19e9@n) to19ea@ids))))) to19f0@ls/false) (let ((to19f6@t to19ee@t)) (let ((to19f8@ls/false (tod8f@syntax-dispatch to19f6@t '(any any)))) (if (and to19f8@ls/false (apply (lambda (to19fa@p to19fb@dots) (tod91@ellipsis? to19fb@dots)) to19f8@ls/false)) (apply (lambda (to19fe@p to19ff@dots) (call-with-values (lambda () (to19e7@cvt to19fe@p (+ to19e9@n '1) to19ea@ids)) (lambda (to1a06@to1a03 to1a07@to1a05) (let ((to1a0a@ids to1a07@to1a05) (to1a0b@p to1a06@to1a03)) (values (if (eq? to1a0b@p 'any) 'each-any (vector 'each to1a0b@p)) to1a0a@ids))))) to19f8@ls/false) (let ((to1a0e@t to19f6@t)) (let ((to1a10@ls/false (tod8f@syntax-dispatch to1a0e@t '(any any . #(each+ any () any))))) (if (and to1a10@ls/false (apply (lambda (to1a12@x to1a13@dots to1a14@ys to1a15@z) (tod91@ellipsis? to1a13@dots)) to1a10@ls/false)) (apply (lambda (to1a1a@x to1a1b@dots to1a1c@ys to1a1d@z) (call-with-values (lambda () (to19e7@cvt to1a1d@z to19e9@n to19ea@ids)) (lambda (to1a26@to1a23 to1a27@to1a25) (let ((to1a2a@ids to1a27@to1a25) (to1a2b@z to1a26@to1a23)) (call-with-values (lambda () (to19e5@cvt* to1a1c@ys to19e9@n to1a2a@ids)) (lambda (to1a32@to1a2f to1a33@to1a31) (let ((to1a36@ids to1a33@to1a31) (to1a37@ys to1a32@to1a2f)) (call-with-values (lambda () (to19e7@cvt to1a1a@x (+ to19e9@n '1) to1a36@ids)) (lambda (to1a3e@to1a3b to1a3f@to1a3d) (let ((to1a42@ids to1a3f@to1a3d) (to1a43@x to1a3e@to1a3b)) (values (vector 'each+ to1a43@x (reverse to1a37@ys) to1a2b@z) to1a42@ids))))))))))) to1a10@ls/false) (let ((to1a46@t to1a0e@t)) (let ((to1a48@ls/false (tod8f@syntax-dispatch to1a46@t '(any . any)))) (if to1a48@ls/false (apply (lambda (to1a4a@x to1a4b@y) (call-with-values (lambda () (to19e7@cvt to1a4b@y to19e9@n to19ea@ids)) (lambda (to1a52@to1a4f to1a53@to1a51) (let ((to1a56@ids to1a53@to1a51) (to1a57@y to1a52@to1a4f)) (call-with-values (lambda () (to19e7@cvt to1a4a@x to19e9@n to1a56@ids)) (lambda (to1a5e@to1a5b to1a5f@to1a5d) (let ((to1a62@ids to1a5f@to1a5d) (to1a63@x to1a5e@to1a5b)) (values (cons to1a63@x to1a57@y) to1a62@ids)))))))) to1a48@ls/false) (let ((to1a66@t to1a46@t)) (let ((to1a68@ls/false (tod8f@syntax-dispatch to1a66@t '()))) (if to1a68@ls/false (apply (lambda () (values '() to19ea@ids)) to1a68@ls/false) (let ((to1a6a@t to1a66@t)) (let ((to1a6c@ls/false (tod8f@syntax-dispatch to1a6a@t '#(vector each-any)))) (if (and to1a6c@ls/false (apply (lambda (to1a6e@p) (not (tob54@stx? to1a6e@p))) to1a6c@ls/false)) (apply (lambda (to1a70@p) (call-with-values (lambda () (to19e7@cvt to1a70@p to19e9@n to19ea@ids)) (lambda (to1a76@to1a73 to1a77@to1a75) (let ((to1a7a@ids to1a77@to1a75) (to1a7b@p to1a76@to1a73)) (values (vector 'vector to1a7b@p) to1a7a@ids))))) to1a6c@ls/false) (let ((to1a7e@t to1a6a@t)) (let ((to1a80@ls/false (tod8f@syntax-dispatch to1a7e@t 'any))) (if to1a80@ls/false (apply (lambda (to1a82@datum) (values (vector 'atom (tob9c@stx->datum to1a82@datum)) to19ea@ids)) to1a80@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1a7e@t))))))))))))))))))))))))) (to19e7@cvt to19e0@pattern '0 '())))) (set! to289a@tod8d@convert-pattern tod8d@convert-pattern) (set! tod8f@syntax-dispatch (letrec* ((to1aa3@stx^ (lambda (to1b7e@e to1b7f@m* to1b80@s* to1b81@ae*) (if (and (null? to1b7f@m*) (null? to1b80@s*) (null? to1b81@ae*)) to1b7e@e (tob70@mkstx to1b7e@e to1b7f@m* to1b80@s* to1b81@ae*)))) (to1aa5@match-each (lambda (to1b5e@e to1b5f@p to1b60@m* to1b61@s* to1b62@ae*) (if (pair? to1b5e@e) (let ((to1b68@first (to1ab1@match (car to1b5e@e) to1b5f@p to1b60@m* to1b61@s* to1b62@ae* '()))) (and to1b68@first (let ((to1b6a@rest (to1aa5@match-each (cdr to1b5e@e) to1b5f@p to1b60@m* to1b61@s* to1b62@ae*))) (and to1b6a@rest (cons to1b68@first to1b6a@rest))))) (if (null? to1b5e@e) '() (if (tob54@stx? to1b5e@e) (and (not (tob0e@top-marked? to1b60@m*)) (call-with-values (lambda () (join-wraps to1b60@m* to1b61@s* to1b62@ae* to1b5e@e)) (lambda (to1b72@to1b6d to1b73@to1b6f to1b74@to1b71) (let ((to1b78@ae* to1b74@to1b71) (to1b79@s* to1b73@to1b6f) (to1b7a@m* to1b72@to1b6d)) (to1aa5@match-each (tob56@stx-expr to1b5e@e) to1b5f@p to1b7a@m* to1b79@s* to1b78@ae*))))) (if (to6cc@to59e@annotation? to1b5e@e) (to1aa5@match-each (to6ce@to5a2@annotation-expression to1b5e@e) to1b5f@p to1b60@m* to1b61@s* to1b62@ae*) '#f)))))) (to1aa7@match-each+ (lambda (to1b1e@e to1b1f@x-pat to1b20@y-pat to1b21@z-pat to1b22@m* to1b23@s* to1b24@ae* to1b25@r) (let to1b36@f ((to1b2e@e to1b1e@e) (to1b2f@m* to1b22@m*) (to1b30@s* to1b23@s*) (to1b31@ae* to1b24@ae*)) (if (pair? to1b2e@e) (call-with-values (lambda () (to1b36@f (cdr to1b2e@e) to1b2f@m* to1b30@s* to1b31@ae*)) (lambda (to1b3e@to1b39 to1b3f@to1b3b to1b40@to1b3d) (let ((to1b44@r to1b40@to1b3d) (to1b45@y-pat to1b3f@to1b3b) (to1b46@xr* to1b3e@to1b39)) (if to1b44@r (if (null? to1b45@y-pat) (let ((to1b4a@xr (to1ab1@match (car to1b2e@e) to1b1f@x-pat to1b2f@m* to1b30@s* to1b31@ae* '()))) (if to1b4a@xr (values (cons to1b4a@xr to1b46@xr*) to1b45@y-pat to1b44@r) (values '#f '#f '#f))) (values '() (cdr to1b45@y-pat) (to1ab1@match (car to1b2e@e) (car to1b45@y-pat) to1b2f@m* to1b30@s* to1b31@ae* to1b44@r))) (values '#f '#f '#f))))) (if (tob54@stx? to1b2e@e) (if (tob0e@top-marked? to1b2f@m*) (values '() to1b20@y-pat (to1ab1@match to1b2e@e to1b21@z-pat to1b2f@m* to1b30@s* to1b31@ae* to1b25@r)) (call-with-values (lambda () (join-wraps to1b2f@m* to1b30@s* to1b31@ae* to1b2e@e)) (lambda (to1b52@to1b4d to1b53@to1b4f to1b54@to1b51) (let ((to1b58@ae* to1b54@to1b51) (to1b59@s* to1b53@to1b4f) (to1b5a@m* to1b52@to1b4d)) (to1b36@f (tob56@stx-expr to1b2e@e) to1b5a@m* to1b59@s* to1b58@ae*))))) (if (to6cc@to59e@annotation? to1b2e@e) (to1b36@f (to6ce@to5a2@annotation-expression to1b2e@e) to1b2f@m* to1b30@s* to1b31@ae*) (values '() to1b20@y-pat (to1ab1@match to1b2e@e to1b21@z-pat to1b2f@m* to1b30@s* to1b31@ae* to1b25@r)))))))) (to1aa9@match-each-any (lambda (to1b02@e to1b03@m* to1b04@s* to1b05@ae*) (if (pair? to1b02@e) (let ((to1b0a@l (to1aa9@match-each-any (cdr to1b02@e) to1b03@m* to1b04@s* to1b05@ae*))) (and to1b0a@l (cons (to1aa3@stx^ (car to1b02@e) to1b03@m* to1b04@s* to1b05@ae*) to1b0a@l))) (if (null? to1b02@e) '() (if (tob54@stx? to1b02@e) (and (not (tob0e@top-marked? to1b03@m*)) (call-with-values (lambda () (join-wraps to1b03@m* to1b04@s* to1b05@ae* to1b02@e)) (lambda (to1b12@to1b0d to1b13@to1b0f to1b14@to1b11) (let ((to1b18@ae* to1b14@to1b11) (to1b19@s* to1b13@to1b0f) (to1b1a@m* to1b12@to1b0d)) (to1aa9@match-each-any (tob56@stx-expr to1b02@e) to1b1a@m* to1b19@s* to1b18@ae*))))) (if (to6cc@to59e@annotation? to1b02@e) (to1aa9@match-each-any (to6ce@to5a2@annotation-expression to1b02@e) to1b03@m* to1b04@s* to1b05@ae*) '#f)))))) (to1aab@match-empty (lambda (to1afc@p to1afd@r) (if (null? to1afc@p) to1afd@r (if (eq? to1afc@p '_) to1afd@r (if (eq? to1afc@p 'any) (cons '() to1afd@r) (if (pair? to1afc@p) (to1aab@match-empty (car to1afc@p) (to1aab@match-empty (cdr to1afc@p) to1afd@r)) (if (eq? to1afc@p 'each-any) (cons '() to1afd@r) (let ((to1b00@t (vector-ref to1afc@p '0))) (if (memv to1b00@t '(each)) (to1aab@match-empty (vector-ref to1afc@p '1) to1afd@r) (if (memv to1b00@t '(each+)) (to1aab@match-empty (vector-ref to1afc@p '1) (to1aab@match-empty (reverse (vector-ref to1afc@p '2)) (to1aab@match-empty (vector-ref to1afc@p '3) to1afd@r))) (if (memv to1b00@t '(free-id atom)) to1afd@r (if (memv to1b00@t '(scheme-id atom)) to1afd@r (if (memv to1b00@t '(vector)) (to1aab@match-empty (vector-ref to1afc@p '1) to1afd@r) (assertion-violation 'syntax-dispatch '"invalid pattern" to1afc@p)))))))))))))) (to1aad@combine (lambda (to1af8@r* to1af9@r) (if (null? (car to1af8@r*)) to1af9@r (cons (map car to1af8@r*) (to1aad@combine (map cdr to1af8@r*) to1af9@r))))) (to1aaf@match* (lambda (to1ad4@e to1ad5@p to1ad6@m* to1ad7@s* to1ad8@ae* to1ad9@r) (if (null? to1ad5@p) (and (null? to1ad4@e) to1ad9@r) (if (pair? to1ad5@p) (and (pair? to1ad4@e) (to1ab1@match (car to1ad4@e) (car to1ad5@p) to1ad6@m* to1ad7@s* to1ad8@ae* (to1ab1@match (cdr to1ad4@e) (cdr to1ad5@p) to1ad6@m* to1ad7@s* to1ad8@ae* to1ad9@r))) (if (eq? to1ad5@p 'each-any) (let ((to1ae0@l (to1aa9@match-each-any to1ad4@e to1ad6@m* to1ad7@s* to1ad8@ae*))) (and to1ae0@l (cons to1ae0@l to1ad9@r))) (let ((to1ae2@t (vector-ref to1ad5@p '0))) (if (memv to1ae2@t '(each)) (if (null? to1ad4@e) (to1aab@match-empty (vector-ref to1ad5@p '1) to1ad9@r) (let ((to1ae4@r* (to1aa5@match-each to1ad4@e (vector-ref to1ad5@p '1) to1ad6@m* to1ad7@s* to1ad8@ae*))) (and to1ae4@r* (to1aad@combine to1ae4@r* to1ad9@r)))) (if (memv to1ae2@t '(free-id)) (and (symbol? to1ad4@e) (tob0e@top-marked? to1ad6@m*) (tob8e@free-id=? (to1aa3@stx^ to1ad4@e to1ad6@m* to1ad7@s* to1ad8@ae*) (vector-ref to1ad5@p '1)) to1ad9@r) (if (memv to1ae2@t '(scheme-id)) (and (symbol? to1ad4@e) (tob0e@top-marked? to1ad6@m*) (tob8e@free-id=? (to1aa3@stx^ to1ad4@e to1ad6@m* to1ad7@s* to1ad8@ae*) (tod17@scheme-stx (vector-ref to1ad5@p '1))) to1ad9@r) (if (memv to1ae2@t '(each+)) (call-with-values (lambda () (to1aa7@match-each+ to1ad4@e (vector-ref to1ad5@p '1) (vector-ref to1ad5@p '2) (vector-ref to1ad5@p '3) to1ad6@m* to1ad7@s* to1ad8@ae* to1ad9@r)) (lambda (to1aec@to1ae7 to1aed@to1ae9 to1aee@to1aeb) (let ((to1af2@r to1aee@to1aeb) (to1af3@y-pat to1aed@to1ae9) (to1af4@xr* to1aec@to1ae7)) (and to1af2@r (null? to1af3@y-pat) (if (null? to1af4@xr*) (to1aab@match-empty (vector-ref to1ad5@p '1) to1af2@r) (to1aad@combine to1af4@xr* to1af2@r)))))) (if (memv to1ae2@t '(atom)) (and (fast-equal? (vector-ref to1ad5@p '1) (tob9a@strip to1ad4@e to1ad6@m*)) to1ad9@r) (if (memv to1ae2@t '(vector)) (and (vector? to1ad4@e) (to1ab1@match (vector->list to1ad4@e) (vector-ref to1ad5@p '1) to1ad6@m* to1ad7@s* to1ad8@ae* to1ad9@r)) (assertion-violation 'syntax-dispatch '"invalid pattern" to1ad5@p))))))))))))) (to1ab1@match (lambda (to1ab6@e to1ab7@p to1ab8@m* to1ab9@s* to1aba@ae* to1abb@r) (if (not to1abb@r) '#f (if (eq? to1ab7@p '_) to1abb@r (if (eq? to1ab7@p 'any) (cons (to1aa3@stx^ to1ab6@e to1ab8@m* to1ab9@s* to1aba@ae*) to1abb@r) (if (tob54@stx? to1ab6@e) (and (not (tob0e@top-marked? to1ab8@m*)) (call-with-values (lambda () (join-wraps to1ab8@m* to1ab9@s* to1aba@ae* to1ab6@e)) (lambda (to1ac8@to1ac3 to1ac9@to1ac5 to1aca@to1ac7) (let ((to1ace@ae* to1aca@to1ac7) (to1acf@s* to1ac9@to1ac5) (to1ad0@m* to1ac8@to1ac3)) (to1ab1@match (tob56@stx-expr to1ab6@e) to1ab7@p to1ad0@m* to1acf@s* to1ace@ae* to1abb@r))))) (if (to6cc@to59e@annotation? to1ab6@e) (to1ab1@match (to6ce@to5a2@annotation-expression to1ab6@e) to1ab7@p to1ab8@m* to1ab9@s* to1aba@ae* to1abb@r) (to1aaf@match* to1ab6@e to1ab7@p to1ab8@m* to1ab9@s* to1aba@ae* to1abb@r))))))))) (lambda (to1ab2@e to1ab3@p) (to1ab1@match to1ab2@e to1ab3@p '() '() '() '())))) (set! to289b@tod8f@syntax-dispatch tod8f@syntax-dispatch) (set! tod91@ellipsis? (lambda (to1b86@x) (and (tob88@id? to1b86@x) (tob8e@free-id=? to1b86@x (tod17@scheme-stx '...))))) (set! to289c@tod91@ellipsis? tod91@ellipsis?) (set! tod93@underscore? (lambda (to1b88@x) (and (tob88@id? to1b88@x) (tob8e@free-id=? to1b88@x (tod17@scheme-stx '_))))) (set! to289d@tod93@underscore? tod93@underscore?) (set! tod95@verify-literals (lambda (to1b8a@lits to1b8b@expr) (for-each (lambda (to1b8e@x) (if (or (not (tob88@id? to1b8e@x)) (tod91@ellipsis? to1b8e@x) (tod93@underscore? to1b8e@x)) (toe6f@syntax-violation '#f '"invalid literal" to1b8b@expr to1b8e@x) (void))) to1b8a@lits))) (set! to289e@tod95@verify-literals tod95@verify-literals) (set! tod97@syntax-case-transformer (letrec* ((to1b91@build-dispatch-call (lambda (to1c02@pvars to1c03@expr to1c04@y to1c05@r to1c06@mr) (let ((to1c0c@ids (map car to1c02@pvars)) (to1c0d@levels (map cdr to1c02@pvars))) (let ((to1c10@labels (map tob14@gen-label to1c0c@ids)) (to1c11@new-vars (map tob10@gen-lexical to1c0c@ids))) (let ((to1c14@body (todb1@chi-expr (tob72@add-subst (tob48@make-full-rib to1c0c@ids to1c10@labels) to1c03@expr) (append (map (lambda (to1c16@label to1c17@var to1c18@level) (cons to1c16@label (toba2@make-binding 'syntax (cons to1c17@var to1c18@level)))) to1c10@labels to1c11@new-vars (map cdr to1c02@pvars)) to1c05@r) to1c06@mr))) (list '(primitive apply) (toaeb@toa1d@build-lambda '#f to1c11@new-vars to1c14@body) to1c04@y)))))) (to1b93@invalid-ids-error (lambda (to1bf6@id* to1bf7@e to1bf8@class) (let to1c00@find ((to1bfc@id* to1bf6@id*) (to1bfd@ok* '())) (if (null? to1bfc@id*) (toe6f@syntax-violation '#f '"invalid syntax" to1bf7@e) (if (tob88@id? (car to1bfc@id*)) (if (tob94@bound-id-member? (car to1bfc@id*) to1bfd@ok*) (toe6b@syntax-error (car to1bfc@id*) '"duplicate " to1bf8@class) (to1c00@find (cdr to1bfc@id*) (cons (car to1bfc@id*) to1bfd@ok*))) (toe6b@syntax-error (car to1bfc@id*) '"invalid " to1bf8@class)))))) (to1b95@gen-clause (lambda (to1bce@x to1bcf@keys to1bd0@clauses to1bd1@r to1bd2@mr to1bd3@pat to1bd4@fender to1bd5@expr) (call-with-values (lambda () (tod8d@convert-pattern to1bd3@pat to1bcf@keys)) (lambda (to1be2@to1bdf to1be3@to1be1) (let ((to1be6@pvars to1be3@to1be1) (to1be7@p to1be2@to1bdf)) (if (not (tob92@distinct-bound-ids? (map car to1be6@pvars))) (to1b93@invalid-ids-error (map car to1be6@pvars) to1bd3@pat '"pattern variable") (if (not (for-all (lambda (to1bea@x) (not (tod91@ellipsis? (car to1bea@x)))) to1be6@pvars)) (toe6f@syntax-violation '#f '"misplaced ellipsis in syntax-case pattern" to1bd3@pat) (let ((to1bec@y (tob10@gen-lexical 'tmp))) (let ((to1bee@test (if (eq? to1bd4@fender '#t) to1bec@y (let ((to1bf0@call (to1b91@build-dispatch-call to1be6@pvars to1bd4@fender to1bec@y to1bd1@r to1bd2@mr))) (list 'if to1bec@y to1bf0@call (list 'quote '#f)))))) (let ((to1bf2@conseq (to1b91@build-dispatch-call to1be6@pvars to1bd5@expr to1bec@y to1bd1@r to1bd2@mr))) (let ((to1bf4@altern (to1b97@gen-syntax-case to1bce@x to1bcf@keys to1bd0@clauses to1bd1@r to1bd2@mr))) (list (toaeb@toa1d@build-lambda '#f (list to1bec@y) (list 'if to1bee@test to1bf2@conseq to1bf4@altern)) (list '(primitive syntax-dispatch) to1bce@x (list 'quote to1be7@p)))))))))))))) (to1b97@gen-syntax-case (lambda (to1bac@x to1bad@keys to1bae@clauses to1baf@r to1bb0@mr) (if (null? to1bae@clauses) (list '(primitive syntax-error) to1bac@x) (let ((to1bb6@t (car to1bae@clauses))) (let ((to1bb8@ls/false (tod8f@syntax-dispatch to1bb6@t '(any any)))) (if to1bb8@ls/false (apply (lambda (to1bba@pat to1bbb@expr) (if (and (tob88@id? to1bba@pat) (not (tob94@bound-id-member? to1bba@pat to1bad@keys)) (not (tod91@ellipsis? to1bba@pat))) (if (tob8e@free-id=? to1bba@pat (tod17@scheme-stx '_)) (todb1@chi-expr to1bbb@expr to1baf@r to1bb0@mr) (let ((to1bbe@lab (tob14@gen-label to1bba@pat)) (to1bbf@lex (tob10@gen-lexical to1bba@pat))) (let ((to1bc2@body (todb1@chi-expr (tob72@add-subst (tob48@make-full-rib (list to1bba@pat) (list to1bbe@lab)) to1bbb@expr) (cons (cons to1bbe@lab (toba2@make-binding 'syntax (cons to1bbf@lex '0))) to1baf@r) to1bb0@mr))) (list (toaeb@toa1d@build-lambda '#f (list to1bbf@lex) to1bc2@body) to1bac@x)))) (to1b95@gen-clause to1bac@x to1bad@keys (cdr to1bae@clauses) to1baf@r to1bb0@mr to1bba@pat '#t to1bbb@expr))) to1bb8@ls/false) (let ((to1bc4@t to1bb6@t)) (let ((to1bc6@ls/false (tod8f@syntax-dispatch to1bc4@t '(any any any)))) (if to1bc6@ls/false (apply (lambda (to1bc8@pat to1bc9@fender to1bca@expr) (to1b95@gen-clause to1bac@x to1bad@keys (cdr to1bae@clauses) to1baf@r to1bb0@mr to1bc8@pat to1bc9@fender to1bca@expr)) to1bc6@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1bc4@t))))))))))) (lambda (to1b98@e to1b99@r to1b9a@mr) (let ((to1b9e@t to1b98@e)) (let ((to1ba0@ls/false (tod8f@syntax-dispatch to1b9e@t '(_ any each-any . each-any)))) (if to1ba0@ls/false (apply (lambda (to1ba2@expr to1ba3@keys to1ba4@clauses) (begin (tod95@verify-literals to1ba3@keys to1b98@e) (let ((to1ba8@x (tob10@gen-lexical 'tmp))) (let ((to1baa@body (to1b97@gen-syntax-case to1ba8@x to1ba3@keys to1ba4@clauses to1b99@r to1b9a@mr))) (list (toaeb@toa1d@build-lambda '#f (list to1ba8@x) to1baa@body) (todb1@chi-expr to1ba2@expr to1b99@r to1b9a@mr)))))) to1ba0@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1b9e@t))))))) (set! to289f@tod97@syntax-case-transformer tod97@syntax-case-transformer) (set! tod99@ellipsis-map (lambda (to1c1c@proc to1c1d@ls . to1c20@ls*) (letrec* ((to1c23@who '...)) (begin (if (not (list? to1c1d@ls)) (assertion-violation to1c23@who '"not a list" to1c1d@ls) (void)) (if (not (null? to1c20@ls*)) (let ((to1c24@n (length to1c1d@ls))) (for-each (lambda (to1c26@x) (begin (if (not (list? to1c26@x)) (assertion-violation to1c23@who '"not a list" to1c26@x) (void)) (if (not (= (length to1c26@x) to1c24@n)) (assertion-violation to1c23@who '"length mismatch" to1c1d@ls to1c26@x) (void)))) to1c20@ls*)) (void)) (apply map to1c1c@proc to1c1d@ls to1c20@ls*))))) (set! to28a0@tod99@ellipsis-map tod99@ellipsis-map) (set! tod9b@syntax-transformer (letrec* ((to1c29@gen-syntax (lambda (to1ca0@src to1ca1@e to1ca2@r to1ca3@maps to1ca4@ellipsis? to1ca5@vec?) (let ((to1cac@t to1ca1@e)) (let ((to1cae@ls/false (tod8f@syntax-dispatch to1cac@t 'any))) (if (and to1cae@ls/false (apply (lambda (to1cb0@dots) (to1ca4@ellipsis? to1cb0@dots)) to1cae@ls/false)) (apply (lambda (to1cb2@dots) (toe6f@syntax-violation '#f '"misplaced ellipsis in syntax form" to1ca0@src)) to1cae@ls/false) (let ((to1cb4@t to1cac@t)) (let ((to1cb6@ls/false (tod8f@syntax-dispatch to1cb4@t 'any))) (if (and to1cb6@ls/false (apply (lambda (to1cb8@id) (tob88@id? to1cb8@id)) to1cb6@ls/false)) (apply (lambda (to1cba@id) (let ((to1cbc@label (tob9e@id->label to1ca1@e))) (let ((to1cbe@b (toba0@label->binding to1cbc@label to1ca2@r))) (if (eq? (toba4@binding-type to1cbe@b) 'syntax) (call-with-values (lambda () (let ((to1cc4@var.lev (toba6@binding-value to1cbe@b))) (to1c2b@gen-ref to1ca0@src (car to1cc4@var.lev) (cdr to1cc4@var.lev) to1ca3@maps))) (lambda (to1cc6@to1cc1 to1cc7@to1cc3) (let ((to1cca@maps to1cc7@to1cc3) (to1ccb@var to1cc6@to1cc1)) (values (list 'ref to1ccb@var) to1cca@maps)))) (values (list 'quote to1ca1@e) to1ca3@maps))))) to1cb6@ls/false) (let ((to1cce@t to1cb4@t)) (let ((to1cd0@ls/false (tod8f@syntax-dispatch to1cce@t '(any any)))) (if (and to1cd0@ls/false (apply (lambda (to1cd2@dots to1cd3@e) (to1ca4@ellipsis? to1cd2@dots)) to1cd0@ls/false)) (apply (lambda (to1cd6@dots to1cd7@e) (if to1ca5@vec? (toe6f@syntax-violation '#f '"misplaced ellipsis in syntax form" to1ca0@src) (to1c29@gen-syntax to1ca0@src to1cd7@e to1ca2@r to1ca3@maps (lambda (to1cda@x) '#f) '#f))) to1cd0@ls/false) (let ((to1cdc@t to1cce@t)) (let ((to1cde@ls/false (tod8f@syntax-dispatch to1cdc@t '(any any . any)))) (if (and to1cde@ls/false (apply (lambda (to1ce0@x to1ce1@dots to1ce2@y) (to1ca4@ellipsis? to1ce1@dots)) to1cde@ls/false)) (apply (lambda (to1ce6@x to1ce7@dots to1ce8@y) (let to1cfe@f ((to1cec@y to1ce8@y) (to1ced@k (lambda (to1cf0@maps) (call-with-values (lambda () (to1c29@gen-syntax to1ca0@src to1ce6@x to1ca2@r (cons '() to1cf0@maps) to1ca4@ellipsis? '#f)) (lambda (to1cf6@to1cf3 to1cf7@to1cf5) (let ((to1cfa@maps to1cf7@to1cf5) (to1cfb@x to1cf6@to1cf3)) (if (null? (car to1cfa@maps)) (toe6f@syntax-violation '#f '"extra ellipsis in syntax form" to1ca0@src) (values (to1c31@gen-map to1cfb@x (car to1cfa@maps)) (cdr to1cfa@maps))))))))) (let ((to1d00@t to1cec@y)) (let ((to1d02@ls/false (tod8f@syntax-dispatch to1d00@t '()))) (if to1d02@ls/false (apply (lambda () (to1ced@k to1ca3@maps)) to1d02@ls/false) (let ((to1d04@t to1d00@t)) (let ((to1d06@ls/false (tod8f@syntax-dispatch to1d04@t '(any . any)))) (if (and to1d06@ls/false (apply (lambda (to1d08@dots to1d09@y) (to1ca4@ellipsis? to1d08@dots)) to1d06@ls/false)) (apply (lambda (to1d0c@dots to1d0d@y) (to1cfe@f to1d0d@y (lambda (to1d10@maps) (call-with-values (lambda () (to1ced@k (cons '() to1d10@maps))) (lambda (to1d16@to1d13 to1d17@to1d15) (let ((to1d1a@maps to1d17@to1d15) (to1d1b@x to1d16@to1d13)) (if (null? (car to1d1a@maps)) (toe6f@syntax-violation '#f '"extra ellipsis in syntax form" to1ca0@src) (values (to1c2f@gen-mappend to1d1b@x (car to1d1a@maps)) (cdr to1d1a@maps))))))))) to1d06@ls/false) (let ((to1d1e@t to1d04@t)) (let ((to1d20@ls/false (tod8f@syntax-dispatch to1d1e@t '_))) (if to1d20@ls/false (apply (lambda () (call-with-values (lambda () (to1c29@gen-syntax to1ca0@src to1cec@y to1ca2@r to1ca3@maps to1ca4@ellipsis? to1ca5@vec?)) (lambda (to1d26@to1d23 to1d27@to1d25) (let ((to1d2a@maps to1d27@to1d25) (to1d2b@y to1d26@to1d23)) (call-with-values (lambda () (to1ced@k to1d2a@maps)) (lambda (to1d32@to1d2f to1d33@to1d31) (let ((to1d36@maps to1d33@to1d31) (to1d37@x to1d32@to1d2f)) (values (to1c2d@gen-append to1d37@x to1d2b@y) to1d36@maps)))))))) to1d20@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1d1e@t)))))))))))) to1cde@ls/false) (let ((to1d3a@t to1cdc@t)) (let ((to1d3c@ls/false (tod8f@syntax-dispatch to1d3a@t '(any . any)))) (if to1d3c@ls/false (apply (lambda (to1d3e@x to1d3f@y) (call-with-values (lambda () (to1c29@gen-syntax to1ca0@src to1d3e@x to1ca2@r to1ca3@maps to1ca4@ellipsis? '#f)) (lambda (to1d46@to1d43 to1d47@to1d45) (let ((to1d4a@maps to1d47@to1d45) (to1d4b@xnew to1d46@to1d43)) (call-with-values (lambda () (to1c29@gen-syntax to1ca0@src to1d3f@y to1ca2@r to1d4a@maps to1ca4@ellipsis? to1ca5@vec?)) (lambda (to1d52@to1d4f to1d53@to1d51) (let ((to1d56@maps to1d53@to1d51) (to1d57@ynew to1d52@to1d4f)) (values (to1c33@gen-cons to1ca1@e to1d3e@x to1d3f@y to1d4b@xnew to1d57@ynew) to1d56@maps)))))))) to1d3c@ls/false) (let ((to1d5a@t to1d3a@t)) (let ((to1d5c@ls/false (tod8f@syntax-dispatch to1d5a@t '#(vector each-any)))) (if to1d5c@ls/false (apply (lambda (to1d5e@ls) (call-with-values (lambda () (to1c29@gen-syntax to1ca0@src to1d5e@ls to1ca2@r to1ca3@maps to1ca4@ellipsis? '#t)) (lambda (to1d64@to1d61 to1d65@to1d63) (let ((to1d68@maps to1d65@to1d63) (to1d69@lsnew to1d64@to1d61)) (values (to1c35@gen-vector to1ca1@e to1d5e@ls to1d69@lsnew) to1d68@maps))))) to1d5c@ls/false) (let ((to1d6c@t to1d5a@t)) (let ((to1d6e@ls/false (tod8f@syntax-dispatch to1d6c@t '_))) (if to1d6e@ls/false (apply (lambda () (values (list 'quote to1ca1@e) to1ca3@maps)) to1d6e@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1d6c@t)))))))))))))))))))))))) (to1c2b@gen-ref (lambda (to1c86@src to1c87@var to1c88@level to1c89@maps) (if (= to1c88@level '0) (values to1c87@var to1c89@maps) (if (null? to1c89@maps) (toe6f@syntax-violation '#f '"missing ellipsis in syntax form" to1c86@src) (call-with-values (lambda () (to1c2b@gen-ref to1c86@src to1c87@var (- to1c88@level '1) (cdr to1c89@maps))) (lambda (to1c92@to1c8f to1c93@to1c91) (let ((to1c96@outer-maps to1c93@to1c91) (to1c97@outer-var to1c92@to1c8f)) (let ((to1c9a@t (assq to1c97@outer-var (car to1c89@maps)))) (if to1c9a@t ((lambda (to1c9c@b) (values (cdr to1c9c@b) to1c89@maps)) to1c9a@t) (let ((to1c9e@inner-var (tob10@gen-lexical 'tmp))) (values to1c9e@inner-var (cons (cons (cons to1c97@outer-var to1c9e@inner-var) (car to1c89@maps)) to1c96@outer-maps)))))))))))) (to1c2d@gen-append (lambda (to1c82@x to1c83@y) (if (fast-equal? to1c83@y ''()) to1c82@x (list 'append to1c82@x to1c83@y)))) (to1c2f@gen-mappend (lambda (to1c7e@e to1c7f@map-env) (list 'apply '(primitive append) (to1c31@gen-map to1c7e@e to1c7f@map-env)))) (to1c31@gen-map (lambda (to1c6c@e to1c6d@map-env) (let ((to1c70@formals (map cdr to1c6d@map-env)) (to1c71@actuals (map (lambda (to1c74@x) (list 'ref (car to1c74@x))) to1c6d@map-env))) (if (eq? (car to1c6c@e) 'ref) (car to1c71@actuals) (if (for-all (lambda (to1c76@x) (and (eq? (car to1c76@x) 'ref) (memq (cadr to1c76@x) to1c70@formals))) (cdr to1c6c@e)) (let ((to1c78@args (map (let ((to1c7a@r (map cons to1c70@formals to1c71@actuals))) (lambda (to1c7c@x) (cdr (assq (cadr to1c7c@x) to1c7a@r)))) (cdr to1c6c@e)))) (cons 'map (cons (list 'primitive (car to1c6c@e)) to1c78@args))) (cons* 'map (list 'lambda to1c70@formals to1c6c@e) to1c71@actuals)))))) (to1c33@gen-cons (lambda (to1c5c@e to1c5d@x to1c5e@y to1c5f@xnew to1c60@ynew) (let ((to1c66@t (car to1c60@ynew))) (if (memv to1c66@t '(quote)) (if (eq? (car to1c5f@xnew) 'quote) (let ((to1c68@xnew (cadr to1c5f@xnew)) (to1c69@ynew (cadr to1c60@ynew))) (if (and (eq? to1c68@xnew to1c5d@x) (eq? to1c69@ynew to1c5e@y)) (list 'quote to1c5c@e) (list 'quote (cons to1c68@xnew to1c69@ynew)))) (if (null? (cadr to1c60@ynew)) (list 'list to1c5f@xnew) (list 'cons to1c5f@xnew to1c60@ynew))) (if (memv to1c66@t '(list)) (cons 'list (cons to1c5f@xnew (cdr to1c60@ynew))) (list 'cons to1c5f@xnew to1c60@ynew)))))) (to1c35@gen-vector (lambda (to1c56@e to1c57@ls to1c58@lsnew) (if (eq? (car to1c58@lsnew) 'quote) (if (eq? (cadr to1c58@lsnew) to1c57@ls) (list 'quote to1c56@e) (list 'quote (list->vector (cadr to1c58@lsnew)))) (if (eq? (car to1c58@lsnew) 'list) (cons 'vector (cdr to1c58@lsnew)) (list 'list->vector to1c58@lsnew))))) (to1c37@regen (lambda (to1c50@x) (let ((to1c52@t (car to1c50@x))) (if (memv to1c52@t '(ref)) (cadr to1c50@x) (if (memv to1c52@t '(primitive)) (list 'primitive (cadr to1c50@x)) (if (memv to1c52@t '(quote)) (list 'quote (cadr to1c50@x)) (if (memv to1c52@t '(lambda)) (toaeb@toa1d@build-lambda '#f (cadr to1c50@x) (to1c37@regen (caddr to1c50@x))) (if (memv to1c52@t '(map)) (let ((to1c54@ls (map to1c37@regen (cdr to1c50@x)))) (cons '(primitive ellipsis-map) to1c54@ls)) (cons (list 'primitive (car to1c50@x)) (map to1c37@regen (cdr to1c50@x)))))))))))) (lambda (to1c38@e to1c39@r to1c3a@mr) (let ((to1c3e@t to1c38@e)) (let ((to1c40@ls/false (tod8f@syntax-dispatch to1c3e@t '(_ any)))) (if to1c40@ls/false (apply (lambda (to1c42@x) (call-with-values (lambda () (to1c29@gen-syntax to1c38@e to1c42@x to1c39@r '() tod91@ellipsis? '#f)) (lambda (to1c48@to1c45 to1c49@to1c47) (let ((to1c4c@maps to1c49@to1c47) (to1c4d@e to1c48@to1c45)) (to1c37@regen to1c4d@e))))) to1c40@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1c3e@t))))))) (set! to28a1@tod9b@syntax-transformer tod9b@syntax-transformer) (set! tod9d@core-macro-transformer (lambda (to1d70@name) (let ((to1d72@t to1d70@name)) (if (memv to1d72@t '(quote)) tod3f@quote-transformer (if (memv to1d72@t '(lambda)) tod43@lambda-transformer (if (memv to1d72@t '(case-lambda)) tod41@case-lambda-transformer (if (memv to1d72@t '(letrec)) tod27@letrec-transformer (if (memv to1d72@t '(letrec*)) tod29@letrec*-transformer (if (memv to1d72@t '(let)) tod25@let-transformer (if (memv to1d72@t '(if)) tod37@if-transformer (if (memv to1d72@t '(and)) tod39@and-transformer (if (memv to1d72@t '(or)) tod3b@or-transformer (if (memv to1d72@t '(foreign-call)) tod8b@foreign-call-transformer (if (memv to1d72@t '(syntax-case)) tod97@syntax-case-transformer (if (memv to1d72@t '(syntax)) tod9b@syntax-transformer (if (memv to1d72@t '(type-descriptor)) tod2d@type-descriptor-transformer (if (memv to1d72@t '(record-type-descriptor)) tod2f@record-type-descriptor-transformer (if (memv to1d72@t '(record-constructor-descriptor)) tod31@record-constructor-descriptor-transformer (if (memv to1d72@t '(fluid-let-syntax)) tod2b@fluid-let-syntax-transformer (assertion-violation 'macro-transformer '"BUG: cannot find transformer" to1d70@name)))))))))))))))))))) (set! to28a2@tod9d@core-macro-transformer tod9d@core-macro-transformer) (set! tod9f@symbol-macro (lambda (to1d74@x to1d75@set) (let ((to1d78@t to1d74@x)) (let ((to1d7a@ls/false (tod8f@syntax-dispatch to1d78@t '(_ any)))) (if (and to1d7a@ls/false (apply (lambda (to1d7c@name) (and (tob88@id? to1d7c@name) (memq (tob8a@id->sym to1d7c@name) to1d75@set))) to1d7a@ls/false)) (apply (lambda (to1d7e@name) (tod45@bless (list 'quote to1d7e@name))) to1d7a@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1d78@t)))))) (set! to28a3@tod9f@symbol-macro tod9f@symbol-macro) (set! toda1@macro-transformer (lambda (to1d80@x) (if (procedure? to1d80@x) to1d80@x (if (symbol? to1d80@x) (let ((to1d82@t to1d80@x)) (if (memv to1d82@t '(define-record-type)) tod83@define-record-type-macro (if (memv to1d82@t '(define-struct)) tod81@define-struct-macro (if (memv to1d82@t '(include)) tod77@include-macro (if (memv to1d82@t '(cond)) tod73@cond-macro (if (memv to1d82@t '(let)) tod4b@let-macro (if (memv to1d82@t '(do)) tod6b@do-macro (if (memv to1d82@t '(or)) tod6f@or-macro (if (memv to1d82@t '(and)) tod71@and-macro (if (memv to1d82@t '(let*)) tod6d@let*-macro (if (memv to1d82@t '(let-values)) tod4d@let-values-macro (if (memv to1d82@t '(let*-values)) tod4f@let*-values-macro (if (memv to1d82@t '(syntax-rules)) tod7b@syntax-rules-macro (if (memv to1d82@t '(quasiquote)) tod7d@quasiquote-macro (if (memv to1d82@t '(quasisyntax)) tod7f@quasisyntax-macro (if (memv to1d82@t '(with-syntax)) tod47@with-syntax-macro (if (memv to1d82@t '(when)) tod33@when-macro (if (memv to1d82@t '(unless)) tod35@unless-macro (if (memv to1d82@t '(case)) tod3d@case-macro (if (memv to1d82@t '(identifier-syntax)) tod69@identifier-syntax-macro (if (memv to1d82@t '(time)) tod61@time-macro (if (memv to1d82@t '(delay)) tod63@delay-macro (if (memv to1d82@t '(assert)) tod65@assert-macro (if (memv to1d82@t '(endianness)) tod67@endianness-macro (if (memv to1d82@t '(guard)) tod5d@guard-macro (if (memv to1d82@t '(define-enumeration)) tod5f@define-enumeration-macro (if (memv to1d82@t '(trace-lambda)) tod51@trace-lambda-macro (if (memv to1d82@t '(trace-define)) tod53@trace-define-macro (if (memv to1d82@t '(trace-define-syntax)) tod55@trace-define-syntax-macro (if (memv to1d82@t '(trace-let-syntax)) tod59@trace-let-syntax-macro (if (memv to1d82@t '(trace-letrec-syntax)) tod5b@trace-letrec-syntax-macro (if (memv to1d82@t '(define-condition-type)) tod85@define-condition-type-macro (if (memv to1d82@t '(parameterize)) tod89@parameterize-macro (if (memv to1d82@t '(include-into)) tod79@include-into-macro (if (memv to1d82@t '(eol-style)) (lambda (to1d84@x) (tod9f@symbol-macro to1d84@x '(none lf cr crlf nel crnel ls))) (if (memv to1d82@t '(error-handling-mode)) (lambda (to1d86@x) (tod9f@symbol-macro to1d86@x '(ignore raise replace))) (if (memv to1d82@t '(buffer-mode)) (lambda (to1d88@x) (tod9f@symbol-macro to1d88@x '(none line block))) (if (memv to1d82@t '(file-options)) tob03@file-options-macro (if (memv to1d82@t '(... => _ else unquote unquote-splicing unsyntax unsyntax-splicing fields mutable immutable parent protocol sealed opaque nongenerative parent-rtd)) tod87@incorrect-usage-macro (error 'macro-transformer '"BUG: invalid macro" to1d80@x)))))))))))))))))))))))))))))))))))))))) (error 'core-macro-transformer '"BUG: invalid macro" to1d80@x))))) (set! to28a4@toda1@macro-transformer toda1@macro-transformer) (set! toda3@local-macro-transformer (lambda (to1d8a@x) (car to1d8a@x))) (set! to28a5@toda3@local-macro-transformer toda3@local-macro-transformer) (set! toda5@do-macro-call (lambda (to1d8c@transformer to1d8d@expr to1d8e@rib) (let ((to1d92@out (to1d8c@transformer (tob74@add-mark tob6c@anti-mark '#f to1d8d@expr '#f)))) (begin (let to1d96@f ((to1d94@x to1d92@out)) (if (not (tob54@stx? to1d94@x)) (if (pair? to1d94@x) (begin (to1d96@f (car to1d94@x)) (to1d96@f (cdr to1d94@x))) (if (vector? to1d94@x) (vector-for-each to1d96@f to1d94@x) (if (symbol? to1d94@x) (toe6f@syntax-violation '#f '"raw symbol encountered in output of macro" to1d8d@expr to1d94@x) (void)))) (void))) (tob74@add-mark (tob6a@gen-mark) to1d8e@rib to1d92@out to1d8d@expr))))) (set! to28a6@toda5@do-macro-call toda5@do-macro-call) (set! toda7@chi-macro (lambda (to1d98@p to1d99@e to1d9a@rib) (toda5@do-macro-call (toda1@macro-transformer to1d98@p) to1d99@e to1d9a@rib))) (set! to28a7@toda7@chi-macro toda7@chi-macro) (set! toda9@chi-local-macro (lambda (to1d9e@p to1d9f@e to1da0@rib) (toda5@do-macro-call (toda3@local-macro-transformer to1d9e@p) to1d9f@e to1da0@rib))) (set! to28a8@toda9@chi-local-macro toda9@chi-local-macro) (set! todab@chi-global-macro (lambda (to1da4@p to1da5@e to1da6@rib) (let ((to1daa@lib (car to1da4@p)) (to1dab@loc (cdr to1da4@p))) (begin (to9a5@to7f4@visit-library to1daa@lib) (let ((to1dae@x (symbol-value to1dab@loc))) (let ((to1db0@transformer (if (procedure? to1dae@x) to1dae@x (assertion-violation 'chi-global-macro '"BUG: not a procedure" to1dae@x)))) (toda5@do-macro-call to1db0@transformer to1da5@e to1da6@rib))))))) (set! to28a9@todab@chi-global-macro todab@chi-global-macro) (set! todad@chi-expr* (lambda (to1db2@e* to1db3@r to1db4@mr) (if (null? to1db2@e*) '() (let ((to1db8@e (todb1@chi-expr (car to1db2@e*) to1db3@r to1db4@mr))) (cons to1db8@e (todad@chi-expr* (cdr to1db2@e*) to1db3@r to1db4@mr)))))) (set! to28aa@todad@chi-expr* todad@chi-expr*) (set! todaf@chi-application (lambda (to1dba@e to1dbb@r to1dbc@mr) (let ((to1dc0@t to1dba@e)) (let ((to1dc2@ls/false (tod8f@syntax-dispatch to1dc0@t '(any . each-any)))) (if to1dc2@ls/false (apply (lambda (to1dc4@rator to1dc5@rands) (let ((to1dc8@rator (todb1@chi-expr to1dc4@rator to1dbb@r to1dbc@mr))) (cons to1dc8@rator (todad@chi-expr* to1dc5@rands to1dbb@r to1dbc@mr)))) to1dc2@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1dc0@t)))))) (set! to28ab@todaf@chi-application todaf@chi-application) (set! todb1@chi-expr (lambda (to1dca@e to1dcb@r to1dcc@mr) (call-with-values (lambda () (tobaa@syntax-type to1dca@e to1dcb@r)) (lambda (to1dd6@to1dd1 to1dd7@to1dd3 to1dd8@to1dd5) (let ((to1ddc@kwd to1dd8@to1dd5) (to1ddd@value to1dd7@to1dd3) (to1dde@type to1dd6@to1dd1)) (let ((to1de2@t to1dde@type)) (if (memv to1de2@t '(core-macro)) (let ((to1de4@transformer (tod9d@core-macro-transformer to1ddd@value))) (to1de4@transformer to1dca@e to1dcb@r to1dcc@mr)) (if (memv to1de2@t '(global)) (let ((to1de6@lib (car to1ddd@value))) (let ((to1de8@loc (cdr to1ddd@value))) (begin ((todf7@inv-collector) to1de6@lib) to1de8@loc))) (if (memv to1de2@t '(core-prim)) (let ((to1dea@name to1ddd@value)) (list 'primitive to1dea@name)) (if (memv to1de2@t '(call)) (todaf@chi-application to1dca@e to1dcb@r to1dcc@mr) (if (memv to1de2@t '(lexical)) (let ((to1dec@lex (tod19@lexical-var to1ddd@value))) to1dec@lex) (if (memv to1de2@t '(global-macro global-macro!)) (todb1@chi-expr (todab@chi-global-macro to1ddd@value to1dca@e '#f) to1dcb@r to1dcc@mr) (if (memv to1de2@t '(local-macro local-macro!)) (todb1@chi-expr (toda9@chi-local-macro to1ddd@value to1dca@e '#f) to1dcb@r to1dcc@mr) (if (memv to1de2@t '(macro macro!)) (todb1@chi-expr (toda7@chi-macro to1ddd@value to1dca@e '#f) to1dcb@r to1dcc@mr) (if (memv to1de2@t '(constant)) (let ((to1dee@datum to1ddd@value)) (list 'quote to1dee@datum)) (if (memv to1de2@t '(set!)) (todb3@chi-set! to1dca@e to1dcb@r to1dcc@mr) (if (memv to1de2@t '(begin)) (let ((to1df0@t to1dca@e)) (let ((to1df2@ls/false (tod8f@syntax-dispatch to1df0@t '(_ any . each-any)))) (if to1df2@ls/false (apply (lambda (to1df4@x to1df5@x*) (toaed@toa4d@build-sequence '#f (todad@chi-expr* (cons to1df4@x to1df5@x*) to1dcb@r to1dcc@mr))) to1df2@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1df0@t)))) (if (memv to1de2@t '(let-syntax letrec-syntax)) (let ((to1df8@t to1dca@e)) (let ((to1dfa@ls/false (tod8f@syntax-dispatch to1df8@t '(_ #(each (any any)) any . each-any)))) (if (and to1dfa@ls/false (apply (lambda (to1dfc@xlhs* to1dfd@xrhs* to1dfe@xbody to1dff@xbody*) (if (not (tob90@valid-bound-ids? to1dfc@xlhs*)) (toe6f@syntax-violation '#f '"invalid identifiers" to1dca@e) (void))) to1dfa@ls/false)) (apply (lambda (to1e04@xlhs* to1e05@xrhs* to1e06@xbody to1e07@xbody*) (let ((to1e0c@xlab* (map tob14@gen-label to1e04@xlhs*))) (let ((to1e0e@xrib (tob48@make-full-rib to1e04@xlhs* to1e0c@xlab*))) (let ((to1e10@xb* (map (lambda (to1e12@x) (tobc0@make-eval-transformer (tode9@expand-transformer (if (eq? to1dde@type 'let-syntax) to1e12@x (tob72@add-subst to1e0e@xrib to1e12@x)) to1dcc@mr))) to1e05@xrhs*))) (toaed@toa4d@build-sequence '#f (todad@chi-expr* (map (lambda (to1e14@x) (tob72@add-subst to1e0e@xrib to1e14@x)) (cons to1e06@xbody to1e07@xbody*)) (append (map cons to1e0c@xlab* to1e10@xb*) to1dcb@r) (append (map cons to1e0c@xlab* to1e10@xb*) to1dcc@mr))))))) to1dfa@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1df8@t)))) (if (memv to1de2@t '(displaced-lexical)) (toe6f@syntax-violation '#f '"identifier out of context" to1dca@e) (if (memv to1de2@t '(syntax)) (toe6f@syntax-violation '#f '"reference to pattern variable outside a syntax form" to1dca@e) (if (memv to1de2@t '(define define-syntax module import library)) (toe6f@syntax-violation '#f (string-append (let ((to1e16@t to1dde@type)) (if (memv to1e16@t '(define)) '"a definition" (if (memv to1e16@t '(define-syntax)) '"a define-syntax" (if (memv to1e16@t '(module)) '"a module definition" (if (memv to1e16@t '(library)) '"a library definition" (if (memv to1e16@t '(import)) '"an import declaration" (if (memv to1e16@t '(export)) '"an export declaration" '"a non-expression"))))))) '" was found where an expression was expected") to1dca@e) (if (memv to1de2@t '(mutable)) (toe6f@syntax-violation '#f '"attempt to reference an unexportable variable" to1dca@e) (toe6f@syntax-violation '#f '"invalid expression" to1dca@e))))))))))))))))))))))) (set! to28ac@todb1@chi-expr todb1@chi-expr) (set! todb3@chi-set! (lambda (to1e18@e to1e19@r to1e1a@mr) (let ((to1e1e@t to1e18@e)) (let ((to1e20@ls/false (tod8f@syntax-dispatch to1e1e@t '(_ any any)))) (if (and to1e20@ls/false (apply (lambda (to1e22@x to1e23@v) (tob88@id? to1e22@x)) to1e20@ls/false)) (apply (lambda (to1e26@x to1e27@v) (call-with-values (lambda () (tobaa@syntax-type to1e26@x to1e19@r)) (lambda (to1e30@to1e2b to1e31@to1e2d to1e32@to1e2f) (let ((to1e36@kwd to1e32@to1e2f) (to1e37@value to1e31@to1e2d) (to1e38@type to1e30@to1e2b)) (let ((to1e3c@t to1e38@type)) (if (memv to1e3c@t '(lexical)) (begin (tod1d@set-lexical-mutable! to1e37@value '#t) (list 'set! (tod19@lexical-var to1e37@value) (todb1@chi-expr to1e27@v to1e19@r to1e1a@mr))) (if (memv to1e3c@t '(core-prim)) (toe6f@syntax-violation '#f '"cannot modify imported core primitive" to1e18@e) (if (memv to1e3c@t '(global)) (toe6f@syntax-violation '#f '"attempt to modify imported binding" to1e18@e) (if (memv to1e3c@t '(global-macro!)) (todb1@chi-expr (todab@chi-global-macro to1e37@value to1e18@e '#f) to1e19@r to1e1a@mr) (if (memv to1e3c@t '(local-macro!)) (todb1@chi-expr (toda9@chi-local-macro to1e37@value to1e18@e '#f) to1e19@r to1e1a@mr) (if (memv to1e3c@t '(mutable)) (toe6f@syntax-violation '#f '"attempt to assign to an unexportable variable" to1e18@e) (toe6f@syntax-violation '#f '"invalid syntax" to1e18@e)))))))))))) to1e20@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1e1e@t)))))) (set! to28ad@todb3@chi-set! todb3@chi-set!) (set! todb5@verify-formals (lambda (to1e3e@fmls to1e3f@stx) (let ((to1e42@t to1e3e@fmls)) (let ((to1e44@ls/false (tod8f@syntax-dispatch to1e42@t 'each-any))) (if to1e44@ls/false (apply (lambda (to1e46@x*) (if (not (tob90@valid-bound-ids? to1e46@x*)) (tod49@invalid-fmls-error to1e3f@stx to1e3e@fmls) (void))) to1e44@ls/false) (let ((to1e48@t to1e42@t)) (let ((to1e4a@ls/false (tod8f@syntax-dispatch to1e48@t '#(each+ any () any)))) (if to1e4a@ls/false (apply (lambda (to1e4c@x* to1e4d@x) (if (not (tob90@valid-bound-ids? (cons to1e4d@x to1e4c@x*))) (tod49@invalid-fmls-error to1e3f@stx to1e3e@fmls) (void))) to1e4a@ls/false) (let ((to1e50@t to1e48@t)) (let ((to1e52@ls/false (tod8f@syntax-dispatch to1e50@t '_))) (if to1e52@ls/false (apply (lambda () (toe6f@syntax-violation '#f '"invalid syntax" to1e3f@stx)) to1e52@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1e50@t)))))))))))) (set! to28ae@todb5@verify-formals todb5@verify-formals) (set! todb7@chi-lambda-clause (lambda (to1e54@stx to1e55@fmls to1e56@body* to1e57@r to1e58@mr) (let ((to1e5e@t to1e55@fmls)) (let ((to1e60@ls/false (tod8f@syntax-dispatch to1e5e@t 'each-any))) (if to1e60@ls/false (apply (lambda (to1e62@x*) (begin (todb5@verify-formals to1e55@fmls to1e54@stx) (let ((to1e64@lex* (map tob10@gen-lexical to1e62@x*)) (to1e65@lab* (map tob14@gen-label to1e62@x*))) (values to1e64@lex* (todc7@chi-internal (tob72@add-subst (tob48@make-full-rib to1e62@x* to1e65@lab*) to1e56@body*) (tod21@add-lexicals to1e65@lab* to1e64@lex* to1e57@r) to1e58@mr))))) to1e60@ls/false) (let ((to1e68@t to1e5e@t)) (let ((to1e6a@ls/false (tod8f@syntax-dispatch to1e68@t '#(each+ any () any)))) (if to1e6a@ls/false (apply (lambda (to1e6c@x* to1e6d@x) (begin (todb5@verify-formals to1e55@fmls to1e54@stx) (let ((to1e70@lex* (map tob10@gen-lexical to1e6c@x*)) (to1e71@lab* (map tob14@gen-label to1e6c@x*)) (to1e72@lex (tob10@gen-lexical to1e6d@x)) (to1e73@lab (tob14@gen-label to1e6d@x))) (values (append to1e70@lex* to1e72@lex) (todc7@chi-internal (tob72@add-subst (tob48@make-full-rib (cons to1e6d@x to1e6c@x*) (cons to1e73@lab to1e71@lab*)) to1e56@body*) (tod21@add-lexicals (cons to1e73@lab to1e71@lab*) (cons to1e72@lex to1e70@lex*) to1e57@r) to1e58@mr))))) to1e6a@ls/false) (let ((to1e78@t to1e68@t)) (let ((to1e7a@ls/false (tod8f@syntax-dispatch to1e78@t '_))) (if to1e7a@ls/false (apply (lambda () (toe6f@syntax-violation '#f '"invalid syntax" to1e55@fmls)) to1e7a@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1e78@t)))))))))))) (set! to28af@todb7@chi-lambda-clause todb7@chi-lambda-clause) (set! todb9@chi-lambda-clause* (lambda (to1e7c@stx to1e7d@fmls* to1e7e@body** to1e7f@r to1e80@mr) (if (null? to1e7d@fmls*) (values '() '()) (call-with-values (lambda () (todb7@chi-lambda-clause to1e7c@stx (car to1e7d@fmls*) (car to1e7e@body**) to1e7f@r to1e80@mr)) (lambda (to1e8a@to1e87 to1e8b@to1e89) (let ((to1e8e@b to1e8b@to1e89) (to1e8f@a to1e8a@to1e87)) (call-with-values (lambda () (todb9@chi-lambda-clause* to1e7c@stx (cdr to1e7d@fmls*) (cdr to1e7e@body**) to1e7f@r to1e80@mr)) (lambda (to1e96@to1e93 to1e97@to1e95) (let ((to1e9a@b* to1e97@to1e95) (to1e9b@a* to1e96@to1e93)) (values (cons to1e8f@a to1e9b@a*) (cons to1e8e@b to1e9a@b*))))))))))) (set! to28b0@todb9@chi-lambda-clause* todb9@chi-lambda-clause*) (set! todbb@chi-defun (lambda (to1e9e@x to1e9f@r to1ea0@mr) (let ((to1ea4@fmls (car to1e9e@x)) (to1ea5@body* (cdr to1e9e@x))) (call-with-values (lambda () (todb7@chi-lambda-clause to1ea4@fmls to1ea4@fmls to1ea5@body* to1e9f@r to1ea0@mr)) (lambda (to1eac@to1ea9 to1ead@to1eab) (let ((to1eb0@body to1ead@to1eab) (to1eb1@fmls to1eac@to1ea9)) (toaeb@toa1d@build-lambda '#f to1eb1@fmls to1eb0@body))))))) (set! to28b1@todbb@chi-defun todbb@chi-defun) (set! todbd@chi-rhs (lambda (to1eb4@rhs to1eb5@r to1eb6@mr) (let ((to1eba@t (car to1eb4@rhs))) (if (memv to1eba@t '(defun)) (todbb@chi-defun (cdr to1eb4@rhs) to1eb5@r to1eb6@mr) (if (memv to1eba@t '(expr)) (let ((to1ebc@expr (cdr to1eb4@rhs))) (todb1@chi-expr to1ebc@expr to1eb5@r to1eb6@mr)) (if (memv to1eba@t '(top-expr)) (let ((to1ebe@expr (cdr to1eb4@rhs))) (toaed@toa4d@build-sequence '#f (list (todb1@chi-expr to1ebe@expr to1eb5@r to1eb6@mr) (toaee@toa4f@build-void)))) (assertion-violation 'chi-rhs '"BUG: invalid rhs" to1eb4@rhs))))))) (set! to28b2@todbd@chi-rhs todbd@chi-rhs) (set! todbf@expand-interaction-rhs*/init* (lambda (to1ec0@lhs* to1ec1@rhs* to1ec2@init* to1ec3@r to1ec4@mr) (let to1ece@f ((to1eca@lhs* to1ec0@lhs*) (to1ecb@rhs* to1ec1@rhs*)) (if (null? to1eca@lhs*) (map (lambda (to1ed0@x) (todb1@chi-expr to1ed0@x to1ec3@r to1ec4@mr)) to1ec2@init*) (let ((to1ed2@lhs (car to1eca@lhs*)) (to1ed3@rhs (car to1ecb@rhs*))) (let ((to1ed6@t (car to1ed3@rhs))) (if (memv to1ed6@t '(defun)) (let ((to1ed8@rhs (todbb@chi-defun (cdr to1ed3@rhs) to1ec3@r to1ec4@mr))) (cons (list 'set! to1ed2@lhs to1ed8@rhs) (to1ece@f (cdr to1eca@lhs*) (cdr to1ecb@rhs*)))) (if (memv to1ed6@t '(expr)) (let ((to1eda@rhs (todb1@chi-expr (cdr to1ed3@rhs) to1ec3@r to1ec4@mr))) (cons (list 'set! to1ed2@lhs to1eda@rhs) (to1ece@f (cdr to1eca@lhs*) (cdr to1ecb@rhs*)))) (if (memv to1ed6@t '(top-expr)) (let ((to1edc@e (todb1@chi-expr (cdr to1ed3@rhs) to1ec3@r to1ec4@mr))) (cons to1edc@e (to1ece@f (cdr to1eca@lhs*) (cdr to1ecb@rhs*)))) (error 'expand-interaction '"invallid" to1ed3@rhs)))))))))) (set! to28b3@todbf@expand-interaction-rhs*/init* todbf@expand-interaction-rhs*/init*) (set! todc1@chi-rhs* (lambda (to1ede@rhs* to1edf@r to1ee0@mr) (let to1ee6@f ((to1ee4@ls to1ede@rhs*)) (if (null? to1ee4@ls) '() (let ((to1ee8@a (todbd@chi-rhs (car to1ee4@ls) to1edf@r to1ee0@mr))) (cons to1ee8@a (to1ee6@f (cdr to1ee4@ls)))))))) (set! to28b4@todc1@chi-rhs* todc1@chi-rhs*) (set! todc3@find-bound=? (lambda (to1eea@x to1eeb@lhs* to1eec@rhs*) (if (null? to1eeb@lhs*) '#f (if (tob8c@bound-id=? to1eea@x (car to1eeb@lhs*)) (car to1eec@rhs*) (todc3@find-bound=? to1eea@x (cdr to1eeb@lhs*) (cdr to1eec@rhs*)))))) (set! to28b5@todc3@find-bound=? todc3@find-bound=?) (set! todc5@find-dups (lambda (to1ef0@ls) (let to1ef6@f ((to1ef2@ls to1ef0@ls) (to1ef3@dups '())) (if (null? to1ef2@ls) to1ef3@dups (let ((to1ef8@t (todc3@find-bound=? (car to1ef2@ls) (cdr to1ef2@ls) (cdr to1ef2@ls)))) (if to1ef8@t ((lambda (to1efa@x) (to1ef6@f (cdr to1ef2@ls) (cons (list (car to1ef2@ls) to1efa@x) to1ef3@dups))) to1ef8@t) (to1ef6@f (cdr to1ef2@ls) to1ef3@dups))))))) (set! to28b6@todc5@find-dups todc5@find-dups) (set! todc7@chi-internal (lambda (to1efc@e* to1efd@r to1efe@mr) (let ((to1f02@rib (tob3c@make-empty-rib))) (call-with-values (lambda () (tode7@chi-body* (map (lambda (to1f14@x) (tob72@add-subst to1f02@rib to1f14@x)) (tob86@syntax->list to1efc@e*)) to1efd@r to1efe@mr '() '() '() '() '() to1f02@rib '#f)) (lambda (to1f16@to1f05 to1f17@to1f07 to1f18@to1f09 to1f19@to1f0b to1f1a@to1f0d to1f1b@to1f0f to1f1c@to1f11 to1f1d@to1f13) (let ((to1f26@_exp* to1f1d@to1f13) (to1f27@kwd* to1f1c@to1f11) (to1f28@mod** to1f1b@to1f0f) (to1f29@rhs* to1f1a@to1f0d) (to1f2a@lex* to1f19@to1f0b) (to1f2b@mr to1f18@to1f09) (to1f2c@r to1f17@to1f07) (to1f2d@e* to1f16@to1f05)) (begin (if (null? to1f2d@e*) (toe6f@syntax-violation '#f '"no expression in body" to1f2d@e*) (void)) (let ((to1f36@init* (todad@chi-expr* (append (apply append (reverse to1f28@mod**)) to1f2d@e*) to1f2c@r to1f2b@mr))) (let ((to1f38@rhs* (todc1@chi-rhs* to1f29@rhs* to1f2c@r to1f2b@mr))) (toaf2@toa57@build-letrec* '#f (reverse to1f2a@lex*) (reverse to1f38@rhs*) (toaed@toa4d@build-sequence '#f to1f36@init*))))))))))) (set! to28b7@todc7@chi-internal todc7@chi-internal) (set! todc9@parse-module (lambda (to1f3a@e) (let ((to1f3c@t to1f3a@e)) (let ((to1f3e@ls/false (tod8f@syntax-dispatch to1f3c@t '(_ each-any . each-any)))) (if to1f3e@ls/false (apply (lambda (to1f40@export* to1f41@b*) (begin (if (not (for-all tob88@id? to1f40@export*)) (toe6f@syntax-violation '#f '"module exports must be identifiers" to1f3a@e) (void)) (values '#f (list->vector to1f40@export*) to1f41@b*))) to1f3e@ls/false) (let ((to1f44@t to1f3c@t)) (let ((to1f46@ls/false (tod8f@syntax-dispatch to1f44@t '(_ any each-any . each-any)))) (if to1f46@ls/false (apply (lambda (to1f48@name to1f49@export* to1f4a@b*) (begin (if (not (tob88@id? to1f48@name)) (toe6f@syntax-violation '#f '"module name must be an identifier" to1f3a@e) (void)) (if (not (for-all tob88@id? to1f49@export*)) (toe6f@syntax-violation '#f '"module exports must be identifiers" to1f3a@e) (void)) (values to1f48@name (list->vector to1f49@export*) to1f4a@b*))) to1f46@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to1f44@t))))))))) (set! to28b8@todc9@parse-module todc9@parse-module) (set! todd3@module-interface? (lambda (to1f4e@x) (and (simple-struct? to1f4e@x) (eq? (simple-struct-name to1f4e@x) 'module-interface)))) (set! to28b9@todd3@module-interface? todd3@module-interface?) (set! todd5@module-interface-first-mark (lambda (to1f50@x) (simple-struct-ref to1f50@x '0))) (set! to28ba@todd5@module-interface-first-mark todd5@module-interface-first-mark) (set! todd7@set-module-interface-first-mark! (lambda (to1f52@x to1f53@val) (simple-struct-set! to1f52@x '0 to1f53@val))) (set! to28bb@todd7@set-module-interface-first-mark! todd7@set-module-interface-first-mark!) (set! todd9@module-interface-exp-id-vec (lambda (to1f56@x) (simple-struct-ref to1f56@x '1))) (set! to28bc@todd9@module-interface-exp-id-vec todd9@module-interface-exp-id-vec) (set! toddb@set-module-interface-exp-id-vec! (lambda (to1f58@x to1f59@val) (simple-struct-set! to1f58@x '1 to1f59@val))) (set! to28bd@toddb@set-module-interface-exp-id-vec! toddb@set-module-interface-exp-id-vec!) (set! toddd@module-interface-exp-lab-vec (lambda (to1f5c@x) (simple-struct-ref to1f5c@x '2))) (set! to28be@toddd@module-interface-exp-lab-vec toddd@module-interface-exp-lab-vec) (set! toddf@set-module-interface-exp-lab-vec! (lambda (to1f5e@x to1f5f@val) (simple-struct-set! to1f5e@x '2 to1f5f@val))) (set! to28bf@toddf@set-module-interface-exp-lab-vec! toddf@set-module-interface-exp-lab-vec!) (set! tode1@dummy '3) (set! to28c0@tode1@dummy tode1@dummy) (set! tode3@module-interface-exp-id* (lambda (to1f62@iface to1f63@id) (letrec* ((to1f67@diff-marks (lambda (to1f6e@ls to1f6f@x) (begin (if (null? to1f6e@ls) (error 'diff-marks '"BUG: should not happen") (void)) (let ((to1f72@a (car to1f6e@ls))) (if (eq? to1f72@a to1f6f@x) '() (cons to1f72@a (to1f67@diff-marks (cdr to1f6e@ls) to1f6f@x)))))))) (let ((to1f68@diff (to1f67@diff-marks (tob5a@stx-mark* to1f63@id) (todd5@module-interface-first-mark to1f62@iface))) (to1f69@id-vec (todd9@module-interface-exp-id-vec to1f62@iface))) (if (null? to1f68@diff) to1f69@id-vec (vector-map (lambda (to1f6c@x) (make-simple-struct 'stx '5 (list (tob56@stx-expr to1f6c@x) (append to1f68@diff (tob5a@stx-mark* to1f6c@x)) '() '()))) to1f69@id-vec)))))) (set! to28c1@tode3@module-interface-exp-id* tode3@module-interface-exp-id*) (set! tode5@chi-internal-module (lambda (to1f74@e to1f75@r to1f76@mr to1f77@lex* to1f78@rhs* to1f79@mod** to1f7a@kwd*) (call-with-values (lambda () (todc9@parse-module to1f74@e)) (lambda (to1f88@to1f83 to1f89@to1f85 to1f8a@to1f87) (let ((to1f8e@e* to1f8a@to1f87) (to1f8f@exp-id* to1f89@to1f85) (to1f90@name to1f88@to1f83)) (let ((to1f94@rib (tob3c@make-empty-rib))) (let ((to1f96@e* (map (lambda (to1f98@x) (tob72@add-subst to1f94@rib to1f98@x)) (tob86@syntax->list to1f8e@e*)))) (call-with-values (lambda () (tode7@chi-body* to1f96@e* to1f75@r to1f76@mr to1f77@lex* to1f78@rhs* to1f79@mod** to1f7a@kwd* '() to1f94@rib '#f)) (lambda (to1faa@to1f9b to1fab@to1f9d to1fac@to1f9f to1fad@to1fa1 to1fae@to1fa3 to1faf@to1fa5 to1fb0@to1fa7 to1fb1@to1fa9) (let ((to1fba@_exp* to1fb1@to1fa9) (to1fbb@kwd* to1fb0@to1fa7) (to1fbc@mod** to1faf@to1fa5) (to1fbd@rhs* to1fae@to1fa3) (to1fbe@lex* to1fad@to1fa1) (to1fbf@mr to1fac@to1f9f) (to1fc0@r to1fab@to1f9d) (to1fc1@e* to1faa@to1f9b)) (let ((to1fca@exp-lab* (vector-map (lambda (to1fce@x) (or (tob9e@id->label (make-simple-struct 'stx '5 (list (tob8a@id->sym to1fce@x) (tob5a@stx-mark* to1fce@x) (list to1f94@rib) '()))) (toe6f@syntax-violation '#f '"cannot find module export" to1fce@x))) to1f8f@exp-id*)) (to1fcb@mod** (cons to1fc1@e* to1fbc@mod**))) (if (not to1f90@name) (values to1fbe@lex* to1fbd@rhs* to1f8f@exp-id* to1fca@exp-lab* to1fc0@r to1fbf@mr to1fcb@mod** to1fbb@kwd*) (let ((to1fd0@lab (tob14@gen-label 'module)) (to1fd1@iface (make-simple-struct 'module-interface '4 (list (car (tob5a@stx-mark* to1f90@name)) (vector-map (lambda (to1fd4@x) (make-simple-struct 'stx '5 (list (tob56@stx-expr to1fd4@x) (tob5a@stx-mark* to1fd4@x) '() '()))) to1f8f@exp-id*) to1fca@exp-lab*)))) (values to1fbe@lex* to1fbd@rhs* (vector to1f90@name) (vector to1fd0@lab) (cons (cons to1fd0@lab (cons '$module to1fd1@iface)) to1fc0@r) (cons (cons to1fd0@lab (cons '$module to1fd1@iface)) to1fbf@mr) to1fcb@mod** to1fbb@kwd*)))))))))))))) (set! to28c2@tode5@chi-internal-module tode5@chi-internal-module) (set! tode7@chi-body* (lambda (to1fd6@e* to1fd7@r to1fd8@mr to1fd9@lex* to1fda@rhs* to1fdb@mod** to1fdc@kwd* to1fdd@exp* to1fde@rib to1fdf@top?) (if (null? to1fd6@e*) (values to1fd6@e* to1fd7@r to1fd8@mr to1fd9@lex* to1fda@rhs* to1fdb@mod** to1fdc@kwd* to1fdd@exp*) (let ((to1fea@e (car to1fd6@e*))) (call-with-values (lambda () (tobaa@syntax-type to1fea@e to1fd7@r)) (lambda (to1ff2@to1fed to1ff3@to1fef to1ff4@to1ff1) (let ((to1ff8@kwd to1ff4@to1ff1) (to1ff9@value to1ff3@to1fef) (to1ffa@type to1ff2@to1fed)) (let ((to1ffe@kwd* (if (tob88@id? to1ff8@kwd) (cons to1ff8@kwd to1fdc@kwd*) to1fdc@kwd*))) (let ((to2000@t to1ffa@type)) (if (memv to2000@t '(define)) (call-with-values (lambda () (tod11@parse-define to1fea@e)) (lambda (to2006@to2003 to2007@to2005) (let ((to200a@rhs to2007@to2005) (to200b@id to2006@to2003)) (begin (if (tob94@bound-id-member? to200b@id to1ffe@kwd*) (toe6f@syntax-violation '#f '"cannot redefine keyword" to1fea@e) (void)) (call-with-values (lambda () (tob18@gen-define-label+loc to200b@id to1fde@rib)) (lambda (to2012@to200f to2013@to2011) (let ((to2016@lex to2013@to2011) (to2017@lab to2012@to200f)) (begin (tob3e@extend-rib! to1fde@rib to200b@id to2017@lab) (tode7@chi-body* (cdr to1fd6@e*) (tod1f@add-lexical to2017@lab to2016@lex to1fd7@r) to1fd8@mr (cons to2016@lex to1fd9@lex*) (cons to200a@rhs to1fda@rhs*) to1fdb@mod** to1ffe@kwd* to1fdd@exp* to1fde@rib to1fdf@top?))))))))) (if (memv to2000@t '(define-syntax)) (call-with-values (lambda () (tod13@parse-define-syntax to1fea@e)) (lambda (to201e@to201b to201f@to201d) (let ((to2022@rhs to201f@to201d) (to2023@id to201e@to201b)) (begin (if (tob94@bound-id-member? to2023@id to1ffe@kwd*) (toe6f@syntax-violation '#f '"cannot redefine keyword" to1fea@e) (void)) (let ((to2026@lab (tob1a@gen-define-label to2023@id to1fde@rib)) (to2027@expanded-rhs (tode9@expand-transformer to2022@rhs to1fd8@mr))) (begin (tob3e@extend-rib! to1fde@rib to2023@id to2026@lab) (let ((to202a@b (tobc0@make-eval-transformer to2027@expanded-rhs))) (tode7@chi-body* (cdr to1fd6@e*) (cons (cons to2026@lab to202a@b) to1fd7@r) (cons (cons to2026@lab to202a@b) to1fd8@mr) to1fd9@lex* to1fda@rhs* to1fdb@mod** to1ffe@kwd* to1fdd@exp* to1fde@rib to1fdf@top?)))))))) (if (memv to2000@t '(let-syntax letrec-syntax)) (let ((to202c@t to1fea@e)) (let ((to202e@ls/false (tod8f@syntax-dispatch to202c@t '(_ #(each (any any)) . each-any)))) (if (and to202e@ls/false (apply (lambda (to2030@xlhs* to2031@xrhs* to2032@xbody*) (if (not (tob90@valid-bound-ids? to2030@xlhs*)) (toe6f@syntax-violation '#f '"invalid identifiers" to1fea@e) (void))) to202e@ls/false)) (apply (lambda (to2036@xlhs* to2037@xrhs* to2038@xbody*) (let ((to203c@xlab* (map tob14@gen-label to2036@xlhs*))) (let ((to203e@xrib (tob48@make-full-rib to2036@xlhs* to203c@xlab*))) (let ((to2040@xb* (map (lambda (to2042@x) (tobc0@make-eval-transformer (tode9@expand-transformer (if (eq? to1ffa@type 'let-syntax) to2042@x (tob72@add-subst to203e@xrib to2042@x)) to1fd8@mr))) to2037@xrhs*))) (tode7@chi-body* (append (map (lambda (to2044@x) (tob72@add-subst to203e@xrib to2044@x)) to2038@xbody*) (cdr to1fd6@e*)) (append (map cons to203c@xlab* to2040@xb*) to1fd7@r) (append (map cons to203c@xlab* to2040@xb*) to1fd8@mr) to1fd9@lex* to1fda@rhs* to1fdb@mod** to1ffe@kwd* to1fdd@exp* to1fde@rib to1fdf@top?))))) to202e@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to202c@t)))) (if (memv to2000@t '(begin)) (let ((to2046@t to1fea@e)) (let ((to2048@ls/false (tod8f@syntax-dispatch to2046@t '(_ . each-any)))) (if to2048@ls/false (apply (lambda (to204a@x*) (tode7@chi-body* (append to204a@x* (cdr to1fd6@e*)) to1fd7@r to1fd8@mr to1fd9@lex* to1fda@rhs* to1fdb@mod** to1ffe@kwd* to1fdd@exp* to1fde@rib to1fdf@top?)) to2048@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to2046@t)))) (if (memv to2000@t '(global-macro global-macro!)) (tode7@chi-body* (cons (todab@chi-global-macro to1ff9@value to1fea@e to1fde@rib) (cdr to1fd6@e*)) to1fd7@r to1fd8@mr to1fd9@lex* to1fda@rhs* to1fdb@mod** to1ffe@kwd* to1fdd@exp* to1fde@rib to1fdf@top?) (if (memv to2000@t '(local-macro local-macro!)) (tode7@chi-body* (cons (toda9@chi-local-macro to1ff9@value to1fea@e to1fde@rib) (cdr to1fd6@e*)) to1fd7@r to1fd8@mr to1fd9@lex* to1fda@rhs* to1fdb@mod** to1ffe@kwd* to1fdd@exp* to1fde@rib to1fdf@top?) (if (memv to2000@t '(macro macro!)) (tode7@chi-body* (cons (toda7@chi-macro to1ff9@value to1fea@e to1fde@rib) (cdr to1fd6@e*)) to1fd7@r to1fd8@mr to1fd9@lex* to1fda@rhs* to1fdb@mod** to1ffe@kwd* to1fdd@exp* to1fde@rib to1fdf@top?) (if (memv to2000@t '(module)) (call-with-values (lambda () (tode5@chi-internal-module to1fea@e to1fd7@r to1fd8@mr to1fd9@lex* to1fda@rhs* to1fdb@mod** to1ffe@kwd*)) (lambda (to205c@to204d to205d@to204f to205e@to2051 to205f@to2053 to2060@to2055 to2061@to2057 to2062@to2059 to2063@to205b) (let ((to206c@kwd* to2063@to205b) (to206d@mod** to2062@to2059) (to206e@mr to2061@to2057) (to206f@r to2060@to2055) (to2070@m-exp-lab* to205f@to2053) (to2071@m-exp-id* to205e@to2051) (to2072@rhs* to205d@to204f) (to2073@lex* to205c@to204d)) (begin (vector-for-each (lambda (to207c@id to207d@lab) (tob3e@extend-rib! to1fde@rib to207c@id to207d@lab)) to2071@m-exp-id* to2070@m-exp-lab*) (tode7@chi-body* (cdr to1fd6@e*) to206f@r to206e@mr to2073@lex* to2072@rhs* to206d@mod** to206c@kwd* to1fdd@exp* to1fde@rib to1fdf@top?))))) (if (memv to2000@t '(library)) (begin (toe51@library-expander (tob9c@stx->datum to1fea@e)) (tode7@chi-body* (cdr to1fd6@e*) to1fd7@r to1fd8@mr to1fd9@lex* to1fda@rhs* to1fdb@mod** to1ffe@kwd* to1fdd@exp* to1fde@rib to1fdf@top?)) (if (memv to2000@t '(export)) (let ((to2080@t to1fea@e)) (let ((to2082@ls/false (tod8f@syntax-dispatch to2080@t '(_ . each-any)))) (if to2082@ls/false (apply (lambda (to2084@exp-decl*) (tode7@chi-body* (cdr to1fd6@e*) to1fd7@r to1fd8@mr to1fd9@lex* to1fda@rhs* to1fdb@mod** to1ffe@kwd* (append to2084@exp-decl* to1fdd@exp*) to1fde@rib to1fdf@top?)) to2082@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to2080@t)))) (if (memv to2000@t '(import)) (letrec* ((to2087@module-import? (lambda (to20da@e) (let ((to20dc@t to20da@e)) (let ((to20de@ls/false (tod8f@syntax-dispatch to20dc@t '(_ any)))) (if (and to20de@ls/false (apply (lambda (to20e0@id) (tob88@id? to20e0@id)) to20de@ls/false)) (apply (lambda (to20e2@id) '#t) to20de@ls/false) (let ((to20e4@t to20dc@t)) (let ((to20e6@ls/false (tod8f@syntax-dispatch to20e4@t '(_ . each-any)))) (if to20e6@ls/false (apply (lambda (to20e8@imp*) '#f) to20e6@ls/false) (let ((to20ea@t to20e4@t)) (let ((to20ec@ls/false (tod8f@syntax-dispatch to20ea@t '_))) (if to20ec@ls/false (apply (lambda () (toe6f@syntax-violation '#f '"malformed import form" to20da@e)) to20ec@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to20ea@t)))))))))))) (to2089@module-import (lambda (to20b8@e to20b9@r) (let ((to20bc@t to20b8@e)) (let ((to20be@ls/false (tod8f@syntax-dispatch to20bc@t '(_ any)))) (if (and to20be@ls/false (apply (lambda (to20c0@id) (tob88@id? to20c0@id)) to20be@ls/false)) (apply (lambda (to20c2@id) (call-with-values (lambda () (tobaa@syntax-type to20c2@id to20b9@r)) (lambda (to20ca@to20c5 to20cb@to20c7 to20cc@to20c9) (let ((to20d0@kwd to20cc@to20c9) (to20d1@value to20cb@to20c7) (to20d2@type to20ca@to20c5)) (let ((to20d6@t to20d2@type)) (if (memv to20d6@t '($module)) (let ((to20d8@iface to20d1@value)) (values (tode3@module-interface-exp-id* to20d8@iface to20c2@id) (toddd@module-interface-exp-lab-vec to20d8@iface))) (toe6f@syntax-violation '#f '"invalid import" to20b8@e))))))) to20be@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to20bc@t)))))) (to208b@library-import (lambda (to209c@e) (let ((to209e@t to209c@e)) (let ((to20a0@ls/false (tod8f@syntax-dispatch to209e@t '(any . each-any)))) (if to20a0@ls/false (apply (lambda (to20a2@ctxt to20a3@imp*) (call-with-values (lambda () (todf1@parse-import-spec* (toe75@syntax->datum to20a3@imp*))) (lambda (to20aa@to20a7 to20ab@to20a9) (let ((to20ae@subst-labels to20ab@to20a9) (to20af@subst-names to20aa@to20a7)) (values (vector-map (lambda (to20b2@name) (tob68@datum->stx to20a2@ctxt to20b2@name)) to20af@subst-names) to20ae@subst-labels))))) to20a0@ls/false) (let ((to20b4@t to209e@t)) (let ((to20b6@ls/false (tod8f@syntax-dispatch to20b4@t '_))) (if to20b6@ls/false (apply (lambda () (toe6f@syntax-violation '#f '"invalid import form" to209c@e)) to20b6@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to20b4@t)))))))))) (begin (call-with-values (lambda () (if (to2087@module-import? to1fea@e) (to2089@module-import to1fea@e to1fd7@r) (to208b@library-import to1fea@e))) (lambda (to2090@to208d to2091@to208f) (let ((to2094@lab* to2091@to208f) (to2095@id* to2090@to208d)) (vector-for-each (lambda (to2098@id to2099@lab) (tob3e@extend-rib! to1fde@rib to2098@id to2099@lab)) to2095@id* to2094@lab*)))) (tode7@chi-body* (cdr to1fd6@e*) to1fd7@r to1fd8@mr to1fd9@lex* to1fda@rhs* to1fdb@mod** to1ffe@kwd* to1fdd@exp* to1fde@rib to1fdf@top?))) (if to1fdf@top? (tode7@chi-body* (cdr to1fd6@e*) to1fd7@r to1fd8@mr (cons (tob10@gen-lexical 'dummy) to1fd9@lex*) (cons (cons 'top-expr to1fea@e) to1fda@rhs*) to1fdb@mod** to1ffe@kwd* to1fdd@exp* to1fde@rib to1fdf@top?) (values to1fd6@e* to1fd7@r to1fd8@mr to1fd9@lex* to1fda@rhs* to1fdb@mod** to1ffe@kwd* to1fdd@exp*)))))))))))))))))))))) (set! to28c3@tode7@chi-body* tode7@chi-body*) (set! tode9@expand-transformer (lambda (to20ee@expr to20ef@r) (let ((to20f2@rtc (todf5@make-collector))) (let ((to20f4@expanded-rhs (let ((to20fe@to20f7 todf7@inv-collector) (to20ff@to20f9 todf9@vis-collector) (to2100@to20fb to20f2@rtc) (to2101@to20fd (lambda (to2106@x) (values)))) (let ((to2108@swap (lambda () (begin (let ((to210a@t (to20fe@to20f7))) (begin (to20fe@to20f7 to2100@to20fb) (set! to2100@to20fb to210a@t))) (let ((to210c@t (to20ff@to20f9))) (begin (to20ff@to20f9 to2101@to20fd) (set! to2101@to20fd to210c@t))))))) (dynamic-wind to2108@swap (lambda () (todb1@chi-expr to20ee@expr to20ef@r to20ef@r)) to2108@swap))))) (begin (for-each (let ((to210e@mark-visit (todf9@vis-collector))) (lambda (to2110@x) (begin (to9a4@to7f2@invoke-library to2110@x) (to210e@mark-visit to2110@x)))) (to20f2@rtc)) to20f4@expanded-rhs))))) (set! to28c4@tode9@expand-transformer tode9@expand-transformer) (set! todeb@parse-exports (lambda (to2112@exp*) (let to211a@f ((to2114@exp* to2112@exp*) (to2115@int* '()) (to2116@ext* '())) (if (null? to2114@exp*) (begin (if (not (tob90@valid-bound-ids? to2116@ext*)) (toe6f@syntax-violation 'export '"invalid exports" (todc5@find-dups to2116@ext*)) (void)) (values (map toe75@syntax->datum to2116@ext*) to2115@int*)) (let ((to211c@t (car to2114@exp*))) (let ((to211e@ls/false (tod8f@syntax-dispatch to211c@t '(any . #(each (any any)))))) (if to211e@ls/false (apply (lambda (to2120@rename to2121@i* to2122@e*) (begin (if (not (and (eq? (toe75@syntax->datum to2120@rename) 'rename) (for-all tob88@id? to2121@i*) (for-all tob88@id? to2122@e*))) (toe6f@syntax-violation 'export '"invalid export specifier" (car to2114@exp*)) (void)) (to211a@f (cdr to2114@exp*) (append to2121@i* to2115@int*) (append to2122@e* to2116@ext*)))) to211e@ls/false) (let ((to2126@t to211c@t)) (let ((to2128@ls/false (tod8f@syntax-dispatch to2126@t 'any))) (if to2128@ls/false (apply (lambda (to212a@ie) (begin (if (not (tob88@id? to212a@ie)) (toe6f@syntax-violation 'export '"invalid export" to212a@ie) (void)) (to211a@f (cdr to2114@exp*) (cons to212a@ie to2115@int*) (cons to212a@ie to2116@ext*)))) to2128@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to2126@t))))))))))) (set! to28c5@todeb@parse-exports todeb@parse-exports) (set! toded@parse-library-name (lambda (to212c@spec) (letrec* ((to212f@parse (lambda (to213c@x) (let ((to213e@t to213c@x)) (let ((to2140@ls/false (tod8f@syntax-dispatch to213e@t '(each-any)))) (if (and to2140@ls/false (apply (lambda (to2142@v*) (for-all (lambda (to2144@x) (let ((to2146@x (toe75@syntax->datum to2144@x))) (and (integer? to2146@x) (exact? to2146@x)))) to2142@v*)) to2140@ls/false)) (apply (lambda (to2148@v*) (values '() (map toe75@syntax->datum to2148@v*))) to2140@ls/false) (let ((to214a@t to213e@t)) (let ((to214c@ls/false (tod8f@syntax-dispatch to214a@t '(any . any)))) (if (and to214c@ls/false (apply (lambda (to214e@x to214f@rest) (symbol? (toe75@syntax->datum to214e@x))) to214c@ls/false)) (apply (lambda (to2152@x to2153@rest) (call-with-values (lambda () (to212f@parse to2153@rest)) (lambda (to215a@to2157 to215b@to2159) (let ((to215e@v* to215b@to2159) (to215f@x* to215a@to2157)) (values (cons (toe75@syntax->datum to2152@x) to215f@x*) to215e@v*))))) to214c@ls/false) (let ((to2162@t to214a@t)) (let ((to2164@ls/false (tod8f@syntax-dispatch to2162@t '()))) (if to2164@ls/false (apply (lambda () (values '() '())) to2164@ls/false) (let ((to2166@t to2162@t)) (let ((to2168@ls/false (tod8f@syntax-dispatch to2166@t '_))) (if to2168@ls/false (apply (lambda () (toe6f@syntax-violation '#f '"invalid library name" to212c@spec)) to2168@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to2166@t)))))))))))))))) (call-with-values (lambda () (to212f@parse to212c@spec)) (lambda (to2134@to2131 to2135@to2133) (let ((to2138@ver* to2135@to2133) (to2139@name* to2134@to2131)) (begin (if (null? to2139@name*) (toe6f@syntax-violation '#f '"empty library name" to212c@spec) (void)) (values to2139@name* to2138@ver*)))))))) (set! to28c6@toded@parse-library-name toded@parse-library-name) (set! todef@parse-library (lambda (to216a@e) (let ((to216c@t to216a@e)) (let ((to216e@ls/false (tod8f@syntax-dispatch to216c@t '(any each-any (any . each-any) (any . each-any) . each-any)))) (if (and to216e@ls/false (apply (lambda (to2170@library to2171@name* to2172@export to2173@exp* to2174@import to2175@imp* to2176@b*) (and (eq? (toe75@syntax->datum to2172@export) 'export) (eq? (toe75@syntax->datum to2174@import) 'import) (eq? (toe75@syntax->datum to2170@library) 'library))) to216e@ls/false)) (apply (lambda (to217e@library to217f@name* to2180@export to2181@exp* to2182@import to2183@imp* to2184@b*) (values to217f@name* to2181@exp* to2183@imp* to2184@b*)) to216e@ls/false) (let ((to218c@t to216c@t)) (let ((to218e@ls/false (tod8f@syntax-dispatch to218c@t '_))) (if to218e@ls/false (apply (lambda () (toe6f@syntax-violation '#f '"malformed library" to216a@e)) to218e@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to218c@t))))))))) (set! to28c7@todef@parse-library todef@parse-library) (set! todf1@parse-import-spec* (letrec* ((to2191@idsyn? (lambda (to239a@x) (symbol? (toe75@syntax->datum to239a@x)))) (to2193@dup-error (lambda (to2398@name) (toe6f@syntax-violation 'import '"two imports with different bindings" to2398@name))) (to2195@merge-substs (lambda (to2386@s to2387@subst) (letrec* ((to238b@insert-to-subst (lambda (to238c@a to238d@subst) (let ((to2390@name (car to238c@a)) (to2391@label (cdr to238c@a))) (let ((to2394@t (assq to2390@name to238d@subst))) (if to2394@t ((lambda (to2396@x) (if (eq? (cdr to2396@x) to2391@label) to238d@subst (to2193@dup-error to2390@name))) to2394@t) (cons to238c@a to238d@subst))))))) (if (null? to2386@s) to2387@subst (to238b@insert-to-subst (car to2386@s) (to2195@merge-substs (cdr to2386@s) to2387@subst)))))) (to2197@exclude* (lambda (to2356@sym* to2357@subst) (letrec* ((to235b@exclude (lambda (to2374@sym to2375@subst) (if (null? to2375@subst) (toe6f@syntax-violation 'import '"cannot rename unbound identifier" to2374@sym) (if (eq? to2374@sym (caar to2375@subst)) (values (cdar to2375@subst) (cdr to2375@subst)) (let ((to2378@a (car to2375@subst))) (call-with-values (lambda () (to235b@exclude to2374@sym (cdr to2375@subst))) (lambda (to237e@to237b to237f@to237d) (let ((to2382@subst to237f@to237d) (to2383@old to237e@to237b)) (values to2383@old (cons to2378@a to2382@subst))))))))))) (if (null? to2356@sym*) (values '() to2357@subst) (call-with-values (lambda () (to235b@exclude (car to2356@sym*) to2357@subst)) (lambda (to2360@to235d to2361@to235f) (let ((to2364@subst to2361@to235f) (to2365@old to2360@to235d)) (call-with-values (lambda () (to2197@exclude* (cdr to2356@sym*) to2364@subst)) (lambda (to236c@to2369 to236d@to236b) (let ((to2370@subst to236d@to236b) (to2371@old* to236c@to2369)) (values (cons to2365@old to2371@old*) to2370@subst))))))))))) (to2199@find* (lambda (to234e@sym* to234f@subst) (map (lambda (to2352@x) (let ((to2354@t (assq to2352@x to234f@subst))) (if to2354@t (cdr to2354@t) (toe6f@syntax-violation 'import '"cannot find identifier" to2352@x)))) to234e@sym*))) (to219b@rem* (lambda (to2346@sym* to2347@subst) (let to234c@f ((to234a@subst to2347@subst)) (if (null? to234a@subst) '() (if (memq (caar to234a@subst) to2346@sym*) (to234c@f (cdr to234a@subst)) (cons (car to234a@subst) (to234c@f (cdr to234a@subst)))))))) (to219d@remove-dups (lambda (to2344@ls) (if (null? to2344@ls) '() (if (memq (car to2344@ls) (cdr to2344@ls)) (to219d@remove-dups (cdr to2344@ls)) (cons (car to2344@ls) (to219d@remove-dups (cdr to2344@ls))))))) (to219f@parse-library-name (lambda (to225c@spec) (letrec* ((to225f@subversion? (lambda (to2340@x) (let ((to2342@x (toe75@syntax->datum to2340@x))) (and (integer? to2342@x) (exact? to2342@x) (>= to2342@x '0))))) (to2261@subversion-pred (lambda (to22e0@x*) (let ((to22e2@t to22e0@x*)) (let ((to22e4@ls/false (tod8f@syntax-dispatch to22e2@t 'any))) (if (and to22e4@ls/false (apply (lambda (to22e6@n) (to225f@subversion? to22e6@n)) to22e4@ls/false)) (apply (lambda (to22e8@n) (lambda (to22ea@x) (= to22ea@x (toe75@syntax->datum to22e8@n)))) to22e4@ls/false) (let ((to22ec@t to22e2@t)) (let ((to22ee@ls/false (tod8f@syntax-dispatch to22ec@t '(any . each-any)))) (if (and to22ee@ls/false (apply (lambda (to22f0@p? to22f1@sub*) (eq? (toe75@syntax->datum to22f0@p?) 'and)) to22ee@ls/false)) (apply (lambda (to22f4@p? to22f5@sub*) (let ((to22f8@p* (map to2261@subversion-pred to22f5@sub*))) (lambda (to22fa@x) (for-all (lambda (to22fc@p) (to22fc@p to22fa@x)) to22f8@p*)))) to22ee@ls/false) (let ((to22fe@t to22ec@t)) (let ((to2300@ls/false (tod8f@syntax-dispatch to22fe@t '(any . each-any)))) (if (and to2300@ls/false (apply (lambda (to2302@p? to2303@sub*) (eq? (toe75@syntax->datum to2302@p?) 'or)) to2300@ls/false)) (apply (lambda (to2306@p? to2307@sub*) (let ((to230a@p* (map to2261@subversion-pred to2307@sub*))) (lambda (to230c@x) (exists (lambda (to230e@p) (to230e@p to230c@x)) to230a@p*)))) to2300@ls/false) (let ((to2310@t to22fe@t)) (let ((to2312@ls/false (tod8f@syntax-dispatch to2310@t '(any any)))) (if (and to2312@ls/false (apply (lambda (to2314@p? to2315@sub) (eq? (toe75@syntax->datum to2314@p?) 'not)) to2312@ls/false)) (apply (lambda (to2318@p? to2319@sub) (let ((to231c@p (to2261@subversion-pred to2319@sub))) (lambda (to231e@x) (not (to231c@p to231e@x))))) to2312@ls/false) (let ((to2320@t to2310@t)) (let ((to2322@ls/false (tod8f@syntax-dispatch to2320@t '(any any)))) (if (and to2322@ls/false (apply (lambda (to2324@p? to2325@n) (and (eq? (toe75@syntax->datum to2324@p?) '<=) (to225f@subversion? to2325@n))) to2322@ls/false)) (apply (lambda (to2328@p? to2329@n) (lambda (to232c@x) (<= to232c@x (toe75@syntax->datum to2329@n)))) to2322@ls/false) (let ((to232e@t to2320@t)) (let ((to2330@ls/false (tod8f@syntax-dispatch to232e@t '(any any)))) (if (and to2330@ls/false (apply (lambda (to2332@p? to2333@n) (and (eq? (toe75@syntax->datum to2332@p?) '>=) (to225f@subversion? to2333@n))) to2330@ls/false)) (apply (lambda (to2336@p? to2337@n) (lambda (to233a@x) (>= to233a@x (toe75@syntax->datum to2337@n)))) to2330@ls/false) (let ((to233c@t to232e@t)) (let ((to233e@ls/false (tod8f@syntax-dispatch to233c@t '_))) (if to233e@ls/false (apply (lambda () (toe6f@syntax-violation 'import '"invalid sub-version spec" to225c@spec to22e0@x*)) to233e@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to233c@t)))))))))))))))))))))))) (to2263@version-pred (lambda (to2290@x*) (let ((to2292@t to2290@x*)) (let ((to2294@ls/false (tod8f@syntax-dispatch to2292@t '()))) (if to2294@ls/false (apply (lambda () (lambda (to2296@x) '#t)) to2294@ls/false) (let ((to2298@t to2292@t)) (let ((to229a@ls/false (tod8f@syntax-dispatch to2298@t '(any . each-any)))) (if (and to229a@ls/false (apply (lambda (to229c@c to229d@ver*) (eq? (toe75@syntax->datum to229c@c) 'and)) to229a@ls/false)) (apply (lambda (to22a0@c to22a1@ver*) (let ((to22a4@p* (map to2263@version-pred to22a1@ver*))) (lambda (to22a6@x) (for-all (lambda (to22a8@p) (to22a8@p to22a6@x)) to22a4@p*)))) to229a@ls/false) (let ((to22aa@t to2298@t)) (let ((to22ac@ls/false (tod8f@syntax-dispatch to22aa@t '(any . each-any)))) (if (and to22ac@ls/false (apply (lambda (to22ae@c to22af@ver*) (eq? (toe75@syntax->datum to22ae@c) 'or)) to22ac@ls/false)) (apply (lambda (to22b2@c to22b3@ver*) (let ((to22b6@p* (map to2263@version-pred to22b3@ver*))) (lambda (to22b8@x) (exists (lambda (to22ba@p) (to22ba@p to22b8@x)) to22b6@p*)))) to22ac@ls/false) (let ((to22bc@t to22aa@t)) (let ((to22be@ls/false (tod8f@syntax-dispatch to22bc@t '(any any)))) (if (and to22be@ls/false (apply (lambda (to22c0@c to22c1@ver) (eq? (toe75@syntax->datum to22c0@c) 'not)) to22be@ls/false)) (apply (lambda (to22c4@c to22c5@ver) (let ((to22c8@p (to2263@version-pred to22c5@ver))) (lambda (to22ca@x) (not (to22c8@p to22ca@x))))) to22be@ls/false) (let ((to22cc@t to22bc@t)) (let ((to22ce@ls/false (tod8f@syntax-dispatch to22cc@t 'each-any))) (if to22ce@ls/false (apply (lambda (to22d0@sub*) (let ((to22d2@p* (map to2261@subversion-pred to22d0@sub*))) (lambda (to22d4@x) (let to22da@f ((to22d6@p* to22d2@p*) (to22d7@x to22d4@x)) (if (null? to22d6@p*) '#t (if (null? to22d7@x) '#f (and ((car to22d6@p*) (car to22d7@x)) (to22da@f (cdr to22d6@p*) (cdr to22d7@x))))))))) to22ce@ls/false) (let ((to22dc@t to22cc@t)) (let ((to22de@ls/false (tod8f@syntax-dispatch to22dc@t '_))) (if to22de@ls/false (apply (lambda () (toe6f@syntax-violation 'import '"invalid version spec" to225c@spec to2290@x*)) to22de@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to22dc@t)))))))))))))))))))))) (let to2266@f ((to2264@x to225c@spec)) (let ((to2268@t to2264@x)) (let ((to226a@ls/false (tod8f@syntax-dispatch to2268@t '(each-any)))) (if to226a@ls/false (apply (lambda (to226c@version-spec*) (values '() (to2263@version-pred to226c@version-spec*))) to226a@ls/false) (let ((to226e@t to2268@t)) (let ((to2270@ls/false (tod8f@syntax-dispatch to226e@t '(any . any)))) (if (and to2270@ls/false (apply (lambda (to2272@x to2273@x*) (to2191@idsyn? to2272@x)) to2270@ls/false)) (apply (lambda (to2276@x to2277@x*) (call-with-values (lambda () (to2266@f to2277@x*)) (lambda (to227e@to227b to227f@to227d) (let ((to2282@pred to227f@to227d) (to2283@name to227e@to227b)) (values (cons (toe75@syntax->datum to2276@x) to2283@name) to2282@pred))))) to2270@ls/false) (let ((to2286@t to226e@t)) (let ((to2288@ls/false (tod8f@syntax-dispatch to2286@t '()))) (if to2288@ls/false (apply (lambda () (values '() (lambda (to228a@x) '#t))) to2288@ls/false) (let ((to228c@t to2286@t)) (let ((to228e@ls/false (tod8f@syntax-dispatch to228c@t '_))) (if to228e@ls/false (apply (lambda () (toe6f@syntax-violation '#f '"invalid import spec" to225c@spec)) to228e@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to228c@t))))))))))))))))) (to21a1@import-library (lambda (to224c@spec*) (call-with-values (lambda () (to219f@parse-library-name to224c@spec*)) (lambda (to2252@to224f to2253@to2251) (let ((to2256@pred to2253@to2251) (to2257@name to2252@to224f)) (begin (if (null? to2257@name) (toe6f@syntax-violation 'import '"empty library name" to224c@spec*) (void)) (let ((to225a@lib (to99d@to7e4@find-library-by-name to2257@name))) (begin (if (not to225a@lib) (toe6f@syntax-violation 'import '"cannot find library with required name" to2257@name) (void)) (if (not (to2256@pred (to977@to798@library-version to225a@lib))) (toe6f@syntax-violation 'import '"library does not satisfy version specification" to224c@spec* to225a@lib) (void)) ((todfb@imp-collector) to225a@lib) (to97f@to7a8@library-subst to225a@lib))))))))) (to21a3@get-import (lambda (to21be@spec) (let ((to21c0@t to21be@spec)) (let ((to21c2@ls/false (tod8f@syntax-dispatch to21c0@t '(any . each-any)))) (if (and to21c2@ls/false (apply (lambda (to21c4@x to21c5@x*) (not (memq (toe75@syntax->datum to21c4@x) '(for rename except only prefix library)))) to21c2@ls/false)) (apply (lambda (to21c8@x to21c9@x*) (to21a1@import-library (cons to21c8@x to21c9@x*))) to21c2@ls/false) (let ((to21cc@t to21c0@t)) (let ((to21ce@ls/false (tod8f@syntax-dispatch to21cc@t '(any any . #(each (any any)))))) (if (and to21ce@ls/false (apply (lambda (to21d0@rename to21d1@isp to21d2@old* to21d3@new*) (and (eq? (toe75@syntax->datum to21d0@rename) 'rename) (for-all to2191@idsyn? to21d2@old*) (for-all to2191@idsyn? to21d3@new*))) to21ce@ls/false)) (apply (lambda (to21d8@rename to21d9@isp to21da@old* to21db@new*) (let ((to21e0@subst (to21a3@get-import to21d9@isp)) (to21e1@old* (map toe75@syntax->datum to21da@old*)) (to21e2@new* (map toe75@syntax->datum to21db@new*))) (let ((to21e6@old-label* (to2199@find* to21e1@old* to21e0@subst))) (let ((to21e8@subst (to219b@rem* to21e1@old* to21e0@subst))) (to2195@merge-substs (map cons to21e2@new* to21e6@old-label*) to21e8@subst))))) to21ce@ls/false) (let ((to21ea@t to21cc@t)) (let ((to21ec@ls/false (tod8f@syntax-dispatch to21ea@t '(any any . each-any)))) (if (and to21ec@ls/false (apply (lambda (to21ee@except to21ef@isp to21f0@sym*) (and (eq? (toe75@syntax->datum to21ee@except) 'except) (for-all to2191@idsyn? to21f0@sym*))) to21ec@ls/false)) (apply (lambda (to21f4@except to21f5@isp to21f6@sym*) (let ((to21fa@subst (to21a3@get-import to21f5@isp))) (to219b@rem* (map toe75@syntax->datum to21f6@sym*) to21fa@subst))) to21ec@ls/false) (let ((to21fc@t to21ea@t)) (let ((to21fe@ls/false (tod8f@syntax-dispatch to21fc@t '(any any . each-any)))) (if (and to21fe@ls/false (apply (lambda (to2200@only to2201@isp to2202@sym*) (and (eq? (toe75@syntax->datum to2200@only) 'only) (for-all to2191@idsyn? to2202@sym*))) to21fe@ls/false)) (apply (lambda (to2206@only to2207@isp to2208@sym*) (let ((to220c@subst (to21a3@get-import to2207@isp)) (to220d@sym* (map toe75@syntax->datum to2208@sym*))) (let ((to2210@sym* (to219d@remove-dups to220d@sym*))) (let ((to2212@lab* (to2199@find* to2210@sym* to220c@subst))) (map cons to2210@sym* to2212@lab*))))) to21fe@ls/false) (let ((to2214@t to21fc@t)) (let ((to2216@ls/false (tod8f@syntax-dispatch to2214@t '(any any any)))) (if (and to2216@ls/false (apply (lambda (to2218@prefix to2219@isp to221a@p) (and (eq? (toe75@syntax->datum to2218@prefix) 'prefix) (to2191@idsyn? to221a@p))) to2216@ls/false)) (apply (lambda (to221e@prefix to221f@isp to2220@p) (let ((to2224@subst (to21a3@get-import to221f@isp)) (to2225@prefix (symbol->string (toe75@syntax->datum to2220@p)))) (map (lambda (to2228@x) (cons (string->symbol (string-append to2225@prefix (symbol->string (car to2228@x)))) (cdr to2228@x))) to2224@subst))) to2216@ls/false) (let ((to222a@t to2214@t)) (let ((to222c@ls/false (tod8f@syntax-dispatch to222a@t '(any each-any)))) (if (and to222c@ls/false (apply (lambda (to222e@library to222f@spec*) (eq? (toe75@syntax->datum to222e@library) 'library)) to222c@ls/false)) (apply (lambda (to2232@library to2233@spec*) (to21a1@import-library to2233@spec*)) to222c@ls/false) (let ((to2236@t to222a@t)) (let ((to2238@ls/false (tod8f@syntax-dispatch to2236@t '(any any . any)))) (if (and to2238@ls/false (apply (lambda (to223a@for to223b@isp to223c@rest) (eq? (toe75@syntax->datum to223a@for) 'for)) to2238@ls/false)) (apply (lambda (to2240@for to2241@isp to2242@rest) (to21a3@get-import to2241@isp)) to2238@ls/false) (let ((to2246@t to2236@t)) (let ((to2248@ls/false (tod8f@syntax-dispatch to2246@t 'any))) (if to2248@ls/false (apply (lambda (to224a@spec) (toe6f@syntax-violation 'import '"invalid import spec" to224a@spec)) to2248@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to2246@t))))))))))))))))))))))))))) (to21a5@add-imports! (lambda (to21ae@imp to21af@h) (let ((to21b2@subst (to21a3@get-import to21ae@imp))) (for-each (lambda (to21b4@x) (let ((to21b6@name (car to21b4@x)) (to21b7@label (cdr to21b4@x))) (let ((to21ba@t (hashtable-ref to21af@h to21b6@name '#f))) (if to21ba@t ((lambda (to21bc@l) (if (not (eq? to21bc@l to21b7@label)) (to2193@dup-error to21b6@name) (void))) to21ba@t) (hashtable-set! to21af@h to21b6@name to21b7@label))))) to21b2@subst))))) (lambda (to21a6@imp*) (let to21ac@f ((to21a8@imp* to21a6@imp*) (to21a9@h (make-eq-hashtable))) (if (null? to21a8@imp*) (hashtable-entries to21a9@h) (begin (to21a5@add-imports! (car to21a8@imp*) to21a9@h) (to21ac@f (cdr to21a8@imp*) to21a9@h))))))) (set! to28c8@todf1@parse-import-spec* todf1@parse-import-spec*) (set! todf3@make-top-rib (lambda (to239c@names to239d@labels) (let ((to23a0@rib (tob3c@make-empty-rib))) (begin (vector-for-each (lambda (to23a2@name to23a3@label) (begin (if (not (symbol? to23a2@name)) (error 'make-top-rib '"BUG: not a symbol" to23a2@name) (void)) (tob40@extend-rib/nc! to23a0@rib (make-simple-struct 'stx '5 (list to23a2@name tob0c@top-mark* '() '())) to23a3@label))) to239c@names to239d@labels) to23a0@rib)))) (set! to28c9@todf3@make-top-rib todf3@make-top-rib) (set! todf5@make-collector (lambda () (let ((to23a6@ls '())) (lambda to23aa (let ((to23ab (length to23aa))) (if (= to23ab '0) (apply (lambda () to23a6@ls) to23aa) (if (= to23ab '1) (apply (lambda (to23a8@x) (set! to23a6@ls (tob05@set-cons to23a8@x to23a6@ls))) to23aa) (error 'apply '"invalid arg count")))))))) (set! to28ca@todf5@make-collector todf5@make-collector) (set! todf7@inv-collector (to6d8@to5b6@make-parameter (lambda to23ac@args (assertion-violation 'inv-collector '"BUG: not initialized")) (lambda (to23ae@x) (begin (if (not (procedure? to23ae@x)) (assertion-violation 'inv-collector '"BUG: not a procedure" to23ae@x) (void)) to23ae@x)))) (set! to28cb@todf7@inv-collector todf7@inv-collector) (set! todf9@vis-collector (to6d8@to5b6@make-parameter (lambda to23b0@args (assertion-violation 'vis-collector '"BUG: not initialized")) (lambda (to23b2@x) (begin (if (not (procedure? to23b2@x)) (assertion-violation 'vis-collector '"BUG: not a procedure" to23b2@x) (void)) to23b2@x)))) (set! to28cc@todf9@vis-collector todf9@vis-collector) (set! todfb@imp-collector (to6d8@to5b6@make-parameter (lambda to23b4@args (assertion-violation 'imp-collector '"BUG: not initialized")) (lambda (to23b6@x) (begin (if (not (procedure? to23b6@x)) (assertion-violation 'imp-collector '"BUG: not a procedure" to23b6@x) (void)) to23b6@x)))) (set! to28cd@todfb@imp-collector todfb@imp-collector) (set! todfd@chi-library-internal (lambda (to23b8@e* to23b9@rib to23ba@top?) (call-with-values (lambda () (tode7@chi-body* to23b8@e* '() '() '() '() '() '() '() to23b9@rib to23ba@top?)) (lambda (to23ce@to23bf to23cf@to23c1 to23d0@to23c3 to23d1@to23c5 to23d2@to23c7 to23d3@to23c9 to23d4@to23cb to23d5@to23cd) (let ((to23de@exp* to23d5@to23cd) (to23df@_kwd* to23d4@to23cb) (to23e0@mod** to23d3@to23c9) (to23e1@rhs* to23d2@to23c7) (to23e2@lex* to23d1@to23c5) (to23e3@mr to23d0@to23c3) (to23e4@r to23cf@to23c1) (to23e5@e* to23ce@to23bf)) (values (append (apply append (reverse to23e0@mod**)) to23e5@e*) to23e4@r to23e3@mr (reverse to23e2@lex*) (reverse to23e1@rhs*) to23de@exp*)))))) (set! to28ce@todfd@chi-library-internal todfd@chi-library-internal) (set! todff@chi-interaction-expr (lambda (to23ee@e to23ef@rib to23f0@r) (call-with-values (lambda () (tode7@chi-body* (list to23ee@e) to23f0@r to23f0@r '() '() '() '() '() to23ef@rib '#t)) (lambda (to2404@to23f5 to2405@to23f7 to2406@to23f9 to2407@to23fb to2408@to23fd to2409@to23ff to240a@to2401 to240b@to2403) (let ((to2414@_exp* to240b@to2403) (to2415@_kwd* to240a@to2401) (to2416@mod** to2409@to23ff) (to2417@rhs* to2408@to23fd) (to2418@lex* to2407@to23fb) (to2419@mr to2406@to23f9) (to241a@r to2405@to23f7) (to241b@e* to2404@to23f5)) (let ((to2424@e* (todbf@expand-interaction-rhs*/init* (reverse to2418@lex*) (reverse to2417@rhs*) (append (apply append (reverse to2416@mod**)) to241b@e*) to241a@r to2419@mr))) (let ((to2426@e (if (null? to2424@e*) (toaee@toa4f@build-void) (if (null? (cdr to2424@e*)) (car to2424@e*) (toaed@toa4d@build-sequence '#f to2424@e*))))) (values to2426@e to241a@r)))))))) (set! to28cf@todff@chi-interaction-expr todff@chi-interaction-expr) (set! toe01@library-body-expander (lambda (to2428@name to2429@main-exp* to242a@imp* to242b@b* to242c@top?) (letrec* ((to2433@itc (todf5@make-collector))) (let ((to243c@to2435 todfb@imp-collector) (to243d@to2437 toe7f@top-level-context) (to243e@to2439 to2433@itc) (to243f@to243b '#f)) (let ((to2444@swap (lambda () (begin (let ((to2446@t (to243c@to2435))) (begin (to243c@to2435 to243e@to2439) (set! to243e@to2439 to2446@t))) (let ((to2448@t (to243d@to2437))) (begin (to243d@to2437 to243f@to243b) (set! to243f@to243b to2448@t))))))) (dynamic-wind to2444@swap (lambda () (call-with-values (lambda () (todf1@parse-import-spec* to242a@imp*)) (lambda (to244e@to244b to244f@to244d) (let ((to2452@subst-labels to244f@to244d) (to2453@subst-names to244e@to244b)) (let ((to2456@rib (todf3@make-top-rib to2453@subst-names to2452@subst-labels))) (letrec* ((to2459@wrap (lambda (to24d4@x) (make-simple-struct 'stx '5 (list to24d4@x tob0c@top-mark* (list to2456@rib) '()))))) (let ((to245a@b* (map to2459@wrap to242b@b*)) (to245b@main-exp* (map to2459@wrap to2429@main-exp*)) (to245c@rtc (todf5@make-collector)) (to245d@vtc (todf5@make-collector))) (let ((to246a@to2463 todf7@inv-collector) (to246b@to2465 todf9@vis-collector) (to246c@to2467 to245c@rtc) (to246d@to2469 to245d@vtc)) (let ((to2472@swap (lambda () (begin (let ((to2474@t (to246a@to2463))) (begin (to246a@to2463 to246c@to2467) (set! to246c@to2467 to2474@t))) (let ((to2476@t (to246b@to2465))) (begin (to246b@to2465 to246d@to2469) (set! to246d@to2469 to2476@t))))))) (dynamic-wind to2472@swap (lambda () (call-with-values (lambda () (todfd@chi-library-internal to245a@b* to2456@rib to242c@top?)) (lambda (to2484@to2479 to2485@to247b to2486@to247d to2487@to247f to2488@to2481 to2489@to2483) (let ((to2490@internal-exp* to2489@to2483) (to2491@rhs* to2488@to2481) (to2492@lex* to2487@to247f) (to2493@mr to2486@to247d) (to2494@r to2485@to247b) (to2495@init* to2484@to2479)) (call-with-values (lambda () (todeb@parse-exports (append to245b@main-exp* to2490@internal-exp*))) (lambda (to24a0@to249d to24a1@to249f) (let ((to24a4@exp-id* to24a1@to249f) (to24a5@exp-name* to24a0@to249d)) (begin (tob44@seal-rib! to2456@rib) (let ((to24a8@init* (todad@chi-expr* to2495@init* to2494@r to2493@mr))) (let ((to24aa@rhs* (todc1@chi-rhs* to2491@rhs* to2494@r to2493@mr))) (begin (tob46@unseal-rib! to2456@rib) (let ((to24ac@loc* (map tob12@gen-global to2492@lex*)) (to24ad@export-subst (toe59@make-export-subst to24a5@exp-name* to24a4@exp-id*))) (letrec* ((to24b1@errstr '"attempt to export mutated variable")) (call-with-values (lambda () (toe5b@make-export-env/macros to2492@lex* to24ac@loc* to2494@r)) (lambda (to24b8@to24b3 to24b9@to24b5 to24ba@to24b7) (let ((to24be@macro* to24ba@to24b7) (to24bf@global* to24b9@to24b5) (to24c0@export-env to24b8@to24b3)) (begin (for-each (lambda (to24c4@s) (let ((to24c6@name (car to24c4@s)) (to24c7@label (cdr to24c4@s))) (let ((to24ca@p (assq to24c7@label to24c0@export-env))) (if to24ca@p (let ((to24cc@b (cdr to24ca@p))) (let ((to24ce@type (car to24cc@b))) (if (eq? to24ce@type 'mutable) (toe6f@syntax-violation 'export to24b1@errstr to24c6@name) (void)))) (void))))) to24ad@export-subst) (let ((to24d0@invoke-body (toaf3@toa59@build-library-letrec* '#f to2428@name to2492@lex* to24ac@loc* to24aa@rhs* (if (null? to24a8@init*) (toaee@toa4f@build-void) (toaed@toa4d@build-sequence '#f to24a8@init*)))) (to24d1@invoke-definitions (map toaea@to9ac@build-global-define (map cdr to24bf@global*)))) (values (to2433@itc) (to245c@rtc) (to245d@vtc) (toaed@toa4d@build-sequence '#f (append to24d1@invoke-definitions (list to24d0@invoke-body))) to24be@macro* to24ad@export-subst to24c0@export-env))))))))))))))))))) to2472@swap)))))))))) to2444@swap)))))) (set! to28d0@toe01@library-body-expander toe01@library-body-expander) (set! toe03@core-library-expander (lambda (to24d6@e to24d7@verify-name) (call-with-values (lambda () (todef@parse-library to24d6@e)) (lambda (to24e2@to24db to24e3@to24dd to24e4@to24df to24e5@to24e1) (let ((to24ea@b* to24e5@to24e1) (to24eb@imp* to24e4@to24df) (to24ec@exp* to24e3@to24dd) (to24ed@name* to24e2@to24db)) (call-with-values (lambda () (toded@parse-library-name to24ed@name*)) (lambda (to24f6@to24f3 to24f7@to24f5) (let ((to24fa@ver to24f7@to24f5) (to24fb@name to24f6@to24f3)) (begin (to24d7@verify-name to24fb@name) (call-with-values (lambda () (toe01@library-body-expander to24fb@name to24ec@exp* to24eb@imp* to24ea@b* '#f)) (lambda (to250c@to24ff to250d@to2501 to250e@to2503 to250f@to2505 to2510@to2507 to2511@to2509 to2512@to250b) (let ((to251a@export-env to2512@to250b) (to251b@export-subst to2511@to2509) (to251c@visit-code to2510@to2507) (to251d@invoke-code to250f@to2505) (to251e@visit-req* to250e@to2503) (to251f@invoke-req* to250d@to2501) (to2520@imp* to250c@to24ff)) (values to24fb@name to24fa@ver to2520@imp* to251f@invoke-req* to251e@visit-req* to251d@invoke-code to251c@visit-code to251b@export-subst to251a@export-env))))))))))))) (set! to28d1@toe03@core-library-expander toe03@core-library-expander) (set! toe05@parse-top-level-program (lambda (to2528@e*) (let ((to252a@t to2528@e*)) (let ((to252c@ls/false (tod8f@syntax-dispatch to252a@t '((any . each-any) . each-any)))) (if (and to252c@ls/false (apply (lambda (to252e@import to252f@imp* to2530@b*) (eq? (toe75@syntax->datum to252e@import) 'import)) to252c@ls/false)) (apply (lambda (to2534@import to2535@imp* to2536@b*) (values to2535@imp* to2536@b*)) to252c@ls/false) (let ((to253a@t to252a@t)) (let ((to253c@ls/false (tod8f@syntax-dispatch to253a@t '((any . any) . any)))) (if (and to253c@ls/false (apply (lambda (to253e@import to253f@x to2540@y) (eq? (toe75@syntax->datum to253e@import) 'import)) to253c@ls/false)) (apply (lambda (to2544@import to2545@x to2546@y) (toe6f@syntax-violation 'expander '"invalid syntax of top-level program" (tob82@syntax-car to2528@e*))) to253c@ls/false) (let ((to254a@t to253a@t)) (let ((to254c@ls/false (tod8f@syntax-dispatch to254a@t '_))) (if to254c@ls/false (apply (lambda () (assertion-violation 'expander '"top-level program is missing an (import ---) clause")) to254c@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to254a@t)))))))))))) (set! to28d2@toe05@parse-top-level-program toe05@parse-top-level-program) (set! toe07@top-level-expander (lambda (to254e@e*) (call-with-values (lambda () (toe05@parse-top-level-program to254e@e*)) (lambda (to2554@to2551 to2555@to2553) (let ((to2558@b* to2555@to2553) (to2559@imp* to2554@to2551)) (call-with-values (lambda () (toe01@library-body-expander '() '() to2559@imp* to2558@b* '#t)) (lambda (to256a@to255d to256b@to255f to256c@to2561 to256d@to2563 to256e@to2565 to256f@to2567 to2570@to2569) (let ((to2578@export-env to2570@to2569) (to2579@export-subst to256f@to2567) (to257a@visit-code to256e@to2565) (to257b@invoke-code to256d@to2563) (to257c@visit-req* to256c@to2561) (to257d@invoke-req* to256b@to255f) (to257e@imp* to256a@to255d)) (values to257d@invoke-req* to257b@invoke-code))))))))) (set! to28d3@toe07@top-level-expander toe07@top-level-expander) (set! toe09@rp (to6d5@to5b0@make-record-printer 'env (lambda (to2586@x to2587@p to2588@wr) (display '"#<environment>" to2587@p)))) (set! to28d4@toe09@rp toe09@rp) (set! toe13@env? (lambda (to258c@x) (and (simple-struct? to258c@x) (eq? (simple-struct-name to258c@x) 'env)))) (set! to28d5@toe13@env? toe13@env?) (set! toe15@env-names (lambda (to258e@x) (simple-struct-ref to258e@x '0))) (set! to28d6@toe15@env-names toe15@env-names) (set! toe17@set-env-names! (lambda (to2590@x to2591@val) (simple-struct-set! to2590@x '0 to2591@val))) (set! to28d7@toe17@set-env-names! toe17@set-env-names!) (set! toe19@env-labels (lambda (to2594@x) (simple-struct-ref to2594@x '1))) (set! to28d8@toe19@env-labels toe19@env-labels) (set! toe1b@set-env-labels! (lambda (to2596@x to2597@val) (simple-struct-set! to2596@x '1 to2597@val))) (set! to28d9@toe1b@set-env-labels! toe1b@set-env-labels!) (set! toe1d@env-itc (lambda (to259a@x) (simple-struct-ref to259a@x '2))) (set! to28da@toe1d@env-itc toe1d@env-itc) (set! toe1f@set-env-itc! (lambda (to259c@x to259d@val) (simple-struct-set! to259c@x '2 to259d@val))) (set! to28db@toe1f@set-env-itc! toe1f@set-env-itc!) (set! toe21@dummy '3) (set! to28dc@toe21@dummy toe21@dummy) (set! toe23@rp (to6d5@to5b0@make-record-printer 'interaction-env (lambda (to25a0@x to25a1@p to25a2@wr) (display '"#<environment>" to25a1@p)))) (set! to28dd@toe23@rp toe23@rp) (set! toe2d@interaction-env? (lambda (to25a6@x) (and (simple-struct? to25a6@x) (eq? (simple-struct-name to25a6@x) 'interaction-env)))) (set! to28de@toe2d@interaction-env? toe2d@interaction-env?) (set! toe2f@interaction-env-rib (lambda (to25a8@x) (simple-struct-ref to25a8@x '0))) (set! to28df@toe2f@interaction-env-rib toe2f@interaction-env-rib) (set! toe31@set-interaction-env-rib! (lambda (to25aa@x to25ab@val) (simple-struct-set! to25aa@x '0 to25ab@val))) (set! to28e0@toe31@set-interaction-env-rib! toe31@set-interaction-env-rib!) (set! toe33@interaction-env-r (lambda (to25ae@x) (simple-struct-ref to25ae@x '1))) (set! to28e1@toe33@interaction-env-r toe33@interaction-env-r) (set! toe35@set-interaction-env-r! (lambda (to25b0@x to25b1@val) (simple-struct-set! to25b0@x '1 to25b1@val))) (set! to28e2@toe35@set-interaction-env-r! toe35@set-interaction-env-r!) (set! toe37@interaction-env-locs (lambda (to25b4@x) (simple-struct-ref to25b4@x '2))) (set! to28e3@toe37@interaction-env-locs toe37@interaction-env-locs) (set! toe39@set-interaction-env-locs! (lambda (to25b6@x to25b7@val) (simple-struct-set! to25b6@x '2 to25b7@val))) (set! to28e4@toe39@set-interaction-env-locs! toe39@set-interaction-env-locs!) (set! toe3b@dummy '3) (set! to28e5@toe3b@dummy toe3b@dummy) (set! toe3d@interaction-environment-symbols (lambda () (toe45@environment-symbols (toe7d@interaction-environment)))) (set! to28e6@toe3d@interaction-environment-symbols toe3d@interaction-environment-symbols) (set! toe3f@environment-bindings (lambda (to25ba@e) (vector->list (vector-map (lambda (to25bc@name to25bd@label) (toe41@parse-binding (cons to25bc@name (to9a3@to7f0@imported-label->binding to25bd@label)))) (toe15@env-names to25ba@e) (toe19@env-labels to25ba@e))))) (set! to28e7@toe3f@environment-bindings toe3f@environment-bindings) (set! toe41@parse-binding (lambda (to25c0@b) (cons (car to25c0@b) (let ((to25c2@t (cadr to25c0@b))) (if (memv to25c2@t '(core-prim global)) 'procedure (if (memv to25c2@t '(core-macro macro global-macro)) 'syntax (if (memv to25c2@t '($core-rtd)) 'record (if (eq? (car to25c0@b) (cadr to25c0@b)) 'syntax 'unknown)))))))) (set! to28e8@toe41@parse-binding toe41@parse-binding) (set! toe43@environment? (lambda (to25c4@x) (or (toe13@env? to25c4@x) (toe2d@interaction-env? to25c4@x)))) (set! to28e9@toe43@environment? toe43@environment?) (set! toe45@environment-symbols (lambda (to25c6@x) (if (toe13@env? to25c6@x) (vector->list (toe15@env-names to25c6@x)) (if (toe2d@interaction-env? to25c6@x) (map values (tob26@rib-sym* (toe2f@interaction-env-rib to25c6@x))) (assertion-violation 'environment-symbols '"not an environment" to25c6@x))))) (set! to28ea@toe45@environment-symbols toe45@environment-symbols) (set! toe47@environment (lambda to25c8@imp* (let ((to25ca@itc (todf5@make-collector))) (let ((to25d0@to25cd todfb@imp-collector) (to25d1@to25cf to25ca@itc)) (let ((to25d4@swap (lambda () (let ((to25d6@t (to25d0@to25cd))) (begin (to25d0@to25cd to25d1@to25cf) (set! to25d1@to25cf to25d6@t)))))) (dynamic-wind to25d4@swap (lambda () (call-with-values (lambda () (todf1@parse-import-spec* to25c8@imp*)) (lambda (to25dc@to25d9 to25dd@to25db) (let ((to25e0@subst-labels to25dd@to25db) (to25e1@subst-names to25dc@to25d9)) (make-simple-struct 'env '4 (list to25e1@subst-names to25e0@subst-labels to25ca@itc)))))) to25d4@swap)))))) (set! to28eb@toe47@environment toe47@environment) (set! toe49@null-environment (lambda (to25e4@n) (begin (if (not (eqv? to25e4@n '5)) (assertion-violation 'null-environment '"not 5" to25e4@n) (void)) (toe47@environment '(psyntax null-environment-5))))) (set! to28ec@toe49@null-environment toe49@null-environment) (set! toe4b@scheme-report-environment (lambda (to25e6@n) (begin (if (not (eqv? to25e6@n '5)) (assertion-violation 'scheme-report-environment '"not 5" to25e6@n) (void)) (toe47@environment '(psyntax scheme-report-environment-5))))) (set! to28ed@toe4b@scheme-report-environment toe4b@scheme-report-environment) (set! toe4d@expand (lambda (to25e8@x to25e9@env) (if (toe13@env? to25e9@env) (let ((to25ec@rib (todf3@make-top-rib (toe15@env-names to25e9@env) (toe19@env-labels to25e9@env)))) (let ((to25ee@x (make-simple-struct 'stx '5 (list to25e8@x tob0c@top-mark* (list to25ec@rib) '()))) (to25ef@itc (toe1d@env-itc to25e9@env)) (to25f0@rtc (todf5@make-collector)) (to25f1@vtc (todf5@make-collector))) (let ((to25f6@x (let ((to2608@to25f9 toe7f@top-level-context) (to2609@to25fb todf7@inv-collector) (to260a@to25fd todf9@vis-collector) (to260b@to25ff todfb@imp-collector) (to260c@to2601 '#f) (to260d@to2603 to25f0@rtc) (to260e@to2605 to25f1@vtc) (to260f@to2607 to25ef@itc)) (let ((to2618@swap (lambda () (begin (let ((to261a@t (to2608@to25f9))) (begin (to2608@to25f9 to260c@to2601) (set! to260c@to2601 to261a@t))) (let ((to261c@t (to2609@to25fb))) (begin (to2609@to25fb to260d@to2603) (set! to260d@to2603 to261c@t))) (let ((to261e@t (to260a@to25fd))) (begin (to260a@to25fd to260e@to2605) (set! to260e@to2605 to261e@t))) (let ((to2620@t (to260b@to25ff))) (begin (to260b@to25ff to260f@to2607) (set! to260f@to2607 to2620@t))))))) (dynamic-wind to2618@swap (lambda () (todb1@chi-expr to25ee@x '() '())) to2618@swap))))) (begin (tob44@seal-rib! to25ec@rib) (values to25f6@x (to25f0@rtc)))))) (if (toe2d@interaction-env? to25e9@env) (let ((to2622@rib (toe2f@interaction-env-rib to25e9@env)) (to2623@r (toe33@interaction-env-r to25e9@env)) (to2624@rtc (todf5@make-collector))) (let ((to2628@x (make-simple-struct 'stx '5 (list to25e8@x tob0c@top-mark* (list to2622@rib) '())))) (call-with-values (lambda () (let ((to263e@to262f toe7f@top-level-context) (to263f@to2631 todf7@inv-collector) (to2640@to2633 todf9@vis-collector) (to2641@to2635 todfb@imp-collector) (to2642@to2637 to25e9@env) (to2643@to2639 to2624@rtc) (to2644@to263b (todf5@make-collector)) (to2645@to263d (todf5@make-collector))) (let ((to264e@swap (lambda () (begin (let ((to2650@t (to263e@to262f))) (begin (to263e@to262f to2642@to2637) (set! to2642@to2637 to2650@t))) (let ((to2652@t (to263f@to2631))) (begin (to263f@to2631 to2643@to2639) (set! to2643@to2639 to2652@t))) (let ((to2654@t (to2640@to2633))) (begin (to2640@to2633 to2644@to263b) (set! to2644@to263b to2654@t))) (let ((to2656@t (to2641@to2635))) (begin (to2641@to2635 to2645@to263d) (set! to2645@to263d to2656@t))))))) (dynamic-wind to264e@swap (lambda () (todff@chi-interaction-expr to2628@x to2622@rib to2623@r)) to264e@swap)))) (lambda (to2658@to262b to2659@to262d) (let ((to265c@r^ to2659@to262d) (to265d@e to2658@to262b)) (begin (toe35@set-interaction-env-r! to25e9@env to265c@r^) (values to265d@e (to2624@rtc)))))))) (assertion-violation 'expand '"not an environment" to25e9@env))))) (set! to28ee@toe4d@expand toe4d@expand) (set! toe4f@eval (lambda (to2660@x to2661@env) (begin (if (not (toe43@environment? to2661@env)) (error 'eval '"not an environment" to2661@env) (void)) (call-with-values (lambda () (toe4d@expand to2660@x to2661@env)) (lambda (to2668@to2665 to2669@to2667) (let ((to266c@invoke-req* to2669@to2667) (to266d@x to2668@to2665)) (begin (for-each to9a4@to7f2@invoke-library to266c@invoke-req*) (eval-core (to72e@to6e6@expanded->core to266d@x))))))))) (set! to28ef@toe4f@eval toe4f@eval) (set! toe51@library-expander (lambda to26de (let ((to26df (length to26de))) (if (= to26df '3) (apply (lambda (to2670@x to2671@filename to2672@verify-name) (letrec* ((to2677@build-visit-code (lambda (to26cc@macro*) (if (null? to26cc@macro*) (toaee@toa4f@build-void) (toaed@toa4d@build-sequence '#f (map (lambda (to26ce@x) (let ((to26d0@loc (car to26ce@x)) (to26d1@src (cddr to26ce@x))) (list 'set! to26d0@loc to26d1@src))) to26cc@macro*))))) (to2679@visit! (lambda (to26c4@macro*) (for-each (lambda (to26c6@x) (let ((to26c8@loc (car to26c6@x)) (to26c9@proc (cadr to26c6@x))) (set-symbol-value! to26c8@loc to26c9@proc))) to26c4@macro*)))) (call-with-values (lambda () (toe03@core-library-expander to2670@x to2672@verify-name)) (lambda (to268c@to267b to268d@to267d to268e@to267f to268f@to2681 to2690@to2683 to2691@to2685 to2692@to2687 to2693@to2689 to2694@to268b) (let ((to269e@export-env to2694@to268b) (to269f@export-subst to2693@to2689) (to26a0@macro* to2692@to2687) (to26a1@invoke-code to2691@to2685) (to26a2@vis* to2690@to2683) (to26a3@inv* to268f@to2681) (to26a4@imp* to268e@to267f) (to26a5@ver to268d@to267d) (to26a6@name to268c@to267b)) (let ((to26b0@id (gensym)) (to26b1@name to26a6@name) (to26b2@ver to26a5@ver) (to26b3@imp* (map to9a8@to7fa@library-spec to26a4@imp*)) (to26b4@vis* (map to9a8@to7fa@library-spec to26a2@vis*)) (to26b5@inv* (map to9a8@to7fa@library-spec to26a3@inv*)) (to26b6@visit-proc (lambda () (to2679@visit! to26a0@macro*))) (to26b7@invoke-proc (lambda () (eval-core (to72e@to6e6@expanded->core to26a1@invoke-code)))) (to26b8@visit-code (to2677@build-visit-code to26a0@macro*)) (to26b9@invoke-code to26a1@invoke-code)) (begin (to9a2@to7ee@install-library to26b0@id to26b1@name to26b2@ver to26b3@imp* to26b4@vis* to26b5@inv* to269f@export-subst to269e@export-env to26b6@visit-proc to26b7@invoke-proc to26b8@visit-code to26b9@invoke-code '#t to2671@filename) (values to26b0@id to26b1@name to26b2@ver to26b3@imp* to26b4@vis* to26b5@inv* to26b9@invoke-code to26b8@visit-code to269f@export-subst to269e@export-env)))))))) to26de) (if (= to26df '2) (apply (lambda (to26d4@x to26d5@filename) (toe51@library-expander to26d4@x to26d5@filename (lambda (to26d8@x) (values)))) to26de) (if (= to26df '1) (apply (lambda (to26da@x) (toe51@library-expander to26da@x '#f (lambda (to26dc@x) (values)))) to26de) (error 'apply '"invalid arg count"))))))) (set! to28f0@toe51@library-expander toe51@library-expander) (set! toe53@boot-library-expand (lambda (to26e0@x) (call-with-values (lambda () (toe51@library-expander to26e0@x)) (lambda (to26f6@to26e3 to26f7@to26e5 to26f8@to26e7 to26f9@to26e9 to26fa@to26eb to26fb@to26ed to26fc@to26ef to26fd@to26f1 to26fe@to26f3 to26ff@to26f5) (let ((to270a@export-env to26ff@to26f5) (to270b@export-subst to26fe@to26f3) (to270c@visit-code to26fd@to26f1) (to270d@invoke-code to26fc@to26ef) (to270e@inv* to26fb@to26ed) (to270f@vis* to26fa@to26eb) (to2710@imp* to26f9@to26e9) (to2711@ver to26f8@to26e7) (to2712@name to26f7@to26e5) (to2713@id to26f6@to26e3)) (values to2712@name to270d@invoke-code to270b@export-subst to270a@export-env)))))) (set! to28f1@toe53@boot-library-expand toe53@boot-library-expand) (set! toe55@rev-map-append (lambda (to271e@f to271f@ls to2720@ac) (if (null? to271f@ls) to2720@ac (toe55@rev-map-append to271e@f (cdr to271f@ls) (cons (to271e@f (car to271f@ls)) to2720@ac))))) (set! to28f2@toe55@rev-map-append toe55@rev-map-append) (set! toe57@build-exports (lambda (to2724@lex*+loc* to2725@init*) (toaed@toa4d@build-sequence '#f (cons (toaee@toa4f@build-void) (toe55@rev-map-append (lambda (to2728@x) (list 'set! (cdr to2728@x) (car to2728@x))) to2724@lex*+loc* to2725@init*))))) (set! to28f3@toe57@build-exports toe57@build-exports) (set! toe59@make-export-subst (lambda (to272a@name* to272b@id*) (map (lambda (to272e@name to272f@id) (let ((to2732@label (tob9e@id->label to272f@id))) (begin (if (not to2732@label) (toe6f@syntax-violation '#f '"cannot export unbound identifier" to272f@id) (void)) (cons to272e@name to2732@label)))) to272a@name* to272b@id*))) (set! to28f4@toe59@make-export-subst toe59@make-export-subst) (set! toe5b@make-export-env/macros (lambda (to2734@lex* to2735@loc* to2736@r) (letrec* ((to273b@lookup (lambda (to2758@x) (let to2760@f ((to275a@x to2758@x) (to275b@lex* to2734@lex*) (to275c@loc* to2735@loc*)) (if (pair? to275b@lex*) (if (eq? to275a@x (car to275b@lex*)) (car to275c@loc*) (to2760@f to275a@x (cdr to275b@lex*) (cdr to275c@loc*))) (assertion-violation 'lookup-make-export '"BUG")))))) (let to2744@f ((to273c@r to2736@r) (to273d@env '()) (to273e@global* '()) (to273f@macro* '())) (if (null? to273c@r) (values to273d@env to273e@global* to273f@macro*) (let ((to2746@x (car to273c@r))) (let ((to2748@label (car to2746@x)) (to2749@b (cdr to2746@x))) (let ((to274c@t (toba4@binding-type to2749@b))) (if (memv to274c@t '(lexical)) (let ((to274e@v (toba6@binding-value to2749@b))) (let ((to2750@loc (to273b@lookup (tod19@lexical-var to274e@v))) (to2751@type (if (tod1b@lexical-mutable? to274e@v) 'mutable 'global))) (to2744@f (cdr to273c@r) (cons (cons* to2748@label to2751@type to2750@loc) to273d@env) (cons (cons (tod19@lexical-var to274e@v) to2750@loc) to273e@global*) to273f@macro*))) (if (memv to274c@t '(local-macro)) (let ((to2754@loc (gensym))) (to2744@f (cdr to273c@r) (cons (cons* to2748@label 'global-macro to2754@loc) to273d@env) to273e@global* (cons (cons to2754@loc (toba6@binding-value to2749@b)) to273f@macro*))) (if (memv to274c@t '(local-macro!)) (let ((to2756@loc (gensym))) (to2744@f (cdr to273c@r) (cons (cons* to2748@label 'global-macro! to2756@loc) to273d@env) to273e@global* (cons (cons to2756@loc (toba6@binding-value to2749@b)) to273f@macro*))) (if (memv to274c@t '($rtd $module)) (to2744@f (cdr to273c@r) (cons to2746@x to273d@env) to273e@global* to273f@macro*) (assertion-violation 'expander '"BUG: do not know how to export" (toba4@binding-type to2749@b) (toba6@binding-value to2749@b)))))))))))))) (set! to28f5@toe5b@make-export-env/macros toe5b@make-export-env/macros) (set! toe5d@generate-temporaries (lambda (to2762@ls) (let ((to2764@t to2762@ls)) (let ((to2766@ls/false (tod8f@syntax-dispatch to2764@t 'each-any))) (if to2766@ls/false (apply (lambda (to2768@ls) (map (lambda (to276a@x) (make-simple-struct 'stx '5 (list (let ((to276c@x (toe75@syntax->datum to276a@x))) (if (or (symbol? to276c@x) (string? to276c@x)) (gensym to276c@x) (gensym 't))) tob0c@top-mark* '() '()))) to2768@ls)) to2766@ls/false) (let ((to276e@t to2764@t)) (let ((to2770@ls/false (tod8f@syntax-dispatch to276e@t '_))) (if to2770@ls/false (apply (lambda () (assertion-violation 'generate-temporaries '"not a list")) to2770@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to276e@t))))))))) (set! to28f6@toe5d@generate-temporaries toe5d@generate-temporaries) (set! toe5f@free-identifier=? (lambda (to2772@x to2773@y) (if (tob88@id? to2772@x) (if (tob88@id? to2773@y) (tob8e@free-id=? to2772@x to2773@y) (assertion-violation 'free-identifier=? '"not an identifier" to2773@y)) (assertion-violation 'free-identifier=? '"not an identifier" to2772@x)))) (set! to28f7@toe5f@free-identifier=? toe5f@free-identifier=?) (set! toe61@bound-identifier=? (lambda (to2776@x to2777@y) (if (tob88@id? to2776@x) (if (tob88@id? to2777@y) (tob8c@bound-id=? to2776@x to2777@y) (assertion-violation 'bound-identifier=? '"not an identifier" to2777@y)) (assertion-violation 'bound-identifier=? '"not an identifier" to2776@x)))) (set! to28f8@toe61@bound-identifier=? toe61@bound-identifier=?) (set! toe63@make-source-condition (lambda (to277a@x) (letrec* ((to2784@to277f (make-record-type-descriptor '&source-information &condition-rtd 'to2782 '#f '#f '#((immutable file-name) (immutable line)))) (to2786@to2781 '#f) (to2788@to2780 (make-record-constructor-descriptor to2784@to277f &condition-rcd to2786@to2781)) (to278b@to277e (record-predicate to2784@to277f)) (to278d@make-source-condition (record-constructor to2788@to2780)) (to278f@to277c (record-accessor to2784@to277f '0)) (to2791@to277d (record-accessor to2784@to277f '1)) (to2793@source-condition? (condition-predicate to2784@to277f)) (to2795@source-filename (condition-accessor to2784@to277f to278f@to277c)) (to2797@source-character (condition-accessor to2784@to277f to2791@to277d))) (if (and (pair? to277a@x) (pair? (cdr to277a@x))) (to278d@make-source-condition (car to277a@x) (cadr to277a@x)) (condition))))) (set! to28f9@toe63@make-source-condition toe63@make-source-condition) (set! toe65@extract-position-condition (lambda (to2798@x) (toe63@make-source-condition (toe67@expression-position to2798@x)))) (set! to28fa@toe65@extract-position-condition toe65@extract-position-condition) (set! toe67@expression-position (lambda (to279a@x) (and (tob54@stx? to279a@x) (let ((to279c@x (tob56@stx-expr to279a@x))) (and (to6cc@to59e@annotation? to279c@x) (to6cd@to5a0@annotation-source to279c@x)))))) (set! to28fb@toe67@expression-position toe67@expression-position) (set! toe69@assertion-error (lambda (to279e@expr to279f@pos) (raise (condition (make-assertion-violation) (make-who-condition 'assert) (make-message-condition '"assertion failed") (make-irritants-condition (list to279e@expr)) (toe63@make-source-condition to279f@pos))))) (set! to28fc@toe69@assertion-error toe69@assertion-error) (set! toe6b@syntax-error (lambda (to27a2@x . to27a4@args) (begin (if (not (for-all string? to27a4@args)) (assertion-violation 'syntax-error '"invalid argument" to27a4@args) (void)) (raise (condition (make-message-condition (if (null? to27a4@args) '"invalid syntax" (apply string-append to27a4@args))) (make-syntax-violation (toe75@syntax->datum to27a2@x) '#f) (toe65@extract-position-condition to27a2@x)))))) (set! to28fd@toe6b@syntax-error toe6b@syntax-error) (set! toe6d@syntax-violation* (lambda (to27a6@who to27a7@msg to27a8@form to27a9@condition-object) (begin (if (not (string? to27a7@msg)) (assertion-violation 'syntax-violation '"message is not a string" to27a7@msg) (void)) (let ((to27ae@who (if (or (string? to27a6@who) (symbol? to27a6@who)) to27a6@who (if (not to27a6@who) (let ((to27b0@t to27a8@form)) (let ((to27b2@ls/false (tod8f@syntax-dispatch to27b0@t 'any))) (if (and to27b2@ls/false (apply (lambda (to27b4@id) (tob88@id? to27b4@id)) to27b2@ls/false)) (apply (lambda (to27b6@id) (toe75@syntax->datum to27b6@id)) to27b2@ls/false) (let ((to27b8@t to27b0@t)) (let ((to27ba@ls/false (tod8f@syntax-dispatch to27b8@t '(any . any)))) (if (and to27ba@ls/false (apply (lambda (to27bc@id to27bd@rest) (tob88@id? to27bc@id)) to27ba@ls/false)) (apply (lambda (to27c0@id to27c1@rest) (toe75@syntax->datum to27c0@id)) to27ba@ls/false) (let ((to27c4@t to27b8@t)) (let ((to27c6@ls/false (tod8f@syntax-dispatch to27c4@t '_))) (if to27c6@ls/false (apply (lambda () '#f) to27c6@ls/false) (toe6f@syntax-violation '#f '"invalid syntax" to27c4@t)))))))))) (assertion-violation 'syntax-violation '"invalid who argument" to27a6@who))))) (raise (condition (if to27ae@who (make-who-condition to27ae@who) (condition)) (make-message-condition to27a7@msg) to27a9@condition-object (toe65@extract-position-condition to27a8@form))))))) (set! to28fe@toe6d@syntax-violation* toe6d@syntax-violation*) (set! toe6f@syntax-violation (lambda to27d6 (let ((to27d7 (length to27d6))) (if (= to27d7 '3) (apply (lambda (to27c8@who to27c9@msg to27ca@form) (toe6f@syntax-violation to27c8@who to27c9@msg to27ca@form '#f)) to27d6) (if (= to27d7 '4) (apply (lambda (to27ce@who to27cf@msg to27d0@form to27d1@subform) (toe6d@syntax-violation* to27ce@who to27cf@msg to27d0@form (make-syntax-violation (toe75@syntax->datum to27d0@form) (toe75@syntax->datum to27d1@subform)))) to27d6) (error 'apply '"invalid arg count")))))) (set! to28ff@toe6f@syntax-violation toe6f@syntax-violation) (set! toe71@identifier? (lambda (to27d8@x) (tob88@id? to27d8@x))) (set! to2900@toe71@identifier? toe71@identifier?) (set! toe73@datum->syntax (lambda (to27da@id to27db@datum) (if (tob88@id? to27da@id) (tob68@datum->stx to27da@id to27db@datum) (assertion-violation 'datum->syntax '"not an identifier" to27da@id)))) (set! to2901@toe73@datum->syntax toe73@datum->syntax) (set! toe75@syntax->datum (lambda (to27de@x) (tob9c@stx->datum to27de@x))) (set! to2902@toe75@syntax->datum toe75@syntax->datum) (set! toe77@ungensym-all (lambda (to27e0@code) (if (pair? to27e0@code) (cons (toe77@ungensym-all (car to27e0@code)) (toe77@ungensym-all (cdr to27e0@code))) (if (symbol? to27e0@code) (ungensym to27e0@code) to27e0@code)))) (set! to2903@toe77@ungensym-all toe77@ungensym-all) (set! toe79@compile-r6rs-top-level (lambda (to27e2@x*) (call-with-values (lambda () (toe07@top-level-expander to27e2@x*)) (lambda (to27e8@to27e5 to27e9@to27e7) (let ((to27ec@invoke-code to27e9@to27e7) (to27ed@lib* to27e8@to27e5)) (lambda () (begin (for-each to9a4@to7f2@invoke-library to27ed@lib*) (let ((to27f0@expanded (to72e@to6e6@expanded->core to27ec@invoke-code))) (begin (if (symbol-value 'debug-expand) (format '#t '"psyntax expanded=~a\n" (toe77@ungensym-all to27f0@expanded)) (void)) (eval-core to27f0@expanded)))))))))) (set! to2904@toe79@compile-r6rs-top-level toe79@compile-r6rs-top-level) (set! toe7b@pre-compile-r6rs-top-level (lambda (to27f2@x*) (call-with-values (lambda () (toe07@top-level-expander to27f2@x*)) (lambda (to27f8@to27f5 to27f9@to27f7) (let ((to27fc@invoke-code to27f9@to27f7) (to27fd@lib* to27f8@to27f5)) (begin (for-each to9a4@to7f2@invoke-library to27fd@lib*) (to6d6@to5b2@compile-core (to72e@to6e6@expanded->core to27fc@invoke-code)))))))) (set! to2905@toe7b@pre-compile-r6rs-top-level toe7b@pre-compile-r6rs-top-level) (set! toe7d@interaction-environment (let ((to2800@the-env '#f)) (lambda () (or to2800@the-env (let ((to2802@lib (to99d@to7e4@find-library-by-name '(mosh interaction))) (to2803@rib (tob3c@make-empty-rib))) (begin (let ((to2806@subst (to97f@to7a8@library-subst to2802@lib))) (begin (tob28@set-rib-sym*! to2803@rib (map car to2806@subst)) (tob2c@set-rib-mark**! to2803@rib (map (lambda (to2808@x) tob0c@top-mark*) to2806@subst)) (tob30@set-rib-label*! to2803@rib (map cdr to2806@subst)))) (let ((to280a@env (make-simple-struct 'interaction-env '4 (list to2803@rib '() '())))) (begin (set! to2800@the-env to280a@env) to280a@env)))))))) (set! to2906@toe7d@interaction-environment toe7d@interaction-environment) (set! toe7f@top-level-context (to6d8@to5b6@make-parameter '#f)) (set! to2907@toe7f@top-level-context toe7f@top-level-context) (to99a@to7de@current-library-expander toe51@library-expander))
(begin (begin (to72b@to6e0@current-primitive-locations (lambda (to2e6d@x) (let ((to2e6f@t (assq to2e6d@x '((syntax-error . to28fd@toe6b@syntax-error) (syntax-dispatch . to289b@tod8f@syntax-dispatch) (load . to2a87@to292e@load) (interaction-environment . to2906@toe7d@interaction-environment) (library-path . to992@to7ce@library-path) (mosh-cache-dir . to6d9@to5b8@mosh-cache-dir) (make-parameter . to6d8@to5b6@make-parameter) (make-variable-transformer . to2858@tobba@make-variable-transformer) (identifier? . to2900@toe71@identifier?) (generate-temporaries . to28f6@toe5d@generate-temporaries) (free-identifier=? . to28f7@toe5f@free-identifier=?) (syntax->datum . to2902@toe75@syntax->datum) (datum->syntax . to2901@toe73@datum->syntax) (bound-identifier=? . to28f8@toe61@bound-identifier=?) (scheme-report-environment . to28ed@toe4b@scheme-report-environment) (null-environment . to28ec@toe49@null-environment) (command-line . to2a84@to2928@command-line) (eval . to28ef@toe4f@eval) (environment . to28eb@toe47@environment) (syntax-violation . to28ff@toe6f@syntax-violation) (assertion-error . to28fc@toe69@assertion-error))))) (if to2e6f@t (cdr to2e6f@t) '#f)))) (to9a2@to7ee@install-library 'to2e4a '(mosh interaction) '() '() '() '() '((regexp? . to2e0a) (alist->eq-hash-table . to2e06) (format . to2e03) (string-split . to2de9) (%start-process . to2de2) (%call-process . to2de1) (set-current-directory! . to2ddd) (expand-path . to2ddc) (current-directory . to2ddb) (%getpid . to2dda) (%spawn . to2dd9) (%waitpid . to2dd8) (simple-struct-name . to2dd7) (simple-struct-set! . to2dd6) (simple-struct-ref . to2dd5) (make-simple-struct . to2dd4) (simple-struct? . to2dd3) (pointer-ref-c-int64 . to2dd2) (pointer-ref-c-int32 . to2dd1) (pointer-ref-c-int16 . to2dd0) (pointer-ref-c-int8 . to2dcf) (pointer-ref-c-uint64 . to2dce) (pointer-ref-c-uint32 . to2dcd) (pointer-ref-c-uint16 . to2dcc) (pointer-ref-c-uint8 . to2dcb) (pointer-set-c-uint64! . to2dca) (pointer-set-c-uint32! . to2dc9) (pointer-set-c-uint16! . to2dc8) (pointer-set-c-uint8! . to2dc7) (pointer-set-c-int64! . to2dc6) (pointer-set-c-int32! . to2dc5) (pointer-set-c-int16! . to2dc4) (pointer-set-c-int8! . to2dc3) (pointer-set-c-pointer! . to2dc2) (pointer-set-c-double! . to2dc1) (pointer-set-c-float! . to2dc0) (pointer-set-c-long-long! . to2dbf) (pointer-set-c-long! . to2dbe) (pointer-set-c-int! . to2dbd) (pointer-set-c-short! . to2dbc) (pointer-set-c-char! . to2dbb) (pointer-ref-c-pointer . to2dba) (pointer-ref-c-double . to2db9) (pointer-ref-c-float . to2db8) (pointer-ref-c-unsigned-long-long . to2db7) (pointer-ref-c-signed-long-long . to2db6) (pointer-ref-c-unsigned-long . to2db5) (pointer-ref-c-signed-long . to2db4) (pointer-ref-c-unsigned-int . to2db3) (pointer-ref-c-signed-int . to2db2) (pointer-ref-c-unsigned-short . to2db1) (pointer-ref-c-signed-short . to2db0) (pointer-ref-c-unsigned-char . to2daf) (pointer-ref-c-signed-char . to2dae) (pointer->integer . to2dad) (integer->pointer . to2dac) (pointer? . to2dab) (shared-errno . to2daa) (%ffi-supported? . to2da5) (%ffi-pointer->string . to2da4) (%ffi-call . to2da3) (%ffi-lookup . to2da2) (%ffi-open . to2da1) (null-terminated-utf8->string . to2da0) (null-terminated-bytevector->string . to2d9f) (%exec . to2d9e) (%fork . to2d9d) (%pipe . to2d9c) (p . to2d9b) (whereis . to2d7f) (register . to2d7e) (vm-join! . to2d7d) (vm-set-value! . to2d7c) (vm? . to2d7b) (main-vm? . to2d7a) (vm-eval . to2d79) (vm-self . to2d78) (vm-start! . to2d77) (make-vm . to2d76) (mutex-try-lock! . to2d75) (mutex-unlock! . to2d74) (mutex-lock! . to2d73) (mutex? . to2d72) (make-mutex . to2d71) (condition-variable-notify-all! . to2d70) (condition-variable-notify! . to2d6f) (condition-variable-wait! . to2d6e) (make-condition-variable . to2d6d) (write/ss . to2d6c) (string-upcase . to2d4f) (string-titlecase . to2d4e) (string-normalize-nfkd . to2d4d) (string-normalize-nfkc . to2d4c) (string-normalize-nfd . to2d4b) (string-normalize-nfc . to2d4a) (string-foldcase . to2d49) (string-downcase . to2d48) (string-ci>? . to2d47) (string-ci>=? . to2d46) (string-ci=? . to2d45) (string-ci<? . to2d44) (string-ci<=? . to2d43) (char-whitespace? . to2d42) (char-upper-case? . to2d41) (char-title-case? . to2d40) (char-numeric? . to2d3f) (char-lower-case? . to2d3e) (char-general-category . to2d3d) (char-upcase . to2d3c) (char-titlecase . to2d3b) (char-foldcase . to2d3a) (char-downcase . to2d39) (char-ci>? . to2d38) (char-ci>=? . to2d37) (char-ci=? . to2d36) (char-ci<? . to2d35) (char-ci<=? . to2d34) (char-alphabetic? . to2d33) (make-variable-transformer . tobb9) (identifier? . toe70) (generate-temporaries . toe5c) (free-identifier=? . toe5e) (syntax->datum . toe74) (datum->syntax . toe72) (bound-identifier=? . toe60) (record-type-descriptor? . to2d32) (record-predicate . to2d31) (record-mutator . to2d30) (record-constructor . to2d2f) (record-accessor . to2d2e) (make-record-type-descriptor . to2d2d) (make-record-constructor-descriptor . to2d2c) (record? . to2d2b) (record-type-uid . to2d2a) (record-type-sealed? . to2d29) (record-type-parent . to2d28) (record-type-opaque? . to2d27) (record-type-name . to2d26) (record-type-generative? . to2d25) (record-type-field-names . to2d24) (record-rtd . to2d23) (record-field-mutable? . to2d22) (delete-file . to2d21) (file-exists? . to2d20) (vector-sort! . to2d1f) (vector-sort . to2d1e) (list-sort . to2d1d) (symbol-hash . to2d1c) (string-ci-hash . to2d1b) (string-hash . to2d1a) (equal-hash . to2d19) (hashtable-equivalence-function . to2d18) (make-hashtable . to2d17) (hashtable-hash-function . to2d16) (make-eqv-hashtable . to2d15) (make-eq-hashtable . to2d14) (hashtable? . to2d13) (hashtable-update! . to2d12) (hashtable-size . to2d11) (hashtable-set! . to2d10) (hashtable-ref . to2d0f) (hashtable-mutable? . to2d0e) (hashtable-keys . to2d0d) (hashtable-entries . to2d0c) (hashtable-delete! . to2d0b) (hashtable-copy . to2d0a) (hashtable-contains? . to2d09) (hashtable-clear! . to2d08) (call-with-output-file . to2d07) (call-with-input-file . to2d06) (write-char . to2d05) (write . to2d04) (with-output-to-file . to2d03) (with-input-from-file . to2d02) (read-char . to2d01) (read . to2d00) (peek-char . to2cff) (open-output-file . to2cfe) (open-input-file . to2cfd) (newline . to2cfc) (display . to2cfb) (close-output-port . to2cfa) (close-input-port . to2cf9) (eof-object? . to2cf8) (eof-object . to2cf7) (current-error-port . to2cf6) (current-output-port . to2cf5) (current-input-port . to2cf4) (output-port? . to2cf3) (input-port? . to2cf2) (utf-8-codec . to2cf1) (utf-16-codec . to2cf0) (transcoder-error-handling-mode . to2cef) (transcoder-eol-style . to2cee) (transcoder-codec . to2ced) (transcoded-port . to2cec) (textual-port? . to2ceb) (string->bytevector . to2cea) (standard-output-port . to2ce9) (standard-input-port . to2ce8) (standard-error-port . to2ce7) (set-port-position! . to2ce6) (put-u8 . to2ce5) (put-string . to2ce4) (put-datum . to2ce3) (put-char . to2ce2) (put-bytevector . to2ce1) (port? . to2ce0) (port-transcoder . to2cdf) (port-position . to2cde) (port-has-set-port-position!? . to2cdd) (port-has-port-position? . to2cdc) (port-eof? . to2cdb) (output-port-buffer-mode . to2cda) (open-string-output-port . to2cd9) (open-string-input-port . to2cd8) (open-file-output-port . to2cd7) (open-file-input/output-port . to2cd6) (open-file-input-port . to2cd5) (open-bytevector-output-port . to2cd4) (open-bytevector-input-port . to2cd3) (native-transcoder . to2cd2) (native-eol-style . to2cd1) (make-transcoder . to2cd0) (latin-1-codec . to2ccf) (make-i/o-write-error . to2cce) (make-i/o-read-error . to2ccd) (make-i/o-port-error . to2ccc) (make-i/o-invalid-position-error . to2ccb) (make-i/o-filename-error . to2cca) (make-i/o-file-protection-error . to2cc9) (make-i/o-file-is-read-only-error . to2cc8) (make-i/o-file-does-not-exist-error . to2cc7) (make-i/o-file-already-exists-error . to2cc6) (make-i/o-error . to2cc5) (make-i/o-encoding-error . to2cc4) (make-i/o-decoding-error . to2cc3) (make-custom-textual-output-port . to2cc2) (make-custom-textual-input/output-port . to2cc1) (make-custom-textual-input-port . to2cc0) (make-custom-binary-output-port . to2cbf) (make-custom-binary-input/output-port . to2cbe) (make-custom-binary-input-port . to2cbd) (make-bytevector . to2cbc) (lookahead-u8 . to2cbb) (lookahead-char . to2cba) (i/o-write-error? . to2cb9) (i/o-read-error? . to2cb8) (i/o-port-error? . to2cb7) (i/o-invalid-position-error? . to2cb6) (i/o-filename-error? . to2cb5) (i/o-file-protection-error? . to2cb4) (i/o-file-is-read-only-error? . to2cb3) (i/o-file-does-not-exist-error? . to2cb2) (i/o-file-already-exists-error? . to2cb1) (i/o-error? . to2cb0) (i/o-error-position . to2caf) (i/o-error-port . to2cae) (i/o-error-filename . to2cad) (i/o-encoding-error? . to2cac) (i/o-encoding-error-char . to2cab) (i/o-decoding-error? . to2caa) (get-u8 . to2ca9) (get-string-n! . to2ca8) (get-string-n . to2ca7) (get-string-all . to2ca6) (get-line . to2ca5) (get-datum . to2ca4) (get-char . to2ca3) (get-bytevector-some . to2ca2) (get-bytevector-n! . to2ca1) (get-bytevector-n . to2ca0) (get-bytevector-all . to2c9f) (flush-output-port . to2c9e) (close-port . to2c9d) (exit . to2c95) (command-line . to2927) (string-fill! . to2c94) (string-set! . to2c93) (set-cdr! . to2c92) (set-car! . to2c91) (remove . to2c90) (remv . to2c8f) (remp . to2c8e) (remq . to2c8d) (partition . to2c8c) (memv . to2c8b) (memq . to2c8a) (memp . to2c89) (member . to2c88) (exists . to2c87) (for-all . to2c86) (fold-right . to2c85) (fold-left . to2c84) (find . to2c83) (filter . to2c82) (cons* . to2c81) (assv . to2c80) (assq . to2c7f) (assp . to2c7e) (assoc . to2c7d) (call-with-string-output-port . to2c7c) (call-with-port . to2c7b) (call-with-bytevector-output-port . to2c7a) (bytevector->string . to2c79) (buffer-mode? . to2c78) (binary-port? . to2c77) (with-exception-handler . to2c76) (raise-continuable . to2c75) (raise . to2c74) (eval . toe4e) (environment . toe46) (make-enumeration . to2c73) (enum-set=? . to2c72) (enum-set-universe . to2c71) (enum-set-union . to2c70) (enum-set-subset? . to2c6f) (enum-set-projection . to2c6e) (enum-set-member? . to2c6d) (enum-set-intersection . to2c6c) (enum-set-indexer . to2c6b) (enum-set-difference . to2c6a) (enum-set-constructor . to2c69) (enum-set-complement . to2c68) (enum-set->list . to2c67) (who-condition? . to2c66) (warning? . to2c65) (violation? . to2c64) (undefined-violation? . to2c63) (syntax-violation? . to2c62) (syntax-violation-subform . to2c61) (syntax-violation-form . to2c60) (syntax-violation . toe6e) (simple-conditions . to2c5f) (serious-condition? . to2c5e) (non-continuable-violation? . to2c5d) (message-condition? . to2c5c) (make-who-condition . to2c5b) (make-warning . to2c5a) (make-violation . to2c59) (make-undefined-violation . to2c58) (make-syntax-violation . to2c57) (make-serious-condition . to2c56) (make-non-continuable-violation . to2c55) (make-message-condition . to2c54) (make-lexical-violation . to2c53) (make-irritants-condition . to2c52) (make-implementation-restriction-violation . to2c51) (make-error . to2c50) (make-assertion-violation . to2c4f) (lexical-violation? . to2c4e) (irritants-condition? . to2c4d) (implementation-restriction-violation? . to2c4c) (error? . to2c4b) (condition-who . to2c4a) (condition-predicate . to2c49) (condition-message . to2c48) (condition-irritants . to2c47) (condition-accessor . to2c46) (condition . to2c45) (assertion-violation? . to2c44) (condition? . to2c43) (utf32->string . to2c42) (utf16->string . to2c41) (utf8->string . to2c40) (uint-list->bytevector . to2c3f) (u8-list->bytevector . to2c3e) (string->utf8 . to2c3d) (string->utf32 . to2c3c) (string->utf16 . to2c3b) (sint-list->bytevector . to2c3a) (native-endianness . to2c39) (bytevector? . to2c38) (bytevector=? . to2c37) (bytevector-uint-set! . to2c36) (bytevector-uint-ref . to2c35) (bytevector-u8-set! . to2c34) (bytevector-u8-ref . to2c33) (bytevector-u64-set! . to2c32) (bytevector-u64-ref . to2c31) (bytevector-u64-native-set! . to2c30) (bytevector-u64-native-ref . to2c2f) (bytevector-u32-set! . to2c2e) (bytevector-u32-ref . to2c2d) (bytevector-u32-native-set! . to2c2c) (bytevector-u32-native-ref . to2c2b) (bytevector-u16-set! . to2c2a) (bytevector-u16-ref . to2c29) (bytevector-u16-native-set! . to2c28) (bytevector-u16-native-ref . to2c27) (bytevector-sint-set! . to2c26) (bytevector-sint-ref . to2c25) (bytevector-s8-set! . to2c24) (bytevector-s8-ref . to2c23) (bytevector-s64-set! . to2c22) (bytevector-s64-ref . to2c21) (bytevector-s64-native-set! . to2c20) (bytevector-s64-native-ref . to2c1f) (bytevector-s32-set! . to2c1e) (bytevector-s32-ref . to2c1d) (bytevector-s32-native-set! . to2c1c) (bytevector-s32-native-ref . to2c1b) (bytevector-s16-set! . to2c1a) (bytevector-s16-ref . to2c19) (bytevector-s16-native-set! . to2c18) (bytevector-s16-native-ref . to2c17) (bytevector-length . to2c16) (bytevector-ieee-single-ref . to2c15) (bytevector-ieee-single-set! . to2c14) (bytevector-ieee-single-native-set! . to2c13) (bytevector-ieee-single-native-ref . to2c12) (bytevector-ieee-double-set! . to2c11) (bytevector-ieee-double-ref . to2c10) (bytevector-ieee-double-native-set! . to2c0f) (bytevector-ieee-double-native-ref . to2c0e) (bytevector-fill! . to2c0d) (bytevector-copy! . to2c0c) (bytevector-copy . to2c0b) (bytevector->uint-list . to2c0a) (bytevector->u8-list . to2c09) (bytevector->sint-list . to2c08) (no-nans-violation? . to2c07) (no-infinities-violation? . to2c06) (make-no-nans-violation . to2c05) (make-no-infinities-violation . to2c04) (real->flonum . to2c03) (flzero? . to2c02) (fltruncate . to2c01) (fltan . to2c00) (flsqrt . to2bff) (flsin . to2bfe) (flround . to2bfd) (flpositive? . to2bfc) (flonum? . to2bfb) (flodd? . to2bfa) (flnumerator . to2bf9) (flnegative? . to2bf8) (flnan? . to2bf7) (flmod0 . to2bf6) (flmod . to2bf5) (flmin . to2bf4) (flmax . to2bf3) (fllog . to2bf2) (flinteger? . to2bf1) (flinfinite? . to2bf0) (flfloor . to2bef) (flfinite? . to2bee) (flexpt . to2bed) (flexp . to2bec) (fleven? . to2beb) (fldiv0-and-mod0 . to2bea) (fldiv0 . to2be9) (fldiv-and-mod . to2be8) (fldiv . to2be7) (fldenominator . to2be6) (flcos . to2be5) (flceiling . to2be4) (flatan . to2be3) (flasin . to2be2) (flacos . to2be1) (flabs . to2be0) (fl>? . to2bdf) (fl>=? . to2bde) (fl=? . to2bdd) (fl<? . to2bdc) (fl<=? . to2bdb) (fl/ . to2bda) (fl- . to2bd9) (fl+ . to2bd8) (fl* . to2bd7) (fixnum->flonum . to2bd6) (fxzero? . to2bd5) (fxxor . to2bd4) (fxrotate-bit-field . to2bd3) (fxreverse-bit-field . to2bd2) (fxpositive? . to2bd1) (fxodd? . to2bd0) (fxnot . to2bcf) (fxnegative? . to2bce) (fxmod0 . to2bcd) (fxmod . to2bcc) (fxmin . to2bcb) (fxmax . to2bca) (fxlength . to2bc9) (fxior . to2bc8) (fxif . to2bc7) (fxfirst-bit-set . to2bc6) (fxeven? . to2bc5) (fxdiv0-and-mod0 . to2bc4) (fxdiv0 . to2bc3) (fxdiv-and-mod . to2bc2) (fxdiv . to2bc1) (fxcopy-bit-field . to2bc0) (fxcopy-bit . to2bbf) (fxbit-set? . to2bbe) (fxbit-field . to2bbd) (fxbit-count . to2bbc) (fxarithmetic-shift-right . to2bbb) (fxarithmetic-shift-left . to2bba) (fxarithmetic-shift . to2bb9) (fxand . to2bb8) (fx>? . to2bb7) (fx>=? . to2bb6) (fx=? . to2bb5) (fx<? . to2bb4) (fx<=? . to2bb3) (fx-/carry . to2bb2) (fx- . to2bb1) (fx+/carry . to2bb0) (fx+ . to2baf) (fx*/carry . to2bae) (fx* . to2bad) (greatest-fixnum . to2bac) (least-fixnum . to2bab) (fixnum-width . to2baa) (fixnum? . to2ba9) (bitwise-rotate-bit-field . to2ba8) (bitwise-reverse-bit-field . to2ba7) (bitwise-length . to2ba6) (bitwise-if . to2ba5) (bitwise-first-bit-set . to2ba4) (bitwise-copy-bit-field . to2ba3) (bitwise-copy-bit . to2ba2) (bitwise-bit-set? . to2ba1) (bitwise-bit-field . to2ba0) (bitwise-bit-count . to2b9f) (bitwise-xor . to2b9e) (bitwise-ior . to2b9d) (bitwise-and . to2b9c) (bitwise-not . to2b9b) (bitwise-arithmetic-shift-right . to2b9a) (bitwise-arithmetic-shift-left . to2b99) (bitwise-arithmetic-shift . to2b98) (zero? . to2b97) (vector? . to2b96) (vector-set! . to2b95) (vector-ref . to2b94) (vector-map . to2b93) (vector-length . to2b92) (vector-for-each . to2b91) (vector-fill! . to2b90) (vector->list . to2b8f) (vector . to2b8e) (values . to2b8d) (truncate . to2b8c) (tan . to2b8b) (symbol? . to2b8a) (symbol=? . to2b89) (symbol->string . to2b88) (substring . to2b87) (string? . to2b86) (string>? . to2b85) (string>=? . to2b84) (string=? . to2b83) (string<? . to2b82) (string<=? . to2b81) (string-ref . to2b80) (string-length . to2b7f) (string-for-each . to2b7e) (string-copy . to2b7d) (string-append . to2b7c) (string->symbol . to2b7b) (string->number . to2b7a) (string->list . to2b79) (string . to2b78) (sqrt . to2b77) (sin . to2b76) (round . to2b75) (reverse . to2b74) (real? . to2b73) (real-valued? . to2b72) (real-part . to2b71) (rationalize . to2b70) (rational? . to2b6f) (rational-valued? . to2b6e) (procedure? . to2b6d) (positive? . to2b6c) (pair? . to2b6b) (odd? . to2b6a) (numerator . to2b69) (number? . to2b68) (number->string . to2b67) (null? . to2b66) (not . to2b65) (negative? . to2b64) (nan? . to2b63) (min . to2b62) (max . to2b61) (map . to2b60) (make-vector . to2b5f) (make-string . to2b5e) (make-rectangular . to2b5d) (make-polar . to2b5c) (magnitude . to2b5b) (log . to2b5a) (list? . to2b59) (list-tail . to2b58) (list-ref . to2b57) (list->vector . to2b56) (list->string . to2b55) (list . to2b54) (length . to2b53) (lcm . to2b52) (integer? . to2b51) (integer-valued? . to2b50) (integer->char . to2b4f) (infinite? . to2b4e) (inexact? . to2b4d) (inexact . to2b4c) (imag-part . to2b4b) (gcd . to2b4a) (for-each . to2b49) (floor . to2b48) (finite? . to2b47) (expt . to2b46) (exp . to2b45) (exact? . to2b44) (exact-integer-sqrt . to2b43) (exact . to2b42) (even? . to2b41) (error . to2b40) (eqv? . to2b3f) (equal? . to2b3e) (eq? . to2b3d) (dynamic-wind . to2b3c) (div0-and-mod0 . to2b3b) (mod0 . to2b3a) (div0 . to2b39) (div-and-mod . to2b38) (mod . to2b37) (div . to2b36) (denominator . to2b35) (cos . to2b34) (cons . to2b33) (complex? . to2b32) (char? . to2b31) (char>? . to2b30) (char>=? . to2b2f) (char=? . to2b2e) (char<? . to2b2d) (char<=? . to2b2c) (char->integer . to2b2b) (ceiling . to2b2a) (call-with-values . to2b29) (call/cc . to2b28) (call-with-current-continuation . to2b27) (cddddr . to2b26) (cdddar . to2b25) (cddadr . to2b24) (cddaar . to2b23) (cdaddr . to2b22) (cdadar . to2b21) (cdaadr . to2b20) (cdaaar . to2b1f) (cadddr . to2b1e) (caddar . to2b1d) (cadadr . to2b1c) (cadaar . to2b1b) (caaddr . to2b1a) (caadar . to2b19) (caaadr . to2b18) (caaaar . to2b17) (cdddr . to2b16) (cddar . to2b15) (cdadr . to2b14) (cdaar . to2b13) (caddr . to2b12) (cadar . to2b11) (caadr . to2b10) (caaar . to2b0f) (cddr . to2b0e) (cdar . to2b0d) (cadr . to2b0c) (caar . to2b0b) (cdr . to2b0a) (car . to2b09) (boolean? . to2b08) (boolean=? . to2b07) (atan . to2b06) (assertion-violation . to2b05) (asin . to2b04) (apply . to2b03) (append . to2b02) (angle . to2b01) (acos . to2b00) (abs . to2aff) (/ . to2afe) (* . to2afd) (- . to2afc) (+ . to2afb) (>= . to2afa) (> . to2af9) (= . to2af8) (<= . to2af7) (< . to2af6) (library . to2af5) (&no-nans . to2af4) (&no-infinities . to2af3) (&i/o-encoding . to2af2) (&i/o-decoding . to2af1) (&i/o-port . to2af0) (&i/o-file-does-not-exist . to2aef) (&i/o-file-already-exists . to2aee) (&i/o-file-is-read-only . to2aed) (&i/o-file-protection . to2aec) (&i/o-filename . to2aeb) (&i/o-invalid-position . to2aea) (&i/o-write . to2ae9) (&i/o-read . to2ae8) (&i/o . to2ae7) (&undefined . to2ae6) (&syntax . to2ae5) (&lexical . to2ae4) (&implementation-restriction . to2ae3) (&non-continuable . to2ae2) (&who . to2ae1) (&irritants . to2ae0) (&assertion . to2adf) (&violation . to2ade) (&error . to2add) (&serious . to2adc) (&warning . to2adb) (&message . to2ada) (&condition . to2ad9) (define-condition-type . to2ad8) (define-enumeration . to2ad7) (define-record-type . to2ad6) (parent-rtd . to2ad5) (nongenerative . to2ad4) (opaque . to2ad3) (sealed . to2ad2) (protocol . to2ad1) (parent . to2ad0) (immutable . to2acf) (mutable . to2ace) (fields . to2acd) (error-handling-mode . to2acc) (file-options . to2acb) (buffer-mode . to2aca) (eol-style . to2ac9) (guard . to2ac8) (unsyntax-splicing . to2ac5) (unsyntax . to2ac4) (unquote-splicing . to2ac3) (unquote . to2ac2) (_ . to2ac1) (else . to2ac0) (=> . to2abf) (... . to2abe) (assert . to2abd) (endianness . to2abc) (time . to2aba) (do . to2ab9) (cond . to2ab8) (let* . to2ab7) (let*-values . to2ab6) (let-values . to2ab5) (identifier-syntax . to2ab4) (with-syntax . to2ab3) (quasisyntax . to2ab2) (quasiquote . to2ab1) (syntax-rules . to2ab0) (include . to2aaf) (record-constructor-descriptor . to2aad) (record-type-descriptor . to2aac) (case . to2aab) (unless . to2aa9) (when . to2aa8) (or . to2aa7) (and . to2aa6) (if . to2aa5) (let . to2aa4) (letrec* . to2aa3) (letrec . to2aa2) (case-lambda . to2aa0) (lambda . to2a9f) (syntax . to2a9e) (syntax-case . to2a9d) (quote . to2a9c) (letrec-syntax . to2a9a) (let-syntax . to2a99) (set! . to2a98) (import . to2a97) (begin . to2a96) (define-syntax . to2a94) (define . to2a93)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e4b '(psyntax null-environment-5) '() '() '() '() '((make-promise . to2c96) (unquote-splicing . to2ac3) (unquote . to2ac2) (_ . to2ac1) (else . to2ac0) (=> . to2abf) (... . to2abe) (delay . to2abb) (do . to2ab9) (cond . to2ab8) (let* . to2ab7) (quasiquote . to2ab1) (syntax-rules . to2ab0) (case . to2aab) (or . to2aa7) (and . to2aa6) (if . to2aa5) (let . to2aa4) (letrec . to2aa2) (lambda . to2a9f) (quote . to2a9c) (letrec-syntax . to2a9a) (let-syntax . to2a99) (set! . to2a98) (begin . to2a96) (define-syntax . to2a94) (define . to2a93)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e4c '(psyntax scheme-report-environment-5) '() '() '() '() '((string-ci>? . to2d47) (string-ci>=? . to2d46) (string-ci=? . to2d45) (string-ci<? . to2d44) (string-ci<=? . to2d43) (char-whitespace? . to2d42) (char-upper-case? . to2d41) (char-numeric? . to2d3f) (char-lower-case? . to2d3e) (char-upcase . to2d3c) (char-downcase . to2d39) (char-ci>? . to2d38) (char-ci>=? . to2d37) (char-ci=? . to2d36) (char-ci<? . to2d35) (char-ci<=? . to2d34) (char-alphabetic? . to2d33) (call-with-output-file . to2d07) (call-with-input-file . to2d06) (write-char . to2d05) (write . to2d04) (with-output-to-file . to2d03) (with-input-from-file . to2d02) (read-char . to2d01) (read . to2d00) (peek-char . to2cff) (open-output-file . to2cfe) (open-input-file . to2cfd) (newline . to2cfc) (display . to2cfb) (close-output-port . to2cfa) (close-input-port . to2cf9) (eof-object . to2cf7) (current-output-port . to2cf5) (current-input-port . to2cf4) (output-port? . to2cf3) (input-port? . to2cf2) (scheme-report-environment . toe4a) (quotient . to2c9c) (null-environment . toe48) (remainder . to2c9b) (modulo . to2c9a) (inexact->exact . to2c99) (force . to2c98) (exact->inexact . to2c97) (make-promise . to2c96) (string-fill! . to2c94) (string-set! . to2c93) (set-cdr! . to2c92) (set-car! . to2c91) (memv . to2c8b) (memq . to2c8a) (member . to2c88) (assv . to2c80) (assq . to2c7f) (assoc . to2c7d) (eval . toe4e) (zero? . to2b97) (vector? . to2b96) (vector-set! . to2b95) (vector-ref . to2b94) (vector-length . to2b92) (vector-fill! . to2b90) (vector->list . to2b8f) (vector . to2b8e) (values . to2b8d) (truncate . to2b8c) (tan . to2b8b) (symbol? . to2b8a) (symbol->string . to2b88) (substring . to2b87) (string? . to2b86) (string>? . to2b85) (string>=? . to2b84) (string=? . to2b83) (string<? . to2b82) (string<=? . to2b81) (string-ref . to2b80) (string-length . to2b7f) (string-copy . to2b7d) (string-append . to2b7c) (string->symbol . to2b7b) (string->number . to2b7a) (string->list . to2b79) (string . to2b78) (sqrt . to2b77) (sin . to2b76) (round . to2b75) (reverse . to2b74) (real? . to2b73) (real-part . to2b71) (rationalize . to2b70) (rational? . to2b6f) (procedure? . to2b6d) (positive? . to2b6c) (pair? . to2b6b) (odd? . to2b6a) (numerator . to2b69) (number? . to2b68) (number->string . to2b67) (not . to2b65) (negative? . to2b64) (min . to2b62) (max . to2b61) (map . to2b60) (make-vector . to2b5f) (make-string . to2b5e) (make-rectangular . to2b5d) (make-polar . to2b5c) (magnitude . to2b5b) (log . to2b5a) (list? . to2b59) (list-tail . to2b58) (list-ref . to2b57) (list->vector . to2b56) (list->string . to2b55) (list . to2b54) (length . to2b53) (lcm . to2b52) (integer? . to2b51) (integer->char . to2b4f) (inexact? . to2b4d) (imag-part . to2b4b) (gcd . to2b4a) (for-each . to2b49) (floor . to2b48) (expt . to2b46) (exp . to2b45) (exact? . to2b44) (even? . to2b41) (eqv? . to2b3f) (equal? . to2b3e) (eq? . to2b3d) (dynamic-wind . to2b3c) (denominator . to2b35) (cos . to2b34) (cons . to2b33) (complex? . to2b32) (char? . to2b31) (char>? . to2b30) (char>=? . to2b2f) (char=? . to2b2e) (char<? . to2b2d) (char<=? . to2b2c) (char->integer . to2b2b) (ceiling . to2b2a) (call-with-values . to2b29) (call-with-current-continuation . to2b27) (cddddr . to2b26) (cdddar . to2b25) (cddadr . to2b24) (cddaar . to2b23) (cdaddr . to2b22) (cdadar . to2b21) (cdaadr . to2b20) (cdaaar . to2b1f) (cadddr . to2b1e) (caddar . to2b1d) (cadadr . to2b1c) (cadaar . to2b1b) (caaddr . to2b1a) (caadar . to2b19) (caaadr . to2b18) (caaaar . to2b17) (cdddr . to2b16) (cddar . to2b15) (cdadr . to2b14) (cdaar . to2b13) (caddr . to2b12) (cadar . to2b11) (caadr . to2b10) (caaar . to2b0f) (cddr . to2b0e) (cdar . to2b0d) (cadr . to2b0c) (caar . to2b0b) (cdr . to2b0a) (car . to2b09) (boolean? . to2b08) (atan . to2b06) (asin . to2b04) (apply . to2b03) (append . to2b02) (angle . to2b01) (acos . to2b00) (abs . to2aff) (/ . to2afe) (* . to2afd) (- . to2afc) (+ . to2afb) (>= . to2afa) (> . to2af9) (= . to2af8) (<= . to2af7) (< . to2af6) (unquote-splicing . to2ac3) (unquote . to2ac2) (else . to2ac0) (=> . to2abf) (... . to2abe) (delay . to2abb) (do . to2ab9) (cond . to2ab8) (let* . to2ab7) (quasiquote . to2ab1) (syntax-rules . to2ab0) (case . to2aab) (or . to2aa7) (and . to2aa6) (if . to2aa5) (let . to2aa4) (letrec . to2aa2) (lambda . to2a9f) (quote . to2a9c) (letrec-syntax . to2a9a) (let-syntax . to2a99) (set! . to2a98) (begin . to2a96) (define-syntax . to2a94) (define . to2a93)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e4d '(psyntax modules) '() '() '() '() '((module . to2a95)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e4e '(chez parameters) '() '() '() '() '() '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e4f '(rnrs) '(6) '() '() '() '((regexp? . to2e0a) (string-upcase . to2d4f) (string-titlecase . to2d4e) (string-normalize-nfkd . to2d4d) (string-normalize-nfkc . to2d4c) (string-normalize-nfd . to2d4b) (string-normalize-nfc . to2d4a) (string-foldcase . to2d49) (string-downcase . to2d48) (string-ci>? . to2d47) (string-ci>=? . to2d46) (string-ci=? . to2d45) (string-ci<? . to2d44) (string-ci<=? . to2d43) (char-whitespace? . to2d42) (char-upper-case? . to2d41) (char-title-case? . to2d40) (char-numeric? . to2d3f) (char-lower-case? . to2d3e) (char-general-category . to2d3d) (char-upcase . to2d3c) (char-titlecase . to2d3b) (char-foldcase . to2d3a) (char-downcase . to2d39) (char-ci>? . to2d38) (char-ci>=? . to2d37) (char-ci=? . to2d36) (char-ci<? . to2d35) (char-ci<=? . to2d34) (char-alphabetic? . to2d33) (make-variable-transformer . tobb9) (identifier? . toe70) (generate-temporaries . toe5c) (free-identifier=? . toe5e) (syntax->datum . toe74) (datum->syntax . toe72) (bound-identifier=? . toe60) (record-type-descriptor? . to2d32) (record-predicate . to2d31) (record-mutator . to2d30) (record-constructor . to2d2f) (record-accessor . to2d2e) (make-record-type-descriptor . to2d2d) (make-record-constructor-descriptor . to2d2c) (record? . to2d2b) (record-type-uid . to2d2a) (record-type-sealed? . to2d29) (record-type-parent . to2d28) (record-type-opaque? . to2d27) (record-type-name . to2d26) (record-type-generative? . to2d25) (record-type-field-names . to2d24) (record-rtd . to2d23) (record-field-mutable? . to2d22) (delete-file . to2d21) (file-exists? . to2d20) (vector-sort! . to2d1f) (vector-sort . to2d1e) (list-sort . to2d1d) (symbol-hash . to2d1c) (string-ci-hash . to2d1b) (string-hash . to2d1a) (equal-hash . to2d19) (hashtable-equivalence-function . to2d18) (make-hashtable . to2d17) (hashtable-hash-function . to2d16) (make-eqv-hashtable . to2d15) (make-eq-hashtable . to2d14) (hashtable? . to2d13) (hashtable-update! . to2d12) (hashtable-size . to2d11) (hashtable-set! . to2d10) (hashtable-ref . to2d0f) (hashtable-mutable? . to2d0e) (hashtable-keys . to2d0d) (hashtable-entries . to2d0c) (hashtable-delete! . to2d0b) (hashtable-copy . to2d0a) (hashtable-contains? . to2d09) (hashtable-clear! . to2d08) (call-with-output-file . to2d07) (call-with-input-file . to2d06) (write-char . to2d05) (write . to2d04) (with-output-to-file . to2d03) (with-input-from-file . to2d02) (read-char . to2d01) (read . to2d00) (peek-char . to2cff) (open-output-file . to2cfe) (open-input-file . to2cfd) (newline . to2cfc) (display . to2cfb) (close-output-port . to2cfa) (close-input-port . to2cf9) (eof-object? . to2cf8) (eof-object . to2cf7) (current-error-port . to2cf6) (current-output-port . to2cf5) (current-input-port . to2cf4) (output-port? . to2cf3) (input-port? . to2cf2) (utf-8-codec . to2cf1) (utf-16-codec . to2cf0) (transcoder-error-handling-mode . to2cef) (transcoder-eol-style . to2cee) (transcoder-codec . to2ced) (transcoded-port . to2cec) (textual-port? . to2ceb) (string->bytevector . to2cea) (standard-output-port . to2ce9) (standard-input-port . to2ce8) (standard-error-port . to2ce7) (set-port-position! . to2ce6) (put-u8 . to2ce5) (put-string . to2ce4) (put-datum . to2ce3) (put-char . to2ce2) (put-bytevector . to2ce1) (port? . to2ce0) (port-transcoder . to2cdf) (port-position . to2cde) (port-has-set-port-position!? . to2cdd) (port-has-port-position? . to2cdc) (port-eof? . to2cdb) (output-port-buffer-mode . to2cda) (open-string-output-port . to2cd9) (open-string-input-port . to2cd8) (open-file-output-port . to2cd7) (open-file-input/output-port . to2cd6) (open-file-input-port . to2cd5) (open-bytevector-output-port . to2cd4) (open-bytevector-input-port . to2cd3) (native-transcoder . to2cd2) (native-eol-style . to2cd1) (make-transcoder . to2cd0) (latin-1-codec . to2ccf) (make-i/o-write-error . to2cce) (make-i/o-read-error . to2ccd) (make-i/o-port-error . to2ccc) (make-i/o-invalid-position-error . to2ccb) (make-i/o-filename-error . to2cca) (make-i/o-file-protection-error . to2cc9) (make-i/o-file-is-read-only-error . to2cc8) (make-i/o-file-does-not-exist-error . to2cc7) (make-i/o-file-already-exists-error . to2cc6) (make-i/o-error . to2cc5) (make-i/o-encoding-error . to2cc4) (make-i/o-decoding-error . to2cc3) (make-custom-textual-output-port . to2cc2) (make-custom-textual-input/output-port . to2cc1) (make-custom-textual-input-port . to2cc0) (make-custom-binary-output-port . to2cbf) (make-custom-binary-input/output-port . to2cbe) (make-custom-binary-input-port . to2cbd) (make-bytevector . to2cbc) (lookahead-u8 . to2cbb) (lookahead-char . to2cba) (i/o-write-error? . to2cb9) (i/o-read-error? . to2cb8) (i/o-port-error? . to2cb7) (i/o-invalid-position-error? . to2cb6) (i/o-filename-error? . to2cb5) (i/o-file-protection-error? . to2cb4) (i/o-file-is-read-only-error? . to2cb3) (i/o-file-does-not-exist-error? . to2cb2) (i/o-file-already-exists-error? . to2cb1) (i/o-error? . to2cb0) (i/o-error-position . to2caf) (i/o-error-port . to2cae) (i/o-error-filename . to2cad) (i/o-encoding-error? . to2cac) (i/o-encoding-error-char . to2cab) (i/o-decoding-error? . to2caa) (get-u8 . to2ca9) (get-string-n! . to2ca8) (get-string-n . to2ca7) (get-string-all . to2ca6) (get-line . to2ca5) (get-datum . to2ca4) (get-char . to2ca3) (get-bytevector-some . to2ca2) (get-bytevector-n! . to2ca1) (get-bytevector-n . to2ca0) (get-bytevector-all . to2c9f) (flush-output-port . to2c9e) (close-port . to2c9d) (exit . to2c95) (command-line . to2927) (remove . to2c90) (remv . to2c8f) (remp . to2c8e) (remq . to2c8d) (partition . to2c8c) (memv . to2c8b) (memq . to2c8a) (memp . to2c89) (member . to2c88) (exists . to2c87) (for-all . to2c86) (fold-right . to2c85) (fold-left . to2c84) (find . to2c83) (filter . to2c82) (cons* . to2c81) (assv . to2c80) (assq . to2c7f) (assp . to2c7e) (assoc . to2c7d) (call-with-string-output-port . to2c7c) (call-with-port . to2c7b) (call-with-bytevector-output-port . to2c7a) (bytevector->string . to2c79) (buffer-mode? . to2c78) (binary-port? . to2c77) (with-exception-handler . to2c76) (raise-continuable . to2c75) (raise . to2c74) (make-enumeration . to2c73) (enum-set=? . to2c72) (enum-set-universe . to2c71) (enum-set-union . to2c70) (enum-set-subset? . to2c6f) (enum-set-projection . to2c6e) (enum-set-member? . to2c6d) (enum-set-intersection . to2c6c) (enum-set-indexer . to2c6b) (enum-set-difference . to2c6a) (enum-set-constructor . to2c69) (enum-set-complement . to2c68) (enum-set->list . to2c67) (who-condition? . to2c66) (warning? . to2c65) (violation? . to2c64) (undefined-violation? . to2c63) (syntax-violation? . to2c62) (syntax-violation-subform . to2c61) (syntax-violation-form . to2c60) (syntax-violation . toe6e) (simple-conditions . to2c5f) (serious-condition? . to2c5e) (non-continuable-violation? . to2c5d) (message-condition? . to2c5c) (make-who-condition . to2c5b) (make-warning . to2c5a) (make-violation . to2c59) (make-undefined-violation . to2c58) (make-syntax-violation . to2c57) (make-serious-condition . to2c56) (make-non-continuable-violation . to2c55) (make-message-condition . to2c54) (make-lexical-violation . to2c53) (make-irritants-condition . to2c52) (make-implementation-restriction-violation . to2c51) (make-error . to2c50) (make-assertion-violation . to2c4f) (lexical-violation? . to2c4e) (irritants-condition? . to2c4d) (implementation-restriction-violation? . to2c4c) (error? . to2c4b) (condition-who . to2c4a) (condition-predicate . to2c49) (condition-message . to2c48) (condition-irritants . to2c47) (condition-accessor . to2c46) (condition . to2c45) (assertion-violation? . to2c44) (condition? . to2c43) (utf32->string . to2c42) (utf16->string . to2c41) (utf8->string . to2c40) (uint-list->bytevector . to2c3f) (u8-list->bytevector . to2c3e) (string->utf8 . to2c3d) (string->utf32 . to2c3c) (string->utf16 . to2c3b) (sint-list->bytevector . to2c3a) (native-endianness . to2c39) (bytevector? . to2c38) (bytevector=? . to2c37) (bytevector-uint-set! . to2c36) (bytevector-uint-ref . to2c35) (bytevector-u8-set! . to2c34) (bytevector-u8-ref . to2c33) (bytevector-u64-set! . to2c32) (bytevector-u64-ref . to2c31) (bytevector-u64-native-set! . to2c30) (bytevector-u64-native-ref . to2c2f) (bytevector-u32-set! . to2c2e) (bytevector-u32-ref . to2c2d) (bytevector-u32-native-set! . to2c2c) (bytevector-u32-native-ref . to2c2b) (bytevector-u16-set! . to2c2a) (bytevector-u16-ref . to2c29) (bytevector-u16-native-set! . to2c28) (bytevector-u16-native-ref . to2c27) (bytevector-sint-set! . to2c26) (bytevector-sint-ref . to2c25) (bytevector-s8-set! . to2c24) (bytevector-s8-ref . to2c23) (bytevector-s64-set! . to2c22) (bytevector-s64-ref . to2c21) (bytevector-s64-native-set! . to2c20) (bytevector-s64-native-ref . to2c1f) (bytevector-s32-set! . to2c1e) (bytevector-s32-ref . to2c1d) (bytevector-s32-native-set! . to2c1c) (bytevector-s32-native-ref . to2c1b) (bytevector-s16-set! . to2c1a) (bytevector-s16-ref . to2c19) (bytevector-s16-native-set! . to2c18) (bytevector-s16-native-ref . to2c17) (bytevector-length . to2c16) (bytevector-ieee-single-ref . to2c15) (bytevector-ieee-single-set! . to2c14) (bytevector-ieee-single-native-set! . to2c13) (bytevector-ieee-single-native-ref . to2c12) (bytevector-ieee-double-set! . to2c11) (bytevector-ieee-double-ref . to2c10) (bytevector-ieee-double-native-set! . to2c0f) (bytevector-ieee-double-native-ref . to2c0e) (bytevector-fill! . to2c0d) (bytevector-copy! . to2c0c) (bytevector-copy . to2c0b) (bytevector->uint-list . to2c0a) (bytevector->u8-list . to2c09) (bytevector->sint-list . to2c08) (no-nans-violation? . to2c07) (no-infinities-violation? . to2c06) (make-no-nans-violation . to2c05) (make-no-infinities-violation . to2c04) (real->flonum . to2c03) (flzero? . to2c02) (fltruncate . to2c01) (fltan . to2c00) (flsqrt . to2bff) (flsin . to2bfe) (flround . to2bfd) (flpositive? . to2bfc) (flonum? . to2bfb) (flodd? . to2bfa) (flnumerator . to2bf9) (flnegative? . to2bf8) (flnan? . to2bf7) (flmod0 . to2bf6) (flmod . to2bf5) (flmin . to2bf4) (flmax . to2bf3) (fllog . to2bf2) (flinteger? . to2bf1) (flinfinite? . to2bf0) (flfloor . to2bef) (flfinite? . to2bee) (flexpt . to2bed) (flexp . to2bec) (fleven? . to2beb) (fldiv0-and-mod0 . to2bea) (fldiv0 . to2be9) (fldiv-and-mod . to2be8) (fldiv . to2be7) (fldenominator . to2be6) (flcos . to2be5) (flceiling . to2be4) (flatan . to2be3) (flasin . to2be2) (flacos . to2be1) (flabs . to2be0) (fl>? . to2bdf) (fl>=? . to2bde) (fl=? . to2bdd) (fl<? . to2bdc) (fl<=? . to2bdb) (fl/ . to2bda) (fl- . to2bd9) (fl+ . to2bd8) (fl* . to2bd7) (fixnum->flonum . to2bd6) (fxzero? . to2bd5) (fxxor . to2bd4) (fxrotate-bit-field . to2bd3) (fxreverse-bit-field . to2bd2) (fxpositive? . to2bd1) (fxodd? . to2bd0) (fxnot . to2bcf) (fxnegative? . to2bce) (fxmod0 . to2bcd) (fxmod . to2bcc) (fxmin . to2bcb) (fxmax . to2bca) (fxlength . to2bc9) (fxior . to2bc8) (fxif . to2bc7) (fxfirst-bit-set . to2bc6) (fxeven? . to2bc5) (fxdiv0-and-mod0 . to2bc4) (fxdiv0 . to2bc3) (fxdiv-and-mod . to2bc2) (fxdiv . to2bc1) (fxcopy-bit-field . to2bc0) (fxcopy-bit . to2bbf) (fxbit-set? . to2bbe) (fxbit-field . to2bbd) (fxbit-count . to2bbc) (fxarithmetic-shift-right . to2bbb) (fxarithmetic-shift-left . to2bba) (fxarithmetic-shift . to2bb9) (fxand . to2bb8) (fx>? . to2bb7) (fx>=? . to2bb6) (fx=? . to2bb5) (fx<? . to2bb4) (fx<=? . to2bb3) (fx-/carry . to2bb2) (fx- . to2bb1) (fx+/carry . to2bb0) (fx+ . to2baf) (fx*/carry . to2bae) (fx* . to2bad) (greatest-fixnum . to2bac) (least-fixnum . to2bab) (fixnum-width . to2baa) (fixnum? . to2ba9) (bitwise-rotate-bit-field . to2ba8) (bitwise-reverse-bit-field . to2ba7) (bitwise-length . to2ba6) (bitwise-if . to2ba5) (bitwise-first-bit-set . to2ba4) (bitwise-copy-bit-field . to2ba3) (bitwise-copy-bit . to2ba2) (bitwise-bit-set? . to2ba1) (bitwise-bit-field . to2ba0) (bitwise-bit-count . to2b9f) (bitwise-xor . to2b9e) (bitwise-ior . to2b9d) (bitwise-and . to2b9c) (bitwise-not . to2b9b) (bitwise-arithmetic-shift-right . to2b9a) (bitwise-arithmetic-shift-left . to2b99) (bitwise-arithmetic-shift . to2b98) (zero? . to2b97) (vector? . to2b96) (vector-set! . to2b95) (vector-ref . to2b94) (vector-map . to2b93) (vector-length . to2b92) (vector-for-each . to2b91) (vector-fill! . to2b90) (vector->list . to2b8f) (vector . to2b8e) (values . to2b8d) (truncate . to2b8c) (tan . to2b8b) (symbol? . to2b8a) (symbol=? . to2b89) (symbol->string . to2b88) (substring . to2b87) (string? . to2b86) (string>? . to2b85) (string>=? . to2b84) (string=? . to2b83) (string<? . to2b82) (string<=? . to2b81) (string-ref . to2b80) (string-length . to2b7f) (string-for-each . to2b7e) (string-copy . to2b7d) (string-append . to2b7c) (string->symbol . to2b7b) (string->number . to2b7a) (string->list . to2b79) (string . to2b78) (sqrt . to2b77) (sin . to2b76) (round . to2b75) (reverse . to2b74) (real? . to2b73) (real-valued? . to2b72) (real-part . to2b71) (rationalize . to2b70) (rational? . to2b6f) (rational-valued? . to2b6e) (procedure? . to2b6d) (positive? . to2b6c) (pair? . to2b6b) (odd? . to2b6a) (numerator . to2b69) (number? . to2b68) (number->string . to2b67) (null? . to2b66) (not . to2b65) (negative? . to2b64) (nan? . to2b63) (min . to2b62) (max . to2b61) (map . to2b60) (make-vector . to2b5f) (make-string . to2b5e) (make-rectangular . to2b5d) (make-polar . to2b5c) (magnitude . to2b5b) (log . to2b5a) (list? . to2b59) (list-tail . to2b58) (list-ref . to2b57) (list->vector . to2b56) (list->string . to2b55) (list . to2b54) (length . to2b53) (lcm . to2b52) (integer? . to2b51) (integer-valued? . to2b50) (integer->char . to2b4f) (infinite? . to2b4e) (inexact? . to2b4d) (inexact . to2b4c) (imag-part . to2b4b) (gcd . to2b4a) (for-each . to2b49) (floor . to2b48) (finite? . to2b47) (expt . to2b46) (exp . to2b45) (exact? . to2b44) (exact-integer-sqrt . to2b43) (exact . to2b42) (even? . to2b41) (error . to2b40) (eqv? . to2b3f) (equal? . to2b3e) (eq? . to2b3d) (dynamic-wind . to2b3c) (div0-and-mod0 . to2b3b) (mod0 . to2b3a) (div0 . to2b39) (div-and-mod . to2b38) (mod . to2b37) (div . to2b36) (denominator . to2b35) (cos . to2b34) (cons . to2b33) (complex? . to2b32) (char? . to2b31) (char>? . to2b30) (char>=? . to2b2f) (char=? . to2b2e) (char<? . to2b2d) (char<=? . to2b2c) (char->integer . to2b2b) (ceiling . to2b2a) (call-with-values . to2b29) (call/cc . to2b28) (call-with-current-continuation . to2b27) (cddddr . to2b26) (cdddar . to2b25) (cddadr . to2b24) (cddaar . to2b23) (cdaddr . to2b22) (cdadar . to2b21) (cdaadr . to2b20) (cdaaar . to2b1f) (cadddr . to2b1e) (caddar . to2b1d) (cadadr . to2b1c) (cadaar . to2b1b) (caaddr . to2b1a) (caadar . to2b19) (caaadr . to2b18) (caaaar . to2b17) (cdddr . to2b16) (cddar . to2b15) (cdadr . to2b14) (cdaar . to2b13) (caddr . to2b12) (cadar . to2b11) (caadr . to2b10) (caaar . to2b0f) (cddr . to2b0e) (cdar . to2b0d) (cadr . to2b0c) (caar . to2b0b) (cdr . to2b0a) (car . to2b09) (boolean? . to2b08) (boolean=? . to2b07) (atan . to2b06) (assertion-violation . to2b05) (asin . to2b04) (apply . to2b03) (append . to2b02) (angle . to2b01) (acos . to2b00) (abs . to2aff) (/ . to2afe) (* . to2afd) (- . to2afc) (+ . to2afb) (>= . to2afa) (> . to2af9) (= . to2af8) (<= . to2af7) (< . to2af6) (&no-nans . to2af4) (&no-infinities . to2af3) (&i/o-encoding . to2af2) (&i/o-decoding . to2af1) (&i/o-port . to2af0) (&i/o-file-does-not-exist . to2aef) (&i/o-file-already-exists . to2aee) (&i/o-file-is-read-only . to2aed) (&i/o-file-protection . to2aec) (&i/o-filename . to2aeb) (&i/o-invalid-position . to2aea) (&i/o-write . to2ae9) (&i/o-read . to2ae8) (&i/o . to2ae7) (&undefined . to2ae6) (&syntax . to2ae5) (&lexical . to2ae4) (&implementation-restriction . to2ae3) (&non-continuable . to2ae2) (&who . to2ae1) (&irritants . to2ae0) (&assertion . to2adf) (&violation . to2ade) (&error . to2add) (&serious . to2adc) (&warning . to2adb) (&message . to2ada) (&condition . to2ad9) (define-condition-type . to2ad8) (define-enumeration . to2ad7) (define-record-type . to2ad6) (parent-rtd . to2ad5) (nongenerative . to2ad4) (opaque . to2ad3) (sealed . to2ad2) (protocol . to2ad1) (parent . to2ad0) (immutable . to2acf) (mutable . to2ace) (fields . to2acd) (error-handling-mode . to2acc) (file-options . to2acb) (buffer-mode . to2aca) (eol-style . to2ac9) (guard . to2ac8) (unsyntax-splicing . to2ac5) (unsyntax . to2ac4) (unquote-splicing . to2ac3) (unquote . to2ac2) (_ . to2ac1) (else . to2ac0) (=> . to2abf) (... . to2abe) (assert . to2abd) (endianness . to2abc) (do . to2ab9) (cond . to2ab8) (let* . to2ab7) (let*-values . to2ab6) (let-values . to2ab5) (identifier-syntax . to2ab4) (with-syntax . to2ab3) (quasisyntax . to2ab2) (quasiquote . to2ab1) (syntax-rules . to2ab0) (record-constructor-descriptor . to2aad) (record-type-descriptor . to2aac) (case . to2aab) (unless . to2aa9) (when . to2aa8) (or . to2aa7) (and . to2aa6) (if . to2aa5) (let . to2aa4) (letrec* . to2aa3) (letrec . to2aa2) (case-lambda . to2aa0) (lambda . to2a9f) (syntax . to2a9e) (syntax-case . to2a9d) (quote . to2a9c) (letrec-syntax . to2a9a) (let-syntax . to2a99) (set! . to2a98) (begin . to2a96) (define-syntax . to2a94) (define . to2a93)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e50 '(rnrs r5rs) '(6) '() '() '() '((scheme-report-environment . toe4a) (quotient . to2c9c) (null-environment . toe48) (remainder . to2c9b) (modulo . to2c9a) (inexact->exact . to2c99) (force . to2c98) (exact->inexact . to2c97) (make-promise . to2c96) (delay . to2abb)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e51 '(rnrs control) '(6) '() '() '() '((do . to2ab9) (unless . to2aa9) (when . to2aa8) (case-lambda . to2aa0)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e52 '(rnrs eval) '(6) '() '() '() '((eval . toe4e) (environment . toe46)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e53 '(rnrs mutable-pairs) '(6) '() '() '() '((set-cdr! . to2c92) (set-car! . to2c91)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e54 '(rnrs mutable-strings) '(6) '() '() '() '((string-fill! . to2c94) (string-set! . to2c93)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e55 '(rnrs programs) '(6) '() '() '() '((exit . to2c95) (command-line . to2927)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e56 '(rnrs syntax-case) '(6) '() '() '() '((make-variable-transformer . tobb9) (identifier? . toe70) (generate-temporaries . toe5c) (free-identifier=? . toe5e) (syntax->datum . toe74) (datum->syntax . toe72) (bound-identifier=? . toe60) (syntax-violation . toe6e) (unsyntax-splicing . to2ac5) (unsyntax . to2ac4) (_ . to2ac1) (... . to2abe) (with-syntax . to2ab3) (quasisyntax . to2ab2) (syntax . to2a9e) (syntax-case . to2a9d)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e57 '(rnrs files) '(6) '() '() '() '((delete-file . to2d21) (file-exists? . to2d20) (make-i/o-write-error . to2cce) (make-i/o-read-error . to2ccd) (make-i/o-port-error . to2ccc) (make-i/o-invalid-position-error . to2ccb) (make-i/o-filename-error . to2cca) (make-i/o-file-protection-error . to2cc9) (make-i/o-file-is-read-only-error . to2cc8) (make-i/o-file-does-not-exist-error . to2cc7) (make-i/o-file-already-exists-error . to2cc6) (make-i/o-error . to2cc5) (i/o-write-error? . to2cb9) (i/o-read-error? . to2cb8) (i/o-port-error? . to2cb7) (i/o-invalid-position-error? . to2cb6) (i/o-filename-error? . to2cb5) (i/o-file-protection-error? . to2cb4) (i/o-file-is-read-only-error? . to2cb3) (i/o-file-does-not-exist-error? . to2cb2) (i/o-file-already-exists-error? . to2cb1) (i/o-error? . to2cb0) (i/o-error-position . to2caf) (i/o-error-port . to2cae) (i/o-error-filename . to2cad) (&i/o-port . to2af0) (&i/o-file-does-not-exist . to2aef) (&i/o-file-already-exists . to2aee) (&i/o-file-is-read-only . to2aed) (&i/o-file-protection . to2aec) (&i/o-filename . to2aeb) (&i/o-invalid-position . to2aea) (&i/o-write . to2ae9) (&i/o-read . to2ae8) (&i/o . to2ae7)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e58 '(rnrs sorting) '(6) '() '() '() '((vector-sort! . to2d1f) (vector-sort . to2d1e) (list-sort . to2d1d)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e59 '(rnrs base) '(6) '() '() '() '((zero? . to2b97) (vector? . to2b96) (vector-set! . to2b95) (vector-ref . to2b94) (vector-map . to2b93) (vector-length . to2b92) (vector-for-each . to2b91) (vector-fill! . to2b90) (vector->list . to2b8f) (vector . to2b8e) (values . to2b8d) (truncate . to2b8c) (tan . to2b8b) (symbol? . to2b8a) (symbol=? . to2b89) (symbol->string . to2b88) (substring . to2b87) (string? . to2b86) (string>? . to2b85) (string>=? . to2b84) (string=? . to2b83) (string<? . to2b82) (string<=? . to2b81) (string-ref . to2b80) (string-length . to2b7f) (string-for-each . to2b7e) (string-copy . to2b7d) (string-append . to2b7c) (string->symbol . to2b7b) (string->number . to2b7a) (string->list . to2b79) (string . to2b78) (sqrt . to2b77) (sin . to2b76) (round . to2b75) (reverse . to2b74) (real? . to2b73) (real-valued? . to2b72) (real-part . to2b71) (rationalize . to2b70) (rational? . to2b6f) (rational-valued? . to2b6e) (procedure? . to2b6d) (positive? . to2b6c) (pair? . to2b6b) (odd? . to2b6a) (numerator . to2b69) (number? . to2b68) (number->string . to2b67) (null? . to2b66) (not . to2b65) (negative? . to2b64) (nan? . to2b63) (min . to2b62) (max . to2b61) (map . to2b60) (make-vector . to2b5f) (make-string . to2b5e) (make-rectangular . to2b5d) (make-polar . to2b5c) (magnitude . to2b5b) (log . to2b5a) (list? . to2b59) (list-tail . to2b58) (list-ref . to2b57) (list->vector . to2b56) (list->string . to2b55) (list . to2b54) (length . to2b53) (lcm . to2b52) (integer? . to2b51) (integer-valued? . to2b50) (integer->char . to2b4f) (infinite? . to2b4e) (inexact? . to2b4d) (inexact . to2b4c) (imag-part . to2b4b) (gcd . to2b4a) (for-each . to2b49) (floor . to2b48) (finite? . to2b47) (expt . to2b46) (exp . to2b45) (exact? . to2b44) (exact-integer-sqrt . to2b43) (exact . to2b42) (even? . to2b41) (error . to2b40) (eqv? . to2b3f) (equal? . to2b3e) (eq? . to2b3d) (dynamic-wind . to2b3c) (div0-and-mod0 . to2b3b) (mod0 . to2b3a) (div0 . to2b39) (div-and-mod . to2b38) (mod . to2b37) (div . to2b36) (denominator . to2b35) (cos . to2b34) (cons . to2b33) (complex? . to2b32) (char? . to2b31) (char>? . to2b30) (char>=? . to2b2f) (char=? . to2b2e) (char<? . to2b2d) (char<=? . to2b2c) (char->integer . to2b2b) (ceiling . to2b2a) (call-with-values . to2b29) (call/cc . to2b28) (call-with-current-continuation . to2b27) (cddddr . to2b26) (cdddar . to2b25) (cddadr . to2b24) (cddaar . to2b23) (cdaddr . to2b22) (cdadar . to2b21) (cdaadr . to2b20) (cdaaar . to2b1f) (cadddr . to2b1e) (caddar . to2b1d) (cadadr . to2b1c) (cadaar . to2b1b) (caaddr . to2b1a) (caadar . to2b19) (caaadr . to2b18) (caaaar . to2b17) (cdddr . to2b16) (cddar . to2b15) (cdadr . to2b14) (cdaar . to2b13) (caddr . to2b12) (cadar . to2b11) (caadr . to2b10) (caaar . to2b0f) (cddr . to2b0e) (cdar . to2b0d) (cadr . to2b0c) (caar . to2b0b) (cdr . to2b0a) (car . to2b09) (boolean? . to2b08) (boolean=? . to2b07) (atan . to2b06) (assertion-violation . to2b05) (asin . to2b04) (apply . to2b03) (append . to2b02) (angle . to2b01) (acos . to2b00) (abs . to2aff) (/ . to2afe) (* . to2afd) (- . to2afc) (+ . to2afb) (>= . to2afa) (> . to2af9) (= . to2af8) (<= . to2af7) (< . to2af6) (unquote-splicing . to2ac3) (unquote . to2ac2) (_ . to2ac1) (else . to2ac0) (=> . to2abf) (... . to2abe) (assert . to2abd) (cond . to2ab8) (let* . to2ab7) (let*-values . to2ab6) (let-values . to2ab5) (identifier-syntax . to2ab4) (quasiquote . to2ab1) (syntax-rules . to2ab0) (case . to2aab) (or . to2aa7) (and . to2aa6) (if . to2aa5) (let . to2aa4) (letrec* . to2aa3) (letrec . to2aa2) (lambda . to2a9f) (quote . to2a9c) (letrec-syntax . to2a9a) (let-syntax . to2a99) (set! . to2a98) (begin . to2a96) (define-syntax . to2a94) (define . to2a93)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e5a '(rnrs lists) '(6) '() '() '() '((remove . to2c90) (remv . to2c8f) (remp . to2c8e) (remq . to2c8d) (partition . to2c8c) (memv . to2c8b) (memq . to2c8a) (memp . to2c89) (member . to2c88) (exists . to2c87) (for-all . to2c86) (fold-right . to2c85) (fold-left . to2c84) (find . to2c83) (filter . to2c82) (cons* . to2c81) (assv . to2c80) (assq . to2c7f) (assp . to2c7e) (assoc . to2c7d)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e5b '(rnrs io simple) '(6) '() '() '() '((call-with-output-file . to2d07) (call-with-input-file . to2d06) (write-char . to2d05) (write . to2d04) (with-output-to-file . to2d03) (with-input-from-file . to2d02) (read-char . to2d01) (read . to2d00) (peek-char . to2cff) (open-output-file . to2cfe) (open-input-file . to2cfd) (newline . to2cfc) (display . to2cfb) (close-output-port . to2cfa) (close-input-port . to2cf9) (eof-object? . to2cf8) (eof-object . to2cf7) (current-error-port . to2cf6) (current-output-port . to2cf5) (current-input-port . to2cf4) (output-port? . to2cf3) (input-port? . to2cf2) (make-i/o-write-error . to2cce) (make-i/o-read-error . to2ccd) (make-i/o-port-error . to2ccc) (make-i/o-invalid-position-error . to2ccb) (make-i/o-filename-error . to2cca) (make-i/o-file-protection-error . to2cc9) (make-i/o-file-is-read-only-error . to2cc8) (make-i/o-file-does-not-exist-error . to2cc7) (make-i/o-file-already-exists-error . to2cc6) (make-i/o-error . to2cc5) (i/o-write-error? . to2cb9) (i/o-read-error? . to2cb8) (i/o-port-error? . to2cb7) (i/o-invalid-position-error? . to2cb6) (i/o-filename-error? . to2cb5) (i/o-file-protection-error? . to2cb4) (i/o-file-is-read-only-error? . to2cb3) (i/o-file-does-not-exist-error? . to2cb2) (i/o-file-already-exists-error? . to2cb1) (i/o-error? . to2cb0) (i/o-error-position . to2caf) (i/o-error-port . to2cae) (i/o-error-filename . to2cad) (&i/o-port . to2af0) (&i/o-file-does-not-exist . to2aef) (&i/o-file-already-exists . to2aee) (&i/o-file-is-read-only . to2aed) (&i/o-file-protection . to2aec) (&i/o-filename . to2aeb) (&i/o-invalid-position . to2aea) (&i/o-write . to2ae9) (&i/o-read . to2ae8) (&i/o . to2ae7)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e5c '(rnrs bytevectors) '(6) '() '() '() '((make-bytevector . to2cbc) (utf32->string . to2c42) (utf16->string . to2c41) (utf8->string . to2c40) (uint-list->bytevector . to2c3f) (u8-list->bytevector . to2c3e) (string->utf8 . to2c3d) (string->utf32 . to2c3c) (string->utf16 . to2c3b) (sint-list->bytevector . to2c3a) (native-endianness . to2c39) (bytevector? . to2c38) (bytevector=? . to2c37) (bytevector-uint-set! . to2c36) (bytevector-uint-ref . to2c35) (bytevector-u8-set! . to2c34) (bytevector-u8-ref . to2c33) (bytevector-u64-set! . to2c32) (bytevector-u64-ref . to2c31) (bytevector-u64-native-set! . to2c30) (bytevector-u64-native-ref . to2c2f) (bytevector-u32-set! . to2c2e) (bytevector-u32-ref . to2c2d) (bytevector-u32-native-set! . to2c2c) (bytevector-u32-native-ref . to2c2b) (bytevector-u16-set! . to2c2a) (bytevector-u16-ref . to2c29) (bytevector-u16-native-set! . to2c28) (bytevector-u16-native-ref . to2c27) (bytevector-sint-set! . to2c26) (bytevector-sint-ref . to2c25) (bytevector-s8-set! . to2c24) (bytevector-s8-ref . to2c23) (bytevector-s64-set! . to2c22) (bytevector-s64-ref . to2c21) (bytevector-s64-native-set! . to2c20) (bytevector-s64-native-ref . to2c1f) (bytevector-s32-set! . to2c1e) (bytevector-s32-ref . to2c1d) (bytevector-s32-native-set! . to2c1c) (bytevector-s32-native-ref . to2c1b) (bytevector-s16-set! . to2c1a) (bytevector-s16-ref . to2c19) (bytevector-s16-native-set! . to2c18) (bytevector-s16-native-ref . to2c17) (bytevector-length . to2c16) (bytevector-ieee-single-ref . to2c15) (bytevector-ieee-single-set! . to2c14) (bytevector-ieee-single-native-set! . to2c13) (bytevector-ieee-single-native-ref . to2c12) (bytevector-ieee-double-set! . to2c11) (bytevector-ieee-double-ref . to2c10) (bytevector-ieee-double-native-set! . to2c0f) (bytevector-ieee-double-native-ref . to2c0e) (bytevector-fill! . to2c0d) (bytevector-copy! . to2c0c) (bytevector-copy . to2c0b) (bytevector->uint-list . to2c0a) (bytevector->u8-list . to2c09) (bytevector->sint-list . to2c08) (endianness . to2abc)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e5d '(rnrs unicode) '(6) '() '() '() '((string-upcase . to2d4f) (string-titlecase . to2d4e) (string-normalize-nfkd . to2d4d) (string-normalize-nfkc . to2d4c) (string-normalize-nfd . to2d4b) (string-normalize-nfc . to2d4a) (string-foldcase . to2d49) (string-downcase . to2d48) (string-ci>? . to2d47) (string-ci>=? . to2d46) (string-ci=? . to2d45) (string-ci<? . to2d44) (string-ci<=? . to2d43) (char-whitespace? . to2d42) (char-upper-case? . to2d41) (char-title-case? . to2d40) (char-numeric? . to2d3f) (char-lower-case? . to2d3e) (char-general-category . to2d3d) (char-upcase . to2d3c) (char-titlecase . to2d3b) (char-foldcase . to2d3a) (char-downcase . to2d39) (char-ci>? . to2d38) (char-ci>=? . to2d37) (char-ci=? . to2d36) (char-ci<? . to2d35) (char-ci<=? . to2d34) (char-alphabetic? . to2d33)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e5e '(rnrs exceptions) '(6) '() '() '() '((with-exception-handler . to2c76) (raise-continuable . to2c75) (raise . to2c74) (guard . to2ac8) (else . to2ac0) (=> . to2abf)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e5f '(rnrs arithmetic bitwise) '(6) '() '() '() '((bitwise-rotate-bit-field . to2ba8) (bitwise-reverse-bit-field . to2ba7) (bitwise-length . to2ba6) (bitwise-if . to2ba5) (bitwise-first-bit-set . to2ba4) (bitwise-copy-bit-field . to2ba3) (bitwise-copy-bit . to2ba2) (bitwise-bit-set? . to2ba1) (bitwise-bit-field . to2ba0) (bitwise-bit-count . to2b9f) (bitwise-xor . to2b9e) (bitwise-ior . to2b9d) (bitwise-and . to2b9c) (bitwise-not . to2b9b) (bitwise-arithmetic-shift-right . to2b9a) (bitwise-arithmetic-shift-left . to2b99) (bitwise-arithmetic-shift . to2b98)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e60 '(rnrs arithmetic fixnums) '(6) '() '() '() '((fxzero? . to2bd5) (fxxor . to2bd4) (fxrotate-bit-field . to2bd3) (fxreverse-bit-field . to2bd2) (fxpositive? . to2bd1) (fxodd? . to2bd0) (fxnot . to2bcf) (fxnegative? . to2bce) (fxmod0 . to2bcd) (fxmod . to2bcc) (fxmin . to2bcb) (fxmax . to2bca) (fxlength . to2bc9) (fxior . to2bc8) (fxif . to2bc7) (fxfirst-bit-set . to2bc6) (fxeven? . to2bc5) (fxdiv0-and-mod0 . to2bc4) (fxdiv0 . to2bc3) (fxdiv-and-mod . to2bc2) (fxdiv . to2bc1) (fxcopy-bit-field . to2bc0) (fxcopy-bit . to2bbf) (fxbit-set? . to2bbe) (fxbit-field . to2bbd) (fxbit-count . to2bbc) (fxarithmetic-shift-right . to2bbb) (fxarithmetic-shift-left . to2bba) (fxarithmetic-shift . to2bb9) (fxand . to2bb8) (fx>? . to2bb7) (fx>=? . to2bb6) (fx=? . to2bb5) (fx<? . to2bb4) (fx<=? . to2bb3) (fx-/carry . to2bb2) (fx- . to2bb1) (fx+/carry . to2bb0) (fx+ . to2baf) (fx*/carry . to2bae) (fx* . to2bad) (greatest-fixnum . to2bac) (least-fixnum . to2bab) (fixnum-width . to2baa) (fixnum? . to2ba9)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e61 '(rnrs arithmetic flonums) '(6) '() '() '() '((no-nans-violation? . to2c07) (no-infinities-violation? . to2c06) (make-no-nans-violation . to2c05) (make-no-infinities-violation . to2c04) (real->flonum . to2c03) (flzero? . to2c02) (fltruncate . to2c01) (fltan . to2c00) (flsqrt . to2bff) (flsin . to2bfe) (flround . to2bfd) (flpositive? . to2bfc) (flonum? . to2bfb) (flodd? . to2bfa) (flnumerator . to2bf9) (flnegative? . to2bf8) (flnan? . to2bf7) (flmod0 . to2bf6) (flmod . to2bf5) (flmin . to2bf4) (flmax . to2bf3) (fllog . to2bf2) (flinteger? . to2bf1) (flinfinite? . to2bf0) (flfloor . to2bef) (flfinite? . to2bee) (flexpt . to2bed) (flexp . to2bec) (fleven? . to2beb) (fldiv0-and-mod0 . to2bea) (fldiv0 . to2be9) (fldiv-and-mod . to2be8) (fldiv . to2be7) (fldenominator . to2be6) (flcos . to2be5) (flceiling . to2be4) (flatan . to2be3) (flasin . to2be2) (flacos . to2be1) (flabs . to2be0) (fl>? . to2bdf) (fl>=? . to2bde) (fl=? . to2bdd) (fl<? . to2bdc) (fl<=? . to2bdb) (fl/ . to2bda) (fl- . to2bd9) (fl+ . to2bd8) (fl* . to2bd7) (fixnum->flonum . to2bd6) (&no-nans . to2af4) (&no-infinities . to2af3)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e62 '(rnrs hashtables) '(6) '() '() '() '((symbol-hash . to2d1c) (string-ci-hash . to2d1b) (string-hash . to2d1a) (equal-hash . to2d19) (hashtable-equivalence-function . to2d18) (make-hashtable . to2d17) (hashtable-hash-function . to2d16) (make-eqv-hashtable . to2d15) (make-eq-hashtable . to2d14) (hashtable? . to2d13) (hashtable-update! . to2d12) (hashtable-size . to2d11) (hashtable-set! . to2d10) (hashtable-ref . to2d0f) (hashtable-mutable? . to2d0e) (hashtable-keys . to2d0d) (hashtable-entries . to2d0c) (hashtable-delete! . to2d0b) (hashtable-copy . to2d0a) (hashtable-contains? . to2d09) (hashtable-clear! . to2d08)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e63 '(rnrs io ports) '(6) '() '() '() '((eof-object? . to2cf8) (eof-object . to2cf7) (current-error-port . to2cf6) (current-output-port . to2cf5) (current-input-port . to2cf4) (output-port? . to2cf3) (input-port? . to2cf2) (utf-8-codec . to2cf1) (utf-16-codec . to2cf0) (transcoder-error-handling-mode . to2cef) (transcoder-eol-style . to2cee) (transcoder-codec . to2ced) (transcoded-port . to2cec) (textual-port? . to2ceb) (string->bytevector . to2cea) (standard-output-port . to2ce9) (standard-input-port . to2ce8) (standard-error-port . to2ce7) (set-port-position! . to2ce6) (put-u8 . to2ce5) (put-string . to2ce4) (put-datum . to2ce3) (put-char . to2ce2) (put-bytevector . to2ce1) (port? . to2ce0) (port-transcoder . to2cdf) (port-position . to2cde) (port-has-set-port-position!? . to2cdd) (port-has-port-position? . to2cdc) (port-eof? . to2cdb) (output-port-buffer-mode . to2cda) (open-string-output-port . to2cd9) (open-string-input-port . to2cd8) (open-file-output-port . to2cd7) (open-file-input/output-port . to2cd6) (open-file-input-port . to2cd5) (open-bytevector-output-port . to2cd4) (open-bytevector-input-port . to2cd3) (native-transcoder . to2cd2) (native-eol-style . to2cd1) (make-transcoder . to2cd0) (latin-1-codec . to2ccf) (make-i/o-write-error . to2cce) (make-i/o-read-error . to2ccd) (make-i/o-port-error . to2ccc) (make-i/o-invalid-position-error . to2ccb) (make-i/o-filename-error . to2cca) (make-i/o-file-protection-error . to2cc9) (make-i/o-file-is-read-only-error . to2cc8) (make-i/o-file-does-not-exist-error . to2cc7) (make-i/o-file-already-exists-error . to2cc6) (make-i/o-error . to2cc5) (make-i/o-encoding-error . to2cc4) (make-i/o-decoding-error . to2cc3) (make-custom-textual-output-port . to2cc2) (make-custom-textual-input/output-port . to2cc1) (make-custom-textual-input-port . to2cc0) (make-custom-binary-output-port . to2cbf) (make-custom-binary-input/output-port . to2cbe) (make-custom-binary-input-port . to2cbd) (lookahead-u8 . to2cbb) (lookahead-char . to2cba) (i/o-write-error? . to2cb9) (i/o-read-error? . to2cb8) (i/o-port-error? . to2cb7) (i/o-invalid-position-error? . to2cb6) (i/o-filename-error? . to2cb5) (i/o-file-protection-error? . to2cb4) (i/o-file-is-read-only-error? . to2cb3) (i/o-file-does-not-exist-error? . to2cb2) (i/o-file-already-exists-error? . to2cb1) (i/o-error? . to2cb0) (i/o-error-position . to2caf) (i/o-error-port . to2cae) (i/o-error-filename . to2cad) (i/o-encoding-error? . to2cac) (i/o-encoding-error-char . to2cab) (i/o-decoding-error? . to2caa) (get-u8 . to2ca9) (get-string-n! . to2ca8) (get-string-n . to2ca7) (get-string-all . to2ca6) (get-line . to2ca5) (get-datum . to2ca4) (get-char . to2ca3) (get-bytevector-some . to2ca2) (get-bytevector-n! . to2ca1) (get-bytevector-n . to2ca0) (get-bytevector-all . to2c9f) (flush-output-port . to2c9e) (close-port . to2c9d) (call-with-string-output-port . to2c7c) (call-with-port . to2c7b) (call-with-bytevector-output-port . to2c7a) (bytevector->string . to2c79) (buffer-mode? . to2c78) (binary-port? . to2c77) (&i/o-encoding . to2af2) (&i/o-decoding . to2af1) (&i/o-port . to2af0) (&i/o-file-does-not-exist . to2aef) (&i/o-file-already-exists . to2aee) (&i/o-file-is-read-only . to2aed) (&i/o-file-protection . to2aec) (&i/o-filename . to2aeb) (&i/o-invalid-position . to2aea) (&i/o-write . to2ae9) (&i/o-read . to2ae8) (&i/o . to2ae7) (error-handling-mode . to2acc) (file-options . to2acb) (buffer-mode . to2aca) (eol-style . to2ac9)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e64 '(rnrs enums) '(6) '() '() '() '((make-enumeration . to2c73) (enum-set=? . to2c72) (enum-set-universe . to2c71) (enum-set-union . to2c70) (enum-set-subset? . to2c6f) (enum-set-projection . to2c6e) (enum-set-member? . to2c6d) (enum-set-intersection . to2c6c) (enum-set-indexer . to2c6b) (enum-set-difference . to2c6a) (enum-set-constructor . to2c69) (enum-set-complement . to2c68) (enum-set->list . to2c67) (define-enumeration . to2ad7)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e65 '(rnrs conditions) '(6) '() '() '() '((who-condition? . to2c66) (warning? . to2c65) (violation? . to2c64) (undefined-violation? . to2c63) (syntax-violation? . to2c62) (syntax-violation-subform . to2c61) (syntax-violation-form . to2c60) (syntax-violation . toe6e) (simple-conditions . to2c5f) (serious-condition? . to2c5e) (non-continuable-violation? . to2c5d) (message-condition? . to2c5c) (make-who-condition . to2c5b) (make-warning . to2c5a) (make-violation . to2c59) (make-undefined-violation . to2c58) (make-syntax-violation . to2c57) (make-serious-condition . to2c56) (make-non-continuable-violation . to2c55) (make-message-condition . to2c54) (make-lexical-violation . to2c53) (make-irritants-condition . to2c52) (make-implementation-restriction-violation . to2c51) (make-error . to2c50) (make-assertion-violation . to2c4f) (lexical-violation? . to2c4e) (irritants-condition? . to2c4d) (implementation-restriction-violation? . to2c4c) (error? . to2c4b) (condition-who . to2c4a) (condition-predicate . to2c49) (condition-message . to2c48) (condition-irritants . to2c47) (condition-accessor . to2c46) (condition . to2c45) (assertion-violation? . to2c44) (condition? . to2c43) (&undefined . to2ae6) (&syntax . to2ae5) (&lexical . to2ae4) (&implementation-restriction . to2ae3) (&non-continuable . to2ae2) (&who . to2ae1) (&irritants . to2ae0) (&assertion . to2adf) (&violation . to2ade) (&error . to2add) (&serious . to2adc) (&warning . to2adb) (&message . to2ada) (&condition . to2ad9) (define-condition-type . to2ad8)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e66 '(rnrs records inspection) '(6) '() '() '() '((record? . to2d2b) (record-type-uid . to2d2a) (record-type-sealed? . to2d29) (record-type-parent . to2d28) (record-type-opaque? . to2d27) (record-type-name . to2d26) (record-type-generative? . to2d25) (record-type-field-names . to2d24) (record-rtd . to2d23) (record-field-mutable? . to2d22)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e67 '(rnrs records procedural) '(6) '() '() '() '((record-type-descriptor? . to2d32) (record-predicate . to2d31) (record-mutator . to2d30) (record-constructor . to2d2f) (record-accessor . to2d2e) (make-record-type-descriptor . to2d2d) (make-record-constructor-descriptor . to2d2c)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e68 '(rnrs records syntactic) '(6) '() '() '() '((define-record-type . to2ad6) (parent-rtd . to2ad5) (nongenerative . to2ad4) (opaque . to2ad3) (sealed . to2ad2) (protocol . to2ad1) (parent . to2ad0) (immutable . to2acf) (mutable . to2ace) (fields . to2acd) (record-constructor-descriptor . to2aad) (record-type-descriptor . to2aac)) '() values values '#f '#f '#t '#f) (to9a2@to7ee@install-library 'to2e69 '(psyntax system $all) '() '() '() '() '((&no-nans-rcd . to2e49) (&no-nans-rtd . to2e48) (&no-infinities-rcd . to2e47) (&no-infinities-rtd . to2e46) (&i/o-encoding-rcd . to2e45) (&i/o-encoding-rtd . to2e44) (&i/o-decoding-rcd . to2e43) (&i/o-decoding-rtd . to2e42) (&i/o-port-rcd . to2e41) (&i/o-port-rtd . to2e40) (&i/o-file-does-not-exist-rcd . to2e3f) (&i/o-file-does-not-exist-rtd . to2e3e) (&i/o-file-already-exists-rcd . to2e3d) (&i/o-file-already-exists-rtd . to2e3c) (&i/o-file-is-read-only-rcd . to2e3b) (&i/o-file-is-read-only-rtd . to2e3a) (&i/o-file-protection-rcd . to2e39) (&i/o-file-protection-rtd . to2e38) (&i/o-filename-rcd . to2e37) (&i/o-filename-rtd . to2e36) (&i/o-invalid-position-rcd . to2e35) (&i/o-invalid-position-rtd . to2e34) (&i/o-write-rcd . to2e33) (&i/o-write-rtd . to2e32) (&i/o-read-rcd . to2e31) (&i/o-read-rtd . to2e30) (&i/o-rcd . to2e2f) (&i/o-rtd . to2e2e) (&undefined-rcd . to2e2d) (&undefined-rtd . to2e2c) (&syntax-rcd . to2e2b) (&syntax-rtd . to2e2a) (&lexical-rcd . to2e29) (&lexical-rtd . to2e28) (&implementation-restriction-rcd . to2e27) (&implementation-restriction-rtd . to2e26) (&non-continuable-rcd . to2e25) (&non-continuable-rtd . to2e24) (&who-rcd . to2e23) (&who-rtd . to2e22) (&irritants-rcd . to2e21) (&irritants-rtd . to2e20) (&assertion-rcd . to2e1f) (&assertion-rtd . to2e1e) (&violation-rcd . to2e1d) (&violation-rtd . to2e1c) (&error-rcd . to2e1b) (&error-rtd . to2e1a) (&serious-rcd . to2e19) (&serious-rtd . to2e18) (&warning-rcd . to2e17) (&warning-rtd . to2e16) (&message-rcd . to2e15) (&message-rtd . to2e14) (&condition-rcd . to2e13) (&condition-rtd . to2e12) (syntax-error . toe6a) (syntax-dispatch . tod8e) (pretty-print . to2e11) (eval-core . to2e10) (set-symbol-value! . to2e0f) (symbol-value . to2e0e) (gensym . to2e0d) (void . to2e0c) (load . to292d) (interaction-environment . toe7c) (char-ready? . to2e0b) (regexp? . to2e0a) (read-line . to2e09) (gensym-prefix-set! . to2e08) (ungensym . to2e07) (alist->eq-hash-table . to2e06) (assoc-ref . to2e05) (print . to2e04) (format . to2e03) (host-os . to2e02) (library-path . to7cd) (standard-library-path . to2e01) (ssl-supported? . to2e00) (ssl-socket? . to2dff) (socket-sslize! . to2dfe) (%monapi-stream-read . to2dfd) (%monapi-stream-write . to2dfc) (%monapi-stream-handle . to2dfb) (%monapi-make-stream . to2dfa) (%monapi-name-add! . to2df9) (%monapi-message-receive . to2df8) (%monapi-name-whereis . to2df7) (%monapi-message-reply . to2df6) (%monapi-message-send-receive . to2df5) (%monapi-message-send . to2df4) (process-terminate! . to2df3) (process-list . to2df2) (file-newer? . to2df1) (stat-mtime . to2df0) (write-to-file . to2def) (file->list . to2dee) (file->string . to2ded) (digit->integer . to2dec) (call-with-string-input-port . to2deb) (call-with-string-io . to2dea) (string-split . to2de9) (bytevector-for-each . to2de8) (string->regexp . to2de7) (rxmatch . to2de6) (regexp-replace-all . to2de5) (hashtable-fold-left . to2de4) (hashtable-for-each . to2de3) (mosh-cache-dir . to5b7) (%start-process . to2de2) (%call-process . to2de1) (local-tz-offset . to2de0) (microseconds . to2ddf) (directory-list . to2dde) (set-current-directory! . to2ddd) (expand-path . to2ddc) (current-directory . to2ddb) (%getpid . to2dda) (%spawn . to2dd9) (%waitpid . to2dd8) (simple-struct-name . to2dd7) (simple-struct-set! . to2dd6) (simple-struct-ref . to2dd5) (make-simple-struct . to2dd4) (simple-struct? . to2dd3) (pointer-ref-c-int64 . to2dd2) (pointer-ref-c-int32 . to2dd1) (pointer-ref-c-int16 . to2dd0) (pointer-ref-c-int8 . to2dcf) (pointer-ref-c-uint64 . to2dce) (pointer-ref-c-uint32 . to2dcd) (pointer-ref-c-uint16 . to2dcc) (pointer-ref-c-uint8 . to2dcb) (pointer-set-c-uint64! . to2dca) (pointer-set-c-uint32! . to2dc9) (pointer-set-c-uint16! . to2dc8) (pointer-set-c-uint8! . to2dc7) (pointer-set-c-int64! . to2dc6) (pointer-set-c-int32! . to2dc5) (pointer-set-c-int16! . to2dc4) (pointer-set-c-int8! . to2dc3) (pointer-set-c-pointer! . to2dc2) (pointer-set-c-double! . to2dc1) (pointer-set-c-float! . to2dc0) (pointer-set-c-long-long! . to2dbf) (pointer-set-c-long! . to2dbe) (pointer-set-c-int! . to2dbd) (pointer-set-c-short! . to2dbc) (pointer-set-c-char! . to2dbb) (pointer-ref-c-pointer . to2dba) (pointer-ref-c-double . to2db9) (pointer-ref-c-float . to2db8) (pointer-ref-c-unsigned-long-long . to2db7) (pointer-ref-c-signed-long-long . to2db6) (pointer-ref-c-unsigned-long . to2db5) (pointer-ref-c-signed-long . to2db4) (pointer-ref-c-unsigned-int . to2db3) (pointer-ref-c-signed-int . to2db2) (pointer-ref-c-unsigned-short . to2db1) (pointer-ref-c-signed-short . to2db0) (pointer-ref-c-unsigned-char . to2daf) (pointer-ref-c-signed-char . to2dae) (pointer->integer . to2dad) (integer->pointer . to2dac) (pointer? . to2dab) (shared-errno . to2daa) (%ffi-free-c-callback-trampoline . to2da9) (%ffi-make-c-callback-trampoline . to2da8) (%ffi-free . to2da7) (%ffi-malloc . to2da6) (%ffi-supported? . to2da5) (%ffi-pointer->string . to2da4) (%ffi-call . to2da3) (%ffi-lookup . to2da2) (%ffi-open . to2da1) (null-terminated-utf8->string . to2da0) (null-terminated-bytevector->string . to2d9f) (%exec . to2d9e) (%fork . to2d9d) (%pipe . to2d9c) (p . to2d9b) (open-output-string . to2d9a) (get-output-string . to2d99) (file-stat-ctime . to2d98) (file-stat-atime . to2d97) (file-stat-mtime . to2d96) (file-size-in-bytes . to2d95) (file-writable? . to2d94) (file-executable? . to2d93) (file-readable? . to2d92) (file-regular? . to2d91) (file-symbolic-link? . to2d90) (file-directory? . to2d8f) (create-symbolic-link . to2d8e) (rename-file . to2d8d) (delete-directory . to2d8c) (create-directory . to2d8b) (create-mosh-cache-dir . to2d8a) (get-environment-variables . to2d89) (current-exception-handler . to2d88) (get-environment-variable . to2d87) (join-wraps . to2d86) (id->real-label . to2d85) (same-marks? . to2d84) (same-marks*? . to2d83) (get-timeofday . to2d82) (get-command-line . to2d81) (sys-display . to2d80) (whereis . to2d7f) (register . to2d7e) (vm-join! . to2d7d) (vm-set-value! . to2d7c) (vm? . to2d7b) (main-vm? . to2d7a) (vm-eval . to2d79) (vm-self . to2d78) (vm-start! . to2d77) (make-vm . to2d76) (mutex-try-lock! . to2d75) (mutex-unlock! . to2d74) (mutex-lock! . to2d73) (mutex? . to2d72) (make-mutex . to2d71) (condition-variable-notify-all! . to2d70) (condition-variable-notify! . to2d6f) (condition-variable-wait! . to2d6e) (make-condition-variable . to2d6d) (write/ss . to2d6c) (mosh-executable-path . to2d6b) (make-file-options . to2d6a) (source-info . to2d69) (make-compiler-instruction . to2d68) (make-instruction . to2d67) (set-annotation! . to2d66) (get-annotation . to2d65) (annotated-pair? . to2d64) (annotated-cons . to2d63) (set-source-info! . to2d62) (bignum? . to2d61) (fast-equal? . to2d60) (fasl-read . to2d5f) (fasl-write . to2d5e) (time-usage . to2d5d) (os-constant . to2d5c) (condition-printer . to2d5b) (disasm . to2d5a) (make-parameter . to5b5) (socket-port . to2d59) (socket-shutdown . to2d58) (socket-close . to2d57) (socket-send . to2d56) (socket-recv! . to2d55) (socket-recv . to2d54) (make-server-socket . to2d53) (make-client-socket . to2d52) (socket-accept . to2d51) (socket? . to2d50) (string-upcase . to2d4f) (string-titlecase . to2d4e) (string-normalize-nfkd . to2d4d) (string-normalize-nfkc . to2d4c) (string-normalize-nfd . to2d4b) (string-normalize-nfc . to2d4a) (string-foldcase . to2d49) (string-downcase . to2d48) (string-ci>? . to2d47) (string-ci>=? . to2d46) (string-ci=? . to2d45) (string-ci<? . to2d44) (string-ci<=? . to2d43) (char-whitespace? . to2d42) (char-upper-case? . to2d41) (char-title-case? . to2d40) (char-numeric? . to2d3f) (char-lower-case? . to2d3e) (char-general-category . to2d3d) (char-upcase . to2d3c) (char-titlecase . to2d3b) (char-foldcase . to2d3a) (char-downcase . to2d39) (char-ci>? . to2d38) (char-ci>=? . to2d37) (char-ci=? . to2d36) (char-ci<? . to2d35) (char-ci<=? . to2d34) (char-alphabetic? . to2d33) (make-variable-transformer . tobb9) (identifier? . toe70) (generate-temporaries . toe5c) (free-identifier=? . toe5e) (syntax->datum . toe74) (datum->syntax . toe72) (bound-identifier=? . toe60) (record-type-descriptor? . to2d32) (record-predicate . to2d31) (record-mutator . to2d30) (record-constructor . to2d2f) (record-accessor . to2d2e) (make-record-type-descriptor . to2d2d) (make-record-constructor-descriptor . to2d2c) (record? . to2d2b) (record-type-uid . to2d2a) (record-type-sealed? . to2d29) (record-type-parent . to2d28) (record-type-opaque? . to2d27) (record-type-name . to2d26) (record-type-generative? . to2d25) (record-type-field-names . to2d24) (record-rtd . to2d23) (record-field-mutable? . to2d22) (delete-file . to2d21) (file-exists? . to2d20) (vector-sort! . to2d1f) (vector-sort . to2d1e) (list-sort . to2d1d) (symbol-hash . to2d1c) (string-ci-hash . to2d1b) (string-hash . to2d1a) (equal-hash . to2d19) (hashtable-equivalence-function . to2d18) (make-hashtable . to2d17) (hashtable-hash-function . to2d16) (make-eqv-hashtable . to2d15) (make-eq-hashtable . to2d14) (hashtable? . to2d13) (hashtable-update! . to2d12) (hashtable-size . to2d11) (hashtable-set! . to2d10) (hashtable-ref . to2d0f) (hashtable-mutable? . to2d0e) (hashtable-keys . to2d0d) (hashtable-entries . to2d0c) (hashtable-delete! . to2d0b) (hashtable-copy . to2d0a) (hashtable-contains? . to2d09) (hashtable-clear! . to2d08) (call-with-output-file . to2d07) (call-with-input-file . to2d06) (write-char . to2d05) (write . to2d04) (with-output-to-file . to2d03) (with-input-from-file . to2d02) (read-char . to2d01) (read . to2d00) (peek-char . to2cff) (open-output-file . to2cfe) (open-input-file . to2cfd) (newline . to2cfc) (display . to2cfb) (close-output-port . to2cfa) (close-input-port . to2cf9) (eof-object? . to2cf8) (eof-object . to2cf7) (current-error-port . to2cf6) (current-output-port . to2cf5) (current-input-port . to2cf4) (output-port? . to2cf3) (input-port? . to2cf2) (utf-8-codec . to2cf1) (utf-16-codec . to2cf0) (transcoder-error-handling-mode . to2cef) (transcoder-eol-style . to2cee) (transcoder-codec . to2ced) (transcoded-port . to2cec) (textual-port? . to2ceb) (string->bytevector . to2cea) (standard-output-port . to2ce9) (standard-input-port . to2ce8) (standard-error-port . to2ce7) (set-port-position! . to2ce6) (put-u8 . to2ce5) (put-string . to2ce4) (put-datum . to2ce3) (put-char . to2ce2) (put-bytevector . to2ce1) (port? . to2ce0) (port-transcoder . to2cdf) (port-position . to2cde) (port-has-set-port-position!? . to2cdd) (port-has-port-position? . to2cdc) (port-eof? . to2cdb) (output-port-buffer-mode . to2cda) (open-string-output-port . to2cd9) (open-string-input-port . to2cd8) (open-file-output-port . to2cd7) (open-file-input/output-port . to2cd6) (open-file-input-port . to2cd5) (open-bytevector-output-port . to2cd4) (open-bytevector-input-port . to2cd3) (native-transcoder . to2cd2) (native-eol-style . to2cd1) (make-transcoder . to2cd0) (latin-1-codec . to2ccf) (make-i/o-write-error . to2cce) (make-i/o-read-error . to2ccd) (make-i/o-port-error . to2ccc) (make-i/o-invalid-position-error . to2ccb) (make-i/o-filename-error . to2cca) (make-i/o-file-protection-error . to2cc9) (make-i/o-file-is-read-only-error . to2cc8) (make-i/o-file-does-not-exist-error . to2cc7) (make-i/o-file-already-exists-error . to2cc6) (make-i/o-error . to2cc5) (make-i/o-encoding-error . to2cc4) (make-i/o-decoding-error . to2cc3) (make-custom-textual-output-port . to2cc2) (make-custom-textual-input/output-port . to2cc1) (make-custom-textual-input-port . to2cc0) (make-custom-binary-output-port . to2cbf) (make-custom-binary-input/output-port . to2cbe) (make-custom-binary-input-port . to2cbd) (make-bytevector . to2cbc) (lookahead-u8 . to2cbb) (lookahead-char . to2cba) (i/o-write-error? . to2cb9) (i/o-read-error? . to2cb8) (i/o-port-error? . to2cb7) (i/o-invalid-position-error? . to2cb6) (i/o-filename-error? . to2cb5) (i/o-file-protection-error? . to2cb4) (i/o-file-is-read-only-error? . to2cb3) (i/o-file-does-not-exist-error? . to2cb2) (i/o-file-already-exists-error? . to2cb1) (i/o-error? . to2cb0) (i/o-error-position . to2caf) (i/o-error-port . to2cae) (i/o-error-filename . to2cad) (i/o-encoding-error? . to2cac) (i/o-encoding-error-char . to2cab) (i/o-decoding-error? . to2caa) (get-u8 . to2ca9) (get-string-n! . to2ca8) (get-string-n . to2ca7) (get-string-all . to2ca6) (get-line . to2ca5) (get-datum . to2ca4) (get-char . to2ca3) (get-bytevector-some . to2ca2) (get-bytevector-n! . to2ca1) (get-bytevector-n . to2ca0) (get-bytevector-all . to2c9f) (flush-output-port . to2c9e) (close-port . to2c9d) (scheme-report-environment . toe4a) (quotient . to2c9c) (null-environment . toe48) (remainder . to2c9b) (modulo . to2c9a) (inexact->exact . to2c99) (force . to2c98) (exact->inexact . to2c97) (make-promise . to2c96) (exit . to2c95) (command-line . to2927) (string-fill! . to2c94) (string-set! . to2c93) (set-cdr! . to2c92) (set-car! . to2c91) (remove . to2c90) (remv . to2c8f) (remp . to2c8e) (remq . to2c8d) (partition . to2c8c) (memv . to2c8b) (memq . to2c8a) (memp . to2c89) (member . to2c88) (exists . to2c87) (for-all . to2c86) (fold-right . to2c85) (fold-left . to2c84) (find . to2c83) (filter . to2c82) (cons* . to2c81) (assv . to2c80) (assq . to2c7f) (assp . to2c7e) (assoc . to2c7d) (call-with-string-output-port . to2c7c) (call-with-port . to2c7b) (call-with-bytevector-output-port . to2c7a) (bytevector->string . to2c79) (buffer-mode? . to2c78) (binary-port? . to2c77) (with-exception-handler . to2c76) (raise-continuable . to2c75) (raise . to2c74) (eval . toe4e) (environment . toe46) (make-enumeration . to2c73) (enum-set=? . to2c72) (enum-set-universe . to2c71) (enum-set-union . to2c70) (enum-set-subset? . to2c6f) (enum-set-projection . to2c6e) (enum-set-member? . to2c6d) (enum-set-intersection . to2c6c) (enum-set-indexer . to2c6b) (enum-set-difference . to2c6a) (enum-set-constructor . to2c69) (enum-set-complement . to2c68) (enum-set->list . to2c67) (who-condition? . to2c66) (warning? . to2c65) (violation? . to2c64) (undefined-violation? . to2c63) (syntax-violation? . to2c62) (syntax-violation-subform . to2c61) (syntax-violation-form . to2c60) (syntax-violation . toe6e) (simple-conditions . to2c5f) (serious-condition? . to2c5e) (non-continuable-violation? . to2c5d) (message-condition? . to2c5c) (make-who-condition . to2c5b) (make-warning . to2c5a) (make-violation . to2c59) (make-undefined-violation . to2c58) (make-syntax-violation . to2c57) (make-serious-condition . to2c56) (make-non-continuable-violation . to2c55) (make-message-condition . to2c54) (make-lexical-violation . to2c53) (make-irritants-condition . to2c52) (make-implementation-restriction-violation . to2c51) (make-error . to2c50) (make-assertion-violation . to2c4f) (lexical-violation? . to2c4e) (irritants-condition? . to2c4d) (implementation-restriction-violation? . to2c4c) (error? . to2c4b) (condition-who . to2c4a) (condition-predicate . to2c49) (condition-message . to2c48) (condition-irritants . to2c47) (condition-accessor . to2c46) (condition . to2c45) (assertion-violation? . to2c44) (condition? . to2c43) (utf32->string . to2c42) (utf16->string . to2c41) (utf8->string . to2c40) (uint-list->bytevector . to2c3f) (u8-list->bytevector . to2c3e) (string->utf8 . to2c3d) (string->utf32 . to2c3c) (string->utf16 . to2c3b) (sint-list->bytevector . to2c3a) (native-endianness . to2c39) (bytevector? . to2c38) (bytevector=? . to2c37) (bytevector-uint-set! . to2c36) (bytevector-uint-ref . to2c35) (bytevector-u8-set! . to2c34) (bytevector-u8-ref . to2c33) (bytevector-u64-set! . to2c32) (bytevector-u64-ref . to2c31) (bytevector-u64-native-set! . to2c30) (bytevector-u64-native-ref . to2c2f) (bytevector-u32-set! . to2c2e) (bytevector-u32-ref . to2c2d) (bytevector-u32-native-set! . to2c2c) (bytevector-u32-native-ref . to2c2b) (bytevector-u16-set! . to2c2a) (bytevector-u16-ref . to2c29) (bytevector-u16-native-set! . to2c28) (bytevector-u16-native-ref . to2c27) (bytevector-sint-set! . to2c26) (bytevector-sint-ref . to2c25) (bytevector-s8-set! . to2c24) (bytevector-s8-ref . to2c23) (bytevector-s64-set! . to2c22) (bytevector-s64-ref . to2c21) (bytevector-s64-native-set! . to2c20) (bytevector-s64-native-ref . to2c1f) (bytevector-s32-set! . to2c1e) (bytevector-s32-ref . to2c1d) (bytevector-s32-native-set! . to2c1c) (bytevector-s32-native-ref . to2c1b) (bytevector-s16-set! . to2c1a) (bytevector-s16-ref . to2c19) (bytevector-s16-native-set! . to2c18) (bytevector-s16-native-ref . to2c17) (bytevector-length . to2c16) (bytevector-ieee-single-ref . to2c15) (bytevector-ieee-single-set! . to2c14) (bytevector-ieee-single-native-set! . to2c13) (bytevector-ieee-single-native-ref . to2c12) (bytevector-ieee-double-set! . to2c11) (bytevector-ieee-double-ref . to2c10) (bytevector-ieee-double-native-set! . to2c0f) (bytevector-ieee-double-native-ref . to2c0e) (bytevector-fill! . to2c0d) (bytevector-copy! . to2c0c) (bytevector-copy . to2c0b) (bytevector->uint-list . to2c0a) (bytevector->u8-list . to2c09) (bytevector->sint-list . to2c08) (no-nans-violation? . to2c07) (no-infinities-violation? . to2c06) (make-no-nans-violation . to2c05) (make-no-infinities-violation . to2c04) (real->flonum . to2c03) (flzero? . to2c02) (fltruncate . to2c01) (fltan . to2c00) (flsqrt . to2bff) (flsin . to2bfe) (flround . to2bfd) (flpositive? . to2bfc) (flonum? . to2bfb) (flodd? . to2bfa) (flnumerator . to2bf9) (flnegative? . to2bf8) (flnan? . to2bf7) (flmod0 . to2bf6) (flmod . to2bf5) (flmin . to2bf4) (flmax . to2bf3) (fllog . to2bf2) (flinteger? . to2bf1) (flinfinite? . to2bf0) (flfloor . to2bef) (flfinite? . to2bee) (flexpt . to2bed) (flexp . to2bec) (fleven? . to2beb) (fldiv0-and-mod0 . to2bea) (fldiv0 . to2be9) (fldiv-and-mod . to2be8) (fldiv . to2be7) (fldenominator . to2be6) (flcos . to2be5) (flceiling . to2be4) (flatan . to2be3) (flasin . to2be2) (flacos . to2be1) (flabs . to2be0) (fl>? . to2bdf) (fl>=? . to2bde) (fl=? . to2bdd) (fl<? . to2bdc) (fl<=? . to2bdb) (fl/ . to2bda) (fl- . to2bd9) (fl+ . to2bd8) (fl* . to2bd7) (fixnum->flonum . to2bd6) (fxzero? . to2bd5) (fxxor . to2bd4) (fxrotate-bit-field . to2bd3) (fxreverse-bit-field . to2bd2) (fxpositive? . to2bd1) (fxodd? . to2bd0) (fxnot . to2bcf) (fxnegative? . to2bce) (fxmod0 . to2bcd) (fxmod . to2bcc) (fxmin . to2bcb) (fxmax . to2bca) (fxlength . to2bc9) (fxior . to2bc8) (fxif . to2bc7) (fxfirst-bit-set . to2bc6) (fxeven? . to2bc5) (fxdiv0-and-mod0 . to2bc4) (fxdiv0 . to2bc3) (fxdiv-and-mod . to2bc2) (fxdiv . to2bc1) (fxcopy-bit-field . to2bc0) (fxcopy-bit . to2bbf) (fxbit-set? . to2bbe) (fxbit-field . to2bbd) (fxbit-count . to2bbc) (fxarithmetic-shift-right . to2bbb) (fxarithmetic-shift-left . to2bba) (fxarithmetic-shift . to2bb9) (fxand . to2bb8) (fx>? . to2bb7) (fx>=? . to2bb6) (fx=? . to2bb5) (fx<? . to2bb4) (fx<=? . to2bb3) (fx-/carry . to2bb2) (fx- . to2bb1) (fx+/carry . to2bb0) (fx+ . to2baf) (fx*/carry . to2bae) (fx* . to2bad) (greatest-fixnum . to2bac) (least-fixnum . to2bab) (fixnum-width . to2baa) (fixnum? . to2ba9) (bitwise-rotate-bit-field . to2ba8) (bitwise-reverse-bit-field . to2ba7) (bitwise-length . to2ba6) (bitwise-if . to2ba5) (bitwise-first-bit-set . to2ba4) (bitwise-copy-bit-field . to2ba3) (bitwise-copy-bit . to2ba2) (bitwise-bit-set? . to2ba1) (bitwise-bit-field . to2ba0) (bitwise-bit-count . to2b9f) (bitwise-xor . to2b9e) (bitwise-ior . to2b9d) (bitwise-and . to2b9c) (bitwise-not . to2b9b) (bitwise-arithmetic-shift-right . to2b9a) (bitwise-arithmetic-shift-left . to2b99) (bitwise-arithmetic-shift . to2b98) (zero? . to2b97) (vector? . to2b96) (vector-set! . to2b95) (vector-ref . to2b94) (vector-map . to2b93) (vector-length . to2b92) (vector-for-each . to2b91) (vector-fill! . to2b90) (vector->list . to2b8f) (vector . to2b8e) (values . to2b8d) (truncate . to2b8c) (tan . to2b8b) (symbol? . to2b8a) (symbol=? . to2b89) (symbol->string . to2b88) (substring . to2b87) (string? . to2b86) (string>? . to2b85) (string>=? . to2b84) (string=? . to2b83) (string<? . to2b82) (string<=? . to2b81) (string-ref . to2b80) (string-length . to2b7f) (string-for-each . to2b7e) (string-copy . to2b7d) (string-append . to2b7c) (string->symbol . to2b7b) (string->number . to2b7a) (string->list . to2b79) (string . to2b78) (sqrt . to2b77) (sin . to2b76) (round . to2b75) (reverse . to2b74) (real? . to2b73) (real-valued? . to2b72) (real-part . to2b71) (rationalize . to2b70) (rational? . to2b6f) (rational-valued? . to2b6e) (procedure? . to2b6d) (positive? . to2b6c) (pair? . to2b6b) (odd? . to2b6a) (numerator . to2b69) (number? . to2b68) (number->string . to2b67) (null? . to2b66) (not . to2b65) (negative? . to2b64) (nan? . to2b63) (min . to2b62) (max . to2b61) (map . to2b60) (make-vector . to2b5f) (make-string . to2b5e) (make-rectangular . to2b5d) (make-polar . to2b5c) (magnitude . to2b5b) (log . to2b5a) (list? . to2b59) (list-tail . to2b58) (list-ref . to2b57) (list->vector . to2b56) (list->string . to2b55) (list . to2b54) (length . to2b53) (lcm . to2b52) (integer? . to2b51) (integer-valued? . to2b50) (integer->char . to2b4f) (infinite? . to2b4e) (inexact? . to2b4d) (inexact . to2b4c) (imag-part . to2b4b) (gcd . to2b4a) (for-each . to2b49) (floor . to2b48) (finite? . to2b47) (expt . to2b46) (exp . to2b45) (exact? . to2b44) (exact-integer-sqrt . to2b43) (exact . to2b42) (even? . to2b41) (error . to2b40) (eqv? . to2b3f) (equal? . to2b3e) (eq? . to2b3d) (dynamic-wind . to2b3c) (div0-and-mod0 . to2b3b) (mod0 . to2b3a) (div0 . to2b39) (div-and-mod . to2b38) (mod . to2b37) (div . to2b36) (denominator . to2b35) (cos . to2b34) (cons . to2b33) (complex? . to2b32) (char? . to2b31) (char>? . to2b30) (char>=? . to2b2f) (char=? . to2b2e) (char<? . to2b2d) (char<=? . to2b2c) (char->integer . to2b2b) (ceiling . to2b2a) (call-with-values . to2b29) (call/cc . to2b28) (call-with-current-continuation . to2b27) (cddddr . to2b26) (cdddar . to2b25) (cddadr . to2b24) (cddaar . to2b23) (cdaddr . to2b22) (cdadar . to2b21) (cdaadr . to2b20) (cdaaar . to2b1f) (cadddr . to2b1e) (caddar . to2b1d) (cadadr . to2b1c) (cadaar . to2b1b) (caaddr . to2b1a) (caadar . to2b19) (caaadr . to2b18) (caaaar . to2b17) (cdddr . to2b16) (cddar . to2b15) (cdadr . to2b14) (cdaar . to2b13) (caddr . to2b12) (cadar . to2b11) (caadr . to2b10) (caaar . to2b0f) (cddr . to2b0e) (cdar . to2b0d) (cadr . to2b0c) (caar . to2b0b) (cdr . to2b0a) (car . to2b09) (boolean? . to2b08) (boolean=? . to2b07) (atan . to2b06) (assertion-violation . to2b05) (assertion-error . toe68) (asin . to2b04) (apply . to2b03) (append . to2b02) (angle . to2b01) (acos . to2b00) (abs . to2aff) (/ . to2afe) (* . to2afd) (- . to2afc) (+ . to2afb) (>= . to2afa) (> . to2af9) (= . to2af8) (<= . to2af7) (< . to2af6) (library . to2af5) (&no-nans . to2af4) (&no-infinities . to2af3) (&i/o-encoding . to2af2) (&i/o-decoding . to2af1) (&i/o-port . to2af0) (&i/o-file-does-not-exist . to2aef) (&i/o-file-already-exists . to2aee) (&i/o-file-is-read-only . to2aed) (&i/o-file-protection . to2aec) (&i/o-filename . to2aeb) (&i/o-invalid-position . to2aea) (&i/o-write . to2ae9) (&i/o-read . to2ae8) (&i/o . to2ae7) (&undefined . to2ae6) (&syntax . to2ae5) (&lexical . to2ae4) (&implementation-restriction . to2ae3) (&non-continuable . to2ae2) (&who . to2ae1) (&irritants . to2ae0) (&assertion . to2adf) (&violation . to2ade) (&error . to2add) (&serious . to2adc) (&warning . to2adb) (&message . to2ada) (&condition . to2ad9) (define-condition-type . to2ad8) (define-enumeration . to2ad7) (define-record-type . to2ad6) (parent-rtd . to2ad5) (nongenerative . to2ad4) (opaque . to2ad3) (sealed . to2ad2) (protocol . to2ad1) (parent . to2ad0) (immutable . to2acf) (mutable . to2ace) (fields . to2acd) (error-handling-mode . to2acc) (file-options . to2acb) (buffer-mode . to2aca) (eol-style . to2ac9) (guard . to2ac8) (trace-define . to2ac7) (trace-lambda . to2ac6) (unsyntax-splicing . to2ac5) (unsyntax . to2ac4) (unquote-splicing . to2ac3) (unquote . to2ac2) (_ . to2ac1) (else . to2ac0) (=> . to2abf) (... . to2abe) (assert . to2abd) (endianness . to2abc) (delay . to2abb) (time . to2aba) (do . to2ab9) (cond . to2ab8) (let* . to2ab7) (let*-values . to2ab6) (let-values . to2ab5) (identifier-syntax . to2ab4) (with-syntax . to2ab3) (quasisyntax . to2ab2) (quasiquote . to2ab1) (syntax-rules . to2ab0) (include . to2aaf) (define-struct . to2aae) (record-constructor-descriptor . to2aad) (record-type-descriptor . to2aac) (case . to2aab) (parameterize . to2aaa) (unless . to2aa9) (when . to2aa8) (or . to2aa7) (and . to2aa6) (if . to2aa5) (let . to2aa4) (letrec* . to2aa3) (letrec . to2aa2) (type-descriptor . to2aa1) (case-lambda . to2aa0) (lambda . to2a9f) (syntax . to2a9e) (syntax-case . to2a9d) (quote . to2a9c) (foreign-call . to2a9b) (letrec-syntax . to2a9a) (let-syntax . to2a99) (set! . to2a98) (import . to2a97) (begin . to2a96) (module . to2a95) (define-syntax . to2a94) (define . to2a93)) '((to2e49 core-prim . &no-nans-rcd) (to2e48 core-prim . &no-nans-rtd) (to2e47 core-prim . &no-infinities-rcd) (to2e46 core-prim . &no-infinities-rtd) (to2e45 core-prim . &i/o-encoding-rcd) (to2e44 core-prim . &i/o-encoding-rtd) (to2e43 core-prim . &i/o-decoding-rcd) (to2e42 core-prim . &i/o-decoding-rtd) (to2e41 core-prim . &i/o-port-rcd) (to2e40 core-prim . &i/o-port-rtd) (to2e3f core-prim . &i/o-file-does-not-exist-rcd) (to2e3e core-prim . &i/o-file-does-not-exist-rtd) (to2e3d core-prim . &i/o-file-already-exists-rcd) (to2e3c core-prim . &i/o-file-already-exists-rtd) (to2e3b core-prim . &i/o-file-is-read-only-rcd) (to2e3a core-prim . &i/o-file-is-read-only-rtd) (to2e39 core-prim . &i/o-file-protection-rcd) (to2e38 core-prim . &i/o-file-protection-rtd) (to2e37 core-prim . &i/o-filename-rcd) (to2e36 core-prim . &i/o-filename-rtd) (to2e35 core-prim . &i/o-invalid-position-rcd) (to2e34 core-prim . &i/o-invalid-position-rtd) (to2e33 core-prim . &i/o-write-rcd) (to2e32 core-prim . &i/o-write-rtd) (to2e31 core-prim . &i/o-read-rcd) (to2e30 core-prim . &i/o-read-rtd) (to2e2f core-prim . &i/o-rcd) (to2e2e core-prim . &i/o-rtd) (to2e2d core-prim . &undefined-rcd) (to2e2c core-prim . &undefined-rtd) (to2e2b core-prim . &syntax-rcd) (to2e2a core-prim . &syntax-rtd) (to2e29 core-prim . &lexical-rcd) (to2e28 core-prim . &lexical-rtd) (to2e27 core-prim . &implementation-restriction-rcd) (to2e26 core-prim . &implementation-restriction-rtd) (to2e25 core-prim . &non-continuable-rcd) (to2e24 core-prim . &non-continuable-rtd) (to2e23 core-prim . &who-rcd) (to2e22 core-prim . &who-rtd) (to2e21 core-prim . &irritants-rcd) (to2e20 core-prim . &irritants-rtd) (to2e1f core-prim . &assertion-rcd) (to2e1e core-prim . &assertion-rtd) (to2e1d core-prim . &violation-rcd) (to2e1c core-prim . &violation-rtd) (to2e1b core-prim . &error-rcd) (to2e1a core-prim . &error-rtd) (to2e19 core-prim . &serious-rcd) (to2e18 core-prim . &serious-rtd) (to2e17 core-prim . &warning-rcd) (to2e16 core-prim . &warning-rtd) (to2e15 core-prim . &message-rcd) (to2e14 core-prim . &message-rtd) (to2e13 core-prim . &condition-rcd) (to2e12 core-prim . &condition-rtd) (toe6a core-prim . syntax-error) (tod8e core-prim . syntax-dispatch) (to2e11 core-prim . pretty-print) (to2e10 core-prim . eval-core) (to2e0f core-prim . set-symbol-value!) (to2e0e core-prim . symbol-value) (to2e0d core-prim . gensym) (to2e0c core-prim . void) (to292d core-prim . load) (toe7c core-prim . interaction-environment) (to2e0b core-prim . char-ready?) (to2e0a core-prim . regexp?) (to2e09 core-prim . read-line) (to2e08 core-prim . gensym-prefix-set!) (to2e07 core-prim . ungensym) (to2e06 core-prim . alist->eq-hash-table) (to2e05 core-prim . assoc-ref) (to2e04 core-prim . print) (to2e03 core-prim . format) (to2e02 core-prim . host-os) (to7cd core-prim . library-path) (to2e01 core-prim . standard-library-path) (to2e00 core-prim . ssl-supported?) (to2dff core-prim . ssl-socket?) (to2dfe core-prim . socket-sslize!) (to2dfd core-prim . %monapi-stream-read) (to2dfc core-prim . %monapi-stream-write) (to2dfb core-prim . %monapi-stream-handle) (to2dfa core-prim . %monapi-make-stream) (to2df9 core-prim . %monapi-name-add!) (to2df8 core-prim . %monapi-message-receive) (to2df7 core-prim . %monapi-name-whereis) (to2df6 core-prim . %monapi-message-reply) (to2df5 core-prim . %monapi-message-send-receive) (to2df4 core-prim . %monapi-message-send) (to2df3 core-prim . process-terminate!) (to2df2 core-prim . process-list) (to2df1 core-prim . file-newer?) (to2df0 core-prim . stat-mtime) (to2def core-prim . write-to-file) (to2dee core-prim . file->list) (to2ded core-prim . file->string) (to2dec core-prim . digit->integer) (to2deb core-prim . call-with-string-input-port) (to2dea core-prim . call-with-string-io) (to2de9 core-prim . string-split) (to2de8 core-prim . bytevector-for-each) (to2de7 core-prim . string->regexp) (to2de6 core-prim . rxmatch) (to2de5 core-prim . regexp-replace-all) (to2de4 core-prim . hashtable-fold-left) (to2de3 core-prim . hashtable-for-each) (to5b7 core-prim . mosh-cache-dir) (to2de2 core-prim . %start-process) (to2de1 core-prim . %call-process) (to2de0 core-prim . local-tz-offset) (to2ddf core-prim . microseconds) (to2dde core-prim . directory-list) (to2ddd core-prim . set-current-directory!) (to2ddc core-prim . expand-path) (to2ddb core-prim . current-directory) (to2dda core-prim . %getpid) (to2dd9 core-prim . %spawn) (to2dd8 core-prim . %waitpid) (to2dd7 core-prim . simple-struct-name) (to2dd6 core-prim . simple-struct-set!) (to2dd5 core-prim . simple-struct-ref) (to2dd4 core-prim . make-simple-struct) (to2dd3 core-prim . simple-struct?) (to2dd2 core-prim . pointer-ref-c-int64) (to2dd1 core-prim . pointer-ref-c-int32) (to2dd0 core-prim . pointer-ref-c-int16) (to2dcf core-prim . pointer-ref-c-int8) (to2dce core-prim . pointer-ref-c-uint64) (to2dcd core-prim . pointer-ref-c-uint32) (to2dcc core-prim . pointer-ref-c-uint16) (to2dcb core-prim . pointer-ref-c-uint8) (to2dca core-prim . pointer-set-c-uint64!) (to2dc9 core-prim . pointer-set-c-uint32!) (to2dc8 core-prim . pointer-set-c-uint16!) (to2dc7 core-prim . pointer-set-c-uint8!) (to2dc6 core-prim . pointer-set-c-int64!) (to2dc5 core-prim . pointer-set-c-int32!) (to2dc4 core-prim . pointer-set-c-int16!) (to2dc3 core-prim . pointer-set-c-int8!) (to2dc2 core-prim . pointer-set-c-pointer!) (to2dc1 core-prim . pointer-set-c-double!) (to2dc0 core-prim . pointer-set-c-float!) (to2dbf core-prim . pointer-set-c-long-long!) (to2dbe core-prim . pointer-set-c-long!) (to2dbd core-prim . pointer-set-c-int!) (to2dbc core-prim . pointer-set-c-short!) (to2dbb core-prim . pointer-set-c-char!) (to2dba core-prim . pointer-ref-c-pointer) (to2db9 core-prim . pointer-ref-c-double) (to2db8 core-prim . pointer-ref-c-float) (to2db7 core-prim . pointer-ref-c-unsigned-long-long) (to2db6 core-prim . pointer-ref-c-signed-long-long) (to2db5 core-prim . pointer-ref-c-unsigned-long) (to2db4 core-prim . pointer-ref-c-signed-long) (to2db3 core-prim . pointer-ref-c-unsigned-int) (to2db2 core-prim . pointer-ref-c-signed-int) (to2db1 core-prim . pointer-ref-c-unsigned-short) (to2db0 core-prim . pointer-ref-c-signed-short) (to2daf core-prim . pointer-ref-c-unsigned-char) (to2dae core-prim . pointer-ref-c-signed-char) (to2dad core-prim . pointer->integer) (to2dac core-prim . integer->pointer) (to2dab core-prim . pointer?) (to2daa core-prim . shared-errno) (to2da9 core-prim . %ffi-free-c-callback-trampoline) (to2da8 core-prim . %ffi-make-c-callback-trampoline) (to2da7 core-prim . %ffi-free) (to2da6 core-prim . %ffi-malloc) (to2da5 core-prim . %ffi-supported?) (to2da4 core-prim . %ffi-pointer->string) (to2da3 core-prim . %ffi-call) (to2da2 core-prim . %ffi-lookup) (to2da1 core-prim . %ffi-open) (to2da0 core-prim . null-terminated-utf8->string) (to2d9f core-prim . null-terminated-bytevector->string) (to2d9e core-prim . %exec) (to2d9d core-prim . %fork) (to2d9c core-prim . %pipe) (to2d9b core-prim . p) (to2d9a core-prim . open-output-string) (to2d99 core-prim . get-output-string) (to2d98 core-prim . file-stat-ctime) (to2d97 core-prim . file-stat-atime) (to2d96 core-prim . file-stat-mtime) (to2d95 core-prim . file-size-in-bytes) (to2d94 core-prim . file-writable?) (to2d93 core-prim . file-executable?) (to2d92 core-prim . file-readable?) (to2d91 core-prim . file-regular?) (to2d90 core-prim . file-symbolic-link?) (to2d8f core-prim . file-directory?) (to2d8e core-prim . create-symbolic-link) (to2d8d core-prim . rename-file) (to2d8c core-prim . delete-directory) (to2d8b core-prim . create-directory) (to2d8a core-prim . create-mosh-cache-dir) (to2d89 core-prim . get-environment-variables) (to2d88 core-prim . current-exception-handler) (to2d87 core-prim . get-environment-variable) (to2d86 core-prim . join-wraps) (to2d85 core-prim . id->real-label) (to2d84 core-prim . same-marks?) (to2d83 core-prim . same-marks*?) (to2d82 core-prim . get-timeofday) (to2d81 core-prim . get-command-line) (to2d80 core-prim . sys-display) (to2d7f core-prim . whereis) (to2d7e core-prim . register) (to2d7d core-prim . vm-join!) (to2d7c core-prim . vm-set-value!) (to2d7b core-prim . vm?) (to2d7a core-prim . main-vm?) (to2d79 core-prim . vm-eval) (to2d78 core-prim . vm-self) (to2d77 core-prim . vm-start!) (to2d76 core-prim . make-vm) (to2d75 core-prim . mutex-try-lock!) (to2d74 core-prim . mutex-unlock!) (to2d73 core-prim . mutex-lock!) (to2d72 core-prim . mutex?) (to2d71 core-prim . make-mutex) (to2d70 core-prim . condition-variable-notify-all!) (to2d6f core-prim . condition-variable-notify!) (to2d6e core-prim . condition-variable-wait!) (to2d6d core-prim . make-condition-variable) (to2d6c core-prim . write/ss) (to2d6b core-prim . mosh-executable-path) (to2d6a core-prim . make-file-options) (to2d69 core-prim . source-info) (to2d68 core-prim . make-compiler-instruction) (to2d67 core-prim . make-instruction) (to2d66 core-prim . set-annotation!) (to2d65 core-prim . get-annotation) (to2d64 core-prim . annotated-pair?) (to2d63 core-prim . annotated-cons) (to2d62 core-prim . set-source-info!) (to2d61 core-prim . bignum?) (to2d60 core-prim . fast-equal?) (to2d5f core-prim . fasl-read) (to2d5e core-prim . fasl-write) (to2d5d core-prim . time-usage) (to2d5c core-prim . os-constant) (to2d5b core-prim . condition-printer) (to2d5a core-prim . disasm) (to5b5 core-prim . make-parameter) (to2d59 core-prim . socket-port) (to2d58 core-prim . socket-shutdown) (to2d57 core-prim . socket-close) (to2d56 core-prim . socket-send) (to2d55 core-prim . socket-recv!) (to2d54 core-prim . socket-recv) (to2d53 core-prim . make-server-socket) (to2d52 core-prim . make-client-socket) (to2d51 core-prim . socket-accept) (to2d50 core-prim . socket?) (to2d4f core-prim . string-upcase) (to2d4e core-prim . string-titlecase) (to2d4d core-prim . string-normalize-nfkd) (to2d4c core-prim . string-normalize-nfkc) (to2d4b core-prim . string-normalize-nfd) (to2d4a core-prim . string-normalize-nfc) (to2d49 core-prim . string-foldcase) (to2d48 core-prim . string-downcase) (to2d47 core-prim . string-ci>?) (to2d46 core-prim . string-ci>=?) (to2d45 core-prim . string-ci=?) (to2d44 core-prim . string-ci<?) (to2d43 core-prim . string-ci<=?) (to2d42 core-prim . char-whitespace?) (to2d41 core-prim . char-upper-case?) (to2d40 core-prim . char-title-case?) (to2d3f core-prim . char-numeric?) (to2d3e core-prim . char-lower-case?) (to2d3d core-prim . char-general-category) (to2d3c core-prim . char-upcase) (to2d3b core-prim . char-titlecase) (to2d3a core-prim . char-foldcase) (to2d39 core-prim . char-downcase) (to2d38 core-prim . char-ci>?) (to2d37 core-prim . char-ci>=?) (to2d36 core-prim . char-ci=?) (to2d35 core-prim . char-ci<?) (to2d34 core-prim . char-ci<=?) (to2d33 core-prim . char-alphabetic?) (tobb9 core-prim . make-variable-transformer) (toe70 core-prim . identifier?) (toe5c core-prim . generate-temporaries) (toe5e core-prim . free-identifier=?) (toe74 core-prim . syntax->datum) (toe72 core-prim . datum->syntax) (toe60 core-prim . bound-identifier=?) (to2d32 core-prim . record-type-descriptor?) (to2d31 core-prim . record-predicate) (to2d30 core-prim . record-mutator) (to2d2f core-prim . record-constructor) (to2d2e core-prim . record-accessor) (to2d2d core-prim . make-record-type-descriptor) (to2d2c core-prim . make-record-constructor-descriptor) (to2d2b core-prim . record?) (to2d2a core-prim . record-type-uid) (to2d29 core-prim . record-type-sealed?) (to2d28 core-prim . record-type-parent) (to2d27 core-prim . record-type-opaque?) (to2d26 core-prim . record-type-name) (to2d25 core-prim . record-type-generative?) (to2d24 core-prim . record-type-field-names) (to2d23 core-prim . record-rtd) (to2d22 core-prim . record-field-mutable?) (to2d21 core-prim . delete-file) (to2d20 core-prim . file-exists?) (to2d1f core-prim . vector-sort!) (to2d1e core-prim . vector-sort) (to2d1d core-prim . list-sort) (to2d1c core-prim . symbol-hash) (to2d1b core-prim . string-ci-hash) (to2d1a core-prim . string-hash) (to2d19 core-prim . equal-hash) (to2d18 core-prim . hashtable-equivalence-function) (to2d17 core-prim . make-hashtable) (to2d16 core-prim . hashtable-hash-function) (to2d15 core-prim . make-eqv-hashtable) (to2d14 core-prim . make-eq-hashtable) (to2d13 core-prim . hashtable?) (to2d12 core-prim . hashtable-update!) (to2d11 core-prim . hashtable-size) (to2d10 core-prim . hashtable-set!) (to2d0f core-prim . hashtable-ref) (to2d0e core-prim . hashtable-mutable?) (to2d0d core-prim . hashtable-keys) (to2d0c core-prim . hashtable-entries) (to2d0b core-prim . hashtable-delete!) (to2d0a core-prim . hashtable-copy) (to2d09 core-prim . hashtable-contains?) (to2d08 core-prim . hashtable-clear!) (to2d07 core-prim . call-with-output-file) (to2d06 core-prim . call-with-input-file) (to2d05 core-prim . write-char) (to2d04 core-prim . write) (to2d03 core-prim . with-output-to-file) (to2d02 core-prim . with-input-from-file) (to2d01 core-prim . read-char) (to2d00 core-prim . read) (to2cff core-prim . peek-char) (to2cfe core-prim . open-output-file) (to2cfd core-prim . open-input-file) (to2cfc core-prim . newline) (to2cfb core-prim . display) (to2cfa core-prim . close-output-port) (to2cf9 core-prim . close-input-port) (to2cf8 core-prim . eof-object?) (to2cf7 core-prim . eof-object) (to2cf6 core-prim . current-error-port) (to2cf5 core-prim . current-output-port) (to2cf4 core-prim . current-input-port) (to2cf3 core-prim . output-port?) (to2cf2 core-prim . input-port?) (to2cf1 core-prim . utf-8-codec) (to2cf0 core-prim . utf-16-codec) (to2cef core-prim . transcoder-error-handling-mode) (to2cee core-prim . transcoder-eol-style) (to2ced core-prim . transcoder-codec) (to2cec core-prim . transcoded-port) (to2ceb core-prim . textual-port?) (to2cea core-prim . string->bytevector) (to2ce9 core-prim . standard-output-port) (to2ce8 core-prim . standard-input-port) (to2ce7 core-prim . standard-error-port) (to2ce6 core-prim . set-port-position!) (to2ce5 core-prim . put-u8) (to2ce4 core-prim . put-string) (to2ce3 core-prim . put-datum) (to2ce2 core-prim . put-char) (to2ce1 core-prim . put-bytevector) (to2ce0 core-prim . port?) (to2cdf core-prim . port-transcoder) (to2cde core-prim . port-position) (to2cdd core-prim . port-has-set-port-position!?) (to2cdc core-prim . port-has-port-position?) (to2cdb core-prim . port-eof?) (to2cda core-prim . output-port-buffer-mode) (to2cd9 core-prim . open-string-output-port) (to2cd8 core-prim . open-string-input-port) (to2cd7 core-prim . open-file-output-port) (to2cd6 core-prim . open-file-input/output-port) (to2cd5 core-prim . open-file-input-port) (to2cd4 core-prim . open-bytevector-output-port) (to2cd3 core-prim . open-bytevector-input-port) (to2cd2 core-prim . native-transcoder) (to2cd1 core-prim . native-eol-style) (to2cd0 core-prim . make-transcoder) (to2ccf core-prim . latin-1-codec) (to2cce core-prim . make-i/o-write-error) (to2ccd core-prim . make-i/o-read-error) (to2ccc core-prim . make-i/o-port-error) (to2ccb core-prim . make-i/o-invalid-position-error) (to2cca core-prim . make-i/o-filename-error) (to2cc9 core-prim . make-i/o-file-protection-error) (to2cc8 core-prim . make-i/o-file-is-read-only-error) (to2cc7 core-prim . make-i/o-file-does-not-exist-error) (to2cc6 core-prim . make-i/o-file-already-exists-error) (to2cc5 core-prim . make-i/o-error) (to2cc4 core-prim . make-i/o-encoding-error) (to2cc3 core-prim . make-i/o-decoding-error) (to2cc2 core-prim . make-custom-textual-output-port) (to2cc1 core-prim . make-custom-textual-input/output-port) (to2cc0 core-prim . make-custom-textual-input-port) (to2cbf core-prim . make-custom-binary-output-port) (to2cbe core-prim . make-custom-binary-input/output-port) (to2cbd core-prim . make-custom-binary-input-port) (to2cbc core-prim . make-bytevector) (to2cbb core-prim . lookahead-u8) (to2cba core-prim . lookahead-char) (to2cb9 core-prim . i/o-write-error?) (to2cb8 core-prim . i/o-read-error?) (to2cb7 core-prim . i/o-port-error?) (to2cb6 core-prim . i/o-invalid-position-error?) (to2cb5 core-prim . i/o-filename-error?) (to2cb4 core-prim . i/o-file-protection-error?) (to2cb3 core-prim . i/o-file-is-read-only-error?) (to2cb2 core-prim . i/o-file-does-not-exist-error?) (to2cb1 core-prim . i/o-file-already-exists-error?) (to2cb0 core-prim . i/o-error?) (to2caf core-prim . i/o-error-position) (to2cae core-prim . i/o-error-port) (to2cad core-prim . i/o-error-filename) (to2cac core-prim . i/o-encoding-error?) (to2cab core-prim . i/o-encoding-error-char) (to2caa core-prim . i/o-decoding-error?) (to2ca9 core-prim . get-u8) (to2ca8 core-prim . get-string-n!) (to2ca7 core-prim . get-string-n) (to2ca6 core-prim . get-string-all) (to2ca5 core-prim . get-line) (to2ca4 core-prim . get-datum) (to2ca3 core-prim . get-char) (to2ca2 core-prim . get-bytevector-some) (to2ca1 core-prim . get-bytevector-n!) (to2ca0 core-prim . get-bytevector-n) (to2c9f core-prim . get-bytevector-all) (to2c9e core-prim . flush-output-port) (to2c9d core-prim . close-port) (toe4a core-prim . scheme-report-environment) (to2c9c core-prim . quotient) (toe48 core-prim . null-environment) (to2c9b core-prim . remainder) (to2c9a core-prim . modulo) (to2c99 core-prim . inexact->exact) (to2c98 core-prim . force) (to2c97 core-prim . exact->inexact) (to2c96 core-prim . make-promise) (to2c95 core-prim . exit) (to2927 core-prim . command-line) (to2c94 core-prim . string-fill!) (to2c93 core-prim . string-set!) (to2c92 core-prim . set-cdr!) (to2c91 core-prim . set-car!) (to2c90 core-prim . remove) (to2c8f core-prim . remv) (to2c8e core-prim . remp) (to2c8d core-prim . remq) (to2c8c core-prim . partition) (to2c8b core-prim . memv) (to2c8a core-prim . memq) (to2c89 core-prim . memp) (to2c88 core-prim . member) (to2c87 core-prim . exists) (to2c86 core-prim . for-all) (to2c85 core-prim . fold-right) (to2c84 core-prim . fold-left) (to2c83 core-prim . find) (to2c82 core-prim . filter) (to2c81 core-prim . cons*) (to2c80 core-prim . assv) (to2c7f core-prim . assq) (to2c7e core-prim . assp) (to2c7d core-prim . assoc) (to2c7c core-prim . call-with-string-output-port) (to2c7b core-prim . call-with-port) (to2c7a core-prim . call-with-bytevector-output-port) (to2c79 core-prim . bytevector->string) (to2c78 core-prim . buffer-mode?) (to2c77 core-prim . binary-port?) (to2c76 core-prim . with-exception-handler) (to2c75 core-prim . raise-continuable) (to2c74 core-prim . raise) (toe4e core-prim . eval) (toe46 core-prim . environment) (to2c73 core-prim . make-enumeration) (to2c72 core-prim . enum-set=?) (to2c71 core-prim . enum-set-universe) (to2c70 core-prim . enum-set-union) (to2c6f core-prim . enum-set-subset?) (to2c6e core-prim . enum-set-projection) (to2c6d core-prim . enum-set-member?) (to2c6c core-prim . enum-set-intersection) (to2c6b core-prim . enum-set-indexer) (to2c6a core-prim . enum-set-difference) (to2c69 core-prim . enum-set-constructor) (to2c68 core-prim . enum-set-complement) (to2c67 core-prim . enum-set->list) (to2c66 core-prim . who-condition?) (to2c65 core-prim . warning?) (to2c64 core-prim . violation?) (to2c63 core-prim . undefined-violation?) (to2c62 core-prim . syntax-violation?) (to2c61 core-prim . syntax-violation-subform) (to2c60 core-prim . syntax-violation-form) (toe6e core-prim . syntax-violation) (to2c5f core-prim . simple-conditions) (to2c5e core-prim . serious-condition?) (to2c5d core-prim . non-continuable-violation?) (to2c5c core-prim . message-condition?) (to2c5b core-prim . make-who-condition) (to2c5a core-prim . make-warning) (to2c59 core-prim . make-violation) (to2c58 core-prim . make-undefined-violation) (to2c57 core-prim . make-syntax-violation) (to2c56 core-prim . make-serious-condition) (to2c55 core-prim . make-non-continuable-violation) (to2c54 core-prim . make-message-condition) (to2c53 core-prim . make-lexical-violation) (to2c52 core-prim . make-irritants-condition) (to2c51 core-prim . make-implementation-restriction-violation) (to2c50 core-prim . make-error) (to2c4f core-prim . make-assertion-violation) (to2c4e core-prim . lexical-violation?) (to2c4d core-prim . irritants-condition?) (to2c4c core-prim . implementation-restriction-violation?) (to2c4b core-prim . error?) (to2c4a core-prim . condition-who) (to2c49 core-prim . condition-predicate) (to2c48 core-prim . condition-message) (to2c47 core-prim . condition-irritants) (to2c46 core-prim . condition-accessor) (to2c45 core-prim . condition) (to2c44 core-prim . assertion-violation?) (to2c43 core-prim . condition?) (to2c42 core-prim . utf32->string) (to2c41 core-prim . utf16->string) (to2c40 core-prim . utf8->string) (to2c3f core-prim . uint-list->bytevector) (to2c3e core-prim . u8-list->bytevector) (to2c3d core-prim . string->utf8) (to2c3c core-prim . string->utf32) (to2c3b core-prim . string->utf16) (to2c3a core-prim . sint-list->bytevector) (to2c39 core-prim . native-endianness) (to2c38 core-prim . bytevector?) (to2c37 core-prim . bytevector=?) (to2c36 core-prim . bytevector-uint-set!) (to2c35 core-prim . bytevector-uint-ref) (to2c34 core-prim . bytevector-u8-set!) (to2c33 core-prim . bytevector-u8-ref) (to2c32 core-prim . bytevector-u64-set!) (to2c31 core-prim . bytevector-u64-ref) (to2c30 core-prim . bytevector-u64-native-set!) (to2c2f core-prim . bytevector-u64-native-ref) (to2c2e core-prim . bytevector-u32-set!) (to2c2d core-prim . bytevector-u32-ref) (to2c2c core-prim . bytevector-u32-native-set!) (to2c2b core-prim . bytevector-u32-native-ref) (to2c2a core-prim . bytevector-u16-set!) (to2c29 core-prim . bytevector-u16-ref) (to2c28 core-prim . bytevector-u16-native-set!) (to2c27 core-prim . bytevector-u16-native-ref) (to2c26 core-prim . bytevector-sint-set!) (to2c25 core-prim . bytevector-sint-ref) (to2c24 core-prim . bytevector-s8-set!) (to2c23 core-prim . bytevector-s8-ref) (to2c22 core-prim . bytevector-s64-set!) (to2c21 core-prim . bytevector-s64-ref) (to2c20 core-prim . bytevector-s64-native-set!) (to2c1f core-prim . bytevector-s64-native-ref) (to2c1e core-prim . bytevector-s32-set!) (to2c1d core-prim . bytevector-s32-ref) (to2c1c core-prim . bytevector-s32-native-set!) (to2c1b core-prim . bytevector-s32-native-ref) (to2c1a core-prim . bytevector-s16-set!) (to2c19 core-prim . bytevector-s16-ref) (to2c18 core-prim . bytevector-s16-native-set!) (to2c17 core-prim . bytevector-s16-native-ref) (to2c16 core-prim . bytevector-length) (to2c15 core-prim . bytevector-ieee-single-ref) (to2c14 core-prim . bytevector-ieee-single-set!) (to2c13 core-prim . bytevector-ieee-single-native-set!) (to2c12 core-prim . bytevector-ieee-single-native-ref) (to2c11 core-prim . bytevector-ieee-double-set!) (to2c10 core-prim . bytevector-ieee-double-ref) (to2c0f core-prim . bytevector-ieee-double-native-set!) (to2c0e core-prim . bytevector-ieee-double-native-ref) (to2c0d core-prim . bytevector-fill!) (to2c0c core-prim . bytevector-copy!) (to2c0b core-prim . bytevector-copy) (to2c0a core-prim . bytevector->uint-list) (to2c09 core-prim . bytevector->u8-list) (to2c08 core-prim . bytevector->sint-list) (to2c07 core-prim . no-nans-violation?) (to2c06 core-prim . no-infinities-violation?) (to2c05 core-prim . make-no-nans-violation) (to2c04 core-prim . make-no-infinities-violation) (to2c03 core-prim . real->flonum) (to2c02 core-prim . flzero?) (to2c01 core-prim . fltruncate) (to2c00 core-prim . fltan) (to2bff core-prim . flsqrt) (to2bfe core-prim . flsin) (to2bfd core-prim . flround) (to2bfc core-prim . flpositive?) (to2bfb core-prim . flonum?) (to2bfa core-prim . flodd?) (to2bf9 core-prim . flnumerator) (to2bf8 core-prim . flnegative?) (to2bf7 core-prim . flnan?) (to2bf6 core-prim . flmod0) (to2bf5 core-prim . flmod) (to2bf4 core-prim . flmin) (to2bf3 core-prim . flmax) (to2bf2 core-prim . fllog) (to2bf1 core-prim . flinteger?) (to2bf0 core-prim . flinfinite?) (to2bef core-prim . flfloor) (to2bee core-prim . flfinite?) (to2bed core-prim . flexpt) (to2bec core-prim . flexp) (to2beb core-prim . fleven?) (to2bea core-prim . fldiv0-and-mod0) (to2be9 core-prim . fldiv0) (to2be8 core-prim . fldiv-and-mod) (to2be7 core-prim . fldiv) (to2be6 core-prim . fldenominator) (to2be5 core-prim . flcos) (to2be4 core-prim . flceiling) (to2be3 core-prim . flatan) (to2be2 core-prim . flasin) (to2be1 core-prim . flacos) (to2be0 core-prim . flabs) (to2bdf core-prim . fl>?) (to2bde core-prim . fl>=?) (to2bdd core-prim . fl=?) (to2bdc core-prim . fl<?) (to2bdb core-prim . fl<=?) (to2bda core-prim . fl/) (to2bd9 core-prim . fl-) (to2bd8 core-prim . fl+) (to2bd7 core-prim . fl*) (to2bd6 core-prim . fixnum->flonum) (to2bd5 core-prim . fxzero?) (to2bd4 core-prim . fxxor) (to2bd3 core-prim . fxrotate-bit-field) (to2bd2 core-prim . fxreverse-bit-field) (to2bd1 core-prim . fxpositive?) (to2bd0 core-prim . fxodd?) (to2bcf core-prim . fxnot) (to2bce core-prim . fxnegative?) (to2bcd core-prim . fxmod0) (to2bcc core-prim . fxmod) (to2bcb core-prim . fxmin) (to2bca core-prim . fxmax) (to2bc9 core-prim . fxlength) (to2bc8 core-prim . fxior) (to2bc7 core-prim . fxif) (to2bc6 core-prim . fxfirst-bit-set) (to2bc5 core-prim . fxeven?) (to2bc4 core-prim . fxdiv0-and-mod0) (to2bc3 core-prim . fxdiv0) (to2bc2 core-prim . fxdiv-and-mod) (to2bc1 core-prim . fxdiv) (to2bc0 core-prim . fxcopy-bit-field) (to2bbf core-prim . fxcopy-bit) (to2bbe core-prim . fxbit-set?) (to2bbd core-prim . fxbit-field) (to2bbc core-prim . fxbit-count) (to2bbb core-prim . fxarithmetic-shift-right) (to2bba core-prim . fxarithmetic-shift-left) (to2bb9 core-prim . fxarithmetic-shift) (to2bb8 core-prim . fxand) (to2bb7 core-prim . fx>?) (to2bb6 core-prim . fx>=?) (to2bb5 core-prim . fx=?) (to2bb4 core-prim . fx<?) (to2bb3 core-prim . fx<=?) (to2bb2 core-prim . fx-/carry) (to2bb1 core-prim . fx-) (to2bb0 core-prim . fx+/carry) (to2baf core-prim . fx+) (to2bae core-prim . fx*/carry) (to2bad core-prim . fx*) (to2bac core-prim . greatest-fixnum) (to2bab core-prim . least-fixnum) (to2baa core-prim . fixnum-width) (to2ba9 core-prim . fixnum?) (to2ba8 core-prim . bitwise-rotate-bit-field) (to2ba7 core-prim . bitwise-reverse-bit-field) (to2ba6 core-prim . bitwise-length) (to2ba5 core-prim . bitwise-if) (to2ba4 core-prim . bitwise-first-bit-set) (to2ba3 core-prim . bitwise-copy-bit-field) (to2ba2 core-prim . bitwise-copy-bit) (to2ba1 core-prim . bitwise-bit-set?) (to2ba0 core-prim . bitwise-bit-field) (to2b9f core-prim . bitwise-bit-count) (to2b9e core-prim . bitwise-xor) (to2b9d core-prim . bitwise-ior) (to2b9c core-prim . bitwise-and) (to2b9b core-prim . bitwise-not) (to2b9a core-prim . bitwise-arithmetic-shift-right) (to2b99 core-prim . bitwise-arithmetic-shift-left) (to2b98 core-prim . bitwise-arithmetic-shift) (to2b97 core-prim . zero?) (to2b96 core-prim . vector?) (to2b95 core-prim . vector-set!) (to2b94 core-prim . vector-ref) (to2b93 core-prim . vector-map) (to2b92 core-prim . vector-length) (to2b91 core-prim . vector-for-each) (to2b90 core-prim . vector-fill!) (to2b8f core-prim . vector->list) (to2b8e core-prim . vector) (to2b8d core-prim . values) (to2b8c core-prim . truncate) (to2b8b core-prim . tan) (to2b8a core-prim . symbol?) (to2b89 core-prim . symbol=?) (to2b88 core-prim . symbol->string) (to2b87 core-prim . substring) (to2b86 core-prim . string?) (to2b85 core-prim . string>?) (to2b84 core-prim . string>=?) (to2b83 core-prim . string=?) (to2b82 core-prim . string<?) (to2b81 core-prim . string<=?) (to2b80 core-prim . string-ref) (to2b7f core-prim . string-length) (to2b7e core-prim . string-for-each) (to2b7d core-prim . string-copy) (to2b7c core-prim . string-append) (to2b7b core-prim . string->symbol) (to2b7a core-prim . string->number) (to2b79 core-prim . string->list) (to2b78 core-prim . string) (to2b77 core-prim . sqrt) (to2b76 core-prim . sin) (to2b75 core-prim . round) (to2b74 core-prim . reverse) (to2b73 core-prim . real?) (to2b72 core-prim . real-valued?) (to2b71 core-prim . real-part) (to2b70 core-prim . rationalize) (to2b6f core-prim . rational?) (to2b6e core-prim . rational-valued?) (to2b6d core-prim . procedure?) (to2b6c core-prim . positive?) (to2b6b core-prim . pair?) (to2b6a core-prim . odd?) (to2b69 core-prim . numerator) (to2b68 core-prim . number?) (to2b67 core-prim . number->string) (to2b66 core-prim . null?) (to2b65 core-prim . not) (to2b64 core-prim . negative?) (to2b63 core-prim . nan?) (to2b62 core-prim . min) (to2b61 core-prim . max) (to2b60 core-prim . map) (to2b5f core-prim . make-vector) (to2b5e core-prim . make-string) (to2b5d core-prim . make-rectangular) (to2b5c core-prim . make-polar) (to2b5b core-prim . magnitude) (to2b5a core-prim . log) (to2b59 core-prim . list?) (to2b58 core-prim . list-tail) (to2b57 core-prim . list-ref) (to2b56 core-prim . list->vector) (to2b55 core-prim . list->string) (to2b54 core-prim . list) (to2b53 core-prim . length) (to2b52 core-prim . lcm) (to2b51 core-prim . integer?) (to2b50 core-prim . integer-valued?) (to2b4f core-prim . integer->char) (to2b4e core-prim . infinite?) (to2b4d core-prim . inexact?) (to2b4c core-prim . inexact) (to2b4b core-prim . imag-part) (to2b4a core-prim . gcd) (to2b49 core-prim . for-each) (to2b48 core-prim . floor) (to2b47 core-prim . finite?) (to2b46 core-prim . expt) (to2b45 core-prim . exp) (to2b44 core-prim . exact?) (to2b43 core-prim . exact-integer-sqrt) (to2b42 core-prim . exact) (to2b41 core-prim . even?) (to2b40 core-prim . error) (to2b3f core-prim . eqv?) (to2b3e core-prim . equal?) (to2b3d core-prim . eq?) (to2b3c core-prim . dynamic-wind) (to2b3b core-prim . div0-and-mod0) (to2b3a core-prim . mod0) (to2b39 core-prim . div0) (to2b38 core-prim . div-and-mod) (to2b37 core-prim . mod) (to2b36 core-prim . div) (to2b35 core-prim . denominator) (to2b34 core-prim . cos) (to2b33 core-prim . cons) (to2b32 core-prim . complex?) (to2b31 core-prim . char?) (to2b30 core-prim . char>?) (to2b2f core-prim . char>=?) (to2b2e core-prim . char=?) (to2b2d core-prim . char<?) (to2b2c core-prim . char<=?) (to2b2b core-prim . char->integer) (to2b2a core-prim . ceiling) (to2b29 core-prim . call-with-values) (to2b28 core-prim . call/cc) (to2b27 core-prim . call-with-current-continuation) (to2b26 core-prim . cddddr) (to2b25 core-prim . cdddar) (to2b24 core-prim . cddadr) (to2b23 core-prim . cddaar) (to2b22 core-prim . cdaddr) (to2b21 core-prim . cdadar) (to2b20 core-prim . cdaadr) (to2b1f core-prim . cdaaar) (to2b1e core-prim . cadddr) (to2b1d core-prim . caddar) (to2b1c core-prim . cadadr) (to2b1b core-prim . cadaar) (to2b1a core-prim . caaddr) (to2b19 core-prim . caadar) (to2b18 core-prim . caaadr) (to2b17 core-prim . caaaar) (to2b16 core-prim . cdddr) (to2b15 core-prim . cddar) (to2b14 core-prim . cdadr) (to2b13 core-prim . cdaar) (to2b12 core-prim . caddr) (to2b11 core-prim . cadar) (to2b10 core-prim . caadr) (to2b0f core-prim . caaar) (to2b0e core-prim . cddr) (to2b0d core-prim . cdar) (to2b0c core-prim . cadr) (to2b0b core-prim . caar) (to2b0a core-prim . cdr) (to2b09 core-prim . car) (to2b08 core-prim . boolean?) (to2b07 core-prim . boolean=?) (to2b06 core-prim . atan) (to2b05 core-prim . assertion-violation) (toe68 core-prim . assertion-error) (to2b04 core-prim . asin) (to2b03 core-prim . apply) (to2b02 core-prim . append) (to2b01 core-prim . angle) (to2b00 core-prim . acos) (to2aff core-prim . abs) (to2afe core-prim . /) (to2afd core-prim . *) (to2afc core-prim . -) (to2afb core-prim . +) (to2afa core-prim . >=) (to2af9 core-prim . >) (to2af8 core-prim . =) (to2af7 core-prim . <=) (to2af6 core-prim . <) (to2af5 core-prim . library) (to2af4 $core-rtd &no-nans-rtd &no-nans-rcd) (to2af3 $core-rtd &no-infinities-rtd &no-infinities-rcd) (to2af2 $core-rtd &i/o-encoding-rtd &i/o-encoding-rcd) (to2af1 $core-rtd &i/o-decoding-rtd &i/o-decoding-rcd) (to2af0 $core-rtd &i/o-port-rtd &i/o-port-rcd) (to2aef $core-rtd &i/o-file-does-not-exist-rtd &i/o-file-does-not-exist-rcd) (to2aee $core-rtd &i/o-file-already-exists-rtd &i/o-file-already-exists-rcd) (to2aed $core-rtd &i/o-file-is-read-only-rtd &i/o-fie-is-read-only-rcd) (to2aec $core-rtd &i/o-file-protection-rtd &i/o-file-protection-rcd) (to2aeb $core-rtd &i/o-filename-rtd &i/o-filename-rcd) (to2aea $core-rtd &i/o-invalid-position-rtd &i/o-invalid-position-rcd) (to2ae9 $core-rtd &i/o-write-rtd &i/o-write-rcd) (to2ae8 $core-rtd &i/o-read-rtd &i/o-read-rcd) (to2ae7 $core-rtd &i/o-rtd &i/o-rcd) (to2ae6 $core-rtd &undefined-rtd &undefined-rcd) (to2ae5 $core-rtd &syntax-rtd &syntax-rcd) (to2ae4 $core-rtd &lexical-rtd &lexical-rcd) (to2ae3 $core-rtd &implementation-restriction-rtd &implementation-restriction-rcd) (to2ae2 $core-rtd &non-continuable-rtd &non-continuable-rcd) (to2ae1 $core-rtd &who-rtd &who-rcd) (to2ae0 $core-rtd &irritants-rtd &irritants-rcd) (to2adf $core-rtd &assertion-rtd &assertion-rcd) (to2ade $core-rtd &violation-rtd &violation-rcd) (to2add $core-rtd &error-rtd &error-rcd) (to2adc $core-rtd &serious-rtd &serious-rcd) (to2adb $core-rtd &warning-rtd &warning-rcd) (to2ada $core-rtd &message-rtd &message-rcd) (to2ad9 $core-rtd &condition-rtd &condition-rcd) (to2ad8 macro . define-condition-type) (to2ad7 macro . define-enumeration) (to2ad6 macro . define-record-type) (to2ad5 macro . parent-rtd) (to2ad4 macro . nongenerative) (to2ad3 macro . opaque) (to2ad2 macro . sealed) (to2ad1 macro . protocol) (to2ad0 macro . parent) (to2acf macro . immutable) (to2ace macro . mutable) (to2acd macro . fields) (to2acc macro . error-handling-mode) (to2acb macro . file-options) (to2aca macro . buffer-mode) (to2ac9 macro . eol-style) (to2ac8 macro . guard) (to2ac7 macro . trace-define) (to2ac6 macro . trace-lambda) (to2ac5 macro . unsyntax-splicing) (to2ac4 macro . unsyntax) (to2ac3 macro . unquote-splicing) (to2ac2 macro . unquote) (to2ac1 macro . _) (to2ac0 macro . else) (to2abf macro . =>) (to2abe macro . ...) (to2abd macro . assert) (to2abc macro . endianness) (to2abb macro . delay) (to2aba macro . time) (to2ab9 macro . do) (to2ab8 macro . cond) (to2ab7 macro . let*) (to2ab6 macro . let*-values) (to2ab5 macro . let-values) (to2ab4 macro . identifier-syntax) (to2ab3 macro . with-syntax) (to2ab2 macro . quasisyntax) (to2ab1 macro . quasiquote) (to2ab0 macro . syntax-rules) (to2aaf macro . include) (to2aae macro . define-struct) (to2aad core-macro . record-constructor-descriptor) (to2aac core-macro . record-type-descriptor) (to2aab macro . case) (to2aaa macro . parameterize) (to2aa9 macro . unless) (to2aa8 macro . when) (to2aa7 core-macro . or) (to2aa6 core-macro . and) (to2aa5 core-macro . if) (to2aa4 core-macro . let) (to2aa3 core-macro . letrec*) (to2aa2 core-macro . letrec) (to2aa1 core-macro . type-descriptor) (to2aa0 core-macro . case-lambda) (to2a9f core-macro . lambda) (to2a9e core-macro . syntax) (to2a9d core-macro . syntax-case) (to2a9c core-macro . quote) (to2a9b core-macro . foreign-call) (to2a9a letrec-syntax) (to2a99 let-syntax) (to2a98 set!) (to2a97 import) (to2a96 begin) (to2a95 module) (to2a94 define-syntax) (to2a93 define)) values values '#f '#f '#f '#f) (to9a2@to7ee@install-library 'to2e6a '(psyntax system $bootstrap) '() '() '() '() '((pretty-print . to2e11) (eval-core . to2e10) (set-symbol-value! . to2e0f) (symbol-value . to2e0e) (gensym . to2e0d) (void . to2e0c)) '() values values '#f '#f '#f '#f) (to9a2@to7ee@install-library 'to2e6b '(mosh) '() '() '() '() '((set-symbol-value! . to2e0f) (symbol-value . to2e0e) (regexp? . to2e0a) (read-line . to2e09) (ungensym . to2e07) (alist->eq-hash-table . to2e06) (assoc-ref . to2e05) (print . to2e04) (format . to2e03) (host-os . to2e02) (library-path . to7cd) (standard-library-path . to2e01) (file-newer? . to2df1) (stat-mtime . to2df0) (digit->integer . to2dec) (call-with-string-input-port . to2deb) (call-with-string-io . to2dea) (string-split . to2de9) (bytevector-for-each . to2de8) (string->regexp . to2de7) (rxmatch . to2de6) (regexp-replace-all . to2de5) (hashtable-fold-left . to2de4) (hashtable-for-each . to2de3) (set-current-directory! . to2ddd) (expand-path . to2ddc) (current-directory . to2ddb) (p . to2d9b) (get-timeofday . to2d82) (get-command-line . to2d81) (sys-display . to2d80) (whereis . to2d7f) (register . to2d7e) (vm-join! . to2d7d) (vm-set-value! . to2d7c) (vm? . to2d7b) (main-vm? . to2d7a) (vm-eval . to2d79) (vm-self . to2d78) (vm-start! . to2d77) (make-vm . to2d76) (mutex-try-lock! . to2d75) (mutex-unlock! . to2d74) (mutex-lock! . to2d73) (mutex? . to2d72) (make-mutex . to2d71) (condition-variable-notify-all! . to2d70) (condition-variable-notify! . to2d6f) (condition-variable-wait! . to2d6e) (make-condition-variable . to2d6d) (write/ss . to2d6c) (mosh-executable-path . to2d6b) (make-file-options . to2d6a) (source-info . to2d69) (make-compiler-instruction . to2d68) (make-instruction . to2d67) (set-annotation! . to2d66) (get-annotation . to2d65) (annotated-pair? . to2d64) (annotated-cons . to2d63) (set-source-info! . to2d62) (bignum? . to2d61) (fast-equal? . to2d60) (fasl-read . to2d5f) (fasl-write . to2d5e) (time-usage . to2d5d) (os-constant . to2d5c) (condition-printer . to2d5b) (time . to2aba) (include . to2aaf)) '() values values '#f '#f '#f '#f) (to9a2@to7ee@install-library 'to2e6c '(system) '() '() '() '() '((gensym-prefix-set! . to2e08) (ssl-supported? . to2e00) (ssl-socket? . to2dff) (socket-sslize! . to2dfe) (%monapi-stream-read . to2dfd) (%monapi-stream-write . to2dfc) (%monapi-stream-handle . to2dfb) (%monapi-make-stream . to2dfa) (%monapi-name-add! . to2df9) (%monapi-message-receive . to2df8) (%monapi-name-whereis . to2df7) (%monapi-message-reply . to2df6) (%monapi-message-send-receive . to2df5) (%monapi-message-send . to2df4) (process-terminate! . to2df3) (process-list . to2df2) (write-to-file . to2def) (file->list . to2dee) (file->string . to2ded) (mosh-cache-dir . to5b7) (%start-process . to2de2) (%call-process . to2de1) (local-tz-offset . to2de0) (microseconds . to2ddf) (directory-list . to2dde) (expand-path . to2ddc) (%getpid . to2dda) (%spawn . to2dd9) (%waitpid . to2dd8) (simple-struct-name . to2dd7) (simple-struct-set! . to2dd6) (simple-struct-ref . to2dd5) (make-simple-struct . to2dd4) (simple-struct? . to2dd3) (pointer-ref-c-int64 . to2dd2) (pointer-ref-c-int32 . to2dd1) (pointer-ref-c-int16 . to2dd0) (pointer-ref-c-int8 . to2dcf) (pointer-ref-c-uint64 . to2dce) (pointer-ref-c-uint32 . to2dcd) (pointer-ref-c-uint16 . to2dcc) (pointer-ref-c-uint8 . to2dcb) (pointer-set-c-uint64! . to2dca) (pointer-set-c-uint32! . to2dc9) (pointer-set-c-uint16! . to2dc8) (pointer-set-c-uint8! . to2dc7) (pointer-set-c-int64! . to2dc6) (pointer-set-c-int32! . to2dc5) (pointer-set-c-int16! . to2dc4) (pointer-set-c-int8! . to2dc3) (pointer-set-c-pointer! . to2dc2) (pointer-set-c-double! . to2dc1) (pointer-set-c-float! . to2dc0) (pointer-set-c-long-long! . to2dbf) (pointer-set-c-long! . to2dbe) (pointer-set-c-int! . to2dbd) (pointer-set-c-short! . to2dbc) (pointer-set-c-char! . to2dbb) (pointer-ref-c-pointer . to2dba) (pointer-ref-c-double . to2db9) (pointer-ref-c-float . to2db8) (pointer-ref-c-unsigned-long-long . to2db7) (pointer-ref-c-signed-long-long . to2db6) (pointer-ref-c-unsigned-long . to2db5) (pointer-ref-c-signed-long . to2db4) (pointer-ref-c-unsigned-int . to2db3) (pointer-ref-c-signed-int . to2db2) (pointer-ref-c-unsigned-short . to2db1) (pointer-ref-c-signed-short . to2db0) (pointer-ref-c-unsigned-char . to2daf) (pointer-ref-c-signed-char . to2dae) (pointer->integer . to2dad) (integer->pointer . to2dac) (pointer? . to2dab) (shared-errno . to2daa) (%ffi-free-c-callback-trampoline . to2da9) (%ffi-make-c-callback-trampoline . to2da8) (%ffi-free . to2da7) (%ffi-malloc . to2da6) (%ffi-supported? . to2da5) (%ffi-pointer->string . to2da4) (%ffi-call . to2da3) (%ffi-lookup . to2da2) (%ffi-open . to2da1) (null-terminated-utf8->string . to2da0) (null-terminated-bytevector->string . to2d9f) (%exec . to2d9e) (%fork . to2d9d) (%pipe . to2d9c) (open-output-string . to2d9a) (get-output-string . to2d99) (file-stat-ctime . to2d98) (file-stat-atime . to2d97) (file-stat-mtime . to2d96) (file-size-in-bytes . to2d95) (file-writable? . to2d94) (file-executable? . to2d93) (file-readable? . to2d92) (file-regular? . to2d91) (file-symbolic-link? . to2d90) (file-directory? . to2d8f) (create-symbolic-link . to2d8e) (rename-file . to2d8d) (delete-directory . to2d8c) (create-directory . to2d8b) (create-mosh-cache-dir . to2d8a) (get-environment-variables . to2d89) (current-exception-handler . to2d88) (get-environment-variable . to2d87) (join-wraps . to2d86) (id->real-label . to2d85) (same-marks? . to2d84) (same-marks*? . to2d83) (disasm . to2d5a) (make-parameter . to5b5) (socket-port . to2d59) (socket-shutdown . to2d58) (socket-close . to2d57) (socket-send . to2d56) (socket-recv! . to2d55) (socket-recv . to2d54) (make-server-socket . to2d53) (make-client-socket . to2d52) (socket-accept . to2d51) (socket? . to2d50) (parameterize . to2aaa)) '() values values '#f '#f '#f '#f)))
(begin (set! to2912@ref (unspecified)) (set! to2914@x* (unspecified)) (set! to2916@add-library-path! (unspecified)) (set! to2918@parse-and-add-library-path (unspecified)) (set! to291a@for-each-with-index (unspecified)) (set! to291c@rpad (unspecified)) (set! to291e@condition-printer/p (unspecified)) (set! to2920@record->field-alist (unspecified)) (set! to2922@map-with-index (unspecified)) (set! to2924@repl (unspecified)) (set! to2926@trace-printer (unspecified)) (set! to2928@command-line (unspecified)) (set! to292a@local-library-path (unspecified)) (set! to292c@load/args (unspecified)) (set! to292e@load (unspecified)) (set! to2930@ironscheme-build (unspecified)) (set! to2932@eval-top-level (unspecified)) (set! to2934@compile-system-libraries (unspecified)) (set! to2936@compile (unspecified)) (set! to2938@compile->closure (unspecified)) (set! to293a@pre-compile-r6rs-file (unspecified)) (set! to293c@load-r6rs-top-level (unspecified)) (set! to293e@load-r6rs-top-level-sexp (unspecified)) (set! to2940@prefix-inc (unspecified)) (set! to2942@prefix-inc! (unspecified)) (set! to2912@ref (lambda (to297d@rtd to297e@i to297f@x) (let ((to2983@val ((record-accessor to297d@rtd to297e@i) to297f@x))) (if (symbol? to2983@val) (ungensym to2983@val) to2983@val)))) (set! to2a79@to2912@ref to2912@ref) (set! to2914@x* '()) (set! to2a7a@to2914@x* to2914@x*) (set! to2916@add-library-path! (lambda (to2985@path) (to992@to7ce@library-path (append (to992@to7ce@library-path) (list to2985@path))))) (set! to2a7b@to2916@add-library-path! to2916@add-library-path!) (set! to2918@parse-and-add-library-path (lambda (to2987@paths to2988@message) (letrec* ((to298c@separator (if (string=? (host-os) '"win32") '#\; '#\:))) (let ((to298d@t to2987@paths)) (if to298d@t ((lambda (to298f@paths) (for-each (lambda (to2991@path) (if (file-exists? to2991@path) (to2916@add-library-path! (expand-path to2991@path)) (format (current-error-port) to2988@message to2991@path))) (string-split to298f@paths to298c@separator))) to298d@t) (void)))))) (set! to2a7c@to2918@parse-and-add-library-path to2918@parse-and-add-library-path) (set! to291a@for-each-with-index (lambda (to2993@proc to2994@lst) (letrec ((to2997@loop (lambda (to2999@i to299a@lst) (if (null? to299a@lst) (if '#f '#f (void)) (begin (to2993@proc to2999@i (car to299a@lst)) (to2997@loop (+ to2999@i '1) (cdr to299a@lst))))))) (to2997@loop '1 to2994@lst)))) (set! to2a7d@to291a@for-each-with-index to291a@for-each-with-index) (set! to291c@rpad (lambda (to299d@str to299e@pad to299f@n) (let ((to29a3@rest (- to299f@n (string-length (format '"~a" to299d@str))))) (let to29a9@loop ((to29a5@rest to29a3@rest) (to29a6@ret (format '"~a" to299d@str))) (if (<= to29a5@rest '0) to29a6@ret (to29a9@loop (- to29a5@rest '1) (string-append to29a6@ret to299e@pad))))))) (set! to2a7e@to291c@rpad to291c@rpad) (set! to291e@condition-printer/p (lambda (to29ab@e to29ac@port) (letrec* ((to29b0@max-condition-len (apply max (map (lambda (to29c1@c) (string-length (symbol->string (record-type-name (record-rtd to29c1@c))))) (simple-conditions to29ab@e))))) (begin (display '" Condition components:\n" to29ac@port) (to291a@for-each-with-index (lambda (to29b1@i to29b2@x) (let ((to29b5@rtd (record-rtd to29b2@x)) (to29b6@fields-alist (to2920@record->field-alist to29b2@x))) (begin (format to29ac@port '" ~d. ~a" to29b1@i (to291c@rpad (symbol->string (record-type-name to29b5@rtd)) '" " to29b0@max-condition-len)) (if (null? to29b6@fields-alist) (newline to29ac@port) (void)) (let to29bd@loop ((to29b9@first '#t) (to29ba@fields-alist to29b6@fields-alist)) (if (null? to29ba@fields-alist) '() (let ((to29bf@field (car to29ba@fields-alist))) (begin (if (not to29b9@first) (display (to291c@rpad '"" '" " (+ '4 to29b0@max-condition-len)) to29ac@port) (void)) (display '"       " to29ac@port) (display (car to29bf@field) to29ac@port) (display '": " to29ac@port) (write (cdr to29bf@field) to29ac@port) (newline to29ac@port) (to29bd@loop '#f (cdr to29ba@fields-alist))))))))) (simple-conditions to29ab@e)))))) (set! to2a7f@to291e@condition-printer/p to291e@condition-printer/p) (set! to2920@record->field-alist (lambda (to29c3@r) (letrec* ((to29c6@ref (lambda (to29d1@rtd to29d2@i to29d3@x) (let ((to29d7@val ((record-accessor to29d1@rtd to29d2@i) to29d3@x))) (if (symbol? to29d7@val) (ungensym to29d7@val) to29d7@val))))) (let to29cb@loop ((to29c7@ret '()) (to29c8@rtd (record-rtd to29c3@r))) (if to29c8@rtd (to29cb@loop (append to29c7@ret (to2922@map-with-index (lambda (to29cd@i to29ce@field) (cons to29ce@field (to29c6@ref to29c8@rtd to29cd@i to29c3@r))) (vector->list (record-type-field-names to29c8@rtd)))) (record-type-parent to29c8@rtd)) to29c7@ret))))) (set! to2a80@to2920@record->field-alist to2920@record->field-alist) (set! to2922@map-with-index (lambda (to29d9@proc to29da@lst) (let to29e3@loop ((to29dd@i '0) (to29de@lst to29da@lst) (to29df@ret '())) (if (null? to29de@lst) (reverse to29df@ret) (to29e3@loop (+ to29dd@i '1) (cdr to29de@lst) (cons (to29d9@proc to29dd@i (car to29de@lst)) to29df@ret)))))) (set! to2a81@to2922@map-with-index to2922@map-with-index) (set! to2924@repl (lambda to29e5@x (letrec* ((to29e8@rec (lambda () (begin (display '"mosh> ") ((call/cc (lambda (to29eb@to29e9) (lambda () (with-exception-handler (lambda (to29ed@e) ((call/cc (lambda (to29ef@to29ea) (to29eb@to29e9 (lambda () (if '#t (begin (display '"\nUnhandled exception:\n\n" (current-error-port)) (if (condition? to29ed@e) (to291e@condition-printer/p to29ed@e (current-error-port)) (format (current-error-port) '"  Non-condition object:\n     ~a\n" to29ed@e))) (to29ef@to29ea (lambda () (raise-continuable to29ed@e)))))))))) (lambda () (let to29f5@loop ((to29f1@line (get-line (current-input-port))) (to29f2@accum '"")) (letrec* ((to29f8@parentheses-ok? (lambda (to2a03@text) (let to2a0b@loop ((to2a05@chars (string->list to2a03@text)) (to2a06@p0 '0) (to2a07@p1 '0)) (if (null? to2a05@chars) (= '0 to2a06@p0 to2a07@p1) (let ((to2a0d@t (car to2a05@chars))) (if (memv to2a0d@t '(#\()) (to2a0b@loop (cdr to2a05@chars) (+ to2a06@p0 '1) to2a07@p1) (if (memv to2a0d@t '(#\))) (to2a0b@loop (cdr to2a05@chars) (- to2a06@p0 '1) to2a07@p1) (if (memv to2a0d@t '(#\[)) (to2a0b@loop (cdr to2a05@chars) to2a06@p0 (+ to2a07@p1 '1)) (if (memv to2a0d@t '(#\])) (to2a0b@loop (cdr to2a05@chars) to2a06@p0 (- to2a07@p1 '1)) (to2a0b@loop (cdr to2a05@chars) to2a06@p0 to2a07@p1)))))))))) (to29fa@eval-string-print (lambda (to29fd@text) (if (not (or (string=? '"\n" to29fd@text) (= '0 (string-length to29fd@text)))) (call-with-values (lambda () (to2932@eval-top-level (call-with-port (open-string-input-port to29fd@text) read))) (lambda to29ff@out* (for-each (lambda (to2a01@out) (begin (write/ss to2a01@out) (newline))) to29ff@out*))) (void))))) (if (eof-object? to29f1@line) (begin (to29fa@eval-string-print to29f2@accum) (exit)) (let ((to29fb@current (string-append to29f2@accum to29f1@line))) (if (to29f8@parentheses-ok? to29fb@current) (to29fa@eval-string-print to29fb@current) (to29f5@loop (get-line (current-input-port)) to29fb@current)))))))))))) (newline) (to29e8@rec))))) (to29e8@rec)))) (set! to2a82@to2924@repl to2924@repl) (set! to2926@trace-printer (to6d8@to5b6@make-parameter write)) (set! to2a83@to2926@trace-printer to2926@trace-printer) (set! to2928@command-line (to6d8@to5b6@make-parameter (get-command-line))) (set! to2a84@to2928@command-line to2928@command-line) (set! to292a@local-library-path (lambda (to2a0f@filename) (to992@to7ce@library-path))) (set! to2a85@to292a@local-library-path to292a@local-library-path) (set! to292c@load/args (lambda (to2a11@filename . to2a13@args) (begin (apply to293c@load-r6rs-top-level to2a11@filename 'load to2a13@args) (void)))) (set! to2a86@to292c@load/args to292c@load/args) (set! to292e@load (lambda (to2a15@filename) (begin (apply to293c@load-r6rs-top-level to2a15@filename 'load (to2928@command-line)) (void)))) (set! to2a87@to292e@load to292e@load) (set! to2930@ironscheme-build (lambda () (to292e@load '"ironscheme-buildscript.ss"))) (set! to2a88@to2930@ironscheme-build to2930@ironscheme-build) (set! to2932@eval-top-level (lambda (to2a17@x) (to28ef@toe4f@eval to2a17@x (to2906@toe7d@interaction-environment)))) (set! to2a89@to2932@eval-top-level to2932@eval-top-level) (set! to2934@compile-system-libraries (lambda () (to2932@eval-top-level '(begin (include "system-libraries.ss") (compile "system-libraries.ss"))))) (set! to2a8a@to2934@compile-system-libraries to2934@compile-system-libraries) (set! to2936@compile (lambda (to2a19@filename) (to293c@load-r6rs-top-level to2a19@filename 'compile))) (set! to2a8b@to2936@compile to2936@compile) (set! to2938@compile->closure (lambda (to2a1b@filename) (to293c@load-r6rs-top-level to2a1b@filename 'closure))) (set! to2a8c@to2938@compile->closure to2938@compile->closure) (set! to293a@pre-compile-r6rs-file (lambda (to2a1d@filename) (to293c@load-r6rs-top-level to2a1d@filename 'compile))) (set! to2a8d@to293a@pre-compile-r6rs-file to293a@pre-compile-r6rs-file) (set! to293c@load-r6rs-top-level (lambda (to2a1f@filename to2a20@how . to2a23@args) (begin (to992@to7ce@library-path (to292a@local-library-path to2a1f@filename)) (let ((to2a25@x* (with-input-from-file to2a1f@filename (lambda () (let to2a27@f () (let ((to2a29@x (to6ca@to59a@read-annotated))) (if (eof-object? to2a29@x) '() (cons to2a29@x (to2a27@f))))))))) (let ((to2a2b@t to2a20@how)) (if (memv to2a2b@t '(closure)) (to2905@toe7b@pre-compile-r6rs-top-level to2a25@x*) (if (memv to2a2b@t '(load)) (begin (to2928@command-line (cons to2a1f@filename (car to2a23@args))) (to6d9@to5b8@mosh-cache-dir (create-mosh-cache-dir)) (if (to6d9@to5b8@mosh-cache-dir) (gensym-prefix-set! (to2942@prefix-inc! (string-append (to6d9@to5b8@mosh-cache-dir) '"/prefix.txt"))) (void)) (if (symbol-value '%clean-acc) (for-each (lambda (to2a2d@file) ((call/cc (lambda (to2a31@to2a2f) (lambda () (with-exception-handler (lambda (to2a33@c) ((call/cc (lambda (to2a35@to2a30) (to2a31@to2a2f (lambda () (if '#t '#t (to2a35@to2a30 (lambda () (raise-continuable to2a33@c)))))))))) (lambda () (delete-file (string-append (to6d9@to5b8@mosh-cache-dir) '"/" to2a2d@file))))))))) (directory-list (to6d9@to5b8@mosh-cache-dir))) (void)) (let ((to2a37@compiled (to2904@toe79@compile-r6rs-top-level to2a25@x*))) (begin (if (and (to6d9@to5b8@mosh-cache-dir) (not (symbol-value '%disable-acc))) (to996@to7d6@serialize-all to6d3@to5ac@serialize-library to72f@to6e8@compile-core-expr) (void)) (to2a37@compiled)))) (if (memv to2a2b@t '(compile)) (begin (to2904@toe79@compile-r6rs-top-level to2a25@x*) (to996@to7d6@serialize-all to6d3@to5ac@serialize-library to72f@to6e8@compile-core-expr)) (if '#f '#f (void)))))))))) (set! to2a8e@to293c@load-r6rs-top-level to293c@load-r6rs-top-level) (set! to293e@load-r6rs-top-level-sexp (lambda (to2a39@import-spec to2a3a@thunk) (let ((to2a45@to2a3e to992@to7ce@library-path) (to2a46@to2a40 to6d9@to5b8@mosh-cache-dir) (to2a47@to2a42 (to292a@local-library-path '"")) (to2a48@to2a44 (create-mosh-cache-dir))) (let ((to2a4d@swap (lambda () (begin (let ((to2a4f@t (to2a45@to2a3e))) (begin (to2a45@to2a3e to2a47@to2a42) (set! to2a47@to2a42 to2a4f@t))) (let ((to2a51@t (to2a46@to2a40))) (begin (to2a46@to2a40 to2a48@to2a44) (set! to2a48@to2a44 to2a51@t))))))) (dynamic-wind to2a4d@swap (lambda () (begin (if (to6d9@to5b8@mosh-cache-dir) (gensym-prefix-set! (to2942@prefix-inc! (string-append (to6d9@to5b8@mosh-cache-dir) '"/prefix.txt"))) (void)) (let ((to2a57@to2a54 to2928@command-line) (to2a58@to2a56 '())) (let ((to2a5b@swap (lambda () (let ((to2a5d@t (to2a57@to2a54))) (begin (to2a57@to2a54 to2a58@to2a56) (set! to2a58@to2a56 to2a5d@t)))))) (dynamic-wind to2a5b@swap (lambda () ((to2904@toe79@compile-r6rs-top-level (list (cons 'import to2a39@import-spec) (list to2a3a@thunk))))) to2a5b@swap))))) to2a4d@swap))))) (set! to2a8f@to293e@load-r6rs-top-level-sexp to293e@load-r6rs-top-level-sexp) (set! to2940@prefix-inc (lambda (to2a5f@prefix-string) (let ((to2a61@prefix (symbol->string to2a5f@prefix-string))) (let ((to2a63@len (string-length to2a61@prefix))) (let to2a6b@loop ((to2a65@i (- to2a63@len '1)) (to2a66@carry? '#t) (to2a67@accum '())) (if (< to2a65@i '0) (string->symbol (list->string (if to2a66@carry? (cons '#\a to2a67@accum) to2a67@accum))) (if to2a66@carry? (let ((to2a6d@next-integer (+ '1 (char->integer (string-ref to2a61@prefix to2a65@i))))) (if (= to2a6d@next-integer '123) (to2a6b@loop (- to2a65@i '1) '#f (cons '#\A to2a67@accum)) (if (= to2a6d@next-integer '91) (to2a6b@loop (- to2a65@i '1) '#t (cons '#\a to2a67@accum)) (to2a6b@loop (- to2a65@i '1) '#f (cons (integer->char to2a6d@next-integer) to2a67@accum))))) (to2a6b@loop (- to2a65@i '1) '#f (cons (string-ref to2a61@prefix to2a65@i) to2a67@accum))))))))) (set! to2a90@to2940@prefix-inc to2940@prefix-inc) (set! to2942@prefix-inc! (lambda (to2a6f@file) (begin (if (not (file-exists? to2a6f@file)) (call-with-output-file to2a6f@file (lambda (to2a71@port) (write 'd to2a71@port))) (void)) (let ((to2a73@prefix (call-with-input-file to2a6f@file read))) (if (main-vm?) (let ((to2a75@next-prefix (to2940@prefix-inc to2a73@prefix))) (begin (call-with-port (open-file-output-port to2a6f@file (make-file-options '(no-fail)) 'block (native-transcoder)) (lambda (to2a77@port) (write to2a75@next-prefix to2a77@port))) to2a73@prefix)) to2a73@prefix))))) (set! to2a91@to2942@prefix-inc! to2942@prefix-inc!) (begin (to997@to7d8@current-precompiled-library-loader to6d4@to5ae@load-serialized-library) (set-symbol-value! 'load to292e@load) (set-symbol-value! 'pre-compile-r6rs-file to293a@pre-compile-r6rs-file) (set-symbol-value! 'eval-r6rs to2932@eval-top-level) (set-symbol-value! 'int-env-syms to28e6@toe3d@interaction-environment-symbols) (set-symbol-value! 'expanded2core to72e@to6e6@expanded->core) (set-symbol-value! 'trace-printer to2926@trace-printer) (set-symbol-value! 'compile-r6rs-top-level 'compile-r6rs-top-level) (set-symbol-value! 'create-non-continuable-violation (lambda (to2943@c) (condition (make-non-continuable-violation) (make-who-condition 'raise) (make-message-condition '"returned from non-continuable exception") (make-irritants-condition (list to2943@c))))) (to2918@parse-and-add-library-path (get-environment-variable '"MOSH_LOADPATH") '"** WARN in environment variable 'MOSH_LOADPATH': directory ~s not exist\n") (to2918@parse-and-add-library-path (symbol-value '%loadpath) '"** WARN in command-line option '--loadpath': directory ~s not exist\n") (if (mosh-executable-path) (if (file-exists? (string-append (mosh-executable-path) '"/lib")) (to2916@add-library-path! (string-append (mosh-executable-path) '"/lib")) (void)) (if (file-exists? (string-append (current-directory) '"/lib")) (to2916@add-library-path! (string-append (current-directory) '"/lib")) (void))) (if (file-exists? (string-append (standard-library-path) '"/lib")) (to2916@add-library-path! (string-append (standard-library-path) '"/lib")) (void)) (let ((to2945@prefix (lambda (to2947@ext to2948@ls) (append (map (lambda (to294b@x) (string-append to2947@ext to294b@x)) to2948@ls) to2948@ls)))) (to993@to7d0@library-extensions (to2945@prefix '".mosh" (to993@to7d0@library-extensions)))) (current-exception-handler (lambda (to294d@c) (begin (if (condition? to294d@c) (to291e@condition-printer/p to294d@c (current-error-port)) (format (current-error-port) '"\n Non-condition object:\n     ~a\n" to294d@c)) to294d@c))) (if ((call/cc (lambda (to2951@to294f) (lambda () (with-exception-handler (lambda (to2953@c) ((call/cc (lambda (to2955@to2950) (to2951@to294f (lambda () (if '#t '#f (to2955@to2950 (lambda () (raise-continuable to2953@c)))))))))) (lambda () (symbol-value '%vm-import-spec))))))) (to293e@load-r6rs-top-level-sexp (symbol-value '%vm-import-spec) (symbol-value '%vm-thunk)) (if (null? (to2928@command-line)) (let ((to295f@to2958 to2928@command-line) (to2960@to295a to6d9@to5b8@mosh-cache-dir) (to2961@to295c '()) (to2962@to295e (create-mosh-cache-dir))) (let ((to2967@swap (lambda () (begin (let ((to2969@t (to295f@to2958))) (begin (to295f@to2958 to2961@to295c) (set! to2961@to295c to2969@t))) (let ((to296b@t (to2960@to295a))) (begin (to2960@to295a to2962@to295e) (set! to2962@to295e to296b@t))))))) (dynamic-wind to2967@swap (lambda () (begin (if (to6d9@to5b8@mosh-cache-dir) (gensym-prefix-set! (to2942@prefix-inc! (string-append (to6d9@to5b8@mosh-cache-dir) '"/prefix.txt"))) (void)) (to2924@repl))) to2967@swap))) (begin (to992@to7ce@library-path (to292a@local-library-path (car (to2928@command-line)))) (set! to2914@x* (with-input-from-file (car (to2928@command-line)) (lambda () (let to296d@f () (let ((to296f@x (to6ca@to59a@read-annotated))) (if (eof-object? to296f@x) '() (cons to296f@x (to296d@f)))))))) (to2928@command-line (cons (car (to2928@command-line)) (cdr (to2928@command-line)))) (to6d9@to5b8@mosh-cache-dir (create-mosh-cache-dir)) (if (to6d9@to5b8@mosh-cache-dir) (gensym-prefix-set! (to2942@prefix-inc! (string-append (to6d9@to5b8@mosh-cache-dir) '"/prefix.txt"))) (void)) (if (symbol-value '%clean-acc) (for-each (lambda (to2971@file) ((call/cc (lambda (to2975@to2973) (lambda () (with-exception-handler (lambda (to2977@c) ((call/cc (lambda (to2979@to2974) (to2975@to2973 (lambda () (if '#t '#t (to2979@to2974 (lambda () (raise-continuable to2977@c)))))))))) (lambda () (delete-file (string-append (to6d9@to5b8@mosh-cache-dir) '"/" to2971@file))))))))) (directory-list (to6d9@to5b8@mosh-cache-dir))) (void)) (let ((to297b@compiled (to2904@toe79@compile-r6rs-top-level to2914@x*))) (begin (if (and (to6d9@to5b8@mosh-cache-dir) (not (symbol-value '%disable-acc))) (to996@to7d6@serialize-all to6d3@to5ac@serialize-library to72f@to6e8@compile-core-expr) (void)) (to297b@compiled))))))))
