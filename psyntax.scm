;;; Copyright (c) 2006, 2007 Abdulaziz Ghuloum and Kent Dybvig
;;; automatically generated from psyntax sources
;;; for copyright details, see psyntax/main.ss

(begin (set! l581@library-file-path->cache-path (unspecified)) (set! l583@read-annotated (unspecified)) (set! l585@annotation-stripped (unspecified)) (set! l587@annotation? (unspecified)) (set! l589@annotation-source (unspecified)) (set! l58b@annotation-expression (unspecified)) (set! l58d@scm->fasl (unspecified)) (set! l58f@fasl-save (unspecified)) (set! l591@fasl-load (unspecified)) (set! l593@verbose? (unspecified)) (set! l595@serialize-library (unspecified)) (set! l597@load-serialized-library (unspecified)) (set! l599@make-record-printer (unspecified)) (set! l59b@compile-core (unspecified)) (set! l59d@read-library-source-file (unspecified)) (set! l59f@make-parameter (unspecified)) (set! l5a1@mosh-cache-dir (unspecified)) (set! l637@file-options-spec (unspecified)) (set! l581@library-file-path->cache-path (lambda (l638@x) (call-with-values (lambda () (open-string-output-port)) (lambda (l63e@l63b l63f@l63d) (let ((l642@extract l63f@l63d) (l643@p l63e@l63b)) (letrec* ((l647@display-hex (lambda (l650@n) (if (<= '0 l650@n '9) (display l650@n l643@p) (display (integer->char (+ (char->integer '#\a) (- l650@n '10))) l643@p))))) (begin (let l64a@f ((l648@ls (string-split l638@x '#\/))) (if (not (null? l648@ls)) (begin (display '"_" l643@p) (for-each (lambda (l64c@c) (if (or (char<=? '#\a l64c@c '#\z) (char<=? '#\A l64c@c '#\Z) (char<=? '#\0 l64c@c '#\9) (memv l64c@c '(#\- #\. #\_ #\~))) (display l64c@c l643@p) (begin (display '"%" l643@p) (let ((l64e@n (char->integer l64c@c))) (begin (l647@display-hex (quotient l64e@n '16)) (l647@display-hex (remainder l64e@n '16))))))) (string->list (car l648@ls))) (l64a@f (cdr l648@ls))) (void))) (l642@extract)))))))) (set! l6b2@l581@library-file-path->cache-path l581@library-file-path->cache-path) (set! l583@read-annotated read) (set! l6b3@l583@read-annotated l583@read-annotated) (set! l585@annotation-stripped (lambda (l652@x) (l58b@annotation-expression l652@x))) (set! l6b4@l585@annotation-stripped l585@annotation-stripped) (set! l587@annotation? (lambda (l654@x) (source-info l654@x))) (set! l6b5@l587@annotation? l587@annotation?) (set! l589@annotation-source (lambda (l656@x) (source-info l656@x))) (set! l6b6@l589@annotation-source l589@annotation-source) (set! l58b@annotation-expression (lambda (l658@x) (if (pair? l658@x) (cons (car l658@x) (cdr l658@x)) (if (procedure? l658@x) (set-source-info! l658@x '#f) l658@x)))) (set! l6b7@l58b@annotation-expression l58b@annotation-expression) (set! l58d@scm->fasl (lambda (l65a@filename) (string-append (l5a1@mosh-cache-dir) '"/" (l581@library-file-path->cache-path l65a@filename) '".mosh-fasl"))) (set! l6b8@l58d@scm->fasl l58d@scm->fasl) (set! l58f@fasl-save (lambda (l65c@filename l65d@obj) (call-with-port (open-file-output-port l65c@filename) (lambda (l660@port) ((symbol-value 'fasl-write!) l65d@obj l660@port))))) (set! l6b9@l58f@fasl-save l58f@fasl-save) (set! l591@fasl-load (lambda (l662@filename) (call-with-port (open-file-input-port l662@filename) (symbol-value 'fasl-read!)))) (set! l6ba@l591@fasl-load l591@fasl-load) (set! l593@verbose? (symbol-value '%verbose)) (set! l6bb@l593@verbose? l593@verbose?) (set! l595@serialize-library (lambda (l664@filename l665@obj) (begin (if l593@verbose? (format (current-error-port) '"serialize-library ~a\n..." l664@filename) (void)) (let ((l668@expanded2core (symbol-value 'expanded2core))) (let ((l66a@compile (symbol-value 'compile-w/o-halt))) (let ((l66c@code l665@obj)) (let ((l66e@pivot (cddddr (cddddr l66c@code)))) (let ((l670@visit (l66a@compile (l668@expanded2core (car l66e@pivot))))) (begin (set-car! l66e@pivot l670@visit) (let ((l672@pivot (cdr l66e@pivot))) (let ((l674@invoke (l66a@compile (l668@expanded2core (car l672@pivot))))) (set-car! l672@pivot l674@invoke))))))))) (let ((l676@fasl-file (l58d@scm->fasl l664@filename))) (begin (if (file-exists? l676@fasl-file) (delete-file l676@fasl-file) (void)) ((call/cc (lambda (l67a@l678) (lambda () (with-exception-handler (lambda (l67c@c) ((call/cc (lambda (l67e@l679) (l67a@l678 (lambda () (if '#t (begin (if l593@verbose? (format (current-error-port) '"Warning:serialize-library failed ~a\n" l664@filename) (void)) (if (file-exists? l676@fasl-file) (delete-file l676@fasl-file) (void)) '#f) (l67e@l679 (lambda () (raise-continuable l67c@c)))))))))) (lambda () (l58f@fasl-save l676@fasl-file l665@obj)))))))))))) (set! l6bc@l595@serialize-library l595@serialize-library) (set! l597@load-serialized-library (lambda (l680@filename l681@obj) (and (l5a1@mosh-cache-dir) (let ((l684@fasl-file (l58d@scm->fasl l680@filename))) (if (and (file-exists? l684@fasl-file) ((symbol-value 'file-newer?) l684@fasl-file l680@filename)) (let ((l686@expanded2core (symbol-value 'expanded2core))) (let ((l688@eval-compiled-core (symbol-value 'eval-compiled!))) (let ((l68a@code (l591@fasl-load l684@fasl-file))) (let ((l68c@pivot (cddddr (cddddr l68a@code)))) (let ((l68e@visit (car l68c@pivot))) (let ((l690@visit-proc (lambda () (l688@eval-compiled-core l68e@visit)))) (begin (set-car! l68c@pivot l690@visit-proc) (let ((l692@pivot (cdr l68c@pivot))) (let ((l694@invoke (car l692@pivot))) (begin (set-car! l692@pivot (lambda () (l688@eval-compiled-core l694@invoke))) (apply l681@obj l68a@code))))))))))) '#f))))) (set! l6bd@l597@load-serialized-library l597@load-serialized-library) (set! l599@make-record-printer (lambda (l696@name l697@printer) (lambda l69a@x (begin (display '"record printer") (for-each display l69a@x))))) (set! l6be@l599@make-record-printer l599@make-record-printer) (set! l59b@compile-core (lambda l69c@x (apply error 'comile-core '"not implementated" l69c@x))) (set! l6bf@l59b@compile-core l59b@compile-core) (set! l59d@read-library-source-file (lambda (l69e@file-name) (with-input-from-file l69e@file-name l583@read-annotated))) (set! l6c0@l59d@read-library-source-file l59d@read-library-source-file) (set! l59f@make-parameter (lambda l6ae (let ((l6af (length l6ae))) (if (= l6af '1) (apply (lambda (l6a0@x) (l59f@make-parameter l6a0@x (lambda (l6a2@x) l6a2@x))) l6ae) (if (= l6af '2) (apply (lambda (l6a4@x l6a5@fender) (let ((l6a8@x (l6a5@fender l6a4@x))) (lambda l6ac (let ((l6ad (length l6ac))) (if (= l6ad '0) (apply (lambda () l6a8@x) l6ac) (if (= l6ad '1) (apply (lambda (l6aa@v) (set! l6a8@x (l6a5@fender l6aa@v))) l6ac) (error 'apply '"invalid arg count"))))))) l6ae) (error 'apply '"invalid arg count")))))) (set! l6c1@l59f@make-parameter l59f@make-parameter) (set! l5a1@mosh-cache-dir (l59f@make-parameter '#f)) (set! l6c2@l5a1@mosh-cache-dir l5a1@mosh-cache-dir) (set! l637@file-options-spec (lambda (l6b0@x) l6b0@x)) (set! l6c3@l637@file-options-spec l637@file-options-spec) (void))
(begin (set! l6c9@current-primitive-locations (unspecified)) (set! l6cb@mutable? (unspecified)) (set! l6cd@rewriter (unspecified)) (set! l6cf@expanded->core (unspecified)) (set! l6d1@compile-core-expr (unspecified)) (set! l6d3@pretty-print (unspecified)) (set! l6d5@compile-core-expr-to-port (unspecified)) (set! l6c9@current-primitive-locations (l6c1@l59f@make-parameter (lambda (l6d6@x) '#f) (lambda (l6d8@p) l6d8@p))) (set! l714@l6c9@current-primitive-locations l6c9@current-primitive-locations) (set! l6cb@mutable? (lambda (l6da@x) (or (pair? l6da@x) (vector? l6da@x) (hashtable? l6da@x)))) (set! l715@l6cb@mutable? l6cb@mutable?) (set! l6cd@rewriter (lambda (l6dc@quote-hack?) (letrec* ((l6df@f (lambda (l6e0@x) (if (pair? l6e0@x) (let ((l6e2@t (car l6e0@x))) (if (memv l6e2@t '(quote)) (if (and l6dc@quote-hack? (l6cb@mutable? (cadr l6e0@x))) (let ((l6e4@g (gensym))) (begin (set-symbol-value! l6e4@g (cadr l6e0@x)) l6e4@g)) l6e0@x) (if (memv l6e2@t '(case-lambda)) (cons 'case-lambda (map (lambda (l6e6@x) (cons (car l6e6@x) (map l6df@f (cdr l6e6@x)))) (cdr l6e0@x))) (if (memv l6e2@t '(lambda)) (cons* 'lambda (cadr l6e0@x) (map l6df@f (cddr l6e0@x))) (if (memv l6e2@t '(letrec)) (let ((l6e8@bindings (cadr l6e0@x)) (l6e9@body* (cddr l6e0@x))) (let ((l6ec@lhs* (map car l6e8@bindings)) (l6ed@rhs* (map cadr l6e8@bindings))) (cons* 'letrec (map list l6ec@lhs* (map l6df@f l6ed@rhs*)) (map l6df@f l6e9@body*)))) (if (memv l6e2@t '(letrec*)) (let ((l6f0@bindings (cadr l6e0@x)) (l6f1@body* (cddr l6e0@x))) (let ((l6f4@lhs* (map car l6f0@bindings)) (l6f5@rhs* (map cadr l6f0@bindings))) (cons* 'letrec* (map list l6f4@lhs* (map l6df@f l6f5@rhs*)) (map l6df@f l6f1@body*)))) (if (memv l6e2@t '(library-letrec*)) (let ((l6f8@name (cadr l6e0@x)) (l6f9@x (cdr l6e0@x))) (let ((l6fc@bindings (cadr l6f9@x)) (l6fd@body* (cddr l6f9@x))) (let ((l700@lhs* (map car l6fc@bindings)) (l701@lhs** (map cadr l6fc@bindings)) (l702@rhs* (map caddr l6fc@bindings))) (cons* 'library-letrec* l6f8@name (map list l700@lhs* l701@lhs** (map l6df@f l702@rhs*)) (map l6df@f l6fd@body*))))) (if (memv l6e2@t '(begin)) (cons 'begin (map l6df@f (cdr l6e0@x))) (if (memv l6e2@t '(set!)) (list 'set! (cadr l6e0@x) (l6df@f (caddr l6e0@x))) (if (memv l6e2@t '(primitive)) (let ((l706@op (cadr l6e0@x))) (let ((l708@t ((l6c9@current-primitive-locations) l706@op))) (if l708@t ((lambda (l70a@loc) l70a@loc) l708@t) l706@op))) (if (memv l6e2@t '(define)) l6e0@x (if (list? l6e0@x) (map l6df@f l6e0@x) (error 'rewrite '"invalid form ~s ~s" l6e0@x (list? l6e0@x)))))))))))))) l6e0@x)))) l6df@f))) (set! l716@l6cd@rewriter l6cd@rewriter) (set! l6cf@expanded->core (lambda (l70c@x) ((l6cd@rewriter '#f) l70c@x))) (set! l717@l6cf@expanded->core l6cf@expanded->core) (set! l6d1@compile-core-expr (lambda (l70e@x) ((l6cd@rewriter '#f) l70e@x))) (set! l718@l6d1@compile-core-expr l6d1@compile-core-expr) (set! l6d3@pretty-print write) (set! l719@l6d3@pretty-print l6d3@pretty-print) (set! l6d5@compile-core-expr-to-port (lambda (l710@x l711@p) (l6d3@pretty-print ((l6cd@rewriter '#f) l710@x) l711@p))) (set! l71a@l6d5@compile-core-expr-to-port l6d5@compile-core-expr-to-port) (void))
(begin (void))
(begin (set! l769@make-collection (unspecified)) (set! l76b@current-library-collection (unspecified)) (set! l76d@rp (unspecified)) (set! l777@library? (unspecified)) (set! l779@library-id (unspecified)) (set! l77b@set-library-id! (unspecified)) (set! l77d@library-name (unspecified)) (set! l77f@set-library-name! (unspecified)) (set! l781@library-version (unspecified)) (set! l783@set-library-version! (unspecified)) (set! l785@library-imp* (unspecified)) (set! l787@set-library-imp*! (unspecified)) (set! l789@library-vis* (unspecified)) (set! l78b@set-library-vis*! (unspecified)) (set! l78d@library-inv* (unspecified)) (set! l78f@set-library-inv*! (unspecified)) (set! l791@library-subst (unspecified)) (set! l793@set-library-subst! (unspecified)) (set! l795@library-env (unspecified)) (set! l797@set-library-env! (unspecified)) (set! l799@library-visit-state (unspecified)) (set! l79b@set-library-visit-state! (unspecified)) (set! l79d@library-invoke-state (unspecified)) (set! l79f@set-library-invoke-state! (unspecified)) (set! l7a1@library-visit-code (unspecified)) (set! l7a3@set-library-visit-code! (unspecified)) (set! l7a5@library-invoke-code (unspecified)) (set! l7a7@set-library-invoke-code! (unspecified)) (set! l7a9@library-visible? (unspecified)) (set! l7ab@set-library-visible?! (unspecified)) (set! l7ad@library-source-file-name (unspecified)) (set! l7af@set-library-source-file-name! (unspecified)) (set! l7b1@dummy (unspecified)) (set! l7b3@find-dependencies (unspecified)) (set! l7b5@find-library-by (unspecified)) (set! l7b7@library-path (unspecified)) (set! l7b9@library-extensions (unspecified)) (set! l7bb@library-name->file-name (unspecified)) (set! l7bd@file-locator (unspecified)) (set! l7bf@serialize-all (unspecified)) (set! l7c1@current-precompiled-library-loader (unspecified)) (set! l7c3@try-load-from-file (unspecified)) (set! l7c5@library-loader (unspecified)) (set! l7c7@current-library-expander (unspecified)) (set! l7c9@external-pending-libraries (unspecified)) (set! l7cb@find-external-library (unspecified)) (set! l7cd@find-library-by-name (unspecified)) (set! l7cf@library-exists? (unspecified)) (set! l7d1@find-library-by-spec/die (unspecified)) (set! l7d3@label->binding-table (unspecified)) (set! l7d5@install-library-record (unspecified)) (set! l7d7@install-library (unspecified)) (set! l7d9@imported-label->binding (unspecified)) (set! l7db@invoke-library (unspecified)) (set! l7dd@visit-library (unspecified)) (set! l7df@invoke-library-by-spec (unspecified)) (set! l7e1@installed-libraries (unspecified)) (set! l7e3@library-spec (unspecified)) (set! l769@make-collection (lambda () (let ((l7e4@set '())) (letrec* ((l7e7@set-cons (lambda (l7ec@x l7ed@ls) (if (memq l7ec@x l7ed@ls) l7ed@ls (cons l7ec@x l7ed@ls))))) (lambda l7ea (let ((l7eb (length l7ea))) (if (= l7eb '0) (apply (lambda () l7e4@set) l7ea) (if (= l7eb '1) (apply (lambda (l7e8@x) (set! l7e4@set (l7e7@set-cons l7e8@x l7e4@set))) l7ea) (error 'apply '"invalid arg count"))))))))) (set! l958@l769@make-collection l769@make-collection) (set! l76b@current-library-collection (l6c1@l59f@make-parameter (l769@make-collection) (lambda (l7f0@x) (begin (if (not (procedure? l7f0@x)) (assertion-violation 'current-library-collection '"not a procedure" l7f0@x) (void)) l7f0@x)))) (set! l959@l76b@current-library-collection l76b@current-library-collection) (set! l76d@rp (l6be@l599@make-record-printer 'library (lambda (l7f2@x l7f3@p l7f4@wr) (begin (if (not (l777@library? l7f2@x)) (assertion-violation 'record-type-printer '"not a library") (void)) (display (format '"#<library ~s>" (if (null? (l781@library-version l7f2@x)) (l77d@library-name l7f2@x) (append (l77d@library-name l7f2@x) (list (l781@library-version l7f2@x))))) l7f3@p))))) (set! l95a@l76d@rp l76d@rp) (set! l777@library? (lambda (l7f8@x) (and (simple-struct? l7f8@x) (eq? (simple-struct-name l7f8@x) 'library)))) (set! l95b@l777@library? l777@library?) (set! l779@library-id (lambda (l7fa@x) (simple-struct-ref l7fa@x '0))) (set! l95c@l779@library-id l779@library-id) (set! l77b@set-library-id! (lambda (l7fc@x l7fd@val) (simple-struct-set! l7fc@x '0 l7fd@val))) (set! l95d@l77b@set-library-id! l77b@set-library-id!) (set! l77d@library-name (lambda (l800@x) (simple-struct-ref l800@x '1))) (set! l95e@l77d@library-name l77d@library-name) (set! l77f@set-library-name! (lambda (l802@x l803@val) (simple-struct-set! l802@x '1 l803@val))) (set! l95f@l77f@set-library-name! l77f@set-library-name!) (set! l781@library-version (lambda (l806@x) (simple-struct-ref l806@x '2))) (set! l960@l781@library-version l781@library-version) (set! l783@set-library-version! (lambda (l808@x l809@val) (simple-struct-set! l808@x '2 l809@val))) (set! l961@l783@set-library-version! l783@set-library-version!) (set! l785@library-imp* (lambda (l80c@x) (simple-struct-ref l80c@x '3))) (set! l962@l785@library-imp* l785@library-imp*) (set! l787@set-library-imp*! (lambda (l80e@x l80f@val) (simple-struct-set! l80e@x '3 l80f@val))) (set! l963@l787@set-library-imp*! l787@set-library-imp*!) (set! l789@library-vis* (lambda (l812@x) (simple-struct-ref l812@x '4))) (set! l964@l789@library-vis* l789@library-vis*) (set! l78b@set-library-vis*! (lambda (l814@x l815@val) (simple-struct-set! l814@x '4 l815@val))) (set! l965@l78b@set-library-vis*! l78b@set-library-vis*!) (set! l78d@library-inv* (lambda (l818@x) (simple-struct-ref l818@x '5))) (set! l966@l78d@library-inv* l78d@library-inv*) (set! l78f@set-library-inv*! (lambda (l81a@x l81b@val) (simple-struct-set! l81a@x '5 l81b@val))) (set! l967@l78f@set-library-inv*! l78f@set-library-inv*!) (set! l791@library-subst (lambda (l81e@x) (simple-struct-ref l81e@x '6))) (set! l968@l791@library-subst l791@library-subst) (set! l793@set-library-subst! (lambda (l820@x l821@val) (simple-struct-set! l820@x '6 l821@val))) (set! l969@l793@set-library-subst! l793@set-library-subst!) (set! l795@library-env (lambda (l824@x) (simple-struct-ref l824@x '7))) (set! l96a@l795@library-env l795@library-env) (set! l797@set-library-env! (lambda (l826@x l827@val) (simple-struct-set! l826@x '7 l827@val))) (set! l96b@l797@set-library-env! l797@set-library-env!) (set! l799@library-visit-state (lambda (l82a@x) (simple-struct-ref l82a@x '8))) (set! l96c@l799@library-visit-state l799@library-visit-state) (set! l79b@set-library-visit-state! (lambda (l82c@x l82d@val) (simple-struct-set! l82c@x '8 l82d@val))) (set! l96d@l79b@set-library-visit-state! l79b@set-library-visit-state!) (set! l79d@library-invoke-state (lambda (l830@x) (simple-struct-ref l830@x '9))) (set! l96e@l79d@library-invoke-state l79d@library-invoke-state) (set! l79f@set-library-invoke-state! (lambda (l832@x l833@val) (simple-struct-set! l832@x '9 l833@val))) (set! l96f@l79f@set-library-invoke-state! l79f@set-library-invoke-state!) (set! l7a1@library-visit-code (lambda (l836@x) (simple-struct-ref l836@x '10))) (set! l970@l7a1@library-visit-code l7a1@library-visit-code) (set! l7a3@set-library-visit-code! (lambda (l838@x l839@val) (simple-struct-set! l838@x '10 l839@val))) (set! l971@l7a3@set-library-visit-code! l7a3@set-library-visit-code!) (set! l7a5@library-invoke-code (lambda (l83c@x) (simple-struct-ref l83c@x '11))) (set! l972@l7a5@library-invoke-code l7a5@library-invoke-code) (set! l7a7@set-library-invoke-code! (lambda (l83e@x l83f@val) (simple-struct-set! l83e@x '11 l83f@val))) (set! l973@l7a7@set-library-invoke-code! l7a7@set-library-invoke-code!) (set! l7a9@library-visible? (lambda (l842@x) (simple-struct-ref l842@x '12))) (set! l974@l7a9@library-visible? l7a9@library-visible?) (set! l7ab@set-library-visible?! (lambda (l844@x l845@val) (simple-struct-set! l844@x '12 l845@val))) (set! l975@l7ab@set-library-visible?! l7ab@set-library-visible?!) (set! l7ad@library-source-file-name (lambda (l848@x) (simple-struct-ref l848@x '13))) (set! l976@l7ad@library-source-file-name l7ad@library-source-file-name) (set! l7af@set-library-source-file-name! (lambda (l84a@x l84b@val) (simple-struct-set! l84a@x '13 l84b@val))) (set! l977@l7af@set-library-source-file-name! l7af@set-library-source-file-name!) (set! l7b1@dummy '3) (set! l978@l7b1@dummy l7b1@dummy) (set! l7b3@find-dependencies (lambda (l84e@ls) (if (null? l84e@ls) '() (assertion-violation 'find-dependencies '"cannot handle deps yet")))) (set! l979@l7b3@find-dependencies l7b3@find-dependencies) (set! l7b5@find-library-by (lambda (l850@pred) (let l854@f ((l852@ls ((l76b@current-library-collection)))) (if (null? l852@ls) '#f (if (l850@pred (car l852@ls)) (car l852@ls) (l854@f (cdr l852@ls))))))) (set! l97a@l7b5@find-library-by l7b5@find-library-by) (set! l7b7@library-path (l6c1@l59f@make-parameter '(".") (lambda (l856@x) (if (and (list? l856@x) (for-all string? l856@x)) (map (lambda (l858@x) l858@x) l856@x) (assertion-violation 'library-path '"not a list of strings" l856@x))))) (set! l97b@l7b7@library-path l7b7@library-path) (set! l7b9@library-extensions (l6c1@l59f@make-parameter '(".sls" ".ss" ".scm") (lambda (l85a@x) (if (and (list? l85a@x) (for-all string? l85a@x)) (map (lambda (l85c@x) l85c@x) l85a@x) (assertion-violation 'library-extensions '"not a list of strings" l85a@x))))) (set! l97c@l7b9@library-extensions l7b9@library-extensions) (set! l7bb@library-name->file-name (lambda (l85e@x) (call-with-values (lambda () (open-string-output-port)) (lambda (l864@l861 l865@l863) (let ((l868@extract l865@l863) (l869@p l864@l861)) (letrec* ((l86d@display-hex (lambda (l876@n) (if (<= '0 l876@n '9) (display l876@n l869@p) (display (integer->char (+ (char->integer '#\a) (- l876@n '10))) l869@p))))) (begin (let l870@f ((l86e@ls l85e@x)) (if (not (null? l86e@ls)) (begin (display '"/" l869@p) (for-each (lambda (l872@c) (if (or (char<=? '#\a l872@c '#\z) (char<=? '#\A l872@c '#\Z) (char<=? '#\0 l872@c '#\9) (memv l872@c '(#\- #\. #\_ #\~))) (display l872@c l869@p) (begin (display '"%" l869@p) (let ((l874@n (char->integer l872@c))) (begin (l86d@display-hex (quotient l874@n '16)) (l86d@display-hex (remainder l874@n '16))))))) (string->list (symbol->string (car l86e@ls)))) (l870@f (cdr l86e@ls))) (void))) (l868@extract)))))))) (set! l97d@l7bb@library-name->file-name l7bb@library-name->file-name) (set! l7bd@file-locator (l6c1@l59f@make-parameter (lambda (l878@x) (let ((l87a@str (l7bb@library-name->file-name l878@x))) (let l882@f ((l87c@ls (l7b7@library-path)) (l87d@exts (l7b9@library-extensions)) (l87e@failed-list '())) (if (null? l87c@ls) (letrec* ((l88c@l887 (make-record-type-descriptor '&library-resolution &condition-rtd 'l88a '#f '#f '#((immutable library) (immutable files)))) (l88e@l889 '#f) (l890@l888 (make-record-constructor-descriptor l88c@l887 &condition-rcd l88e@l889)) (l893@l886 (record-predicate l88c@l887)) (l895@make-library-resolution-condition (record-constructor l890@l888)) (l897@l884 (record-accessor l88c@l887 '0)) (l899@l885 (record-accessor l88c@l887 '1)) (l89b@library-resolution-condition? (condition-predicate l88c@l887)) (l89d@condition-library (condition-accessor l88c@l887 l897@l884)) (l89f@condition-files (condition-accessor l88c@l887 l899@l885))) (raise (condition (make-error) (make-who-condition 'expander) (make-message-condition '"cannot locate library in library-path") (l895@make-library-resolution-condition l878@x (reverse l87e@failed-list))))) (if (null? l87d@exts) (l882@f (cdr l87c@ls) (l7b9@library-extensions) l87e@failed-list) (let ((l8a0@name (string-append (car l87c@ls) l87a@str (car l87d@exts)))) (if (file-exists? l8a0@name) l8a0@name (l882@f l87c@ls (cdr l87d@exts) (cons l8a0@name l87e@failed-list))))))))) (lambda (l8a2@f) (if (procedure? l8a2@f) l8a2@f (assertion-violation 'file-locator '"not a procedure" l8a2@f))))) (set! l97e@l7bd@file-locator l7bd@file-locator) (set! l7bf@serialize-all (lambda (l8a4@serialize l8a5@compile) (letrec* ((l8a9@library-desc (lambda (l8ac@x) (list (l779@library-id l8ac@x) (l77d@library-name l8ac@x))))) (for-each (lambda (l8aa@x) (if (l7ad@library-source-file-name l8aa@x) (l8a4@serialize (l7ad@library-source-file-name l8aa@x) (list (l779@library-id l8aa@x) (l77d@library-name l8aa@x) (l781@library-version l8aa@x) (map l8a9@library-desc (l785@library-imp* l8aa@x)) (map l8a9@library-desc (l789@library-vis* l8aa@x)) (map l8a9@library-desc (l78d@library-inv* l8aa@x)) (l791@library-subst l8aa@x) (l795@library-env l8aa@x) (l8a5@compile (l7a1@library-visit-code l8aa@x)) (l8a5@compile (l7a5@library-invoke-code l8aa@x)) (l7a9@library-visible? l8aa@x))) (void))) ((l76b@current-library-collection)))))) (set! l97f@l7bf@serialize-all l7bf@serialize-all) (set! l7c1@current-precompiled-library-loader (l6c1@l59f@make-parameter (lambda (l8ae@filename l8af@sk) '#f))) (set! l980@l7c1@current-precompiled-library-loader l7c1@current-precompiled-library-loader) (set! l7c3@try-load-from-file (lambda (l8b2@filename) ((l7c1@current-precompiled-library-loader) l8b2@filename (lambda l8d8 (let ((l8d9 (length l8d8))) (if (= l8d9 '11) (apply (lambda (l8b4@id l8b5@name l8b6@ver l8b7@imp* l8b8@vis* l8b9@inv* l8ba@exp-subst l8bb@exp-env l8bc@visit-proc l8bd@invoke-proc l8be@visible?) (let l8cc@f ((l8ca@deps (append l8b7@imp* l8b8@vis* l8b9@inv*))) (if (null? l8ca@deps) (begin (l7d7@install-library l8b4@id l8b5@name l8b6@ver l8b7@imp* l8b8@vis* l8b9@inv* l8ba@exp-subst l8bb@exp-env l8bc@visit-proc l8bd@invoke-proc '#f '#f l8be@visible? '#f) '#t) (let ((l8ce@d (car l8ca@deps))) (let ((l8d0@label (car l8ce@d)) (l8d1@dname (cadr l8ce@d))) (let ((l8d4@l (l7cd@find-library-by-name l8d1@dname))) (if (and (l777@library? l8d4@l) (eq? l8d0@label (l779@library-id l8d4@l))) (l8cc@f (cdr l8ca@deps)) (begin (if l6bb@l593@verbose? (format (current-error-port) '"WARNING: library ~e has an inconsistent dependency on library ~e; file ~e will be recompiled from source. \n" l8b5@name l8d1@dname l8b2@filename) (void)) '#f)))))))) l8d8) (if (>= l8d9 '0) (apply (lambda l8d6@others '#f) l8d8) (error 'apply '"invalid arg count")))))))) (set! l981@l7c3@try-load-from-file l7c3@try-load-from-file) (set! l7c5@library-loader (l6c1@l59f@make-parameter (lambda (l8da@x) (let ((l8dc@file-name ((l7bd@file-locator) l8da@x))) (if (not l8dc@file-name) (assertion-violation '#f '"cannot file library" l8da@x) (or (l7c3@try-load-from-file l8dc@file-name) ((l7c7@current-library-expander) (l6c0@l59d@read-library-source-file l8dc@file-name) l8dc@file-name (lambda (l8de@name) (if (not (fast-equal? l8de@name l8da@x)) (assertion-violation 'import (call-with-values (lambda () (open-string-output-port)) (lambda (l8e4@l8e1 l8e5@l8e3) (let ((l8e8@e l8e5@l8e3) (l8e9@p l8e4@l8e1)) (begin (display '"expected to find library " l8e9@p) (write l8da@x l8e9@p) (display '" in file " l8e9@p) (display l8dc@file-name l8e9@p) (display '", found " l8e9@p) (write l8de@name l8e9@p) (display '" instead" l8e9@p) (l8e8@e)))))) (void)))))))) (lambda (l8ec@f) (if (procedure? l8ec@f) l8ec@f (assertion-violation 'library-locator '"not a procedure" l8ec@f))))) (set! l982@l7c5@library-loader l7c5@library-loader) (set! l7c7@current-library-expander (l6c1@l59f@make-parameter (lambda (l8ee@x) (assertion-violation 'library-expander '"not initialized")) (lambda (l8f0@f) (if (procedure? l8f0@f) l8f0@f (assertion-violation 'library-expander '"not a procedure" l8f0@f))))) (set! l983@l7c7@current-library-expander l7c7@current-library-expander) (set! l7c9@external-pending-libraries (l6c1@l59f@make-parameter '())) (set! l984@l7c9@external-pending-libraries l7c9@external-pending-libraries) (set! l7cb@find-external-library (lambda (l8f2@name) (begin (if (member l8f2@name (l7c9@external-pending-libraries)) (assertion-violation '#f '"circular attempt to import library was detected" l8f2@name) (void)) (let ((l8f8@l8f5 l7c9@external-pending-libraries) (l8f9@l8f7 (cons l8f2@name (l7c9@external-pending-libraries)))) (let ((l8fc@swap (lambda () (let ((l8fe@t (l8f8@l8f5))) (begin (l8f8@l8f5 l8f9@l8f7) (set! l8f9@l8f7 l8fe@t)))))) (dynamic-wind l8fc@swap (lambda () (begin ((l7c5@library-loader) l8f2@name) (or (l7b5@find-library-by (lambda (l900@x) (fast-equal? (l77d@library-name l900@x) l8f2@name))) (assertion-violation '#f '"handling external library did not yield the correct library" l8f2@name)))) l8fc@swap)))))) (set! l985@l7cb@find-external-library l7cb@find-external-library) (set! l7cd@find-library-by-name (lambda (l902@name) (or (l7b5@find-library-by (lambda (l904@x) (fast-equal? (l77d@library-name l904@x) l902@name))) (l7cb@find-external-library l902@name)))) (set! l986@l7cd@find-library-by-name l7cd@find-library-by-name) (set! l7cf@library-exists? (lambda (l906@name) (and (l7b5@find-library-by (lambda (l908@x) (fast-equal? (l77d@library-name l908@x) l906@name))) '#t))) (set! l987@l7cf@library-exists? l7cf@library-exists?) (set! l7d1@find-library-by-spec/die (lambda (l90a@spec) (let ((l90c@id (car l90a@spec))) (or (l7b5@find-library-by (lambda (l90e@x) (eq? l90c@id (l779@library-id l90e@x)))) (assertion-violation '#f '"cannot find library with required spec" l90a@spec))))) (set! l988@l7d1@find-library-by-spec/die l7d1@find-library-by-spec/die) (set! l7d3@label->binding-table (make-eq-hashtable)) (set! l989@l7d3@label->binding-table l7d3@label->binding-table) (set! l7d5@install-library-record (lambda (l910@lib) (begin (let ((l912@exp-env (l795@library-env l910@lib))) (for-each (lambda (l914@x) (let ((l916@label (car l914@x)) (l917@binding (cdr l914@x))) (let ((l91a@binding (let ((l91c@t (car l917@binding))) (if (memv l91c@t '(global)) (cons 'global (cons l910@lib (cdr l917@binding))) (if (memv l91c@t '(global-macro)) (cons 'global-macro (cons l910@lib (cdr l917@binding))) (if (memv l91c@t '(global-macro!)) (cons 'global-macro! (cons l910@lib (cdr l917@binding))) l917@binding)))))) (begin (if (hashtable-ref l7d3@label->binding-table l916@label '#f) (begin (format (current-error-port) '"FATAL overwrite !! key=~a value=~a to ~a\n" l916@label (hashtable-ref l7d3@label->binding-table l916@label '#f) l91a@binding) (exit)) (void)) (hashtable-set! l7d3@label->binding-table l916@label l91a@binding))))) l912@exp-env)) ((l76b@current-library-collection) l910@lib)))) (set! l98a@l7d5@install-library-record l7d5@install-library-record) (set! l7d7@install-library (lambda (l91e@id l91f@name l920@ver l921@imp* l922@vis* l923@inv* l924@exp-subst l925@exp-env l926@visit-proc l927@invoke-proc l928@visit-code l929@invoke-code l92a@visible? l92b@source-file-name) (let ((l93a@imp-lib* (map l7d1@find-library-by-spec/die l921@imp*)) (l93b@vis-lib* (map l7d1@find-library-by-spec/die l922@vis*)) (l93c@inv-lib* (map l7d1@find-library-by-spec/die l923@inv*))) (begin (if (not (and (symbol? l91e@id) (list? l91f@name) (list? l920@ver))) (assertion-violation 'install-library '"invalid spec with id/name/ver" l91e@id l91f@name l920@ver) (void)) (if (l7cf@library-exists? l91f@name) (assertion-violation 'install-library '"library is already installed" l91f@name) (void)) (let ((l940@lib (make-simple-struct 'library '15 (list l91e@id l91f@name l920@ver l93a@imp-lib* l93b@vis-lib* l93c@inv-lib* l924@exp-subst l925@exp-env l926@visit-proc l927@invoke-proc l928@visit-code l929@invoke-code l92a@visible? l92b@source-file-name)))) (l7d5@install-library-record l940@lib)))))) (set! l98b@l7d7@install-library l7d7@install-library) (set! l7d9@imported-label->binding (lambda (l942@lab) (hashtable-ref l7d3@label->binding-table l942@lab '#f))) (set! l98c@l7d9@imported-label->binding l7d9@imported-label->binding) (set! l7db@invoke-library (lambda (l944@lib) (let ((l946@invoke (l79d@library-invoke-state l944@lib))) (if (procedure? l946@invoke) (begin (l79f@set-library-invoke-state! l944@lib (lambda () (assertion-violation 'invoke '"circularity detected" l944@lib))) (for-each l7db@invoke-library (l78d@library-inv* l944@lib)) (l79f@set-library-invoke-state! l944@lib (lambda () (assertion-violation 'invoke '"first invoke did not return" l944@lib))) (l946@invoke) (l79f@set-library-invoke-state! l944@lib '#t)) (void))))) (set! l98d@l7db@invoke-library l7db@invoke-library) (set! l7dd@visit-library (lambda (l948@lib) (let ((l94a@visit (l799@library-visit-state l948@lib))) (if (procedure? l94a@visit) (begin (l79b@set-library-visit-state! l948@lib (lambda () (assertion-violation 'visit '"circularity detected" l948@lib))) (for-each l7db@invoke-library (l789@library-vis* l948@lib)) (l79b@set-library-visit-state! l948@lib (lambda () (assertion-violation 'invoke '"first visit did not return" l948@lib))) (l94a@visit) (l79b@set-library-visit-state! l948@lib '#t)) (void))))) (set! l98e@l7dd@visit-library l7dd@visit-library) (set! l7df@invoke-library-by-spec (lambda (l94c@spec) (l7db@invoke-library (l7d1@find-library-by-spec/die l94c@spec)))) (set! l98f@l7df@invoke-library-by-spec l7df@invoke-library-by-spec) (set! l7e1@installed-libraries (lambda l954 (let ((l955 (length l954))) (if (= l955 '1) (apply (lambda (l94e@all?) (let l952@f ((l950@ls ((l76b@current-library-collection)))) (if (null? l950@ls) '() (if (or l94e@all? (l7a9@library-visible? (car l950@ls))) (cons (car l950@ls) (l952@f (cdr l950@ls))) (l952@f (cdr l950@ls)))))) l954) (if (= l955 '0) (apply (lambda () (l7e1@installed-libraries '#f)) l954) (error 'apply '"invalid arg count")))))) (set! l990@l7e1@installed-libraries l7e1@installed-libraries) (set! l7e3@library-spec (lambda (l956@x) (begin (if (not (l777@library? l956@x)) (assertion-violation 'library-spec '"not a library" l956@x) (void)) (list (l779@library-id l956@x) (l77d@library-name l956@x) (l781@library-version l956@x))))) (set! l991@l7e3@library-spec l7e3@library-spec) (void))
(begin (set! l995@build-global-define (unspecified)) (set! la06@build-lambda (unspecified)) (set! la08@build-case-lambda (unspecified)) (set! la36@build-sequence (unspecified)) (set! la38@build-void (unspecified)) (set! la3a@build-letrec (unspecified)) (set! la3c@build-let (unspecified)) (set! la3e@build-named-let (unspecified)) (set! la40@build-letrec* (unspecified)) (set! la42@build-library-letrec* (unspecified)) (set! la44@build-receive (unspecified)) (set! l995@build-global-define (lambda (la45@x) (la38@build-void))) (set! lad3@l995@build-global-define l995@build-global-define) (set! la06@build-lambda (lambda (la47@ae la48@vars la49@exp) (list 'lambda la48@vars la49@exp))) (set! lad4@la06@build-lambda la06@build-lambda) (set! la08@build-case-lambda (lambda (la4d@ae la4e@vars* la4f@exp*) (letrec* ((la54@build-error (lambda (la8b@ae) (list '(primitive error) ''apply (list 'quote '"invalid arg count")))) (la56@build-pred (lambda (la73@ae la74@n la75@vars) (call-with-values (lambda () (let la81@f ((la7d@vars la75@vars) (la7e@count '0)) (if (pair? la7d@vars) (la81@f (cdr la7d@vars) (+ la7e@count '1)) (if (null? la7d@vars) (values la7e@count '=) (values la7e@count '>=))))) (lambda (la83@la7a la84@la7c) (let ((la87@pred la84@la7c) (la88@count la83@la7a)) (list (list 'primitive la87@pred) la74@n (list 'quote la88@count))))))) (la58@build-apply (lambda (la6b@ae la6c@g la6d@vars la6e@exp) (list '(primitive apply) (la06@build-lambda la6b@ae la6d@vars la6e@exp) la6c@g))) (la5a@expand-case-lambda (lambda (la5b@ae la5c@vars la5d@exp*) (let ((la61@g (gensym)) (la62@n (gensym))) (list 'lambda la61@g (la3c@build-let la5b@ae (list la62@n) (list (list '(primitive length) la61@g)) (let la69@f ((la65@vars* la4e@vars*) (la66@exp* la5d@exp*)) (if (null? la65@vars*) (la54@build-error la5b@ae) (list 'if (la56@build-pred la5b@ae la62@n (car la65@vars*)) (la58@build-apply la5b@ae la61@g (car la65@vars*) (car la66@exp*)) (la69@f (cdr la65@vars*) (cdr la66@exp*))))))))))) (if (= (length la4f@exp*) '1) (la06@build-lambda la4d@ae (car la4e@vars*) (car la4f@exp*)) (la5a@expand-case-lambda la4d@ae la4e@vars* la4f@exp*))))) (set! lad5@la08@build-case-lambda la08@build-case-lambda) (set! la36@build-sequence (lambda (la8d@ae la8e@exps) (let la93@loop ((la91@exps la8e@exps)) (if (null? (cdr la91@exps)) (car la91@exps) (if (equal? (car la91@exps) (la38@build-void)) (la93@loop (cdr la91@exps)) (cons 'begin la91@exps)))))) (set! lad6@la36@build-sequence la36@build-sequence) (set! la38@build-void (lambda () '((primitive void)))) (set! lad7@la38@build-void la38@build-void) (set! la3a@build-letrec (lambda (la95@ae la96@vars la97@val-exps la98@body-exp) (if (null? la96@vars) la98@body-exp (list 'letrec (map list la96@vars la97@val-exps) la98@body-exp)))) (set! lad8@la3a@build-letrec la3a@build-letrec) (set! la3c@build-let (lambda (la9d@ae la9e@vars la9f@val-exps laa0@body-exp) (if (null? la9e@vars) laa0@body-exp (list 'let (map list la9e@vars la9f@val-exps) laa0@body-exp)))) (set! lad9@la3c@build-let la3c@build-let) (set! la3e@build-named-let (lambda (laa5@ae laa6@name laa7@vars laa8@val-exps laa9@body-exp) (list 'let laa6@name (map list laa7@vars laa8@val-exps) laa9@body-exp))) (set! lada@la3e@build-named-let la3e@build-named-let) (set! la40@build-letrec* (lambda (laaf@ae lab0@vars lab1@val-exps lab2@body-exp) (if (null? lab0@vars) lab2@body-exp (list 'letrec* (map list lab0@vars lab1@val-exps) lab2@body-exp)))) (set! ladb@la40@build-letrec* la40@build-letrec*) (set! la42@build-library-letrec* (lambda (lab7@ae lab8@name lab9@vars laba@locs labb@val-exps labc@body-exp) (cons 'begin (append (map (lambda (lac3@var) (cons 'set! (cons lac3@var '((unspecified))))) lab9@vars) (append (apply append (map (lambda (lac5@var lac6@loc lac7@val-exp) (list (list 'set! lac5@var lac7@val-exp) (list 'set! lac6@loc lac5@var))) lab9@vars laba@locs labb@val-exps)) (list labc@body-exp)))))) (set! ladc@la42@build-library-letrec* la42@build-library-letrec*) (set! la44@build-receive (lambda (lacb@ae lacc@vars lacd@producer lace@body*) (begin (display '"************** in ") (cons 'receive (cons lacc@vars (cons lacd@producer lace@body*)))))) (set! ladd@la44@build-receive la44@build-receive) (void))
(begin (set! laec@file-options-macro (unspecified)) (set! laee@set-cons (unspecified)) (set! laf0@set-union (unspecified)) (set! laf5@top-mark* (unspecified)) (set! laf7@top-marked? (unspecified)) (set! laf9@gen-lexical (unspecified)) (set! lafb@gen-global (unspecified)) (set! lafd@gen-label (unspecified)) (set! laff@gen-top-level-label (unspecified)) (set! lb01@gen-define-label+loc (unspecified)) (set! lb03@gen-define-label (unspecified)) (set! lb0d@rib? (unspecified)) (set! lb0f@rib-sym* (unspecified)) (set! lb11@set-rib-sym*! (unspecified)) (set! lb13@rib-mark** (unspecified)) (set! lb15@set-rib-mark**! (unspecified)) (set! lb17@rib-label* (unspecified)) (set! lb19@set-rib-label*! (unspecified)) (set! lb1b@rib-sealed/freq (unspecified)) (set! lb1d@set-rib-sealed/freq! (unspecified)) (set! lb1f@rib-cache (unspecified)) (set! lb21@set-rib-cache! (unspecified)) (set! lb23@dummy (unspecified)) (set! lb25@make-empty-rib (unspecified)) (set! lb27@extend-rib! (unspecified)) (set! lb29@extend-rib/nc! (unspecified)) (set! lb2b@make-rib-map (unspecified)) (set! lb2d@seal-rib! (unspecified)) (set! lb2f@unseal-rib! (unspecified)) (set! lb31@make-full-rib (unspecified)) (set! lb33@rp (unspecified)) (set! lb3d@stx? (unspecified)) (set! lb3f@stx-expr (unspecified)) (set! lb41@set-stx-expr! (unspecified)) (set! lb43@stx-mark* (unspecified)) (set! lb45@set-stx-mark*! (unspecified)) (set! lb47@stx-subst* (unspecified)) (set! lb49@set-stx-subst*! (unspecified)) (set! lb4b@stx-ae* (unspecified)) (set! lb4d@set-stx-ae*! (unspecified)) (set! lb4f@dummy (unspecified)) (set! lb51@datum->stx (unspecified)) (set! lb53@gen-mark (unspecified)) (set! lb55@anti-mark (unspecified)) (set! lb57@anti-mark? (unspecified)) (set! lb59@mkstx (unspecified)) (set! lb5b@add-mark (unspecified)) (set! lb5d@add-subst (unspecified)) (set! lb5f@syntax-kind? (unspecified)) (set! lb61@syntax-vector->list (unspecified)) (set! lb63@syntax-pair? (unspecified)) (set! lb65@syntax-vector? (unspecified)) (set! lb67@syntax-null? (unspecified)) (set! lb69@syntax-list? (unspecified)) (set! lb6b@syntax-car (unspecified)) (set! lb6d@syntax-cdr (unspecified)) (set! lb6f@syntax->list (unspecified)) (set! lb71@id? (unspecified)) (set! lb73@id->sym (unspecified)) (set! lb75@bound-id=? (unspecified)) (set! lb77@free-id=? (unspecified)) (set! lb79@valid-bound-ids? (unspecified)) (set! lb7b@distinct-bound-ids? (unspecified)) (set! lb7d@bound-id-member? (unspecified)) (set! lb7f@self-evaluating? (unspecified)) (set! lb81@strip-annotations (unspecified)) (set! lb83@strip (unspecified)) (set! lb85@stx->datum (unspecified)) (set! lb87@id->label (unspecified)) (set! lb89@label->binding (unspecified)) (set! lb8b@make-binding (unspecified)) (set! lb8d@binding-type (unspecified)) (set! lb8f@binding-value (unspecified)) (set! lb91@raise-unbound-error (unspecified)) (set! lb93@syntax-type (unspecified)) (set! lba1@sanitize-binding (unspecified)) (set! lba3@make-variable-transformer (unspecified)) (set! lba5@variable-transformer? (unspecified)) (set! lba7@variable-transformer-procedure (unspecified)) (set! lba9@make-eval-transformer (unspecified)) (set! lcfa@parse-define (unspecified)) (set! lcfc@parse-define-syntax (unspecified)) (set! lcfe@scheme-stx-hashtable (unspecified)) (set! ld00@scheme-stx (unspecified)) (set! ld02@lexical-var (unspecified)) (set! ld04@lexical-mutable? (unspecified)) (set! ld06@set-lexical-mutable! (unspecified)) (set! ld08@add-lexical (unspecified)) (set! ld0a@add-lexicals (unspecified)) (set! ld0c@letrec-helper (unspecified)) (set! ld0e@let-transformer (unspecified)) (set! ld10@letrec-transformer (unspecified)) (set! ld12@letrec*-transformer (unspecified)) (set! ld14@fluid-let-syntax-transformer (unspecified)) (set! ld16@type-descriptor-transformer (unspecified)) (set! ld18@record-type-descriptor-transformer (unspecified)) (set! ld1a@record-constructor-descriptor-transformer (unspecified)) (set! ld1c@when-macro (unspecified)) (set! ld1e@unless-macro (unspecified)) (set! ld20@if-transformer (unspecified)) (set! ld22@and-transformer (unspecified)) (set! ld24@or-transformer (unspecified)) (set! ld26@case-macro (unspecified)) (set! ld28@quote-transformer (unspecified)) (set! ld2a@case-lambda-transformer (unspecified)) (set! ld2c@lambda-transformer (unspecified)) (set! ld2e@bless (unspecified)) (set! ld30@with-syntax-macro (unspecified)) (set! ld32@invalid-fmls-error (unspecified)) (set! ld34@let-macro (unspecified)) (set! ld36@let-values-macro (unspecified)) (set! ld38@let*-values-macro (unspecified)) (set! ld3a@trace-lambda-macro (unspecified)) (set! ld3c@trace-define-macro (unspecified)) (set! ld3e@trace-define-syntax-macro (unspecified)) (set! ld40@trace-let/rec-syntax (unspecified)) (set! ld42@trace-let-syntax-macro (unspecified)) (set! ld44@trace-letrec-syntax-macro (unspecified)) (set! ld46@guard-macro (unspecified)) (set! ld48@define-enumeration-macro (unspecified)) (set! ld4a@time-macro (unspecified)) (set! ld4c@delay-macro (unspecified)) (set! ld4e@assert-macro (unspecified)) (set! ld50@endianness-macro (unspecified)) (set! ld52@identifier-syntax-macro (unspecified)) (set! ld54@do-macro (unspecified)) (set! ld56@let*-macro (unspecified)) (set! ld58@or-macro (unspecified)) (set! ld5a@and-macro (unspecified)) (set! ld5c@cond-macro (unspecified)) (set! ld5e@do-include (unspecified)) (set! ld60@include-macro (unspecified)) (set! ld62@include-into-macro (unspecified)) (set! ld64@syntax-rules-macro (unspecified)) (set! ld66@quasiquote-macro (unspecified)) (set! ld68@quasisyntax-macro (unspecified)) (set! ld6a@define-struct-macro (unspecified)) (set! ld6c@define-record-type-macro (unspecified)) (set! ld6e@define-condition-type-macro (unspecified)) (set! ld70@incorrect-usage-macro (unspecified)) (set! ld72@parameterize-macro (unspecified)) (set! ld74@foreign-call-transformer (unspecified)) (set! ld76@convert-pattern (unspecified)) (set! ld78@syntax-dispatch (unspecified)) (set! ld7a@ellipsis? (unspecified)) (set! ld7c@underscore? (unspecified)) (set! ld7e@verify-literals (unspecified)) (set! ld80@syntax-case-transformer (unspecified)) (set! ld82@ellipsis-map (unspecified)) (set! ld84@syntax-transformer (unspecified)) (set! ld86@core-macro-transformer (unspecified)) (set! ld88@symbol-macro (unspecified)) (set! ld8a@macro-transformer (unspecified)) (set! ld8c@local-macro-transformer (unspecified)) (set! ld8e@do-macro-call (unspecified)) (set! ld90@chi-macro (unspecified)) (set! ld92@chi-local-macro (unspecified)) (set! ld94@chi-global-macro (unspecified)) (set! ld96@chi-expr* (unspecified)) (set! ld98@chi-application (unspecified)) (set! ld9a@chi-expr (unspecified)) (set! ld9c@chi-set! (unspecified)) (set! ld9e@verify-formals (unspecified)) (set! lda0@chi-lambda-clause (unspecified)) (set! lda2@chi-lambda-clause* (unspecified)) (set! lda4@chi-defun (unspecified)) (set! lda6@chi-rhs (unspecified)) (set! lda8@expand-interaction-rhs*/init* (unspecified)) (set! ldaa@chi-rhs* (unspecified)) (set! ldac@find-bound=? (unspecified)) (set! ldae@find-dups (unspecified)) (set! ldb0@chi-internal (unspecified)) (set! ldb2@parse-module (unspecified)) (set! ldbc@module-interface? (unspecified)) (set! ldbe@module-interface-first-mark (unspecified)) (set! ldc0@set-module-interface-first-mark! (unspecified)) (set! ldc2@module-interface-exp-id-vec (unspecified)) (set! ldc4@set-module-interface-exp-id-vec! (unspecified)) (set! ldc6@module-interface-exp-lab-vec (unspecified)) (set! ldc8@set-module-interface-exp-lab-vec! (unspecified)) (set! ldca@dummy (unspecified)) (set! ldcc@module-interface-exp-id* (unspecified)) (set! ldce@chi-internal-module (unspecified)) (set! ldd0@chi-body* (unspecified)) (set! ldd2@expand-transformer (unspecified)) (set! ldd4@parse-exports (unspecified)) (set! ldd6@parse-library-name (unspecified)) (set! ldd8@parse-library (unspecified)) (set! ldda@parse-import-spec* (unspecified)) (set! lddc@make-top-rib (unspecified)) (set! ldde@make-collector (unspecified)) (set! lde0@inv-collector (unspecified)) (set! lde2@vis-collector (unspecified)) (set! lde4@imp-collector (unspecified)) (set! lde6@chi-library-internal (unspecified)) (set! lde8@chi-interaction-expr (unspecified)) (set! ldea@library-body-expander (unspecified)) (set! ldec@core-library-expander (unspecified)) (set! ldee@parse-top-level-program (unspecified)) (set! ldf0@top-level-expander (unspecified)) (set! ldf2@rp (unspecified)) (set! ldfc@env? (unspecified)) (set! ldfe@env-names (unspecified)) (set! le00@set-env-names! (unspecified)) (set! le02@env-labels (unspecified)) (set! le04@set-env-labels! (unspecified)) (set! le06@env-itc (unspecified)) (set! le08@set-env-itc! (unspecified)) (set! le0a@dummy (unspecified)) (set! le0c@rp (unspecified)) (set! le16@interaction-env? (unspecified)) (set! le18@interaction-env-rib (unspecified)) (set! le1a@set-interaction-env-rib! (unspecified)) (set! le1c@interaction-env-r (unspecified)) (set! le1e@set-interaction-env-r! (unspecified)) (set! le20@interaction-env-locs (unspecified)) (set! le22@set-interaction-env-locs! (unspecified)) (set! le24@dummy (unspecified)) (set! le26@interaction-environment-symbols (unspecified)) (set! le28@environment-bindings (unspecified)) (set! le2a@parse-binding (unspecified)) (set! le2c@environment? (unspecified)) (set! le2e@environment-symbols (unspecified)) (set! le30@environment (unspecified)) (set! le32@null-environment (unspecified)) (set! le34@scheme-report-environment (unspecified)) (set! le36@expand (unspecified)) (set! le38@eval (unspecified)) (set! le3a@library-expander (unspecified)) (set! le3c@boot-library-expand (unspecified)) (set! le3e@rev-map-append (unspecified)) (set! le40@build-exports (unspecified)) (set! le42@make-export-subst (unspecified)) (set! le44@make-export-env/macros (unspecified)) (set! le46@generate-temporaries (unspecified)) (set! le48@free-identifier=? (unspecified)) (set! le4a@bound-identifier=? (unspecified)) (set! le4c@make-source-condition (unspecified)) (set! le4e@extract-position-condition (unspecified)) (set! le50@expression-position (unspecified)) (set! le52@assertion-error (unspecified)) (set! le54@syntax-error (unspecified)) (set! le56@syntax-violation* (unspecified)) (set! le58@syntax-violation (unspecified)) (set! le5a@identifier? (unspecified)) (set! le5c@datum->syntax (unspecified)) (set! le5e@syntax->datum (unspecified)) (set! le60@ungensym-all (unspecified)) (set! le62@compile-r6rs-top-level (unspecified)) (set! le64@pre-compile-r6rs-top-level (unspecified)) (set! le66@interaction-environment (unspecified)) (set! le68@top-level-context (unspecified)) (set! laec@file-options-macro (lambda (le69@x) (letrec* ((le6c@valid-option? (lambda (le75@x) (and (lb71@id? le75@x) (memq (lb73@id->sym le75@x) '(no-fail no-create no-truncate)))))) (let ((le6d@t le69@x)) (let ((le6f@ls/false (ld78@syntax-dispatch le6d@t '(_ . each-any)))) (if (and le6f@ls/false (apply (lambda (le71@opt*) (for-all le6c@valid-option? le71@opt*)) le6f@ls/false)) (apply (lambda (le73@opt*) (ld2e@bless (list 'make-file-options (list 'quote le73@opt*)))) le6f@ls/false) (le58@syntax-violation '#f '"invalid syntax" le6d@t))))))) (set! l27bf@laec@file-options-macro laec@file-options-macro) (set! laee@set-cons (lambda (le77@x le78@ls) (if (memq le77@x le78@ls) le78@ls (cons le77@x le78@ls)))) (set! l27c0@laee@set-cons laee@set-cons) (set! laf0@set-union (lambda (le7b@ls1 le7c@ls2) (if (null? le7b@ls1) le7c@ls2 (if (memq (car le7b@ls1) le7c@ls2) (laf0@set-union (cdr le7b@ls1) le7c@ls2) (cons (car le7b@ls1) (laf0@set-union (cdr le7b@ls1) le7c@ls2)))))) (set! l27c1@laf0@set-union laf0@set-union) (set! laf5@top-mark* '(top)) (set! l27c2@laf5@top-mark* laf5@top-mark*) (set! laf7@top-marked? (lambda (le7f@m*) (memq 'top le7f@m*))) (set! l27c3@laf7@top-marked? laf7@top-marked?) (set! laf9@gen-lexical (lambda (le81@sym) (if (symbol? le81@sym) (gensym le81@sym) (if (lb3d@stx? le81@sym) (laf9@gen-lexical (lb73@id->sym le81@sym)) (assertion-violation 'gen-lexical '"BUG: invalid arg" le81@sym))))) (set! l27c4@laf9@gen-lexical laf9@gen-lexical) (set! lafb@gen-global (lambda (le83@x) (laf9@gen-lexical le83@x))) (set! l27c5@lafb@gen-global lafb@gen-global) (set! lafd@gen-label (lambda (le85@_) (gensym))) (set! l27c6@lafd@gen-label lafd@gen-label) (set! laff@gen-top-level-label (lambda (le87@id le88@rib) (letrec* ((le8c@find (lambda (le97@sym le98@mark* le99@sym* le9a@mark** le9b@label*) (and (pair? le99@sym*) (if (and (eq? le97@sym (car le99@sym*)) (same-marks? le98@mark* (car le9a@mark**))) (car le9b@label*) (le8c@find le97@sym le98@mark* (cdr le99@sym*) (cdr le9a@mark**) (cdr le9b@label*))))))) (let ((le8d@sym (lb73@id->sym le87@id)) (le8e@mark* (lb43@stx-mark* le87@id))) (let ((le91@sym* (lb0f@rib-sym* le88@rib))) (let ((le93@t (and (memq le8d@sym (lb0f@rib-sym* le88@rib)) (le8c@find le8d@sym le8e@mark* le91@sym* (lb13@rib-mark** le88@rib) (lb17@rib-label* le88@rib))))) (if le93@t ((lambda (le95@label) (if (l98c@l7d9@imported-label->binding le95@label) (gensym) le95@label)) le93@t) (gensym)))))))) (set! l27c7@laff@gen-top-level-label laff@gen-top-level-label) (set! lb01@gen-define-label+loc (lambda (lea1@id lea2@rib) (let ((lea5@t (le68@top-level-context))) (if lea5@t ((lambda (lea7@env) (let ((lea9@label (laff@gen-top-level-label lea1@id lea2@rib)) (leaa@locs (le20@interaction-env-locs lea7@env))) (values lea9@label (let ((lead@t (assq lea9@label leaa@locs))) (if lead@t (cdr lead@t) (let ((leaf@loc (laf9@gen-lexical lea1@id))) (begin (le22@set-interaction-env-locs! lea7@env (cons (cons lea9@label leaf@loc) leaa@locs)) leaf@loc))))))) lea5@t) (values (gensym) (laf9@gen-lexical lea1@id)))))) (set! l27c8@lb01@gen-define-label+loc lb01@gen-define-label+loc) (set! lb03@gen-define-label (lambda (leb1@id leb2@rib) (if (le68@top-level-context) (laff@gen-top-level-label leb1@id leb2@rib) (gensym)))) (set! l27c9@lb03@gen-define-label lb03@gen-define-label) (set! lb0d@rib? (lambda (leb5@x) (and (simple-struct? leb5@x) (eq? (simple-struct-name leb5@x) 'rib)))) (set! l27ca@lb0d@rib? lb0d@rib?) (set! lb0f@rib-sym* (lambda (leb7@x) (simple-struct-ref leb7@x '0))) (set! l27cb@lb0f@rib-sym* lb0f@rib-sym*) (set! lb11@set-rib-sym*! (lambda (leb9@x leba@val) (simple-struct-set! leb9@x '0 leba@val))) (set! l27cc@lb11@set-rib-sym*! lb11@set-rib-sym*!) (set! lb13@rib-mark** (lambda (lebd@x) (simple-struct-ref lebd@x '1))) (set! l27cd@lb13@rib-mark** lb13@rib-mark**) (set! lb15@set-rib-mark**! (lambda (lebf@x lec0@val) (simple-struct-set! lebf@x '1 lec0@val))) (set! l27ce@lb15@set-rib-mark**! lb15@set-rib-mark**!) (set! lb17@rib-label* (lambda (lec3@x) (simple-struct-ref lec3@x '2))) (set! l27cf@lb17@rib-label* lb17@rib-label*) (set! lb19@set-rib-label*! (lambda (lec5@x lec6@val) (simple-struct-set! lec5@x '2 lec6@val))) (set! l27d0@lb19@set-rib-label*! lb19@set-rib-label*!) (set! lb1b@rib-sealed/freq (lambda (lec9@x) (simple-struct-ref lec9@x '3))) (set! l27d1@lb1b@rib-sealed/freq lb1b@rib-sealed/freq) (set! lb1d@set-rib-sealed/freq! (lambda (lecb@x lecc@val) (simple-struct-set! lecb@x '3 lecc@val))) (set! l27d2@lb1d@set-rib-sealed/freq! lb1d@set-rib-sealed/freq!) (set! lb1f@rib-cache (lambda (lecf@x) (simple-struct-ref lecf@x '4))) (set! l27d3@lb1f@rib-cache lb1f@rib-cache) (set! lb21@set-rib-cache! (lambda (led1@x led2@val) (simple-struct-set! led1@x '4 led2@val))) (set! l27d4@lb21@set-rib-cache! lb21@set-rib-cache!) (set! lb23@dummy '3) (set! l27d5@lb23@dummy lb23@dummy) (set! lb25@make-empty-rib (lambda () (make-simple-struct 'rib '6 (list '() '() '() '#f '#f)))) (set! l27d6@lb25@make-empty-rib lb25@make-empty-rib) (set! lb27@extend-rib! (lambda (led5@rib led6@id led7@label) (letrec* ((ledc@find (lambda (lee9@sym leea@mark* leeb@sym* leec@mark** leed@label*) (and (pair? leeb@sym*) (if (and (eq? lee9@sym (car leeb@sym*)) (same-marks? leea@mark* (car leec@mark**))) leed@label* (ledc@find lee9@sym leea@mark* (cdr leeb@sym*) (cdr leec@mark**) (cdr leed@label*))))))) (begin (if (lb1b@rib-sealed/freq led5@rib) (assertion-violation 'extend-rib! '"BUG: rib is sealed" led5@rib) (void)) (let ((ledd@sym (lb73@id->sym led6@id)) (lede@mark* (lb43@stx-mark* led6@id))) (let ((lee1@sym* (lb0f@rib-sym* led5@rib))) (let ((lee3@t (and (memq ledd@sym (lb0f@rib-sym* led5@rib)) (ledc@find ledd@sym lede@mark* lee1@sym* (lb13@rib-mark** led5@rib) (lb17@rib-label* led5@rib))))) (if lee3@t ((lambda (lee5@p) (if (not (eq? led7@label (car lee5@p))) (if (le68@top-level-context) (set-car! lee5@p led7@label) (le58@syntax-violation '#f '"multiple definitions of identifier" led6@id)) (void))) lee3@t) (begin (if (lb1f@rib-cache led5@rib) (hashtable-update! (lb1f@rib-cache led5@rib) ledd@sym (lambda (lee7@e) (cons (cons lede@mark* led7@label) lee7@e)) '()) (void)) (lb11@set-rib-sym*! led5@rib (cons ledd@sym lee1@sym*)) (lb15@set-rib-mark**! led5@rib (cons lede@mark* (lb13@rib-mark** led5@rib))) (lb19@set-rib-label*! led5@rib (cons led7@label (lb17@rib-label* led5@rib)))))))))))) (set! l27d7@lb27@extend-rib! lb27@extend-rib!) (set! lb29@extend-rib/nc! (lambda (lef3@rib lef4@id lef5@label) (let ((lef9@sym (lb73@id->sym lef4@id)) (lefa@mark* (lb43@stx-mark* lef4@id))) (let ((lefd@sym* (lb0f@rib-sym* lef3@rib))) (begin (if (lb1f@rib-cache lef3@rib) (hashtable-update! (lb1f@rib-cache lef3@rib) lef9@sym (lambda (leff@e) (cons (cons lefa@mark* lef5@label) leff@e)) '()) (void)) (lb11@set-rib-sym*! lef3@rib (cons lef9@sym lefd@sym*)) (lb15@set-rib-mark**! lef3@rib (cons lefa@mark* (lb13@rib-mark** lef3@rib))) (lb19@set-rib-label*! lef3@rib (cons lef5@label (lb17@rib-label* lef3@rib)))))))) (set! l27d8@lb29@extend-rib/nc! lb29@extend-rib/nc!) (set! lb2b@make-rib-map (lambda (lf01@sym*) (let ((lf03@ht (make-eq-hashtable))) (let lf09@f ((lf05@i '0) (lf06@sym* lf01@sym*)) (if (null? lf06@sym*) lf03@ht (begin (hashtable-update! lf03@ht (car lf06@sym*) (lambda (lf0b@x) (cons lf05@i lf0b@x)) '()) (lf09@f (+ lf05@i '1) (cdr lf06@sym*)))))))) (set! l27d9@lb2b@make-rib-map lb2b@make-rib-map) (set! lb2d@seal-rib! (lambda (lf0d@rib) (let ((lf0f@sym* (lb0f@rib-sym* lf0d@rib))) (if (not (null? lf0f@sym*)) (begin (lb11@set-rib-sym*! lf0d@rib (list->vector lf0f@sym*)) (lb15@set-rib-mark**! lf0d@rib (list->vector (lb13@rib-mark** lf0d@rib))) (lb19@set-rib-label*! lf0d@rib (list->vector (lb17@rib-label* lf0d@rib))) (lb1d@set-rib-sealed/freq! lf0d@rib (lb2b@make-rib-map lf0f@sym*))) (void))))) (set! l27da@lb2d@seal-rib! lb2d@seal-rib!) (set! lb2f@unseal-rib! (lambda (lf11@rib) (if (lb1b@rib-sealed/freq lf11@rib) (begin (lb1d@set-rib-sealed/freq! lf11@rib '#f) (lb11@set-rib-sym*! lf11@rib (vector->list (lb0f@rib-sym* lf11@rib))) (lb15@set-rib-mark**! lf11@rib (vector->list (lb13@rib-mark** lf11@rib))) (lb19@set-rib-label*! lf11@rib (vector->list (lb17@rib-label* lf11@rib)))) (void)))) (set! l27db@lb2f@unseal-rib! lb2f@unseal-rib!) (set! lb31@make-full-rib (lambda (lf13@id* lf14@label*) (let ((lf17@r (make-simple-struct 'rib '6 (list (map lb73@id->sym lf13@id*) (map lb43@stx-mark* lf13@id*) lf14@label* '#f '#f)))) (begin (lb2d@seal-rib! lf17@r) lf17@r)))) (set! l27dc@lb31@make-full-rib lb31@make-full-rib) (set! lb33@rp (l6be@l599@make-record-printer 'stx (lambda (lf19@x lf1a@p lf1b@wr) (begin (display '"#<syntax " lf1a@p) (write (lb85@stx->datum lf19@x) lf1a@p) (let ((lf1f@expr (lb3f@stx-expr lf19@x))) (if (l6b5@l587@annotation? lf1f@expr) (let ((lf21@src (l6b6@l589@annotation-source lf1f@expr))) (if (pair? lf21@src) (begin (display '" [" lf1a@p) (display (cdr lf21@src) lf1a@p) (display '" of " lf1a@p) (display (car lf21@src) lf1a@p) (display '"]" lf1a@p)) (void))) (void))) (display '">" lf1a@p))))) (set! l27dd@lb33@rp lb33@rp) (set! lb3d@stx? (lambda (lf23@x) (and (simple-struct? lf23@x) (eq? (simple-struct-name lf23@x) 'stx)))) (set! l27de@lb3d@stx? lb3d@stx?) (set! lb3f@stx-expr (lambda (lf25@x) (simple-struct-ref lf25@x '0))) (set! l27df@lb3f@stx-expr lb3f@stx-expr) (set! lb41@set-stx-expr! (lambda (lf27@x lf28@val) (simple-struct-set! lf27@x '0 lf28@val))) (set! l27e0@lb41@set-stx-expr! lb41@set-stx-expr!) (set! lb43@stx-mark* (lambda (lf2b@x) (simple-struct-ref lf2b@x '1))) (set! l27e1@lb43@stx-mark* lb43@stx-mark*) (set! lb45@set-stx-mark*! (lambda (lf2d@x lf2e@val) (simple-struct-set! lf2d@x '1 lf2e@val))) (set! l27e2@lb45@set-stx-mark*! lb45@set-stx-mark*!) (set! lb47@stx-subst* (lambda (lf31@x) (simple-struct-ref lf31@x '2))) (set! l27e3@lb47@stx-subst* lb47@stx-subst*) (set! lb49@set-stx-subst*! (lambda (lf33@x lf34@val) (simple-struct-set! lf33@x '2 lf34@val))) (set! l27e4@lb49@set-stx-subst*! lb49@set-stx-subst*!) (set! lb4b@stx-ae* (lambda (lf37@x) (simple-struct-ref lf37@x '3))) (set! l27e5@lb4b@stx-ae* lb4b@stx-ae*) (set! lb4d@set-stx-ae*! (lambda (lf39@x lf3a@val) (simple-struct-set! lf39@x '3 lf3a@val))) (set! l27e6@lb4d@set-stx-ae*! lb4d@set-stx-ae*!) (set! lb4f@dummy '3) (set! l27e7@lb4f@dummy lb4f@dummy) (set! lb51@datum->stx (lambda (lf3d@id lf3e@datum) (make-simple-struct 'stx '5 (list lf3e@datum (lb43@stx-mark* lf3d@id) (lb47@stx-subst* lf3d@id) (lb4b@stx-ae* lf3d@id))))) (set! l27e8@lb51@datum->stx lb51@datum->stx) (set! lb53@gen-mark (lambda () (string '#\m))) (set! l27e9@lb53@gen-mark lb53@gen-mark) (set! lb55@anti-mark '#f) (set! l27ea@lb55@anti-mark lb55@anti-mark) (set! lb57@anti-mark? not) (set! l27eb@lb57@anti-mark? lb57@anti-mark?) (set! lb59@mkstx (lambda (lf41@e lf42@m* lf43@s* lf44@ae*) (if (and (lb3d@stx? lf41@e) (not (laf7@top-marked? lf42@m*))) (call-with-values (lambda () (join-wraps lf42@m* lf43@s* lf44@ae* lf41@e)) (lambda (lf4f@lf4a lf50@lf4c lf51@lf4e) (let ((lf55@ae* lf51@lf4e) (lf56@s* lf50@lf4c) (lf57@m* lf4f@lf4a)) (make-simple-struct 'stx '5 (list (lb3f@stx-expr lf41@e) lf57@m* lf56@s* lf55@ae*))))) (make-simple-struct 'stx '5 (list lf41@e lf42@m* lf43@s* lf44@ae*))))) (set! l27ec@lb59@mkstx lb59@mkstx) (set! lb5b@add-mark (lambda (lf5b@m lf5c@e lf5d@ae) (lb59@mkstx lf5c@e (list lf5b@m) '(shift) (list lf5d@ae)))) (set! l27ed@lb5b@add-mark lb5b@add-mark) (set! lb5d@add-subst (lambda (lf61@subst lf62@e) (lb59@mkstx lf62@e '() (list lf61@subst) '()))) (set! l27ee@lb5d@add-subst lb5d@add-subst) (set! lb5f@syntax-kind? (lambda (lf65@x lf66@p?) (if (lb3d@stx? lf65@x) (lb5f@syntax-kind? (lb3f@stx-expr lf65@x) lf66@p?) (if (l6b5@l587@annotation? lf65@x) (lb5f@syntax-kind? (l6b7@l58b@annotation-expression lf65@x) lf66@p?) (lf66@p? lf65@x))))) (set! l27ef@lb5f@syntax-kind? lb5f@syntax-kind?) (set! lb61@syntax-vector->list (lambda (lf69@x) (if (lb3d@stx? lf69@x) (let ((lf6b@ls (lb61@syntax-vector->list (lb3f@stx-expr lf69@x))) (lf6c@m* (lb43@stx-mark* lf69@x)) (lf6d@s* (lb47@stx-subst* lf69@x)) (lf6e@ae* (lb4b@stx-ae* lf69@x))) (map (lambda (lf73@x) (lb59@mkstx lf73@x lf6c@m* lf6d@s* lf6e@ae*)) lf6b@ls)) (if (l6b5@l587@annotation? lf69@x) (lb61@syntax-vector->list (l6b7@l58b@annotation-expression lf69@x)) (if (vector? lf69@x) (vector->list lf69@x) (assertion-violation 'syntax-vector->list '"BUG: not a syntax vector" lf69@x)))))) (set! l27f0@lb61@syntax-vector->list lb61@syntax-vector->list) (set! lb63@syntax-pair? (lambda (lf75@x) (lb5f@syntax-kind? lf75@x pair?))) (set! l27f1@lb63@syntax-pair? lb63@syntax-pair?) (set! lb65@syntax-vector? (lambda (lf77@x) (lb5f@syntax-kind? lf77@x vector?))) (set! l27f2@lb65@syntax-vector? lb65@syntax-vector?) (set! lb67@syntax-null? (lambda (lf79@x) (lb5f@syntax-kind? lf79@x null?))) (set! l27f3@lb67@syntax-null? lb67@syntax-null?) (set! lb69@syntax-list? (lambda (lf7b@x) (or (lb67@syntax-null? lf7b@x) (and (lb63@syntax-pair? lf7b@x) (lb69@syntax-list? (lb6d@syntax-cdr lf7b@x)))))) (set! l27f4@lb69@syntax-list? lb69@syntax-list?) (set! lb6b@syntax-car (lambda (lf7d@x) (if (lb3d@stx? lf7d@x) (lb59@mkstx (lb6b@syntax-car (lb3f@stx-expr lf7d@x)) (lb43@stx-mark* lf7d@x) (lb47@stx-subst* lf7d@x) (lb4b@stx-ae* lf7d@x)) (if (l6b5@l587@annotation? lf7d@x) (lb6b@syntax-car (l6b7@l58b@annotation-expression lf7d@x)) (if (pair? lf7d@x) (car lf7d@x) (assertion-violation 'syntax-car '"BUG: not a pair" lf7d@x)))))) (set! l27f5@lb6b@syntax-car lb6b@syntax-car) (set! lb6d@syntax-cdr (lambda (lf7f@x) (if (lb3d@stx? lf7f@x) (lb59@mkstx (lb6d@syntax-cdr (lb3f@stx-expr lf7f@x)) (lb43@stx-mark* lf7f@x) (lb47@stx-subst* lf7f@x) (lb4b@stx-ae* lf7f@x)) (if (l6b5@l587@annotation? lf7f@x) (lb6d@syntax-cdr (l6b7@l58b@annotation-expression lf7f@x)) (if (pair? lf7f@x) (cdr lf7f@x) (assertion-violation 'syntax-cdr '"BUG: not a pair" lf7f@x)))))) (set! l27f6@lb6d@syntax-cdr lb6d@syntax-cdr) (set! lb6f@syntax->list (lambda (lf81@x) (if (lb63@syntax-pair? lf81@x) (cons (lb6b@syntax-car lf81@x) (lb6f@syntax->list (lb6d@syntax-cdr lf81@x))) (if (lb67@syntax-null? lf81@x) '() (assertion-violation 'syntax->list '"BUG: invalid argument" lf81@x))))) (set! l27f7@lb6f@syntax->list lb6f@syntax->list) (set! lb71@id? (lambda (lf83@x) (and (lb3d@stx? lf83@x) (symbol? (lb3f@stx-expr lf83@x))))) (set! l27f8@lb71@id? lb71@id?) (set! lb73@id->sym (lambda (lf85@x) (lb3f@stx-expr lf85@x))) (set! l27f9@lb73@id->sym lb73@id->sym) (set! lb75@bound-id=? (lambda (lf87@x lf88@y) (and (eq? (lb73@id->sym lf87@x) (lb73@id->sym lf88@y)) (same-marks? (lb43@stx-mark* lf87@x) (lb43@stx-mark* lf88@y))))) (set! l27fa@lb75@bound-id=? lb75@bound-id=?) (set! lb77@free-id=? (lambda (lf8b@i lf8c@j) (let ((lf8f@t0 (id->real-label lf8b@i)) (lf90@t1 (id->real-label lf8c@j))) (if (or lf8f@t0 lf90@t1) (eq? lf8f@t0 lf90@t1) (eq? (lb73@id->sym lf8b@i) (lb73@id->sym lf8c@j)))))) (set! l27fb@lb77@free-id=? lb77@free-id=?) (set! lb79@valid-bound-ids? (lambda (lf93@id*) (and (for-all lb71@id? lf93@id*) (lb7b@distinct-bound-ids? lf93@id*)))) (set! l27fc@lb79@valid-bound-ids? lb79@valid-bound-ids?) (set! lb7b@distinct-bound-ids? (lambda (lf95@id*) (or (null? lf95@id*) (and (not (lb7d@bound-id-member? (car lf95@id*) (cdr lf95@id*))) (lb7b@distinct-bound-ids? (cdr lf95@id*)))))) (set! l27fd@lb7b@distinct-bound-ids? lb7b@distinct-bound-ids?) (set! lb7d@bound-id-member? (lambda (lf97@id lf98@id*) (and (pair? lf98@id*) (or (lb75@bound-id=? lf97@id (car lf98@id*)) (lb7d@bound-id-member? lf97@id (cdr lf98@id*)))))) (set! l27fe@lb7d@bound-id-member? lb7d@bound-id-member?) (set! lb7f@self-evaluating? (lambda (lf9b@x) (or (number? lf9b@x) (string? lf9b@x) (char? lf9b@x) (boolean? lf9b@x) (regexp? lf9b@x) (bytevector? lf9b@x)))) (set! l27ff@lb7f@self-evaluating? lb7f@self-evaluating?) (set! lb81@strip-annotations (lambda (lf9d@x) (if (pair? lf9d@x) (cons (lb81@strip-annotations (car lf9d@x)) (lb81@strip-annotations (cdr lf9d@x))) (if (vector? lf9d@x) (vector-map lb81@strip-annotations lf9d@x) (if (l6b5@l587@annotation? lf9d@x) (l6b4@l585@annotation-stripped lf9d@x) lf9d@x))))) (set! l2800@lb81@strip-annotations lb81@strip-annotations) (set! lb83@strip (lambda (lf9f@x lfa0@m*) (if (laf7@top-marked? lfa0@m*) (if (or (l6b5@l587@annotation? lf9f@x) (and (pair? lf9f@x) (l6b5@l587@annotation? (car lf9f@x))) (and (vector? lf9f@x) (> (vector-length lf9f@x) '0) (l6b5@l587@annotation? (vector-ref lf9f@x '0)))) (lb81@strip-annotations lf9f@x) lf9f@x) (let lfa5@f ((lfa3@x lf9f@x)) (if (lb3d@stx? lfa3@x) (begin (if (pair? (lb3f@stx-expr lfa3@x)) (begin (set-source-info! (lb3f@stx-expr lfa3@x) '#f) (set-source-info! (cdr (lb3f@stx-expr lfa3@x)) '#f) (set-source-info! (car (lb3f@stx-expr lfa3@x)) '#f)) (void)) (lb83@strip (lb3f@stx-expr lfa3@x) (lb43@stx-mark* lfa3@x))) (if (l6b5@l587@annotation? lfa3@x) (l6b4@l585@annotation-stripped lfa3@x) (if (pair? lfa3@x) (let ((lfa7@a (lfa5@f (car lfa3@x))) (lfa8@d (lfa5@f (cdr lfa3@x)))) (if (and (eq? lfa7@a (car lfa3@x)) (eq? lfa8@d (cdr lfa3@x))) lfa3@x (cons lfa7@a lfa8@d))) (if (vector? lfa3@x) (let ((lfab@old (vector->list lfa3@x))) (let ((lfad@new (map lfa5@f lfab@old))) (if (for-all eq? lfab@old lfad@new) lfa3@x (list->vector lfad@new)))) lfa3@x)))))))) (set! l2801@lb83@strip lb83@strip) (set! lb85@stx->datum (lambda (lfaf@x) (lb83@strip lfaf@x '()))) (set! l2802@lb85@stx->datum lb85@stx->datum) (set! lb87@id->label (lambda (lfb1@id) (or (id->real-label lfb1@id) (let ((lfb3@t (le68@top-level-context))) (if lfb3@t ((lambda (lfb5@env) (let ((lfb7@rib (le18@interaction-env-rib lfb5@env))) (call-with-values (lambda () (lb01@gen-define-label+loc lfb1@id lfb7@rib)) (lambda (lfbd@lfba lfbe@lfbc) (let ((lfc1@loc_ lfbe@lfbc) (lfc2@lab lfbd@lfba)) (begin (lb27@extend-rib! lfb7@rib lfb1@id lfc2@lab) lfc2@lab)))))) lfb3@t) '#f))))) (set! l2803@lb87@id->label lb87@id->label) (set! lb89@label->binding (lambda (lfc5@x lfc6@r) (let ((lfc9@t (l98c@l7d9@imported-label->binding lfc5@x))) (if lfc9@t ((lambda (lfcb@b) (if (and (pair? lfcb@b) (eq? (car lfcb@b) '$core-rtd)) (cons '$rtd (map ld2e@bless (cdr lfcb@b))) (if (and (pair? lfcb@b) (eq? (car lfcb@b) 'global-rtd)) (let ((lfcd@lib (cadr lfcb@b)) (lfce@loc (cddr lfcb@b))) (cons '$rtd (symbol-value lfce@loc))) lfcb@b))) lfc9@t) (let ((lfd1@t (assq lfc5@x lfc6@r))) (if lfd1@t (cdr lfd1@t) (let ((lfd3@t (le68@top-level-context))) (if lfd3@t ((lambda (lfd5@env) (let ((lfd7@t (assq lfc5@x (le20@interaction-env-locs lfd5@env)))) (if lfd7@t ((lambda (lfd9@p) (cons* 'lexical (cdr lfd9@p) '#f)) lfd7@t) '(displaced-lexical . #f)))) lfd3@t) '(displaced-lexical . #f))))))))) (set! l2804@lb89@label->binding lb89@label->binding) (set! lb8b@make-binding cons) (set! l2805@lb8b@make-binding lb8b@make-binding) (set! lb8d@binding-type car) (set! l2806@lb8d@binding-type lb8d@binding-type) (set! lb8f@binding-value cdr) (set! l2807@lb8f@binding-value lb8f@binding-value) (set! lb91@raise-unbound-error (lambda (lfdb@id) (le56@syntax-violation* '#f '"unbound identifier" lfdb@id (make-undefined-violation)))) (set! l2808@lb91@raise-unbound-error lb91@raise-unbound-error) (set! lb93@syntax-type (lambda (lfdd@e lfde@r) (if (lb71@id? lfdd@e) (let ((lfe1@id lfdd@e)) (let ((lfe3@label (lb87@id->label lfe1@id))) (let ((lfe5@b (lb89@label->binding lfe3@label lfde@r))) (let ((lfe7@type (lb8d@binding-type lfe5@b))) (begin (if (not lfe3@label) (lb91@raise-unbound-error lfe1@id) (void)) (let ((lfe9@t lfe7@type)) (if (memv lfe9@t '(lexical core-prim macro macro! global local-macro local-macro! global-macro global-macro! displaced-lexical syntax import export $module $core-rtd library mutable)) (values lfe7@type (lb8f@binding-value lfe5@b) lfe1@id) (values 'other '#f '#f)))))))) (if (lb63@syntax-pair? lfdd@e) (let ((lfeb@id (lb6b@syntax-car lfdd@e))) (if (lb71@id? lfeb@id) (let ((lfed@label (lb87@id->label lfeb@id))) (let ((lfef@b (lb89@label->binding lfed@label lfde@r))) (let ((lff1@type (lb8d@binding-type lfef@b))) (begin (if (not lfed@label) (lb91@raise-unbound-error lfeb@id) (void)) (let ((lff3@t lff1@type)) (if (memv lff3@t '(define define-syntax core-macro begin macro macro! local-macro local-macro! global-macro global-macro! module library set! let-syntax letrec-syntax import export $core-rtd)) (values lff1@type (lb8f@binding-value lfef@b) lfeb@id) (values 'call '#f '#f))))))) (values 'call '#f '#f))) (let ((lff5@d (lb85@stx->datum lfdd@e))) (if (lb7f@self-evaluating? lff5@d) (values 'constant lff5@d '#f) (values 'other '#f '#f))))))) (set! l2809@lb93@syntax-type lb93@syntax-type) (set! lba1@sanitize-binding (lambda (lff7@x lff8@src) (if (procedure? lff7@x) (cons* 'local-macro lff7@x lff8@src) (if (and (pair? lff7@x) (eq? (car lff7@x) 'macro!) (procedure? (cdr lff7@x))) (cons* 'local-macro! (cdr lff7@x) lff8@src) (if (and (pair? lff7@x) (eq? (car lff7@x) '$rtd)) lff7@x (assertion-violation 'expand '"invalid transformer" lff7@x)))))) (set! l280a@lba1@sanitize-binding lba1@sanitize-binding) (set! lba3@make-variable-transformer (lambda (lffb@x) (if (procedure? lffb@x) (cons 'macro! lffb@x) (assertion-violation 'make-variable-transformer '"not a procedure" lffb@x)))) (set! l280b@lba3@make-variable-transformer lba3@make-variable-transformer) (set! lba5@variable-transformer? (lambda (lffd@x) (and (pair? lffd@x) (eq? (car lffd@x) 'macro!) (procedure? (cdr lffd@x))))) (set! l280c@lba5@variable-transformer? lba5@variable-transformer?) (set! lba7@variable-transformer-procedure (lambda (lfff@x) (if (lba5@variable-transformer? lfff@x) (cdr lfff@x) (assertion-violation 'variable-transformer-procedure '"not a variable transformer" lfff@x)))) (set! l280d@lba7@variable-transformer-procedure lba7@variable-transformer-procedure) (set! lba9@make-eval-transformer (lambda (l1001@x) (lba1@sanitize-binding (eval-core (l717@l6cf@expanded->core l1001@x)) l1001@x))) (set! l280e@lba9@make-eval-transformer lba9@make-eval-transformer) (set! lcfa@parse-define (lambda (l1003@x) (let ((l1005@t l1003@x)) (let ((l1007@ls/false (ld78@syntax-dispatch l1005@t '(_ (any . any) any . each-any)))) (if (and l1007@ls/false (apply (lambda (l1009@id l100a@fmls l100b@b l100c@b*) (lb71@id? l1009@id)) l1007@ls/false)) (apply (lambda (l1011@id l1012@fmls l1013@b l1014@b*) (begin (ld9e@verify-formals l1012@fmls l1003@x) (values l1011@id (cons 'defun (cons l1012@fmls (cons l1013@b l1014@b*)))))) l1007@ls/false) (let ((l1019@t l1005@t)) (let ((l101b@ls/false (ld78@syntax-dispatch l1019@t '(_ any any)))) (if (and l101b@ls/false (apply (lambda (l101d@id l101e@val) (lb71@id? l101d@id)) l101b@ls/false)) (apply (lambda (l1021@id l1022@val) (values l1021@id (cons 'expr l1022@val))) l101b@ls/false) (let ((l1025@t l1019@t)) (let ((l1027@ls/false (ld78@syntax-dispatch l1025@t '(_ any)))) (if (and l1027@ls/false (apply (lambda (l1029@id) (lb71@id? l1029@id)) l1027@ls/false)) (apply (lambda (l102b@id) (values l102b@id (cons 'expr (ld2e@bless '(void))))) l1027@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1025@t)))))))))))) (set! l280f@lcfa@parse-define lcfa@parse-define) (set! lcfc@parse-define-syntax (lambda (l102d@x) (let ((l102f@t l102d@x)) (let ((l1031@ls/false (ld78@syntax-dispatch l102f@t '(_ any any)))) (if (and l1031@ls/false (apply (lambda (l1033@id l1034@val) (lb71@id? l1033@id)) l1031@ls/false)) (apply (lambda (l1037@id l1038@val) (values l1037@id l1038@val)) l1031@ls/false) (le58@syntax-violation '#f '"invalid syntax" l102f@t)))))) (set! l2810@lcfc@parse-define-syntax lcfc@parse-define-syntax) (set! lcfe@scheme-stx-hashtable (make-eq-hashtable)) (set! l2811@lcfe@scheme-stx-hashtable lcfe@scheme-stx-hashtable) (set! ld00@scheme-stx (lambda (l103b@sym) (or (hashtable-ref lcfe@scheme-stx-hashtable l103b@sym '#f) (let ((l103d@subst (l968@l791@library-subst (l986@l7cd@find-library-by-name '(psyntax system $all))))) (let ((l103f@stx (make-simple-struct 'stx '5 (list l103b@sym laf5@top-mark* '() '())))) (let ((l1041@stx (let ((l1043@t (assq l103b@sym l103d@subst))) (if l1043@t ((lambda (l1045@x) (let ((l1047@name (car l1045@x)) (l1048@label (cdr l1045@x))) (lb5d@add-subst (make-simple-struct 'rib '6 (list (list l1047@name) (list laf5@top-mark*) (list l1048@label) '#f '#f)) l103f@stx))) l1043@t) l103f@stx)))) (begin (hashtable-set! lcfe@scheme-stx-hashtable l103b@sym l1041@stx) l1041@stx))))))) (set! l2812@ld00@scheme-stx ld00@scheme-stx) (set! ld02@lexical-var car) (set! l2813@ld02@lexical-var ld02@lexical-var) (set! ld04@lexical-mutable? cdr) (set! l2814@ld04@lexical-mutable? ld04@lexical-mutable?) (set! ld06@set-lexical-mutable! set-cdr!) (set! l2815@ld06@set-lexical-mutable! ld06@set-lexical-mutable!) (set! ld08@add-lexical (lambda (l104b@lab l104c@lex l104d@r) (cons (cons* l104b@lab 'lexical l104c@lex '#f) l104d@r))) (set! l2816@ld08@add-lexical ld08@add-lexical) (set! ld0a@add-lexicals (lambda (l1051@lab* l1052@lex* l1053@r) (if (null? l1051@lab*) l1053@r (ld0a@add-lexicals (cdr l1051@lab*) (cdr l1052@lex*) (ld08@add-lexical (car l1051@lab*) (car l1052@lex*) l1053@r))))) (set! l2817@ld0a@add-lexicals ld0a@add-lexicals) (set! ld0c@letrec-helper (lambda (l1057@e l1058@r l1059@mr l105a@build) (let ((l105f@t l1057@e)) (let ((l1061@ls/false (ld78@syntax-dispatch l105f@t '(_ #(each (any any)) any . each-any)))) (if l1061@ls/false (apply (lambda (l1063@lhs* l1064@rhs* l1065@b l1066@b*) (if (not (lb79@valid-bound-ids? l1063@lhs*)) (ld32@invalid-fmls-error l1057@e l1063@lhs*) (let ((l106b@lex* (map laf9@gen-lexical l1063@lhs*)) (l106c@lab* (map lafd@gen-label l1063@lhs*))) (let ((l106f@rib (lb31@make-full-rib l1063@lhs* l106c@lab*)) (l1070@r (ld0a@add-lexicals l106c@lab* l106b@lex* l1058@r))) (let ((l1073@body (ldb0@chi-internal (lb5d@add-subst l106f@rib (cons l1065@b l1066@b*)) l1070@r l1059@mr)) (l1074@rhs* (ld96@chi-expr* (map (lambda (l1077@x) (lb5d@add-subst l106f@rib l1077@x)) l1064@rhs*) l1070@r l1059@mr))) (l105a@build '#f l106b@lex* l1074@rhs* l1073@body)))))) l1061@ls/false) (le58@syntax-violation '#f '"invalid syntax" l105f@t)))))) (set! l2818@ld0c@letrec-helper ld0c@letrec-helper) (set! ld0e@let-transformer (lambda (l1079@e l107a@r l107b@mr) (let ((l107f@t l1079@e)) (let ((l1081@ls/false (ld78@syntax-dispatch l107f@t '(_ #(each (any any)) any . each-any)))) (if l1081@ls/false (apply (lambda (l1083@lhs* l1084@rhs* l1085@b l1086@b*) (if (not (lb79@valid-bound-ids? l1083@lhs*)) (ld32@invalid-fmls-error l1079@e l1083@lhs*) (let ((l108b@lex* (map laf9@gen-lexical l1083@lhs*)) (l108c@lab* (map lafd@gen-label l1083@lhs*)) (l108d@rhs* (ld96@chi-expr* l1084@rhs* l107a@r l107b@mr))) (let ((l1091@rib (lb31@make-full-rib l1083@lhs* l108c@lab*)) (l1092@r (ld0a@add-lexicals l108c@lab* l108b@lex* l107a@r))) (let ((l1095@body (ldb0@chi-internal (lb5d@add-subst l1091@rib (cons l1085@b l1086@b*)) l1092@r l107b@mr))) (lad9@la3c@build-let '#f l108b@lex* l108d@rhs* l1095@body)))))) l1081@ls/false) (let ((l1097@t l107f@t)) (let ((l1099@ls/false (ld78@syntax-dispatch l1097@t '(_ any #(each (any any)) any . each-any)))) (if l1099@ls/false (apply (lambda (l109b@loop l109c@lhs* l109d@rhs* l109e@b l109f@b*) (if (not (lb79@valid-bound-ids? l109c@lhs*)) (ld32@invalid-fmls-error l1079@e l109c@lhs*) (let ((l10a5@lex* (map laf9@gen-lexical l109c@lhs*)) (l10a6@lab* (map lafd@gen-label l109c@lhs*)) (l10a7@rhs* (ld96@chi-expr* l109d@rhs* l107a@r l107b@mr)) (l10a8@loop-lex (laf9@gen-lexical l109b@loop)) (l10a9@loop-lab (lafd@gen-label l109b@loop))) (let ((l10af@loop-rib (lb31@make-full-rib (list l109b@loop) (list l10a9@loop-lab))) (l10b0@rib (lb31@make-full-rib l109c@lhs* l10a6@lab*)) (l10b1@r (ld0a@add-lexicals (cons l10a9@loop-lab l10a6@lab*) (cons l10a8@loop-lex l10a5@lex*) l107a@r))) (let ((l10b5@body (ldb0@chi-internal (lb5d@add-subst l10af@loop-rib (lb5d@add-subst l10b0@rib (cons l109e@b l109f@b*))) l10b1@r l107b@mr))) (lada@la3e@build-named-let '#f l10a8@loop-lex l10a5@lex* l10a7@rhs* l10b5@body)))))) l1099@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1097@t))))))))) (set! l2819@ld0e@let-transformer ld0e@let-transformer) (set! ld10@letrec-transformer (lambda (l10b7@e l10b8@r l10b9@mr) (ld0c@letrec-helper l10b7@e l10b8@r l10b9@mr lad8@la3a@build-letrec))) (set! l281a@ld10@letrec-transformer ld10@letrec-transformer) (set! ld12@letrec*-transformer (lambda (l10bd@e l10be@r l10bf@mr) (ld0c@letrec-helper l10bd@e l10be@r l10bf@mr ladb@la40@build-letrec*))) (set! l281b@ld12@letrec*-transformer ld12@letrec*-transformer) (set! ld14@fluid-let-syntax-transformer (lambda (l10c3@e l10c4@r l10c5@mr) (letrec* ((l10ca@lookup (lambda (l10dd@x) (or (lb87@id->label l10dd@x) (le58@syntax-violation '#f '"unbound identifier" l10c3@e l10dd@x))))) (let ((l10cb@t l10c3@e)) (let ((l10cd@ls/false (ld78@syntax-dispatch l10cb@t '(_ #(each (any any)) any . each-any)))) (if l10cd@ls/false (apply (lambda (l10cf@lhs* l10d0@rhs* l10d1@b l10d2@b*) (if (not (lb79@valid-bound-ids? l10cf@lhs*)) (ld32@invalid-fmls-error l10c3@e l10cf@lhs*) (let ((l10d7@lab* (map l10ca@lookup l10cf@lhs*)) (l10d8@rhs* (map (lambda (l10db@x) (lba9@make-eval-transformer (ldd2@expand-transformer l10db@x l10c5@mr))) l10d0@rhs*))) (ldb0@chi-internal (cons l10d1@b l10d2@b*) (append (map cons l10d7@lab* l10d8@rhs*) l10c4@r) (append (map cons l10d7@lab* l10d8@rhs*) l10c5@mr))))) l10cd@ls/false) (le58@syntax-violation '#f '"invalid syntax" l10cb@t))))))) (set! l281c@ld14@fluid-let-syntax-transformer ld14@fluid-let-syntax-transformer) (set! ld16@type-descriptor-transformer (lambda (l10df@e l10e0@r l10e1@mr) (let ((l10e5@t l10df@e)) (let ((l10e7@ls/false (ld78@syntax-dispatch l10e5@t '(_ any)))) (if (and l10e7@ls/false (apply (lambda (l10e9@id) (lb71@id? l10e9@id)) l10e7@ls/false)) (apply (lambda (l10eb@id) (let ((l10ed@lab (lb87@id->label l10eb@id))) (let ((l10ef@b (lb89@label->binding l10ed@lab l10e0@r))) (let ((l10f1@type (lb8d@binding-type l10ef@b))) (begin (if (not l10ed@lab) (lb91@raise-unbound-error l10eb@id) (void)) (if (not (and (eq? l10f1@type '$rtd) (not (list? (lb8f@binding-value l10ef@b))))) (le58@syntax-violation '#f '"not a record type" l10df@e) (void)) (list 'quote (lb8f@binding-value l10ef@b))))))) l10e7@ls/false) (le58@syntax-violation '#f '"invalid syntax" l10e5@t)))))) (set! l281d@ld16@type-descriptor-transformer ld16@type-descriptor-transformer) (set! ld18@record-type-descriptor-transformer (lambda (l10f3@e l10f4@r l10f5@mr) (let ((l10f9@t l10f3@e)) (let ((l10fb@ls/false (ld78@syntax-dispatch l10f9@t '(_ any)))) (if (and l10fb@ls/false (apply (lambda (l10fd@id) (lb71@id? l10fd@id)) l10fb@ls/false)) (apply (lambda (l10ff@id) (let ((l1101@lab (lb87@id->label l10ff@id))) (let ((l1103@b (lb89@label->binding l1101@lab l10f4@r))) (let ((l1105@type (lb8d@binding-type l1103@b))) (begin (if (not l1101@lab) (lb91@raise-unbound-error l10ff@id) (void)) (if (not (and (eq? l1105@type '$rtd) (list? (lb8f@binding-value l1103@b)))) (le58@syntax-violation '#f '"not a record type" l10f3@e) (void)) (ld9a@chi-expr (car (lb8f@binding-value l1103@b)) l10f4@r l10f5@mr)))))) l10fb@ls/false) (le58@syntax-violation '#f '"invalid syntax" l10f9@t)))))) (set! l281e@ld18@record-type-descriptor-transformer ld18@record-type-descriptor-transformer) (set! ld1a@record-constructor-descriptor-transformer (lambda (l1107@e l1108@r l1109@mr) (let ((l110d@t l1107@e)) (let ((l110f@ls/false (ld78@syntax-dispatch l110d@t '(_ any)))) (if (and l110f@ls/false (apply (lambda (l1111@id) (lb71@id? l1111@id)) l110f@ls/false)) (apply (lambda (l1113@id) (let ((l1115@lab (lb87@id->label l1113@id))) (let ((l1117@b (lb89@label->binding l1115@lab l1108@r))) (let ((l1119@type (lb8d@binding-type l1117@b))) (begin (if (not l1115@lab) (lb91@raise-unbound-error l1113@id) (void)) (if (not (and (eq? l1119@type '$rtd) (list? (lb8f@binding-value l1117@b)))) (le58@syntax-violation '#f '"invalid type" l1107@e) (void)) (ld9a@chi-expr (cadr (lb8f@binding-value l1117@b)) l1108@r l1109@mr)))))) l110f@ls/false) (le58@syntax-violation '#f '"invalid syntax" l110d@t)))))) (set! l281f@ld1a@record-constructor-descriptor-transformer ld1a@record-constructor-descriptor-transformer) (set! ld1c@when-macro (lambda (l111b@e) (let ((l111d@t l111b@e)) (let ((l111f@ls/false (ld78@syntax-dispatch l111d@t '(_ any any . each-any)))) (if l111f@ls/false (apply (lambda (l1121@test l1122@e l1123@e*) (ld2e@bless (list 'if l1121@test (cons 'begin (cons l1122@e l1123@e*))))) l111f@ls/false) (le58@syntax-violation '#f '"invalid syntax" l111d@t)))))) (set! l2820@ld1c@when-macro ld1c@when-macro) (set! ld1e@unless-macro (lambda (l1127@e) (let ((l1129@t l1127@e)) (let ((l112b@ls/false (ld78@syntax-dispatch l1129@t '(_ any any . each-any)))) (if l112b@ls/false (apply (lambda (l112d@test l112e@e l112f@e*) (ld2e@bless (list 'if (list 'not l112d@test) (cons 'begin (cons l112e@e l112f@e*))))) l112b@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1129@t)))))) (set! l2821@ld1e@unless-macro ld1e@unless-macro) (set! ld20@if-transformer (lambda (l1133@e l1134@r l1135@mr) (let ((l1139@t l1133@e)) (let ((l113b@ls/false (ld78@syntax-dispatch l1139@t '(_ any any any)))) (if l113b@ls/false (apply (lambda (l113d@e0 l113e@e1 l113f@e2) (list 'if (ld9a@chi-expr l113d@e0 l1134@r l1135@mr) (ld9a@chi-expr l113e@e1 l1134@r l1135@mr) (ld9a@chi-expr l113f@e2 l1134@r l1135@mr))) l113b@ls/false) (let ((l1143@t l1139@t)) (let ((l1145@ls/false (ld78@syntax-dispatch l1143@t '(_ any any)))) (if l1145@ls/false (apply (lambda (l1147@e0 l1148@e1) (list 'if (ld9a@chi-expr l1147@e0 l1134@r l1135@mr) (ld9a@chi-expr l1148@e1 l1134@r l1135@mr) (lad7@la38@build-void))) l1145@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1143@t))))))))) (set! l2822@ld20@if-transformer ld20@if-transformer) (set! ld22@and-transformer (lambda (l114b@e l114c@r l114d@mr) (let ((l1151@t l114b@e)) (let ((l1153@ls/false (ld78@syntax-dispatch l1151@t '(_ . each-any)))) (if l1153@ls/false (apply (lambda (l1155@e*) (cons 'and (ld96@chi-expr* l1155@e* l114c@r l114d@mr))) l1153@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1151@t)))))) (set! l2823@ld22@and-transformer ld22@and-transformer) (set! ld24@or-transformer (lambda (l1157@e l1158@r l1159@mr) (let ((l115d@t l1157@e)) (let ((l115f@ls/false (ld78@syntax-dispatch l115d@t '(_ . each-any)))) (if l115f@ls/false (apply (lambda (l1161@e*) (cons 'or (ld96@chi-expr* l1161@e* l1158@r l1159@mr))) l115f@ls/false) (le58@syntax-violation '#f '"invalid syntax" l115d@t)))))) (set! l2824@ld24@or-transformer ld24@or-transformer) (set! ld26@case-macro (lambda (l1163@e) (letrec* ((l1166@build-last (lambda (l118d@cls) (let ((l118f@t l118d@cls)) (let ((l1191@ls/false (ld78@syntax-dispatch l118f@t '(#(scheme-id else) any . each-any)))) (if l1191@ls/false (apply (lambda (l1193@e l1194@e*) (cons 'begin (cons l1193@e l1194@e*))) l1191@ls/false) (let ((l1197@t l118f@t)) (let ((l1199@ls/false (ld78@syntax-dispatch l1197@t '_))) (if l1199@ls/false (apply (lambda () (l1168@build-one l118d@cls '(if #f #f))) l1199@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1197@t))))))))) (l1168@build-one (lambda (l117f@cls l1180@k) (let ((l1183@t l117f@cls)) (let ((l1185@ls/false (ld78@syntax-dispatch l1183@t '(each-any any . each-any)))) (if l1185@ls/false (apply (lambda (l1187@d* l1188@e l1189@e*) (list 'if (list 'memv 't (list 'quote l1187@d*)) (cons 'begin (cons l1188@e l1189@e*)) l1180@k)) l1185@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1183@t))))))) (let ((l1169@t l1163@e)) (let ((l116b@ls/false (ld78@syntax-dispatch l1169@t '(_ any)))) (if l116b@ls/false (apply (lambda (l116d@expr) (ld2e@bless (cons 'let (cons (list (list 't l116d@expr)) '((if #f #f)))))) l116b@ls/false) (let ((l116f@t l1169@t)) (let ((l1171@ls/false (ld78@syntax-dispatch l116f@t '(_ any any . each-any)))) (if l1171@ls/false (apply (lambda (l1173@expr l1174@cls l1175@cls*) (ld2e@bless (list 'let (list (list 't l1173@expr)) (let l117d@f ((l1179@cls l1174@cls) (l117a@cls* l1175@cls*)) (if (null? l117a@cls*) (l1166@build-last l1179@cls) (l1168@build-one l1179@cls (l117d@f (car l117a@cls*) (cdr l117a@cls*)))))))) l1171@ls/false) (le58@syntax-violation '#f '"invalid syntax" l116f@t)))))))))) (set! l2825@ld26@case-macro ld26@case-macro) (set! ld28@quote-transformer (lambda (l119b@e l119c@r l119d@mr) (let ((l11a1@t l119b@e)) (let ((l11a3@ls/false (ld78@syntax-dispatch l11a1@t '(_ any)))) (if l11a3@ls/false (apply (lambda (l11a5@datum) (list 'quote (lb85@stx->datum l11a5@datum))) l11a3@ls/false) (le58@syntax-violation '#f '"invalid syntax" l11a1@t)))))) (set! l2826@ld28@quote-transformer ld28@quote-transformer) (set! ld2a@case-lambda-transformer (lambda (l11a7@e l11a8@r l11a9@mr) (let ((l11ad@t l11a7@e)) (let ((l11af@ls/false (ld78@syntax-dispatch l11ad@t '(_ . #(each (any any . each-any)))))) (if l11af@ls/false (apply (lambda (l11b1@fmls* l11b2@b* l11b3@b**) (call-with-values (lambda () (lda2@chi-lambda-clause* l11a7@e l11b1@fmls* (map cons l11b2@b* l11b3@b**) l11a8@r l11a9@mr)) (lambda (l11bb@l11b8 l11bc@l11ba) (let ((l11bf@body* l11bc@l11ba) (l11c0@fmls* l11bb@l11b8)) (lad5@la08@build-case-lambda '#f l11c0@fmls* l11bf@body*))))) l11af@ls/false) (le58@syntax-violation '#f '"invalid syntax" l11ad@t)))))) (set! l2827@ld2a@case-lambda-transformer ld2a@case-lambda-transformer) (set! ld2c@lambda-transformer (lambda (l11c3@e l11c4@r l11c5@mr) (let ((l11c9@t l11c3@e)) (let ((l11cb@ls/false (ld78@syntax-dispatch l11c9@t '(_ any any . each-any)))) (if l11cb@ls/false (apply (lambda (l11cd@fmls l11ce@b l11cf@b*) (call-with-values (lambda () (lda0@chi-lambda-clause l11c3@e l11cd@fmls (cons l11ce@b l11cf@b*) l11c4@r l11c5@mr)) (lambda (l11d7@l11d4 l11d8@l11d6) (let ((l11db@body l11d8@l11d6) (l11dc@fmls l11d7@l11d4)) (lad4@la06@build-lambda '#f l11dc@fmls l11db@body))))) l11cb@ls/false) (le58@syntax-violation '#f '"invalid syntax" l11c9@t)))))) (set! l2828@ld2c@lambda-transformer ld2c@lambda-transformer) (set! ld2e@bless (lambda (l11df@x) (lb59@mkstx (let l11e3@f ((l11e1@x l11df@x)) (if (lb3d@stx? l11e1@x) l11e1@x (if (pair? l11e1@x) (cons (l11e3@f (car l11e1@x)) (l11e3@f (cdr l11e1@x))) (if (symbol? l11e1@x) (ld00@scheme-stx l11e1@x) (if (vector? l11e1@x) (vector-map l11e3@f l11e1@x) l11e1@x))))) '() '() '()))) (set! l2829@ld2e@bless ld2e@bless) (set! ld30@with-syntax-macro (lambda (l11e5@e) (let ((l11e7@t l11e5@e)) (let ((l11e9@ls/false (ld78@syntax-dispatch l11e7@t '(_ #(each (any any)) any . each-any)))) (if l11e9@ls/false (apply (lambda (l11eb@pat* l11ec@expr* l11ed@b l11ee@b*) (let ((l11f3@idn* (let l11f7@f ((l11f5@pat* l11eb@pat*)) (if (null? l11f5@pat*) '() (call-with-values (lambda () (ld76@convert-pattern (car l11f5@pat*) '())) (lambda (l11fd@l11fa l11fe@l11fc) (let ((l1201@idn* l11fe@l11fc) (l1202@pat l11fd@l11fa)) (append l1201@idn* (l11f7@f (cdr l11f5@pat*)))))))))) (begin (ld9e@verify-formals (map car l11f3@idn*) l11e5@e) (let ((l1205@t* (le46@generate-temporaries l11ec@expr*))) (ld2e@bless (list 'let (map list l1205@t* l11ec@expr*) (let l120b@f ((l1207@pat* l11eb@pat*) (l1208@t* l1205@t*)) (if (null? l1207@pat*) (cons 'begin (cons '#f (cons l11ed@b l11ee@b*))) (list 'syntax-case (car l1208@t*) '() (list (car l1207@pat*) (l120b@f (cdr l1207@pat*) (cdr l1208@t*))) (list '_ (list 'assertion-violation ''with-syntax '"pattern does not match value" (list 'quote (car l1207@pat*)) (car l1208@t*)))))))))))) l11e9@ls/false) (le58@syntax-violation '#f '"invalid syntax" l11e7@t)))))) (set! l282a@ld30@with-syntax-macro ld30@with-syntax-macro) (set! ld32@invalid-fmls-error (lambda (l120d@stx l120e@fmls) (let ((l1211@t l120e@fmls)) (let ((l1213@ls/false (ld78@syntax-dispatch l1211@t '#(each+ any () any)))) (if l1213@ls/false (apply (lambda (l1215@id* l1216@last) (let l121b@f ((l1219@id* (if (lb71@id? l1216@last) (cons l1216@last l1215@id*) (if (lb67@syntax-null? l1216@last) l1215@id* (le58@syntax-violation '#f '"not an identifier" l120d@stx l1216@last))))) (if (null? l1219@id*) (values) (if (not (lb71@id? (car l1219@id*))) (le58@syntax-violation '#f '"not an identifier" l120d@stx (car l1219@id*)) (begin (l121b@f (cdr l1219@id*)) (if (lb7d@bound-id-member? (car l1219@id*) (cdr l1219@id*)) (le58@syntax-violation '#f '"duplicate binding" l120d@stx (car l1219@id*)) (void))))))) l1213@ls/false) (let ((l121d@t l1211@t)) (let ((l121f@ls/false (ld78@syntax-dispatch l121d@t '_))) (if l121f@ls/false (apply (lambda () (le58@syntax-violation '#f '"malformed binding form" l120d@stx l120e@fmls)) l121f@ls/false) (le58@syntax-violation '#f '"invalid syntax" l121d@t))))))))) (set! l282b@ld32@invalid-fmls-error ld32@invalid-fmls-error) (set! ld34@let-macro (lambda (l1221@stx) (let ((l1223@t l1221@stx)) (let ((l1225@ls/false (ld78@syntax-dispatch l1223@t '(_ #(each (any any)) any . each-any)))) (if l1225@ls/false (apply (lambda (l1227@lhs* l1228@rhs* l1229@b l122a@b*) (if (lb79@valid-bound-ids? l1227@lhs*) (ld2e@bless (cons (cons 'lambda (cons l1227@lhs* (cons l1229@b l122a@b*))) l1228@rhs*)) (ld32@invalid-fmls-error l1221@stx l1227@lhs*))) l1225@ls/false) (let ((l122f@t l1223@t)) (let ((l1231@ls/false (ld78@syntax-dispatch l122f@t '(_ any #(each (any any)) any . each-any)))) (if (and l1231@ls/false (apply (lambda (l1233@f l1234@lhs* l1235@rhs* l1236@b l1237@b*) (lb71@id? l1233@f)) l1231@ls/false)) (apply (lambda (l123d@f l123e@lhs* l123f@rhs* l1240@b l1241@b*) (if (lb79@valid-bound-ids? l123e@lhs*) (ld2e@bless (cons (list 'letrec (list (list l123d@f (cons 'lambda (cons l123e@lhs* (cons l1240@b l1241@b*))))) l123d@f) l123f@rhs*)) (ld32@invalid-fmls-error l1221@stx l123e@lhs*))) l1231@ls/false) (le58@syntax-violation '#f '"invalid syntax" l122f@t))))))))) (set! l282c@ld34@let-macro ld34@let-macro) (set! ld36@let-values-macro (lambda (l1247@stx) (letrec* ((l124a@rename (lambda (l12af@x l12b0@old* l12b1@new*) (begin (if (not (lb71@id? l12af@x)) (le58@syntax-violation '#f '"not an indentifier" l1247@stx l12af@x) (void)) (if (lb7d@bound-id-member? l12af@x l12b0@old*) (le58@syntax-violation '#f '"duplicate binding" l1247@stx l12af@x) (void)) (let ((l12b5@y (gensym (le5e@syntax->datum l12af@x)))) (values l12b5@y (cons l12af@x l12b0@old*) (cons l12b5@y l12b1@new*)))))) (l124c@rename* (lambda (l129d@x* l129e@old* l129f@new*) (if (null? l129d@x*) (values '() l129e@old* l129f@new*) (call-with-values (lambda () (l124a@rename (car l129d@x*) l129e@old* l129f@new*)) (lambda (l12a3@x l12a4@old* l12a5@new*) (call-with-values (lambda () (l124c@rename* (cdr l129d@x*) l12a4@old* l12a5@new*)) (lambda (l12a9@x* l12aa@old* l12ab@new*) (values (cons l12a3@x l12a9@x*) l12aa@old* l12ab@new*))))))))) (let ((l124d@t l1247@stx)) (let ((l124f@ls/false (ld78@syntax-dispatch l124d@t '(_ () any . each-any)))) (if l124f@ls/false (apply (lambda (l1251@b l1252@b*) (cons* (ld2e@bless 'let) '() l1251@b l1252@b*)) l124f@ls/false) (let ((l1255@t l124d@t)) (let ((l1257@ls/false (ld78@syntax-dispatch l1255@t '(_ #(each (any any)) any . each-any)))) (if l1257@ls/false (apply (lambda (l1259@lhs* l125a@rhs* l125b@b l125c@b*) (ld2e@bless (let l1269@f ((l1261@lhs* l1259@lhs*) (l1262@rhs* l125a@rhs*) (l1263@old* '()) (l1264@new* '())) (if (null? l1261@lhs*) (cons 'let (cons (map list l1263@old* l1264@new*) (cons l125b@b l125c@b*))) (let ((l126b@t (car l1261@lhs*))) (let ((l126d@ls/false (ld78@syntax-dispatch l126b@t 'each-any))) (if l126d@ls/false (apply (lambda (l126f@x*) (call-with-values (lambda () (l124c@rename* l126f@x* l1263@old* l1264@new*)) (lambda (l1277@l1272 l1278@l1274 l1279@l1276) (let ((l127d@new* l1279@l1276) (l127e@old* l1278@l1274) (l127f@y* l1277@l1272)) (list 'call-with-values (list 'lambda '() (car l1262@rhs*)) (list 'lambda l127f@y* (l1269@f (cdr l1261@lhs*) (cdr l1262@rhs*) l127e@old* l127d@new*))))))) l126d@ls/false) (let ((l1283@t l126b@t)) (let ((l1285@ls/false (ld78@syntax-dispatch l1283@t '#(each+ any () any)))) (if l1285@ls/false (apply (lambda (l1287@x* l1288@x) (call-with-values (lambda () (l124a@rename l1288@x l1263@old* l1264@new*)) (lambda (l128b@y l128c@old* l128d@new*) (call-with-values (lambda () (l124c@rename* l1287@x* l128c@old* l128d@new*)) (lambda (l1291@y* l1292@old* l1293@new*) (list 'call-with-values (list 'lambda '() (car l1262@rhs*)) (list 'lambda (append l1291@y* l128b@y) (l1269@f (cdr l1261@lhs*) (cdr l1262@rhs*) l1292@old* l1293@new*)))))))) l1285@ls/false) (let ((l1297@t l1283@t)) (let ((l1299@ls/false (ld78@syntax-dispatch l1297@t 'any))) (if l1299@ls/false (apply (lambda (l129b@others) (le58@syntax-violation '#f '"malformed bindings" l1247@stx l129b@others)) l1299@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1297@t)))))))))))))) l1257@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1255@t)))))))))) (set! l282d@ld36@let-values-macro ld36@let-values-macro) (set! ld38@let*-values-macro (lambda (l12b7@stx) (letrec* ((l12ba@check (lambda (l12e9@x*) (if (not (null? l12e9@x*)) (let ((l12eb@x (car l12e9@x*))) (begin (if (not (lb71@id? l12eb@x)) (le58@syntax-violation '#f '"not an identifier" l12b7@stx l12eb@x) (void)) (l12ba@check (cdr l12e9@x*)) (if (lb7d@bound-id-member? l12eb@x (cdr l12e9@x*)) (le58@syntax-violation '#f '"duplicate identifier" l12b7@stx l12eb@x) (void)))) (void))))) (let ((l12bb@t l12b7@stx)) (let ((l12bd@ls/false (ld78@syntax-dispatch l12bb@t '(_ () any . each-any)))) (if l12bd@ls/false (apply (lambda (l12bf@b l12c0@b*) (cons* (ld2e@bless 'let) '() l12bf@b l12c0@b*)) l12bd@ls/false) (let ((l12c3@t l12bb@t)) (let ((l12c5@ls/false (ld78@syntax-dispatch l12c3@t '(_ #(each (any any)) any . each-any)))) (if l12c5@ls/false (apply (lambda (l12c7@lhs* l12c8@rhs* l12c9@b l12ca@b*) (ld2e@bless (let l12d3@f ((l12cf@lhs* l12c7@lhs*) (l12d0@rhs* l12c8@rhs*)) (if (null? l12cf@lhs*) (cons 'begin (cons l12c9@b l12ca@b*)) (let ((l12d5@t (car l12cf@lhs*))) (let ((l12d7@ls/false (ld78@syntax-dispatch l12d5@t 'each-any))) (if l12d7@ls/false (apply (lambda (l12d9@x*) (begin (l12ba@check l12d9@x*) (list 'call-with-values (list 'lambda '() (car l12d0@rhs*)) (list 'lambda l12d9@x* (l12d3@f (cdr l12cf@lhs*) (cdr l12d0@rhs*)))))) l12d7@ls/false) (let ((l12db@t l12d5@t)) (let ((l12dd@ls/false (ld78@syntax-dispatch l12db@t '#(each+ any () any)))) (if l12dd@ls/false (apply (lambda (l12df@x* l12e0@x) (begin (l12ba@check (cons l12e0@x l12df@x*)) (list 'call-with-values (list 'lambda '() (car l12d0@rhs*)) (list 'lambda (append l12df@x* l12e0@x) (l12d3@f (cdr l12cf@lhs*) (cdr l12d0@rhs*)))))) l12dd@ls/false) (let ((l12e3@t l12db@t)) (let ((l12e5@ls/false (ld78@syntax-dispatch l12e3@t 'any))) (if l12e5@ls/false (apply (lambda (l12e7@others) (le58@syntax-violation '#f '"malformed bindings" l12b7@stx l12e7@others)) l12e5@ls/false) (le58@syntax-violation '#f '"invalid syntax" l12e3@t)))))))))))))) l12c5@ls/false) (le58@syntax-violation '#f '"invalid syntax" l12c3@t)))))))))) (set! l282e@ld38@let*-values-macro ld38@let*-values-macro) (set! ld3a@trace-lambda-macro (lambda (l12ed@stx) (let ((l12ef@t l12ed@stx)) (let ((l12f1@ls/false (ld78@syntax-dispatch l12ef@t '(_ any each-any any . each-any)))) (if l12f1@ls/false (apply (lambda (l12f3@who l12f4@fmls l12f5@b l12f6@b*) (if (lb79@valid-bound-ids? l12f4@fmls) (ld2e@bless (list 'make-traced-procedure (list 'quote l12f3@who) (cons 'lambda (cons l12f4@fmls (cons l12f5@b l12f6@b*))))) (ld32@invalid-fmls-error l12ed@stx l12f4@fmls))) l12f1@ls/false) (let ((l12fb@t l12ef@t)) (let ((l12fd@ls/false (ld78@syntax-dispatch l12fb@t '(_ any #(each+ any () any) any . each-any)))) (if l12fd@ls/false (apply (lambda (l12ff@who l1300@fmls l1301@last l1302@b l1303@b*) (if (lb79@valid-bound-ids? (cons l1301@last l1300@fmls)) (ld2e@bless (list 'make-traced-procedure (list 'quote l12ff@who) (cons 'lambda (cons (append l1300@fmls l1301@last) (cons l1302@b l1303@b*))))) (ld32@invalid-fmls-error l12ed@stx (append l1300@fmls l1301@last)))) l12fd@ls/false) (le58@syntax-violation '#f '"invalid syntax" l12fb@t))))))))) (set! l282f@ld3a@trace-lambda-macro ld3a@trace-lambda-macro) (set! ld3c@trace-define-macro (lambda (l1309@stx) (let ((l130b@t l1309@stx)) (let ((l130d@ls/false (ld78@syntax-dispatch l130b@t '(_ (any . each-any) any . each-any)))) (if l130d@ls/false (apply (lambda (l130f@who l1310@fmls l1311@b l1312@b*) (if (lb79@valid-bound-ids? l1310@fmls) (ld2e@bless (list 'define l130f@who (list 'make-traced-procedure (list 'quote l130f@who) (cons 'lambda (cons l1310@fmls (cons l1311@b l1312@b*)))))) (ld32@invalid-fmls-error l1309@stx l1310@fmls))) l130d@ls/false) (let ((l1317@t l130b@t)) (let ((l1319@ls/false (ld78@syntax-dispatch l1317@t '(_ (any . #(each+ any () any)) any . each-any)))) (if l1319@ls/false (apply (lambda (l131b@who l131c@fmls l131d@last l131e@b l131f@b*) (if (lb79@valid-bound-ids? (cons l131d@last l131c@fmls)) (ld2e@bless (list 'define l131b@who (list 'make-traced-procedure (list 'quote l131b@who) (cons 'lambda (cons (append l131c@fmls l131d@last) (cons l131e@b l131f@b*)))))) (ld32@invalid-fmls-error l1309@stx (append l131c@fmls l131d@last)))) l1319@ls/false) (let ((l1325@t l1317@t)) (let ((l1327@ls/false (ld78@syntax-dispatch l1325@t '(_ any any)))) (if l1327@ls/false (apply (lambda (l1329@who l132a@expr) (if (lb71@id? l1329@who) (ld2e@bless (list 'define l1329@who (list 'let (list (list 'v l132a@expr)) (cons 'if (cons '(procedure? v) (cons (cons 'make-traced-procedure (cons (list 'quote l1329@who) '(v))) '((assertion-violation 'trace-define "not a procedure" v)))))))) (le58@syntax-violation '#f '"invalid name" l1309@stx))) l1327@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1325@t)))))))))))) (set! l2830@ld3c@trace-define-macro ld3c@trace-define-macro) (set! ld3e@trace-define-syntax-macro (lambda (l132d@stx) (let ((l132f@t l132d@stx)) (let ((l1331@ls/false (ld78@syntax-dispatch l132f@t '(_ any any)))) (if l1331@ls/false (apply (lambda (l1333@who l1334@expr) (if (lb71@id? l1333@who) (ld2e@bless (list 'define-syntax l1333@who (list 'make-traced-macro (list 'quote l1333@who) l1334@expr))) (le58@syntax-violation '#f '"invalid name" l132d@stx))) l1331@ls/false) (le58@syntax-violation '#f '"invalid syntax" l132f@t)))))) (set! l2831@ld3e@trace-define-syntax-macro ld3e@trace-define-syntax-macro) (set! ld40@trace-let/rec-syntax (lambda (l1337@who) (lambda (l1339@stx) (let ((l133b@t l1339@stx)) (let ((l133d@ls/false (ld78@syntax-dispatch l133b@t '(_ #(each (any any)) any . each-any)))) (if l133d@ls/false (apply (lambda (l133f@lhs* l1340@rhs* l1341@b l1342@b*) (if (lb79@valid-bound-ids? l133f@lhs*) (let ((l1347@rhs* (map (lambda (l1349@lhs l134a@rhs) (list 'make-traced-macro (list 'quote l1349@lhs) l134a@rhs)) l133f@lhs* l1340@rhs*))) (ld2e@bless (cons l1337@who (cons (map list l133f@lhs* l1347@rhs*) (cons l1341@b l1342@b*))))) (ld32@invalid-fmls-error l1339@stx l133f@lhs*))) l133d@ls/false) (le58@syntax-violation '#f '"invalid syntax" l133b@t))))))) (set! l2832@ld40@trace-let/rec-syntax ld40@trace-let/rec-syntax) (set! ld42@trace-let-syntax-macro (ld40@trace-let/rec-syntax 'let-syntax)) (set! l2833@ld42@trace-let-syntax-macro ld42@trace-let-syntax-macro) (set! ld44@trace-letrec-syntax-macro (ld40@trace-let/rec-syntax 'letrec-syntax)) (set! l2834@ld44@trace-letrec-syntax-macro ld44@trace-letrec-syntax-macro) (set! ld46@guard-macro (lambda (l134d@x) (letrec* ((l1350@gen-clauses (lambda (l1367@con l1368@outerk l1369@clause*) (letrec* ((l136e@f (lambda (l13a7@x l13a8@k) (let ((l13ab@t l13a7@x)) (let ((l13ad@ls/false (ld78@syntax-dispatch l13ab@t '(any #(scheme-id =>) any)))) (if l13ad@ls/false (apply (lambda (l13af@e l13b0@p) (let ((l13b3@t (gensym))) (list 'let (list (list l13b3@t l13af@e)) (list 'if l13b3@t (list l13b0@p l13b3@t) l13a8@k)))) l13ad@ls/false) (let ((l13b5@t l13ab@t)) (let ((l13b7@ls/false (ld78@syntax-dispatch l13b5@t '(any)))) (if l13b7@ls/false (apply (lambda (l13b9@e) (let ((l13bb@t (gensym))) (list 'let (list (list l13bb@t l13b9@e)) (list 'if l13bb@t l13bb@t l13a8@k)))) l13b7@ls/false) (let ((l13bd@t l13b5@t)) (let ((l13bf@ls/false (ld78@syntax-dispatch l13bd@t '(any any . each-any)))) (if l13bf@ls/false (apply (lambda (l13c1@e l13c2@v l13c3@v*) (list 'if l13c1@e (cons 'begin (cons l13c2@v l13c3@v*)) l13a8@k)) l13bf@ls/false) (let ((l13c7@t l13bd@t)) (let ((l13c9@ls/false (ld78@syntax-dispatch l13c7@t '_))) (if l13c9@ls/false (apply (lambda () (le58@syntax-violation '#f '"invalid guard clause" l13a7@x)) l13c9@ls/false) (le58@syntax-violation '#f '"invalid syntax" l13c7@t))))))))))))))) (l1370@f* (lambda (l137d@x*) (let ((l137f@t l137d@x*)) (let ((l1381@ls/false (ld78@syntax-dispatch l137f@t '()))) (if l1381@ls/false (apply (lambda () (let ((l1383@g (gensym))) (values (list l1383@g (list 'lambda '() (list 'raise-continuable l1367@con))) l1383@g))) l1381@ls/false) (let ((l1385@t l137f@t)) (let ((l1387@ls/false (ld78@syntax-dispatch l1385@t '((#(scheme-id else) any . each-any))))) (if l1387@ls/false (apply (lambda (l1389@e l138a@e*) (values (cons 'begin (cons l1389@e l138a@e*)) '#f)) l1387@ls/false) (let ((l138d@t l1385@t)) (let ((l138f@ls/false (ld78@syntax-dispatch l138d@t '(any . any)))) (if l138f@ls/false (apply (lambda (l1391@cls l1392@cls*) (call-with-values (lambda () (l1370@f* l1392@cls*)) (lambda (l1399@l1396 l139a@l1398) (let ((l139d@g l139a@l1398) (l139e@e l1399@l1396)) (values (l136e@f l1391@cls l139e@e) l139d@g))))) l138f@ls/false) (let ((l13a1@t l138d@t)) (let ((l13a3@ls/false (ld78@syntax-dispatch l13a1@t 'any))) (if l13a3@ls/false (apply (lambda (l13a5@others) (le58@syntax-violation '#f '"invalid guard clause" l13a5@others)) l13a3@ls/false) (le58@syntax-violation '#f '"invalid syntax" l13a1@t)))))))))))))))) (call-with-values (lambda () (l1370@f* l1369@clause*)) (lambda (l1375@l1372 l1376@l1374) (let ((l1379@raisek l1376@l1374) (l137a@code l1375@l1372)) (if l1379@raisek (list (list 'call/cc (list 'lambda (list l1379@raisek) (list l1368@outerk (list 'lambda '() l137a@code))))) (list l1368@outerk (list 'lambda '() l137a@code)))))))))) (let ((l1351@t l134d@x)) (let ((l1353@ls/false (ld78@syntax-dispatch l1351@t '(_ (any . each-any) any . each-any)))) (if (and l1353@ls/false (apply (lambda (l1355@con l1356@clause* l1357@b l1358@b*) (lb71@id? l1355@con)) l1353@ls/false)) (apply (lambda (l135d@con l135e@clause* l135f@b l1360@b*) (let ((l1365@outerk (gensym))) (ld2e@bless (list (list 'call/cc (list 'lambda (list l1365@outerk) (list 'lambda '() (list 'with-exception-handler (list 'lambda (list l135d@con) (l1350@gen-clauses l135d@con l1365@outerk l135e@clause*)) (cons 'lambda (cons '() (cons l135f@b l1360@b*))))))))))) l1353@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1351@t))))))) (set! l2835@ld46@guard-macro ld46@guard-macro) (set! ld48@define-enumeration-macro (lambda (l13cb@stx) (letrec* ((l13ce@set? (lambda (l13e7@x) (or (null? l13e7@x) (and (not (memq (car l13e7@x) (cdr l13e7@x))) (l13ce@set? (cdr l13e7@x)))))) (l13d0@remove-dups (lambda (l13e5@ls) (if (null? l13e5@ls) '() (cons (car l13e5@ls) (l13d0@remove-dups (remq (car l13e5@ls) (cdr l13e5@ls)))))))) (let ((l13d1@t l13cb@stx)) (let ((l13d3@ls/false (ld78@syntax-dispatch l13d1@t '(_ any each-any any)))) (if (and l13d3@ls/false (apply (lambda (l13d5@name l13d6@id* l13d7@maker) (and (lb71@id? l13d5@name) (lb71@id? l13d7@maker) (for-all lb71@id? l13d6@id*))) l13d3@ls/false)) (apply (lambda (l13db@name l13dc@id* l13dd@maker) (let ((l13e1@name* (l13d0@remove-dups (le5e@syntax->datum l13dc@id*))) (l13e2@mk (gensym))) (ld2e@bless (list 'begin (list 'define l13e2@mk (list 'enum-set-constructor (list 'make-enumeration (list 'quote l13e1@name*)))) (list 'define-syntax l13db@name (list 'lambda '(x) (list 'syntax-case 'x '() (list '(_ n) '(identifier? (syntax n)) (list 'if (list 'memq '(syntax->datum (syntax n)) (list 'quote l13e1@name*)) '(syntax 'n) (cons 'syntax-violation (cons (list 'quote l13db@name) '("not a member of set" x (syntax n))))))))) (list 'define-syntax l13dd@maker (list 'lambda '(x) (list 'syntax-case 'x '() (list '(_ n* ...) (list 'begin (cons 'for-each (cons (list 'lambda '(n) (list 'unless '(identifier? n) (cons 'syntax-violation (cons (list 'quote l13dd@maker) '("non-identifier argument" x n)))) (list 'unless (list 'memq '(syntax->datum n) (list 'quote l13e1@name*)) (cons 'syntax-violation (cons (list 'quote l13dd@maker) '("not a member of set" x n))))) '((syntax (n* ...))))) (list 'syntax (cons l13e2@mk '('(n* ...))))))))))))) l13d3@ls/false) (le58@syntax-violation '#f '"invalid syntax" l13d1@t))))))) (set! l2836@ld48@define-enumeration-macro ld48@define-enumeration-macro) (set! ld4a@time-macro (lambda (l13e9@stx) (let ((l13eb@t l13e9@stx)) (let ((l13ed@ls/false (ld78@syntax-dispatch l13eb@t '(_ any)))) (if l13ed@ls/false (apply (lambda (l13ef@expr) (ld2e@bless (cons 'let* (cons (cons '(start (time-usage)) (cons (list 'result (list (list 'lambda '() l13ef@expr))) '((end (time-usage)) (used (map - end start)) (real (car used)) (user (cadr used)) (sys (caddr used))))) '((format #t "~%;;~a real ~a user ~a sys~%~!" real user sys) result))))) l13ed@ls/false) (le58@syntax-violation '#f '"invalid syntax" l13eb@t)))))) (set! l2837@ld4a@time-macro ld4a@time-macro) (set! ld4c@delay-macro (lambda (l13f1@stx) (let ((l13f3@t l13f1@stx)) (let ((l13f5@ls/false (ld78@syntax-dispatch l13f3@t '(_ any)))) (if l13f5@ls/false (apply (lambda (l13f7@expr) (ld2e@bless (list 'make-promise (list 'lambda '() l13f7@expr)))) l13f5@ls/false) (le58@syntax-violation '#f '"invalid syntax" l13f3@t)))))) (set! l2838@ld4c@delay-macro ld4c@delay-macro) (set! ld4e@assert-macro (lambda (l13f9@stx) (let ((l13fb@t l13f9@stx)) (let ((l13fd@ls/false (ld78@syntax-dispatch l13fb@t '(_ any)))) (if l13fd@ls/false (apply (lambda (l13ff@expr) (let ((l1401@pos (or (le50@expression-position l13f9@stx) (le50@expression-position l13ff@expr)))) (ld2e@bless (list 'let (list (list 'x l13ff@expr)) (list 'if 'x 'x (list 'assertion-error (list 'quote l13ff@expr) (list 'quote l1401@pos))))))) l13fd@ls/false) (le58@syntax-violation '#f '"invalid syntax" l13fb@t)))))) (set! l2839@ld4e@assert-macro ld4e@assert-macro) (set! ld50@endianness-macro (lambda (l1403@stx) (let ((l1405@t l1403@stx)) (let ((l1407@ls/false (ld78@syntax-dispatch l1405@t '(_ any)))) (if l1407@ls/false (apply (lambda (l1409@e) (let ((l140b@t (le5e@syntax->datum l1409@e))) (if (memv l140b@t '(little)) (ld2e@bless ''little) (if (memv l140b@t '(big)) (ld2e@bless ''big) (le58@syntax-violation '#f '"endianness must be big or little" l1403@stx))))) l1407@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1405@t)))))) (set! l283a@ld50@endianness-macro ld50@endianness-macro) (set! ld52@identifier-syntax-macro (lambda (l140d@stx) (let ((l140f@t l140d@stx)) (let ((l1411@ls/false (ld78@syntax-dispatch l140f@t '(_ any)))) (if l1411@ls/false (apply (lambda (l1413@expr) (ld2e@bless (list 'lambda '(x) (list 'syntax-case 'x '() (list 'id '(identifier? (syntax id)) (list 'syntax l1413@expr)) (list '(id e* ...) '(identifier? (syntax id)) (cons 'cons (cons (list 'syntax l1413@expr) '((syntax (e* ...)))))))))) l1411@ls/false) (let ((l1415@t l140f@t)) (let ((l1417@ls/false (ld78@syntax-dispatch l1415@t '(_ (any any) ((#(scheme-id set!) any any) any))))) (if (and l1417@ls/false (apply (lambda (l1419@id1 l141a@expr1 l141b@id2 l141c@expr2 l141d@expr3) (and (lb71@id? l1419@id1) (lb71@id? l141b@id2) (lb71@id? l141c@expr2))) l1417@ls/false)) (apply (lambda (l1423@id1 l1424@expr1 l1425@id2 l1426@expr2 l1427@expr3) (ld2e@bless (list 'cons ''macro! (list 'lambda '(x) (list 'syntax-case 'x '(set!) (list 'id '(identifier? (syntax id)) (list 'syntax l1424@expr1)) (list (list 'set! 'id l1426@expr2) (list 'syntax l1427@expr3)) (list '(id e* ...) '(identifier? (syntax id)) (list 'syntax (cons l1424@expr1 '(e* ...))))))))) l1417@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1415@t))))))))) (set! l283b@ld52@identifier-syntax-macro ld52@identifier-syntax-macro) (set! ld54@do-macro (lambda (l142d@stx) (letrec* ((l1430@bind (lambda (l1447@x) (let ((l1449@t l1447@x)) (let ((l144b@ls/false (ld78@syntax-dispatch l1449@t '(any any)))) (if l144b@ls/false (apply (lambda (l144d@x l144e@init) (list l144d@x l144e@init l144d@x)) l144b@ls/false) (let ((l1451@t l1449@t)) (let ((l1453@ls/false (ld78@syntax-dispatch l1451@t '(any any any)))) (if l1453@ls/false (apply (lambda (l1455@x l1456@init l1457@step) (list l1455@x l1456@init l1457@step)) l1453@ls/false) (let ((l145b@t l1451@t)) (let ((l145d@ls/false (ld78@syntax-dispatch l145b@t '_))) (if l145d@ls/false (apply (lambda () (le58@syntax-violation '#f '"invalid binding" l142d@stx)) l145d@ls/false) (le58@syntax-violation '#f '"invalid syntax" l145b@t))))))))))))) (let ((l1431@t l142d@stx)) (let ((l1433@ls/false (ld78@syntax-dispatch l1431@t '(_ each-any (any . each-any) . each-any)))) (if l1433@ls/false (apply (lambda (l1435@binding* l1436@test l1437@expr* l1438@command*) (let ((l143d@t (map l1430@bind l1435@binding*))) (let ((l143f@ls/false (ld78@syntax-dispatch l143d@t '#(each (any any any))))) (if l143f@ls/false (apply (lambda (l1441@x* l1442@init* l1443@step*) (if (lb79@valid-bound-ids? l1441@x*) (ld2e@bless (list 'letrec (list (list 'loop (list 'lambda l1441@x* (list 'if l1436@test (cons 'begin (cons '(if #f #f) l1437@expr*)) (cons 'begin (append l1438@command* (list (cons 'loop l1443@step*)))))))) (cons 'loop l1442@init*))) (le58@syntax-violation '#f '"invalid bindings" l142d@stx))) l143f@ls/false) (le58@syntax-violation '#f '"invalid syntax" l143d@t))))) l1433@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1431@t))))))) (set! l283c@ld54@do-macro ld54@do-macro) (set! ld56@let*-macro (lambda (l145f@stx) (let ((l1461@t l145f@stx)) (let ((l1463@ls/false (ld78@syntax-dispatch l1461@t '(_ #(each (any any)) any . each-any)))) (if (and l1463@ls/false (apply (lambda (l1465@lhs* l1466@rhs* l1467@b l1468@b*) (for-all lb71@id? l1465@lhs*)) l1463@ls/false)) (apply (lambda (l146d@lhs* l146e@rhs* l146f@b l1470@b*) (ld2e@bless (let l1477@f ((l1475@x* (map list l146d@lhs* l146e@rhs*))) (if (null? l1475@x*) (cons 'let (cons '() (cons l146f@b l1470@b*))) (list 'let (list (car l1475@x*)) (l1477@f (cdr l1475@x*))))))) l1463@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1461@t)))))) (set! l283d@ld56@let*-macro ld56@let*-macro) (set! ld58@or-macro (lambda (l1479@stx) (let ((l147b@t l1479@stx)) (let ((l147d@ls/false (ld78@syntax-dispatch l147b@t '(_)))) (if l147d@ls/false (apply (lambda () '#f) l147d@ls/false) (let ((l147f@t l147b@t)) (let ((l1481@ls/false (ld78@syntax-dispatch l147f@t '(_ any . each-any)))) (if l1481@ls/false (apply (lambda (l1483@e l1484@e*) (ld2e@bless (let l148b@f ((l1487@e l1483@e) (l1488@e* l1484@e*)) (if (null? l1488@e*) (list 'begin '#f l1487@e) (list 'let (list (list 't l1487@e)) (list 'if 't 't (l148b@f (car l1488@e*) (cdr l1488@e*)))))))) l1481@ls/false) (le58@syntax-violation '#f '"invalid syntax" l147f@t))))))))) (set! l283e@ld58@or-macro ld58@or-macro) (set! ld5a@and-macro (lambda (l148d@stx) (let ((l148f@t l148d@stx)) (let ((l1491@ls/false (ld78@syntax-dispatch l148f@t '(_)))) (if l1491@ls/false (apply (lambda () '#t) l1491@ls/false) (let ((l1493@t l148f@t)) (let ((l1495@ls/false (ld78@syntax-dispatch l1493@t '(_ any . each-any)))) (if l1495@ls/false (apply (lambda (l1497@e l1498@e*) (ld2e@bless (let l149f@f ((l149b@e l1497@e) (l149c@e* l1498@e*)) (if (null? l149c@e*) (list 'begin '#f l149b@e) (cons 'if (cons l149b@e (cons (l149f@f (car l149c@e*) (cdr l149c@e*)) '(#f)))))))) l1495@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1493@t))))))))) (set! l283f@ld5a@and-macro ld5a@and-macro) (set! ld5c@cond-macro (lambda (l14a1@stx) (let ((l14a3@t l14a1@stx)) (let ((l14a5@ls/false (ld78@syntax-dispatch l14a3@t '(_ any . each-any)))) (if l14a5@ls/false (apply (lambda (l14a7@cls l14a8@cls*) (ld2e@bless (let l14af@f ((l14ab@cls l14a7@cls) (l14ac@cls* l14a8@cls*)) (if (null? l14ac@cls*) (let ((l14b1@t l14ab@cls)) (let ((l14b3@ls/false (ld78@syntax-dispatch l14b1@t '(#(scheme-id else) any . each-any)))) (if l14b3@ls/false (apply (lambda (l14b5@e l14b6@e*) (cons 'begin (cons l14b5@e l14b6@e*))) l14b3@ls/false) (let ((l14b9@t l14b1@t)) (let ((l14bb@ls/false (ld78@syntax-dispatch l14b9@t '(any #(scheme-id =>) any)))) (if l14bb@ls/false (apply (lambda (l14bd@e l14be@p) (list 'let (list (list 't l14bd@e)) (list 'if 't (cons l14be@p '(t))))) l14bb@ls/false) (let ((l14c1@t l14b9@t)) (let ((l14c3@ls/false (ld78@syntax-dispatch l14c1@t '(any)))) (if l14c3@ls/false (apply (lambda (l14c5@e) (cons 'or (cons l14c5@e '((if #f #f))))) l14c3@ls/false) (let ((l14c7@t l14c1@t)) (let ((l14c9@ls/false (ld78@syntax-dispatch l14c7@t '(any . each-any)))) (if l14c9@ls/false (apply (lambda (l14cb@e l14cc@e*) (list 'if l14cb@e (cons 'begin l14cc@e*))) l14c9@ls/false) (let ((l14cf@t l14c7@t)) (let ((l14d1@ls/false (ld78@syntax-dispatch l14cf@t '_))) (if l14d1@ls/false (apply (lambda () (le58@syntax-violation '#f '"invalid last clause" l14a1@stx)) l14d1@ls/false) (le58@syntax-violation '#f '"invalid syntax" l14cf@t)))))))))))))))) (let ((l14d3@t l14ab@cls)) (let ((l14d5@ls/false (ld78@syntax-dispatch l14d3@t '(#(scheme-id else) any . each-any)))) (if l14d5@ls/false (apply (lambda (l14d7@e l14d8@e*) (le58@syntax-violation '#f '"incorrect position of keyword else" l14a1@stx)) l14d5@ls/false) (let ((l14db@t l14d3@t)) (let ((l14dd@ls/false (ld78@syntax-dispatch l14db@t '(any #(scheme-id =>) any)))) (if l14dd@ls/false (apply (lambda (l14df@e l14e0@p) (list 'let (list (list 't l14df@e)) (list 'if 't (cons l14e0@p '(t)) (l14af@f (car l14ac@cls*) (cdr l14ac@cls*))))) l14dd@ls/false) (let ((l14e3@t l14db@t)) (let ((l14e5@ls/false (ld78@syntax-dispatch l14e3@t '(any)))) (if l14e5@ls/false (apply (lambda (l14e7@e) (list 'or l14e7@e (l14af@f (car l14ac@cls*) (cdr l14ac@cls*)))) l14e5@ls/false) (let ((l14e9@t l14e3@t)) (let ((l14eb@ls/false (ld78@syntax-dispatch l14e9@t '(any . each-any)))) (if l14eb@ls/false (apply (lambda (l14ed@e l14ee@e*) (list 'if l14ed@e (cons 'begin l14ee@e*) (l14af@f (car l14ac@cls*) (cdr l14ac@cls*)))) l14eb@ls/false) (let ((l14f1@t l14e9@t)) (let ((l14f3@ls/false (ld78@syntax-dispatch l14f1@t '_))) (if l14f3@ls/false (apply (lambda () (le58@syntax-violation '#f '"invalid last clause" l14a1@stx)) l14f3@ls/false) (le58@syntax-violation '#f '"invalid syntax" l14f1@t)))))))))))))))))))) l14a5@ls/false) (le58@syntax-violation '#f '"invalid syntax" l14a3@t)))))) (set! l2840@ld5c@cond-macro ld5c@cond-macro) (set! ld5e@do-include (lambda (l14f5@stx l14f6@id l14f7@filename) (let ((l14fb@filename (lb85@stx->datum l14f7@filename))) (begin (if (not (and (string? l14fb@filename) (lb71@id? l14f6@id))) (le58@syntax-violation '#f '"invalid syntax" l14f5@stx) (void)) (cons (ld2e@bless 'begin) (with-input-from-file l14fb@filename (lambda () (let l14ff@f ((l14fd@ls '())) (let ((l1501@x (l6b3@l583@read-annotated))) (if (eof-object? l1501@x) (reverse l14fd@ls) (l14ff@f (cons (lb51@datum->stx l14f6@id l1501@x) l14fd@ls)))))))))))) (set! l2841@ld5e@do-include ld5e@do-include) (set! ld60@include-macro (lambda (l1503@e) (let ((l1505@t l1503@e)) (let ((l1507@ls/false (ld78@syntax-dispatch l1505@t '(any any)))) (if l1507@ls/false (apply (lambda (l1509@id l150a@filename) (ld5e@do-include l1503@e l1509@id l150a@filename)) l1507@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1505@t)))))) (set! l2842@ld60@include-macro ld60@include-macro) (set! ld62@include-into-macro (lambda (l150d@e) (let ((l150f@t l150d@e)) (let ((l1511@ls/false (ld78@syntax-dispatch l150f@t '(_ any any)))) (if l1511@ls/false (apply (lambda (l1513@id l1514@filename) (ld5e@do-include l150d@e l1513@id l1514@filename)) l1511@ls/false) (le58@syntax-violation '#f '"invalid syntax" l150f@t)))))) (set! l2843@ld62@include-into-macro ld62@include-into-macro) (set! ld64@syntax-rules-macro (lambda (l1517@e) (let ((l1519@t l1517@e)) (let ((l151b@ls/false (ld78@syntax-dispatch l1519@t '(_ each-any . #(each (any any)))))) (if l151b@ls/false (apply (lambda (l151d@lits l151e@pat* l151f@tmp*) (begin (ld7e@verify-literals l151d@lits l1517@e) (ld2e@bless (list 'lambda '(x) (cons 'syntax-case (cons 'x (cons l151d@lits (map (lambda (l1523@pat l1524@tmp) (let ((l1527@t l1523@pat)) (let ((l1529@ls/false (ld78@syntax-dispatch l1527@t '(_ . any)))) (if l1529@ls/false (apply (lambda (l152b@rest) (list (cons 'g l152b@rest) (list 'syntax l1524@tmp))) l1529@ls/false) (let ((l152d@t l1527@t)) (let ((l152f@ls/false (ld78@syntax-dispatch l152d@t '_))) (if l152f@ls/false (apply (lambda () (le58@syntax-violation '#f '"invalid syntax-rules pattern" l1517@e l1523@pat)) l152f@ls/false) (le58@syntax-violation '#f '"invalid syntax" l152d@t)))))))) l151e@pat* l151f@tmp*)))))))) l151b@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1519@t)))))) (set! l2844@ld64@syntax-rules-macro ld64@syntax-rules-macro) (set! ld66@quasiquote-macro (letrec* ((l1532@datum (lambda (l1633@x) (list (ld00@scheme-stx 'quote) (lb59@mkstx l1633@x '() '() '())))) (l154e@quasicons* (lambda (l162b@x l162c@y) (let l1631@f ((l162f@x l162b@x)) (if (null? l162f@x) l162c@y (l1550@quasicons (car l162f@x) (l1631@f (cdr l162f@x))))))) (l1550@quasicons (lambda (l1605@x l1606@y) (let ((l1609@t l1606@y)) (let ((l160b@ls/false (ld78@syntax-dispatch l1609@t '(#(scheme-id quote) any)))) (if l160b@ls/false (apply (lambda (l160d@dy) (let ((l160f@t l1605@x)) (let ((l1611@ls/false (ld78@syntax-dispatch l160f@t '(#(scheme-id quote) any)))) (if l1611@ls/false (apply (lambda (l1613@dx) (list (ld00@scheme-stx 'quote) (cons l1613@dx l160d@dy))) l1611@ls/false) (let ((l1615@t l160f@t)) (let ((l1617@ls/false (ld78@syntax-dispatch l1615@t '_))) (if l1617@ls/false (apply (lambda () (let ((l1619@t l160d@dy)) (let ((l161b@ls/false (ld78@syntax-dispatch l1619@t '()))) (if l161b@ls/false (apply (lambda () (list (ld00@scheme-stx 'list) l1605@x)) l161b@ls/false) (let ((l161d@t l1619@t)) (let ((l161f@ls/false (ld78@syntax-dispatch l161d@t '_))) (if l161f@ls/false (apply (lambda () (list (ld00@scheme-stx 'cons) l1605@x l1606@y)) l161f@ls/false) (le58@syntax-violation '#f '"invalid syntax" l161d@t)))))))) l1617@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1615@t)))))))) l160b@ls/false) (let ((l1621@t l1609@t)) (let ((l1623@ls/false (ld78@syntax-dispatch l1621@t '(#(scheme-id list) . each-any)))) (if l1623@ls/false (apply (lambda (l1625@stuff) (cons* (ld00@scheme-stx 'list) l1605@x l1625@stuff)) l1623@ls/false) (let ((l1627@t l1621@t)) (let ((l1629@ls/false (ld78@syntax-dispatch l1627@t '_))) (if l1629@ls/false (apply (lambda () (list (ld00@scheme-stx 'cons) l1605@x l1606@y)) l1629@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1627@t)))))))))))) (l1552@quasiappend (lambda (l15eb@x l15ec@y) (let ((l15ef@ls (let l15f3@f ((l15f1@x l15eb@x)) (if (null? l15f1@x) (let ((l15f5@t l15ec@y)) (let ((l15f7@ls/false (ld78@syntax-dispatch l15f5@t '(#(scheme-id quote) ())))) (if l15f7@ls/false (apply (lambda () '()) l15f7@ls/false) (let ((l15f9@t l15f5@t)) (let ((l15fb@ls/false (ld78@syntax-dispatch l15f9@t '_))) (if l15fb@ls/false (apply (lambda () (list l15ec@y)) l15fb@ls/false) (le58@syntax-violation '#f '"invalid syntax" l15f9@t))))))) (let ((l15fd@t (car l15f1@x))) (let ((l15ff@ls/false (ld78@syntax-dispatch l15fd@t '(#(scheme-id quote) ())))) (if l15ff@ls/false (apply (lambda () (l15f3@f (cdr l15f1@x))) l15ff@ls/false) (let ((l1601@t l15fd@t)) (let ((l1603@ls/false (ld78@syntax-dispatch l1601@t '_))) (if l1603@ls/false (apply (lambda () (cons (car l15f1@x) (l15f3@f (cdr l15f1@x)))) l1603@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1601@t))))))))))) (if (null? l15ef@ls) (list (ld00@scheme-stx 'quote) '()) (if (null? (cdr l15ef@ls)) (car l15ef@ls) (cons* (ld00@scheme-stx 'append) l15ef@ls)))))) (l1554@quasivector (lambda (l15b9@x) (let ((l15bb@pat-x l15b9@x)) (let ((l15bd@t l15bb@pat-x)) (let ((l15bf@ls/false (ld78@syntax-dispatch l15bd@t '(#(scheme-id quote) each-any)))) (if l15bf@ls/false (apply (lambda (l15c1@x*) (list (ld00@scheme-stx 'quote) (list->vector l15c1@x*))) l15bf@ls/false) (let ((l15c3@t l15bd@t)) (let ((l15c5@ls/false (ld78@syntax-dispatch l15c3@t '_))) (if l15c5@ls/false (apply (lambda () (let l15cd@f ((l15c7@x l15b9@x) (l15c8@k (lambda (l15cb@ls) (cons* (ld00@scheme-stx 'vector) l15cb@ls)))) (let ((l15cf@t l15c7@x)) (let ((l15d1@ls/false (ld78@syntax-dispatch l15cf@t '(#(scheme-id quote) each-any)))) (if l15d1@ls/false (apply (lambda (l15d3@x*) (l15c8@k (map (lambda (l15d5@x) (list (ld00@scheme-stx 'quote) l15d5@x)) l15d3@x*))) l15d1@ls/false) (let ((l15d7@t l15cf@t)) (let ((l15d9@ls/false (ld78@syntax-dispatch l15d7@t '(#(scheme-id list) . each-any)))) (if l15d9@ls/false (apply (lambda (l15db@x*) (l15c8@k l15db@x*)) l15d9@ls/false) (let ((l15dd@t l15d7@t)) (let ((l15df@ls/false (ld78@syntax-dispatch l15dd@t '(#(scheme-id cons) any any)))) (if l15df@ls/false (apply (lambda (l15e1@x l15e2@y) (l15cd@f l15e2@y (lambda (l15e5@ls) (l15c8@k (cons l15e1@x l15e5@ls))))) l15df@ls/false) (let ((l15e7@t l15dd@t)) (let ((l15e9@ls/false (ld78@syntax-dispatch l15e7@t '_))) (if l15e9@ls/false (apply (lambda () (list (ld00@scheme-stx 'list->vector) l15bb@pat-x)) l15e9@ls/false) (le58@syntax-violation '#f '"invalid syntax" l15e7@t))))))))))))))) l15c5@ls/false) (le58@syntax-violation '#f '"invalid syntax" l15c3@t)))))))))) (l1556@vquasi (lambda (l1597@p l1598@lev) (let ((l159b@t l1597@p)) (let ((l159d@ls/false (ld78@syntax-dispatch l159b@t '(any . any)))) (if l159d@ls/false (apply (lambda (l159f@p l15a0@q) (let ((l15a3@t l159f@p)) (let ((l15a5@ls/false (ld78@syntax-dispatch l15a3@t '(#(scheme-id unquote) . each-any)))) (if l15a5@ls/false (apply (lambda (l15a7@p) (if (= l1598@lev '0) (l154e@quasicons* l15a7@p (l1556@vquasi l15a0@q l1598@lev)) (l1550@quasicons (l1550@quasicons (l1532@datum 'unquote) (l1558@quasi l15a7@p (- l1598@lev '1))) (l1556@vquasi l15a0@q l1598@lev)))) l15a5@ls/false) (let ((l15a9@t l15a3@t)) (let ((l15ab@ls/false (ld78@syntax-dispatch l15a9@t '(#(scheme-id unquote-splicing) . each-any)))) (if l15ab@ls/false (apply (lambda (l15ad@p) (if (= l1598@lev '0) (l1552@quasiappend l15ad@p (l1556@vquasi l15a0@q l1598@lev)) (l1550@quasicons (l1550@quasicons (l1532@datum 'unquote-splicing) (l1558@quasi l15ad@p (- l1598@lev '1))) (l1556@vquasi l15a0@q l1598@lev)))) l15ab@ls/false) (let ((l15af@t l15a9@t)) (let ((l15b1@ls/false (ld78@syntax-dispatch l15af@t 'any))) (if l15b1@ls/false (apply (lambda (l15b3@p) (l1550@quasicons (l1558@quasi l15b3@p l1598@lev) (l1556@vquasi l15a0@q l1598@lev))) l15b1@ls/false) (le58@syntax-violation '#f '"invalid syntax" l15af@t))))))))))) l159d@ls/false) (let ((l15b5@t l159b@t)) (let ((l15b7@ls/false (ld78@syntax-dispatch l15b5@t '()))) (if l15b7@ls/false (apply (lambda () (list (ld00@scheme-stx 'quote) '())) l15b7@ls/false) (le58@syntax-violation '#f '"invalid syntax" l15b5@t))))))))) (l1558@quasi (lambda (l1561@p l1562@lev) (let ((l1565@t l1561@p)) (let ((l1567@ls/false (ld78@syntax-dispatch l1565@t '(#(scheme-id unquote) any)))) (if l1567@ls/false (apply (lambda (l1569@p) (if (= l1562@lev '0) l1569@p (l1550@quasicons (l1532@datum 'unquote) (l1558@quasi (list l1569@p) (- l1562@lev '1))))) l1567@ls/false) (let ((l156b@t l1565@t)) (let ((l156d@ls/false (ld78@syntax-dispatch l156b@t '((#(scheme-id unquote) . each-any) . any)))) (if l156d@ls/false (apply (lambda (l156f@p l1570@q) (if (= l1562@lev '0) (l154e@quasicons* l156f@p (l1558@quasi l1570@q l1562@lev)) (l1550@quasicons (l1550@quasicons (l1532@datum 'unquote) (l1558@quasi l156f@p (- l1562@lev '1))) (l1558@quasi l1570@q l1562@lev)))) l156d@ls/false) (let ((l1573@t l156b@t)) (let ((l1575@ls/false (ld78@syntax-dispatch l1573@t '((#(scheme-id unquote-splicing) . each-any) . any)))) (if l1575@ls/false (apply (lambda (l1577@p l1578@q) (if (= l1562@lev '0) (l1552@quasiappend l1577@p (l1558@quasi l1578@q l1562@lev)) (l1550@quasicons (l1550@quasicons (l1532@datum 'unquote-splicing) (l1558@quasi l1577@p (- l1562@lev '1))) (l1558@quasi l1578@q l1562@lev)))) l1575@ls/false) (let ((l157b@t l1573@t)) (let ((l157d@ls/false (ld78@syntax-dispatch l157b@t '(#(scheme-id quasiquote) any)))) (if l157d@ls/false (apply (lambda (l157f@p) (l1550@quasicons (l1532@datum 'quasiquote) (l1558@quasi (list l157f@p) (+ l1562@lev '1)))) l157d@ls/false) (let ((l1581@t l157b@t)) (let ((l1583@ls/false (ld78@syntax-dispatch l1581@t '(any . any)))) (if l1583@ls/false (apply (lambda (l1585@p l1586@q) (l1550@quasicons (l1558@quasi l1585@p l1562@lev) (l1558@quasi l1586@q l1562@lev))) l1583@ls/false) (let ((l1589@t l1581@t)) (let ((l158b@ls/false (ld78@syntax-dispatch l1589@t '#(vector each-any)))) (if (and l158b@ls/false (apply (lambda (l158d@x) (not (lb3d@stx? l158d@x))) l158b@ls/false)) (apply (lambda (l158f@x) (l1554@quasivector (l1556@vquasi l158f@x l1562@lev))) l158b@ls/false) (let ((l1591@t l1589@t)) (let ((l1593@ls/false (ld78@syntax-dispatch l1591@t 'any))) (if l1593@ls/false (apply (lambda (l1595@p) (list (ld00@scheme-stx 'quote) l1595@p)) l1593@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1591@t))))))))))))))))))))))))) (lambda (l1559@x) (let ((l155b@t l1559@x)) (let ((l155d@ls/false (ld78@syntax-dispatch l155b@t '(_ any)))) (if l155d@ls/false (apply (lambda (l155f@e) (l1558@quasi l155f@e '0)) l155d@ls/false) (le58@syntax-violation '#f '"invalid syntax" l155b@t))))))) (set! l2845@ld66@quasiquote-macro ld66@quasiquote-macro) (set! ld68@quasisyntax-macro (letrec* ((l1636@quasi (lambda (l1651@p l1652@lev) (let ((l1655@t l1651@p)) (let ((l1657@ls/false (ld78@syntax-dispatch l1655@t '(#(scheme-id unsyntax) any)))) (if l1657@ls/false (apply (lambda (l1659@p) (if (= l1652@lev '0) (let ((l165b@g (gensym))) (values (list l165b@g) (list l1659@p) l165b@g)) (call-with-values (lambda () (l1636@quasi l1659@p (- l1652@lev '1))) (lambda (l1663@l165e l1664@l1660 l1665@l1662) (let ((l1669@p l1665@l1662) (l166a@rhs* l1664@l1660) (l166b@lhs* l1663@l165e)) (values l166b@lhs* l166a@rhs* (list 'unsyntax l1669@p))))))) l1657@ls/false) (let ((l166f@t l1655@t)) (let ((l1671@ls/false (ld78@syntax-dispatch l166f@t '#(scheme-id unsyntax)))) (if (and l1671@ls/false (apply (lambda () (= l1652@lev '0)) l1671@ls/false)) (apply (lambda () (le58@syntax-violation '#f '"incorrect use of unsyntax" l1651@p)) l1671@ls/false) (let ((l1673@t l166f@t)) (let ((l1675@ls/false (ld78@syntax-dispatch l1673@t '((#(scheme-id unsyntax) . each-any) . any)))) (if l1675@ls/false (apply (lambda (l1677@p* l1678@q) (call-with-values (lambda () (l1636@quasi l1678@q l1652@lev)) (lambda (l1681@l167c l1682@l167e l1683@l1680) (let ((l1687@q l1683@l1680) (l1688@rhs* l1682@l167e) (l1689@lhs* l1681@l167c)) (if (= l1652@lev '0) (let ((l168d@g* (map (lambda (l168f@x) (gensym)) l1677@p*))) (values (append l168d@g* l1689@lhs*) (append l1677@p* l1688@rhs*) (append l168d@g* l1687@q))) (call-with-values (lambda () (l1636@quasi l1677@p* (- l1652@lev '1))) (lambda (l1697@l1692 l1698@l1694 l1699@l1696) (let ((l169d@p* l1699@l1696) (l169e@rhs2* l1698@l1694) (l169f@lhs2* l1697@l1692)) (values (append l169f@lhs2* l1689@lhs*) (append l169e@rhs2* l1688@rhs*) (cons (cons 'unsyntax l169d@p*) l1687@q)))))))))) l1675@ls/false) (let ((l16a3@t l1673@t)) (let ((l16a5@ls/false (ld78@syntax-dispatch l16a3@t '((#(scheme-id unsyntax-splicing) . each-any) . any)))) (if l16a5@ls/false (apply (lambda (l16a7@p* l16a8@q) (call-with-values (lambda () (l1636@quasi l16a8@q l1652@lev)) (lambda (l16b1@l16ac l16b2@l16ae l16b3@l16b0) (let ((l16b7@q l16b3@l16b0) (l16b8@rhs* l16b2@l16ae) (l16b9@lhs* l16b1@l16ac)) (if (= l1652@lev '0) (let ((l16bd@g* (map (lambda (l16bf@x) (gensym)) l16a7@p*))) (values (append (map (lambda (l16c1@g) (cons l16c1@g '(...))) l16bd@g*) l16b9@lhs*) (append l16a7@p* l16b8@rhs*) (append (apply append (map (lambda (l16c3@g) (cons l16c3@g '(...))) l16bd@g*)) l16b7@q))) (call-with-values (lambda () (l1636@quasi l16a7@p* (- l1652@lev '1))) (lambda (l16cb@l16c6 l16cc@l16c8 l16cd@l16ca) (let ((l16d1@p* l16cd@l16ca) (l16d2@rhs2* l16cc@l16c8) (l16d3@lhs2* l16cb@l16c6)) (values (append l16d3@lhs2* l16b9@lhs*) (append l16d2@rhs2* l16b8@rhs*) (cons (cons 'unsyntax-splicing l16d1@p*) l16b7@q)))))))))) l16a5@ls/false) (let ((l16d7@t l16a3@t)) (let ((l16d9@ls/false (ld78@syntax-dispatch l16d7@t '#(scheme-id unsyntax-splicing)))) (if (and l16d9@ls/false (apply (lambda () (= l1652@lev '0)) l16d9@ls/false)) (apply (lambda () (le58@syntax-violation '#f '"incorrect use of unsyntax-splicing" l1651@p)) l16d9@ls/false) (let ((l16db@t l16d7@t)) (let ((l16dd@ls/false (ld78@syntax-dispatch l16db@t '(#(scheme-id quasisyntax) any)))) (if l16dd@ls/false (apply (lambda (l16df@p) (call-with-values (lambda () (l1636@quasi l16df@p (+ l1652@lev '1))) (lambda (l16e7@l16e2 l16e8@l16e4 l16e9@l16e6) (let ((l16ed@p l16e9@l16e6) (l16ee@rhs* l16e8@l16e4) (l16ef@lhs* l16e7@l16e2)) (values l16ef@lhs* l16ee@rhs* (list 'quasisyntax l16ed@p)))))) l16dd@ls/false) (let ((l16f3@t l16db@t)) (let ((l16f5@ls/false (ld78@syntax-dispatch l16f3@t '(any . any)))) (if l16f5@ls/false (apply (lambda (l16f7@p l16f8@q) (call-with-values (lambda () (l1636@quasi l16f7@p l1652@lev)) (lambda (l1707@l16fc l1708@l16fe l1709@l1700) (call-with-values (lambda () (l1636@quasi l16f8@q l1652@lev)) (lambda (l170d@l1702 l170e@l1704 l170f@l1706) (let ((l1713@q l170f@l1706) (l1714@rhs2* l170e@l1704) (l1715@lhs2* l170d@l1702) (l1716@p l1709@l1700) (l1717@rhs* l1708@l16fe) (l1718@lhs* l1707@l16fc)) (values (append l1715@lhs2* l1718@lhs*) (append l1714@rhs2* l1717@rhs*) (cons l1716@p l1713@q)))))))) l16f5@ls/false) (let ((l171f@t l16f3@t)) (let ((l1721@ls/false (ld78@syntax-dispatch l171f@t '#(vector each-any)))) (if l1721@ls/false (apply (lambda (l1723@x*) (call-with-values (lambda () (l1636@quasi l1723@x* l1652@lev)) (lambda (l172b@l1726 l172c@l1728 l172d@l172a) (let ((l1731@x* l172d@l172a) (l1732@rhs* l172c@l1728) (l1733@lhs* l172b@l1726)) (values l1733@lhs* l1732@rhs* (list->vector l1731@x*)))))) l1721@ls/false) (let ((l1737@t l171f@t)) (let ((l1739@ls/false (ld78@syntax-dispatch l1737@t '_))) (if l1739@ls/false (apply (lambda () (values '() '() l1651@p)) l1739@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1737@t))))))))))))))))))))))))))))))) (lambda (l1637@x) (let ((l1639@t l1637@x)) (let ((l163b@ls/false (ld78@syntax-dispatch l1639@t '(_ any)))) (if l163b@ls/false (apply (lambda (l163d@e) (call-with-values (lambda () (l1636@quasi l163d@e '0)) (lambda (l1645@l1640 l1646@l1642 l1647@l1644) (let ((l164b@v l1647@l1644) (l164c@rhs* l1646@l1642) (l164d@lhs* l1645@l1640)) (ld2e@bless (list 'syntax-case (cons 'list l164c@rhs*) '() (list l164d@lhs* (list 'syntax l164b@v)))))))) l163b@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1639@t))))))) (set! l2846@ld68@quasisyntax-macro ld68@quasisyntax-macro) (set! ld6a@define-struct-macro (lambda (l173b@stx) (le58@syntax-violation '#f '"define-struct not supported" l173b@stx))) (set! l2847@ld6a@define-struct-macro ld6a@define-struct-macro) (set! ld6c@define-record-type-macro (lambda (l173d@x) (letrec* ((l1740@id (lambda (l1933@ctxt . l1935@str*) (le5c@datum->syntax l1933@ctxt (string->symbol (apply string-append (map (lambda (l1937@x) (if (symbol? l1937@x) (symbol->string l1937@x) (if (string? l1937@x) l1937@x (assertion-violation 'define-record-type '"BUG")))) l1935@str*)))))) (l1742@get-record-name (lambda (l1921@spec) (let ((l1923@t l1921@spec)) (let ((l1925@ls/false (ld78@syntax-dispatch l1923@t '(any any any)))) (if l1925@ls/false (apply (lambda (l1927@foo l1928@make-foo l1929@foo?) l1927@foo) l1925@ls/false) (let ((l192d@t l1923@t)) (let ((l192f@ls/false (ld78@syntax-dispatch l192d@t 'any))) (if l192f@ls/false (apply (lambda (l1931@foo) l1931@foo) l192f@ls/false) (le58@syntax-violation '#f '"invalid syntax" l192d@t))))))))) (l1744@get-record-constructor-name (lambda (l190d@spec) (let ((l190f@t l190d@spec)) (let ((l1911@ls/false (ld78@syntax-dispatch l190f@t '(any any any)))) (if l1911@ls/false (apply (lambda (l1913@foo l1914@make-foo l1915@foo?) l1914@make-foo) l1911@ls/false) (let ((l1919@t l190f@t)) (let ((l191b@ls/false (ld78@syntax-dispatch l1919@t 'any))) (if (and l191b@ls/false (apply (lambda (l191d@foo) (lb71@id? l191d@foo)) l191b@ls/false)) (apply (lambda (l191f@foo) (l1740@id l191f@foo '"make-" (lb85@stx->datum l191f@foo))) l191b@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1919@t))))))))) (l1746@get-record-predicate-name (lambda (l18f9@spec) (let ((l18fb@t l18f9@spec)) (let ((l18fd@ls/false (ld78@syntax-dispatch l18fb@t '(any any any)))) (if l18fd@ls/false (apply (lambda (l18ff@foo l1900@make-foo l1901@foo?) l1901@foo?) l18fd@ls/false) (let ((l1905@t l18fb@t)) (let ((l1907@ls/false (ld78@syntax-dispatch l1905@t 'any))) (if (and l1907@ls/false (apply (lambda (l1909@foo) (lb71@id? l1909@foo)) l1907@ls/false)) (apply (lambda (l190b@foo) (l1740@id l190b@foo (lb85@stx->datum l190b@foo) '"?")) l1907@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1905@t))))))))) (l1748@get-clause (lambda (l18e7@id l18e8@ls) (let ((l18eb@t l18e8@ls)) (let ((l18ed@ls/false (ld78@syntax-dispatch l18eb@t '()))) (if l18ed@ls/false (apply (lambda () '#f) l18ed@ls/false) (let ((l18ef@t l18eb@t)) (let ((l18f1@ls/false (ld78@syntax-dispatch l18ef@t '((any . any) . any)))) (if l18f1@ls/false (apply (lambda (l18f3@x l18f4@rest l18f5@ls) (if (lb77@free-id=? (ld2e@bless l18e7@id) l18f3@x) (cons l18f3@x l18f4@rest) (l1748@get-clause l18e7@id l18f5@ls))) l18f1@ls/false) (le58@syntax-violation '#f '"invalid syntax" l18ef@t))))))))) (l174a@foo-rtd-code (lambda (l1895@name l1896@clause* l1897@parent-rtd-code) (letrec* ((l189c@convert-field-spec* (lambda (l18cd@ls) (list->vector (map (lambda (l18cf@x) (let ((l18d1@t l18cf@x)) (let ((l18d3@ls/false (ld78@syntax-dispatch l18d1@t '(#(scheme-id mutable) any . any)))) (if l18d3@ls/false (apply (lambda (l18d5@name l18d6@rest) (list 'mutable l18d5@name)) l18d3@ls/false) (let ((l18d9@t l18d1@t)) (let ((l18db@ls/false (ld78@syntax-dispatch l18d9@t '(#(scheme-id immutable) any . any)))) (if l18db@ls/false (apply (lambda (l18dd@name l18de@rest) (list 'immutable l18dd@name)) l18db@ls/false) (let ((l18e1@t l18d9@t)) (let ((l18e3@ls/false (ld78@syntax-dispatch l18e1@t 'any))) (if l18e3@ls/false (apply (lambda (l18e5@name) (list 'immutable l18e5@name)) l18e3@ls/false) (le58@syntax-violation '#f '"invalid syntax" l18e1@t))))))))))) l18cd@ls))))) (let ((l189d@uid-code (let ((l18a5@t (l1748@get-clause 'nongenerative l1896@clause*))) (let ((l18a7@ls/false (ld78@syntax-dispatch l18a5@t '(_)))) (if l18a7@ls/false (apply (lambda () (list 'quote (gensym))) l18a7@ls/false) (let ((l18a9@t l18a5@t)) (let ((l18ab@ls/false (ld78@syntax-dispatch l18a9@t '(_ any)))) (if l18ab@ls/false (apply (lambda (l18ad@uid) (list 'quote l18ad@uid)) l18ab@ls/false) (let ((l18af@t l18a9@t)) (let ((l18b1@ls/false (ld78@syntax-dispatch l18af@t '_))) (if l18b1@ls/false (apply (lambda () '#f) l18b1@ls/false) (le58@syntax-violation '#f '"invalid syntax" l18af@t))))))))))) (l189e@sealed? (let ((l18b3@t (l1748@get-clause 'sealed l1896@clause*))) (let ((l18b5@ls/false (ld78@syntax-dispatch l18b3@t '(_ #(atom #t))))) (if l18b5@ls/false (apply (lambda () '#t) l18b5@ls/false) (let ((l18b7@t l18b3@t)) (let ((l18b9@ls/false (ld78@syntax-dispatch l18b7@t '_))) (if l18b9@ls/false (apply (lambda () '#f) l18b9@ls/false) (le58@syntax-violation '#f '"invalid syntax" l18b7@t)))))))) (l189f@opaque? (let ((l18bb@t (l1748@get-clause 'opaque l1896@clause*))) (let ((l18bd@ls/false (ld78@syntax-dispatch l18bb@t '(_ #(atom #t))))) (if l18bd@ls/false (apply (lambda () '#t) l18bd@ls/false) (let ((l18bf@t l18bb@t)) (let ((l18c1@ls/false (ld78@syntax-dispatch l18bf@t '_))) (if l18c1@ls/false (apply (lambda () '#f) l18c1@ls/false) (le58@syntax-violation '#f '"invalid syntax" l18bf@t)))))))) (l18a0@fields (let ((l18c3@t (l1748@get-clause 'fields l1896@clause*))) (let ((l18c5@ls/false (ld78@syntax-dispatch l18c3@t '(_ . each-any)))) (if l18c5@ls/false (apply (lambda (l18c7@field-spec*) (list 'quote (l189c@convert-field-spec* l18c7@field-spec*))) l18c5@ls/false) (let ((l18c9@t l18c3@t)) (let ((l18cb@ls/false (ld78@syntax-dispatch l18c9@t '_))) (if l18cb@ls/false (apply (lambda () ''#()) l18cb@ls/false) (le58@syntax-violation '#f '"invalid syntax" l18c9@t))))))))) (ld2e@bless (list 'make-record-type-descriptor (list 'quote l1895@name) l1897@parent-rtd-code l189d@uid-code l189e@sealed? l189f@opaque? l18a0@fields)))))) (l174c@parent-rtd-code (lambda (l187d@clause*) (let ((l187f@t (l1748@get-clause 'parent l187d@clause*))) (let ((l1881@ls/false (ld78@syntax-dispatch l187f@t '(_ any)))) (if l1881@ls/false (apply (lambda (l1883@name) (list 'record-type-descriptor l1883@name)) l1881@ls/false) (let ((l1885@t l187f@t)) (let ((l1887@ls/false (ld78@syntax-dispatch l1885@t '#(atom #f)))) (if l1887@ls/false (apply (lambda () (let ((l1889@t (l1748@get-clause 'parent-rtd l187d@clause*))) (let ((l188b@ls/false (ld78@syntax-dispatch l1889@t '(_ any any)))) (if l188b@ls/false (apply (lambda (l188d@rtd l188e@rcd) l188d@rtd) l188b@ls/false) (let ((l1891@t l1889@t)) (let ((l1893@ls/false (ld78@syntax-dispatch l1891@t '#(atom #f)))) (if l1893@ls/false (apply (lambda () '#f) l1893@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1891@t)))))))) l1887@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1885@t))))))))) (l174e@parent-rcd-code (lambda (l1865@clause*) (let ((l1867@t (l1748@get-clause 'parent l1865@clause*))) (let ((l1869@ls/false (ld78@syntax-dispatch l1867@t '(_ any)))) (if l1869@ls/false (apply (lambda (l186b@name) (list 'record-constructor-descriptor l186b@name)) l1869@ls/false) (let ((l186d@t l1867@t)) (let ((l186f@ls/false (ld78@syntax-dispatch l186d@t '#(atom #f)))) (if l186f@ls/false (apply (lambda () (let ((l1871@t (l1748@get-clause 'parent-rtd l1865@clause*))) (let ((l1873@ls/false (ld78@syntax-dispatch l1871@t '(_ any any)))) (if l1873@ls/false (apply (lambda (l1875@rtd l1876@rcd) l1876@rcd) l1873@ls/false) (let ((l1879@t l1871@t)) (let ((l187b@ls/false (ld78@syntax-dispatch l1879@t '#(atom #f)))) (if l187b@ls/false (apply (lambda () '#f) l187b@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1879@t)))))))) l186f@ls/false) (le58@syntax-violation '#f '"invalid syntax" l186d@t))))))))) (l1750@foo-rcd-code (lambda (l185d@clause* l185e@foo-rtd l185f@protocol l1860@parent-rcd-code) (list 'make-record-constructor-descriptor l185e@foo-rtd l1860@parent-rcd-code l185f@protocol))) (l1752@get-protocol-code (lambda (l1851@clause*) (let ((l1853@t (l1748@get-clause 'protocol l1851@clause*))) (let ((l1855@ls/false (ld78@syntax-dispatch l1853@t '(_ any)))) (if l1855@ls/false (apply (lambda (l1857@expr) l1857@expr) l1855@ls/false) (let ((l1859@t l1853@t)) (let ((l185b@ls/false (ld78@syntax-dispatch l1859@t '_))) (if l185b@ls/false (apply (lambda () '#f) l185b@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1859@t))))))))) (l1754@get-fields (lambda (l183f@clause*) (let ((l1841@t l183f@clause*)) (let ((l1843@ls/false (ld78@syntax-dispatch l1841@t '()))) (if l1843@ls/false (apply (lambda () '()) l1843@ls/false) (let ((l1845@t l1841@t)) (let ((l1847@ls/false (ld78@syntax-dispatch l1845@t '((#(scheme-id fields) . each-any) . _)))) (if l1847@ls/false (apply (lambda (l1849@f*) l1849@f*) l1847@ls/false) (let ((l184b@t l1845@t)) (let ((l184d@ls/false (ld78@syntax-dispatch l184b@t '(_ . any)))) (if l184d@ls/false (apply (lambda (l184f@rest) (l1754@get-fields l184f@rest)) l184d@ls/false) (le58@syntax-violation '#f '"invalid syntax" l184b@t)))))))))))) (l1756@get-mutator-indices (lambda (l1827@fields) (let l182d@f ((l1829@fields l1827@fields) (l182a@i '0)) (let ((l182f@t l1829@fields)) (let ((l1831@ls/false (ld78@syntax-dispatch l182f@t '()))) (if l1831@ls/false (apply (lambda () '()) l1831@ls/false) (let ((l1833@t l182f@t)) (let ((l1835@ls/false (ld78@syntax-dispatch l1833@t '((#(scheme-id mutable) . _) . any)))) (if l1835@ls/false (apply (lambda (l1837@rest) (cons l182a@i (l182d@f l1837@rest (+ l182a@i '1)))) l1835@ls/false) (let ((l1839@t l1833@t)) (let ((l183b@ls/false (ld78@syntax-dispatch l1839@t '(_ . any)))) (if l183b@ls/false (apply (lambda (l183d@rest) (l182d@f l183d@rest (+ l182a@i '1))) l183b@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1839@t))))))))))))) (l1758@get-mutators (lambda (l17fd@foo l17fe@fields) (letrec* ((l1802@gen-name (lambda (l1825@x) (le5c@datum->syntax l17fd@foo (string->symbol (string-append (symbol->string (le5e@syntax->datum l17fd@foo)) '"-" (symbol->string (le5e@syntax->datum l1825@x)) '"-set!")))))) (let l1805@f ((l1803@fields l17fe@fields)) (let ((l1807@t l1803@fields)) (let ((l1809@ls/false (ld78@syntax-dispatch l1807@t '()))) (if l1809@ls/false (apply (lambda () '()) l1809@ls/false) (let ((l180b@t l1807@t)) (let ((l180d@ls/false (ld78@syntax-dispatch l180b@t '((#(scheme-id mutable) any any any) . any)))) (if l180d@ls/false (apply (lambda (l180f@name l1810@accessor l1811@mutator l1812@rest) (cons l1811@mutator (l1805@f l1812@rest))) l180d@ls/false) (let ((l1817@t l180b@t)) (let ((l1819@ls/false (ld78@syntax-dispatch l1817@t '((#(scheme-id mutable) any) . any)))) (if l1819@ls/false (apply (lambda (l181b@name l181c@rest) (cons (l1802@gen-name l181b@name) (l1805@f l181c@rest))) l1819@ls/false) (let ((l181f@t l1817@t)) (let ((l1821@ls/false (ld78@syntax-dispatch l181f@t '(_ . any)))) (if l1821@ls/false (apply (lambda (l1823@rest) (l1805@f l1823@rest)) l1821@ls/false) (le58@syntax-violation '#f '"invalid syntax" l181f@t))))))))))))))))) (l175a@get-accessors (lambda (l17b9@foo l17ba@fields) (letrec* ((l17be@gen-name (lambda (l17fb@x) (le5c@datum->syntax l17b9@foo (string->symbol (string-append (symbol->string (le5e@syntax->datum l17b9@foo)) '"-" (symbol->string (le5e@syntax->datum l17fb@x)))))))) (map (lambda (l17bf@field) (let ((l17c1@t l17bf@field)) (let ((l17c3@ls/false (ld78@syntax-dispatch l17c1@t '(#(scheme-id mutable) any any any)))) (if (and l17c3@ls/false (apply (lambda (l17c5@name l17c6@accessor l17c7@mutator) (lb71@id? l17c6@accessor)) l17c3@ls/false)) (apply (lambda (l17cb@name l17cc@accessor l17cd@mutator) l17cc@accessor) l17c3@ls/false) (let ((l17d1@t l17c1@t)) (let ((l17d3@ls/false (ld78@syntax-dispatch l17d1@t '(#(scheme-id immutable) any any)))) (if (and l17d3@ls/false (apply (lambda (l17d5@name l17d6@accessor) (lb71@id? l17d6@accessor)) l17d3@ls/false)) (apply (lambda (l17d9@name l17da@accessor) l17da@accessor) l17d3@ls/false) (let ((l17dd@t l17d1@t)) (let ((l17df@ls/false (ld78@syntax-dispatch l17dd@t '(#(scheme-id mutable) any)))) (if (and l17df@ls/false (apply (lambda (l17e1@name) (lb71@id? l17e1@name)) l17df@ls/false)) (apply (lambda (l17e3@name) (l17be@gen-name l17e3@name)) l17df@ls/false) (let ((l17e5@t l17dd@t)) (let ((l17e7@ls/false (ld78@syntax-dispatch l17e5@t '(#(scheme-id immutable) any)))) (if (and l17e7@ls/false (apply (lambda (l17e9@name) (lb71@id? l17e9@name)) l17e7@ls/false)) (apply (lambda (l17eb@name) (l17be@gen-name l17eb@name)) l17e7@ls/false) (let ((l17ed@t l17e5@t)) (let ((l17ef@ls/false (ld78@syntax-dispatch l17ed@t 'any))) (if (and l17ef@ls/false (apply (lambda (l17f1@name) (lb71@id? l17f1@name)) l17ef@ls/false)) (apply (lambda (l17f3@name) (l17be@gen-name l17f3@name)) l17ef@ls/false) (let ((l17f5@t l17ed@t)) (let ((l17f7@ls/false (ld78@syntax-dispatch l17f5@t 'any))) (if l17f7@ls/false (apply (lambda (l17f9@others) (le58@syntax-violation '#f '"invalid field spec" l17bf@field)) l17f7@ls/false) (le58@syntax-violation '#f '"invalid syntax" l17f5@t)))))))))))))))))))) l17ba@fields)))) (l175c@enumerate (lambda (l17b1@ls) (let l17b7@f ((l17b3@ls l17b1@ls) (l17b4@i '0)) (if (null? l17b3@ls) '() (cons l17b4@i (l17b7@f (cdr l17b3@ls) (+ l17b4@i '1))))))) (l175e@do-define-record (lambda (l1789@namespec l178a@clause*) (let ((l178d@foo (l1742@get-record-name l1789@namespec))) (let ((l178f@foo-rtd (gensym))) (let ((l1791@foo-rcd (gensym))) (let ((l1793@protocol (gensym))) (let ((l1795@make-foo (l1744@get-record-constructor-name l1789@namespec))) (let ((l1797@fields (l1754@get-fields l178a@clause*))) (let ((l1799@idx* (l175c@enumerate l1797@fields))) (let ((l179b@foo-x* (l175a@get-accessors l178d@foo l1797@fields))) (let ((l179d@set-foo-x!* (l1758@get-mutators l178d@foo l1797@fields))) (let ((l179f@set-foo-idx* (l1756@get-mutator-indices l1797@fields))) (let ((l17a1@foo? (l1746@get-record-predicate-name l1789@namespec))) (let ((l17a3@foo-rtd-code (l174a@foo-rtd-code l178d@foo l178a@clause* (l174c@parent-rtd-code l178a@clause*)))) (let ((l17a5@foo-rcd-code (l1750@foo-rcd-code l178a@clause* l178f@foo-rtd l1793@protocol (l174e@parent-rcd-code l178a@clause*)))) (let ((l17a7@protocol-code (l1752@get-protocol-code l178a@clause*))) (ld2e@bless (cons 'begin (cons (list 'define l178f@foo-rtd l17a3@foo-rtd-code) (cons (list 'define l1793@protocol l17a7@protocol-code) (cons (list 'define l1791@foo-rcd l17a5@foo-rcd-code) (cons (list 'define-syntax l178d@foo (list 'list ''$rtd (list 'syntax l178f@foo-rtd) (list 'syntax l1791@foo-rcd))) (cons (list 'define l17a1@foo? (list 'record-predicate l178f@foo-rtd)) (cons (list 'define l1795@make-foo (list 'record-constructor l1791@foo-rcd)) (append (map (lambda (l17a9@foo-x l17aa@idx) (list 'define l17a9@foo-x (list 'record-accessor l178f@foo-rtd l17aa@idx))) l179b@foo-x* l1799@idx*) (map (lambda (l17ad@set-foo-x! l17ae@idx) (list 'define l17ad@set-foo-x! (list 'record-mutator l178f@foo-rtd l17ae@idx))) l179d@set-foo-x!* l179f@set-foo-idx*)))))))))))))))))))))))))) (l1760@verify-clauses (lambda (l1769@x l176a@cls*) (letrec* ((l176e@valid-kwds (map ld2e@bless '(fields parent parent-rtd protocol sealed opaque nongenerative))) (l1770@free-id-member? (lambda (l1785@x l1786@ls) (and (pair? l1786@ls) (or (lb77@free-id=? l1785@x (car l1786@ls)) (l1770@free-id-member? l1785@x (cdr l1786@ls))))))) (let l1775@f ((l1771@cls* l176a@cls*) (l1772@seen* '())) (if (not (null? l1771@cls*)) (let ((l1777@t (car l1771@cls*))) (let ((l1779@ls/false (ld78@syntax-dispatch l1777@t '(any . any)))) (if l1779@ls/false (apply (lambda (l177b@kwd l177c@rest) (if (or (not (lb71@id? l177b@kwd)) (not (l1770@free-id-member? l177b@kwd l176e@valid-kwds))) (le58@syntax-violation '#f '"not a valid define-record-type keyword" l177b@kwd) (if (lb7d@bound-id-member? l177b@kwd l1772@seen*) (le58@syntax-violation '#f '"duplicate use of keyword " l1769@x l177b@kwd) (l1775@f (cdr l1771@cls*) (cons l177b@kwd l1772@seen*))))) l1779@ls/false) (let ((l177f@t l1777@t)) (let ((l1781@ls/false (ld78@syntax-dispatch l177f@t 'any))) (if l1781@ls/false (apply (lambda (l1783@cls) (le58@syntax-violation '#f '"malformed define-record-type clause" l1783@cls)) l1781@ls/false) (le58@syntax-violation '#f '"invalid syntax" l177f@t))))))) (void))))))) (let ((l1761@t l173d@x)) (let ((l1763@ls/false (ld78@syntax-dispatch l1761@t '(_ any . each-any)))) (if l1763@ls/false (apply (lambda (l1765@namespec l1766@clause*) (begin (l1760@verify-clauses l173d@x l1766@clause*) (l175e@do-define-record l1765@namespec l1766@clause*))) l1763@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1761@t))))))) (set! l2848@ld6c@define-record-type-macro ld6c@define-record-type-macro) (set! ld6e@define-condition-type-macro (lambda (l1939@x) (letrec* ((l193c@mkname (lambda (l1969@name l196a@suffix) (le5c@datum->syntax l1969@name (string->symbol (string-append (symbol->string (le5e@syntax->datum l1969@name)) l196a@suffix)))))) (let ((l193d@t l1939@x)) (let ((l193f@ls/false (ld78@syntax-dispatch l193d@t '(any any any any any . #(each (any any)))))) (if (and l193f@ls/false (apply (lambda (l1941@ctxt l1942@name l1943@super l1944@constructor l1945@predicate l1946@field* l1947@accessor*) (and (lb71@id? l1942@name) (lb71@id? l1943@super) (lb71@id? l1944@constructor) (lb71@id? l1945@predicate) (for-all lb71@id? l1946@field*) (for-all lb71@id? l1947@accessor*))) l193f@ls/false)) (apply (lambda (l194f@ctxt l1950@name l1951@super l1952@constructor l1953@predicate l1954@field* l1955@accessor*) (let ((l195d@aux-accessor* (map (lambda (l195f@x) (gensym)) l1955@accessor*))) (ld2e@bless (cons 'begin (cons (cons 'define-record-type (cons (list l1950@name l1952@constructor (gensym)) (cons (list 'parent l1951@super) (cons (cons 'fields (map (lambda (l1961@field l1962@aux) (list 'immutable l1961@field l1962@aux)) l1954@field* l195d@aux-accessor*)) '((nongenerative) (sealed #f) (opaque #f)))))) (cons (list 'define l1953@predicate (list 'condition-predicate (list 'record-type-descriptor l1950@name))) (map (lambda (l1965@accessor l1966@aux) (list 'define l1965@accessor (list 'condition-accessor (list 'record-type-descriptor l1950@name) l1966@aux))) l1955@accessor* l195d@aux-accessor*))))))) l193f@ls/false) (le58@syntax-violation '#f '"invalid syntax" l193d@t))))))) (set! l2849@ld6e@define-condition-type-macro ld6e@define-condition-type-macro) (set! ld70@incorrect-usage-macro (lambda (l196d@e) (le58@syntax-violation '#f '"incorrect usage of auxiliary keyword" l196d@e))) (set! l284a@ld70@incorrect-usage-macro ld70@incorrect-usage-macro) (set! ld72@parameterize-macro (lambda (l196f@e) (let ((l1971@t l196f@e)) (let ((l1973@ls/false (ld78@syntax-dispatch l1971@t '(_ () any . each-any)))) (if l1973@ls/false (apply (lambda (l1975@b l1976@b*) (ld2e@bless (cons 'let (cons '() (cons l1975@b l1976@b*))))) l1973@ls/false) (let ((l1979@t l1971@t)) (let ((l197b@ls/false (ld78@syntax-dispatch l1979@t '(_ #(each (any any)) any . each-any)))) (if l197b@ls/false (apply (lambda (l197d@olhs* l197e@orhs* l197f@b l1980@b*) (let ((l1985@lhs* (le46@generate-temporaries l197d@olhs*)) (l1986@rhs* (le46@generate-temporaries l197e@orhs*))) (ld2e@bless (cons (list 'lambda (append l1985@lhs* l1986@rhs*) (list 'let (list (list 'swap (cons 'lambda (cons '() (map (lambda (l1989@lhs l198a@rhs) (list 'let (list (list 't (list l1989@lhs))) (list l1989@lhs l198a@rhs) (cons 'set! (cons l198a@rhs '(t))))) l1985@lhs* l1986@rhs*))))) (cons 'dynamic-wind (cons 'swap (cons (cons 'lambda (cons '() (cons l197f@b l1980@b*))) '(swap)))))) (append l197d@olhs* l197e@orhs*))))) l197b@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1979@t))))))))) (set! l284b@ld72@parameterize-macro ld72@parameterize-macro) (set! ld74@foreign-call-transformer (lambda (l198d@e l198e@r l198f@mr) (let ((l1993@t l198d@e)) (let ((l1995@ls/false (ld78@syntax-dispatch l1993@t '(_ any . each-any)))) (if l1995@ls/false (apply (lambda (l1997@name l1998@arg*) (cons 'foreign-call (cons (ld9a@chi-expr l1997@name l198e@r l198f@mr) (ld96@chi-expr* l1998@arg* l198e@r l198f@mr)))) l1995@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1993@t)))))) (set! l284c@ld74@foreign-call-transformer ld74@foreign-call-transformer) (set! ld76@convert-pattern (lambda (l199b@pattern l199c@keys) (letrec* ((l19a0@cvt* (lambda (l1a3f@p* l1a40@n l1a41@ids) (if (null? l1a3f@p*) (values '() l1a41@ids) (call-with-values (lambda () (l19a0@cvt* (cdr l1a3f@p*) l1a40@n l1a41@ids)) (lambda (l1a49@l1a46 l1a4a@l1a48) (let ((l1a4d@ids l1a4a@l1a48) (l1a4e@y l1a49@l1a46)) (call-with-values (lambda () (l19a2@cvt (car l1a3f@p*) l1a40@n l1a4d@ids)) (lambda (l1a55@l1a52 l1a56@l1a54) (let ((l1a59@ids l1a56@l1a54) (l1a5a@x l1a55@l1a52)) (values (cons l1a5a@x l1a4e@y) l1a59@ids)))))))))) (l19a2@cvt (lambda (l19a3@p l19a4@n l19a5@ids) (let ((l19a9@t l19a3@p)) (let ((l19ab@ls/false (ld78@syntax-dispatch l19a9@t 'any))) (if (and l19ab@ls/false (apply (lambda (l19ad@id) (lb71@id? l19ad@id)) l19ab@ls/false)) (apply (lambda (l19af@id) (if (lb7d@bound-id-member? l19a3@p l199c@keys) (values (vector 'free-id l19a3@p) l19a5@ids) (if (lb77@free-id=? l19a3@p (ld00@scheme-stx '_)) (values '_ l19a5@ids) (values 'any (cons (cons l19a3@p l19a4@n) l19a5@ids))))) l19ab@ls/false) (let ((l19b1@t l19a9@t)) (let ((l19b3@ls/false (ld78@syntax-dispatch l19b1@t '(any any)))) (if (and l19b3@ls/false (apply (lambda (l19b5@p l19b6@dots) (ld7a@ellipsis? l19b6@dots)) l19b3@ls/false)) (apply (lambda (l19b9@p l19ba@dots) (call-with-values (lambda () (l19a2@cvt l19b9@p (+ l19a4@n '1) l19a5@ids)) (lambda (l19c1@l19be l19c2@l19c0) (let ((l19c5@ids l19c2@l19c0) (l19c6@p l19c1@l19be)) (values (if (eq? l19c6@p 'any) 'each-any (vector 'each l19c6@p)) l19c5@ids))))) l19b3@ls/false) (let ((l19c9@t l19b1@t)) (let ((l19cb@ls/false (ld78@syntax-dispatch l19c9@t '(any any . #(each+ any () any))))) (if (and l19cb@ls/false (apply (lambda (l19cd@x l19ce@dots l19cf@ys l19d0@z) (ld7a@ellipsis? l19ce@dots)) l19cb@ls/false)) (apply (lambda (l19d5@x l19d6@dots l19d7@ys l19d8@z) (call-with-values (lambda () (l19a2@cvt l19d8@z l19a4@n l19a5@ids)) (lambda (l19e1@l19de l19e2@l19e0) (let ((l19e5@ids l19e2@l19e0) (l19e6@z l19e1@l19de)) (call-with-values (lambda () (l19a0@cvt* l19d7@ys l19a4@n l19e5@ids)) (lambda (l19ed@l19ea l19ee@l19ec) (let ((l19f1@ids l19ee@l19ec) (l19f2@ys l19ed@l19ea)) (call-with-values (lambda () (l19a2@cvt l19d5@x (+ l19a4@n '1) l19f1@ids)) (lambda (l19f9@l19f6 l19fa@l19f8) (let ((l19fd@ids l19fa@l19f8) (l19fe@x l19f9@l19f6)) (values (vector 'each+ l19fe@x (reverse l19f2@ys) l19e6@z) l19fd@ids))))))))))) l19cb@ls/false) (let ((l1a01@t l19c9@t)) (let ((l1a03@ls/false (ld78@syntax-dispatch l1a01@t '(any . any)))) (if l1a03@ls/false (apply (lambda (l1a05@x l1a06@y) (call-with-values (lambda () (l19a2@cvt l1a06@y l19a4@n l19a5@ids)) (lambda (l1a0d@l1a0a l1a0e@l1a0c) (let ((l1a11@ids l1a0e@l1a0c) (l1a12@y l1a0d@l1a0a)) (call-with-values (lambda () (l19a2@cvt l1a05@x l19a4@n l1a11@ids)) (lambda (l1a19@l1a16 l1a1a@l1a18) (let ((l1a1d@ids l1a1a@l1a18) (l1a1e@x l1a19@l1a16)) (values (cons l1a1e@x l1a12@y) l1a1d@ids)))))))) l1a03@ls/false) (let ((l1a21@t l1a01@t)) (let ((l1a23@ls/false (ld78@syntax-dispatch l1a21@t '()))) (if l1a23@ls/false (apply (lambda () (values '() l19a5@ids)) l1a23@ls/false) (let ((l1a25@t l1a21@t)) (let ((l1a27@ls/false (ld78@syntax-dispatch l1a25@t '#(vector each-any)))) (if (and l1a27@ls/false (apply (lambda (l1a29@p) (not (lb3d@stx? l1a29@p))) l1a27@ls/false)) (apply (lambda (l1a2b@p) (call-with-values (lambda () (l19a2@cvt l1a2b@p l19a4@n l19a5@ids)) (lambda (l1a31@l1a2e l1a32@l1a30) (let ((l1a35@ids l1a32@l1a30) (l1a36@p l1a31@l1a2e)) (values (vector 'vector l1a36@p) l1a35@ids))))) l1a27@ls/false) (let ((l1a39@t l1a25@t)) (let ((l1a3b@ls/false (ld78@syntax-dispatch l1a39@t 'any))) (if l1a3b@ls/false (apply (lambda (l1a3d@datum) (values (vector 'atom (lb85@stx->datum l1a3d@datum)) l19a5@ids)) l1a3b@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1a39@t))))))))))))))))))))))))) (l19a2@cvt l199b@pattern '0 '())))) (set! l284d@ld76@convert-pattern ld76@convert-pattern) (set! ld78@syntax-dispatch (letrec* ((l1a5e@stx^ (lambda (l1b39@e l1b3a@m* l1b3b@s* l1b3c@ae*) (if (and (null? l1b3a@m*) (null? l1b3b@s*) (null? l1b3c@ae*)) l1b39@e (lb59@mkstx l1b39@e l1b3a@m* l1b3b@s* l1b3c@ae*)))) (l1a60@match-each (lambda (l1b19@e l1b1a@p l1b1b@m* l1b1c@s* l1b1d@ae*) (if (pair? l1b19@e) (let ((l1b23@first (l1a6c@match (car l1b19@e) l1b1a@p l1b1b@m* l1b1c@s* l1b1d@ae* '()))) (and l1b23@first (let ((l1b25@rest (l1a60@match-each (cdr l1b19@e) l1b1a@p l1b1b@m* l1b1c@s* l1b1d@ae*))) (and l1b25@rest (cons l1b23@first l1b25@rest))))) (if (null? l1b19@e) '() (if (lb3d@stx? l1b19@e) (and (not (laf7@top-marked? l1b1b@m*)) (call-with-values (lambda () (join-wraps l1b1b@m* l1b1c@s* l1b1d@ae* l1b19@e)) (lambda (l1b2d@l1b28 l1b2e@l1b2a l1b2f@l1b2c) (let ((l1b33@ae* l1b2f@l1b2c) (l1b34@s* l1b2e@l1b2a) (l1b35@m* l1b2d@l1b28)) (l1a60@match-each (lb3f@stx-expr l1b19@e) l1b1a@p l1b35@m* l1b34@s* l1b33@ae*))))) (if (l6b5@l587@annotation? l1b19@e) (l1a60@match-each (l6b7@l58b@annotation-expression l1b19@e) l1b1a@p l1b1b@m* l1b1c@s* l1b1d@ae*) '#f)))))) (l1a62@match-each+ (lambda (l1ad9@e l1ada@x-pat l1adb@y-pat l1adc@z-pat l1add@m* l1ade@s* l1adf@ae* l1ae0@r) (let l1af1@f ((l1ae9@e l1ad9@e) (l1aea@m* l1add@m*) (l1aeb@s* l1ade@s*) (l1aec@ae* l1adf@ae*)) (if (pair? l1ae9@e) (call-with-values (lambda () (l1af1@f (cdr l1ae9@e) l1aea@m* l1aeb@s* l1aec@ae*)) (lambda (l1af9@l1af4 l1afa@l1af6 l1afb@l1af8) (let ((l1aff@r l1afb@l1af8) (l1b00@y-pat l1afa@l1af6) (l1b01@xr* l1af9@l1af4)) (if l1aff@r (if (null? l1b00@y-pat) (let ((l1b05@xr (l1a6c@match (car l1ae9@e) l1ada@x-pat l1aea@m* l1aeb@s* l1aec@ae* '()))) (if l1b05@xr (values (cons l1b05@xr l1b01@xr*) l1b00@y-pat l1aff@r) (values '#f '#f '#f))) (values '() (cdr l1b00@y-pat) (l1a6c@match (car l1ae9@e) (car l1b00@y-pat) l1aea@m* l1aeb@s* l1aec@ae* l1aff@r))) (values '#f '#f '#f))))) (if (lb3d@stx? l1ae9@e) (if (laf7@top-marked? l1aea@m*) (values '() l1adb@y-pat (l1a6c@match l1ae9@e l1adc@z-pat l1aea@m* l1aeb@s* l1aec@ae* l1ae0@r)) (call-with-values (lambda () (join-wraps l1aea@m* l1aeb@s* l1aec@ae* l1ae9@e)) (lambda (l1b0d@l1b08 l1b0e@l1b0a l1b0f@l1b0c) (let ((l1b13@ae* l1b0f@l1b0c) (l1b14@s* l1b0e@l1b0a) (l1b15@m* l1b0d@l1b08)) (l1af1@f (lb3f@stx-expr l1ae9@e) l1b15@m* l1b14@s* l1b13@ae*))))) (if (l6b5@l587@annotation? l1ae9@e) (l1af1@f (l6b7@l58b@annotation-expression l1ae9@e) l1aea@m* l1aeb@s* l1aec@ae*) (values '() l1adb@y-pat (l1a6c@match l1ae9@e l1adc@z-pat l1aea@m* l1aeb@s* l1aec@ae* l1ae0@r)))))))) (l1a64@match-each-any (lambda (l1abd@e l1abe@m* l1abf@s* l1ac0@ae*) (if (pair? l1abd@e) (let ((l1ac5@l (l1a64@match-each-any (cdr l1abd@e) l1abe@m* l1abf@s* l1ac0@ae*))) (and l1ac5@l (cons (l1a5e@stx^ (car l1abd@e) l1abe@m* l1abf@s* l1ac0@ae*) l1ac5@l))) (if (null? l1abd@e) '() (if (lb3d@stx? l1abd@e) (and (not (laf7@top-marked? l1abe@m*)) (call-with-values (lambda () (join-wraps l1abe@m* l1abf@s* l1ac0@ae* l1abd@e)) (lambda (l1acd@l1ac8 l1ace@l1aca l1acf@l1acc) (let ((l1ad3@ae* l1acf@l1acc) (l1ad4@s* l1ace@l1aca) (l1ad5@m* l1acd@l1ac8)) (l1a64@match-each-any (lb3f@stx-expr l1abd@e) l1ad5@m* l1ad4@s* l1ad3@ae*))))) (if (l6b5@l587@annotation? l1abd@e) (l1a64@match-each-any (l6b7@l58b@annotation-expression l1abd@e) l1abe@m* l1abf@s* l1ac0@ae*) '#f)))))) (l1a66@match-empty (lambda (l1ab7@p l1ab8@r) (if (null? l1ab7@p) l1ab8@r (if (eq? l1ab7@p '_) l1ab8@r (if (eq? l1ab7@p 'any) (cons '() l1ab8@r) (if (pair? l1ab7@p) (l1a66@match-empty (car l1ab7@p) (l1a66@match-empty (cdr l1ab7@p) l1ab8@r)) (if (eq? l1ab7@p 'each-any) (cons '() l1ab8@r) (let ((l1abb@t (vector-ref l1ab7@p '0))) (if (memv l1abb@t '(each)) (l1a66@match-empty (vector-ref l1ab7@p '1) l1ab8@r) (if (memv l1abb@t '(each+)) (l1a66@match-empty (vector-ref l1ab7@p '1) (l1a66@match-empty (reverse (vector-ref l1ab7@p '2)) (l1a66@match-empty (vector-ref l1ab7@p '3) l1ab8@r))) (if (memv l1abb@t '(free-id atom)) l1ab8@r (if (memv l1abb@t '(scheme-id atom)) l1ab8@r (if (memv l1abb@t '(vector)) (l1a66@match-empty (vector-ref l1ab7@p '1) l1ab8@r) (assertion-violation 'syntax-dispatch '"invalid pattern" l1ab7@p)))))))))))))) (l1a68@combine (lambda (l1ab3@r* l1ab4@r) (if (null? (car l1ab3@r*)) l1ab4@r (cons (map car l1ab3@r*) (l1a68@combine (map cdr l1ab3@r*) l1ab4@r))))) (l1a6a@match* (lambda (l1a8f@e l1a90@p l1a91@m* l1a92@s* l1a93@ae* l1a94@r) (if (null? l1a90@p) (and (null? l1a8f@e) l1a94@r) (if (pair? l1a90@p) (and (pair? l1a8f@e) (l1a6c@match (car l1a8f@e) (car l1a90@p) l1a91@m* l1a92@s* l1a93@ae* (l1a6c@match (cdr l1a8f@e) (cdr l1a90@p) l1a91@m* l1a92@s* l1a93@ae* l1a94@r))) (if (eq? l1a90@p 'each-any) (let ((l1a9b@l (l1a64@match-each-any l1a8f@e l1a91@m* l1a92@s* l1a93@ae*))) (and l1a9b@l (cons l1a9b@l l1a94@r))) (let ((l1a9d@t (vector-ref l1a90@p '0))) (if (memv l1a9d@t '(each)) (if (null? l1a8f@e) (l1a66@match-empty (vector-ref l1a90@p '1) l1a94@r) (let ((l1a9f@r* (l1a60@match-each l1a8f@e (vector-ref l1a90@p '1) l1a91@m* l1a92@s* l1a93@ae*))) (and l1a9f@r* (l1a68@combine l1a9f@r* l1a94@r)))) (if (memv l1a9d@t '(free-id)) (and (symbol? l1a8f@e) (laf7@top-marked? l1a91@m*) (lb77@free-id=? (l1a5e@stx^ l1a8f@e l1a91@m* l1a92@s* l1a93@ae*) (vector-ref l1a90@p '1)) l1a94@r) (if (memv l1a9d@t '(scheme-id)) (and (symbol? l1a8f@e) (laf7@top-marked? l1a91@m*) (lb77@free-id=? (l1a5e@stx^ l1a8f@e l1a91@m* l1a92@s* l1a93@ae*) (ld00@scheme-stx (vector-ref l1a90@p '1))) l1a94@r) (if (memv l1a9d@t '(each+)) (call-with-values (lambda () (l1a62@match-each+ l1a8f@e (vector-ref l1a90@p '1) (vector-ref l1a90@p '2) (vector-ref l1a90@p '3) l1a91@m* l1a92@s* l1a93@ae* l1a94@r)) (lambda (l1aa7@l1aa2 l1aa8@l1aa4 l1aa9@l1aa6) (let ((l1aad@r l1aa9@l1aa6) (l1aae@y-pat l1aa8@l1aa4) (l1aaf@xr* l1aa7@l1aa2)) (and l1aad@r (null? l1aae@y-pat) (if (null? l1aaf@xr*) (l1a66@match-empty (vector-ref l1a90@p '1) l1aad@r) (l1a68@combine l1aaf@xr* l1aad@r)))))) (if (memv l1a9d@t '(atom)) (and (fast-equal? (vector-ref l1a90@p '1) (lb83@strip l1a8f@e l1a91@m*)) l1a94@r) (if (memv l1a9d@t '(vector)) (and (vector? l1a8f@e) (l1a6c@match (vector->list l1a8f@e) (vector-ref l1a90@p '1) l1a91@m* l1a92@s* l1a93@ae* l1a94@r)) (assertion-violation 'syntax-dispatch '"invalid pattern" l1a90@p))))))))))))) (l1a6c@match (lambda (l1a71@e l1a72@p l1a73@m* l1a74@s* l1a75@ae* l1a76@r) (if (not l1a76@r) '#f (if (eq? l1a72@p '_) l1a76@r (if (eq? l1a72@p 'any) (cons (l1a5e@stx^ l1a71@e l1a73@m* l1a74@s* l1a75@ae*) l1a76@r) (if (lb3d@stx? l1a71@e) (and (not (laf7@top-marked? l1a73@m*)) (call-with-values (lambda () (join-wraps l1a73@m* l1a74@s* l1a75@ae* l1a71@e)) (lambda (l1a83@l1a7e l1a84@l1a80 l1a85@l1a82) (let ((l1a89@ae* l1a85@l1a82) (l1a8a@s* l1a84@l1a80) (l1a8b@m* l1a83@l1a7e)) (l1a6c@match (lb3f@stx-expr l1a71@e) l1a72@p l1a8b@m* l1a8a@s* l1a89@ae* l1a76@r))))) (if (l6b5@l587@annotation? l1a71@e) (l1a6c@match (l6b7@l58b@annotation-expression l1a71@e) l1a72@p l1a73@m* l1a74@s* l1a75@ae* l1a76@r) (l1a6a@match* l1a71@e l1a72@p l1a73@m* l1a74@s* l1a75@ae* l1a76@r))))))))) (lambda (l1a6d@e l1a6e@p) (l1a6c@match l1a6d@e l1a6e@p '() '() '() '())))) (set! l284e@ld78@syntax-dispatch ld78@syntax-dispatch) (set! ld7a@ellipsis? (lambda (l1b41@x) (and (lb71@id? l1b41@x) (lb77@free-id=? l1b41@x (ld00@scheme-stx '...))))) (set! l284f@ld7a@ellipsis? ld7a@ellipsis?) (set! ld7c@underscore? (lambda (l1b43@x) (and (lb71@id? l1b43@x) (lb77@free-id=? l1b43@x (ld00@scheme-stx '_))))) (set! l2850@ld7c@underscore? ld7c@underscore?) (set! ld7e@verify-literals (lambda (l1b45@lits l1b46@expr) (for-each (lambda (l1b49@x) (if (or (not (lb71@id? l1b49@x)) (ld7a@ellipsis? l1b49@x) (ld7c@underscore? l1b49@x)) (le58@syntax-violation '#f '"invalid literal" l1b46@expr l1b49@x) (void))) l1b45@lits))) (set! l2851@ld7e@verify-literals ld7e@verify-literals) (set! ld80@syntax-case-transformer (letrec* ((l1b4c@build-dispatch-call (lambda (l1bbd@pvars l1bbe@expr l1bbf@y l1bc0@r l1bc1@mr) (let ((l1bc7@ids (map car l1bbd@pvars)) (l1bc8@levels (map cdr l1bbd@pvars))) (let ((l1bcb@labels (map lafd@gen-label l1bc7@ids)) (l1bcc@new-vars (map laf9@gen-lexical l1bc7@ids))) (let ((l1bcf@body (ld9a@chi-expr (lb5d@add-subst (lb31@make-full-rib l1bc7@ids l1bcb@labels) l1bbe@expr) (append (map (lambda (l1bd1@label l1bd2@var l1bd3@level) (cons l1bd1@label (lb8b@make-binding 'syntax (cons l1bd2@var l1bd3@level)))) l1bcb@labels l1bcc@new-vars (map cdr l1bbd@pvars)) l1bc0@r) l1bc1@mr))) (list '(primitive apply) (lad4@la06@build-lambda '#f l1bcc@new-vars l1bcf@body) l1bbf@y)))))) (l1b4e@invalid-ids-error (lambda (l1bb1@id* l1bb2@e l1bb3@class) (let l1bbb@find ((l1bb7@id* l1bb1@id*) (l1bb8@ok* '())) (if (null? l1bb7@id*) (le58@syntax-violation '#f '"invalid syntax" l1bb2@e) (if (lb71@id? (car l1bb7@id*)) (if (lb7d@bound-id-member? (car l1bb7@id*) l1bb8@ok*) (le54@syntax-error (car l1bb7@id*) '"duplicate " l1bb3@class) (l1bbb@find (cdr l1bb7@id*) (cons (car l1bb7@id*) l1bb8@ok*))) (le54@syntax-error (car l1bb7@id*) '"invalid " l1bb3@class)))))) (l1b50@gen-clause (lambda (l1b89@x l1b8a@keys l1b8b@clauses l1b8c@r l1b8d@mr l1b8e@pat l1b8f@fender l1b90@expr) (call-with-values (lambda () (ld76@convert-pattern l1b8e@pat l1b8a@keys)) (lambda (l1b9d@l1b9a l1b9e@l1b9c) (let ((l1ba1@pvars l1b9e@l1b9c) (l1ba2@p l1b9d@l1b9a)) (if (not (lb7b@distinct-bound-ids? (map car l1ba1@pvars))) (l1b4e@invalid-ids-error (map car l1ba1@pvars) l1b8e@pat '"pattern variable") (if (not (for-all (lambda (l1ba5@x) (not (ld7a@ellipsis? (car l1ba5@x)))) l1ba1@pvars)) (le58@syntax-violation '#f '"misplaced ellipsis in syntax-case pattern" l1b8e@pat) (let ((l1ba7@y (laf9@gen-lexical 'tmp))) (let ((l1ba9@test (if (eq? l1b8f@fender '#t) l1ba7@y (let ((l1bab@call (l1b4c@build-dispatch-call l1ba1@pvars l1b8f@fender l1ba7@y l1b8c@r l1b8d@mr))) (list 'if l1ba7@y l1bab@call (list 'quote '#f)))))) (let ((l1bad@conseq (l1b4c@build-dispatch-call l1ba1@pvars l1b90@expr l1ba7@y l1b8c@r l1b8d@mr))) (let ((l1baf@altern (l1b52@gen-syntax-case l1b89@x l1b8a@keys l1b8b@clauses l1b8c@r l1b8d@mr))) (list (lad4@la06@build-lambda '#f (list l1ba7@y) (list 'if l1ba9@test l1bad@conseq l1baf@altern)) (list '(primitive syntax-dispatch) l1b89@x (list 'quote l1ba2@p)))))))))))))) (l1b52@gen-syntax-case (lambda (l1b67@x l1b68@keys l1b69@clauses l1b6a@r l1b6b@mr) (if (null? l1b69@clauses) (list '(primitive syntax-error) l1b67@x) (let ((l1b71@t (car l1b69@clauses))) (let ((l1b73@ls/false (ld78@syntax-dispatch l1b71@t '(any any)))) (if l1b73@ls/false (apply (lambda (l1b75@pat l1b76@expr) (if (and (lb71@id? l1b75@pat) (not (lb7d@bound-id-member? l1b75@pat l1b68@keys)) (not (ld7a@ellipsis? l1b75@pat))) (if (lb77@free-id=? l1b75@pat (ld00@scheme-stx '_)) (ld9a@chi-expr l1b76@expr l1b6a@r l1b6b@mr) (let ((l1b79@lab (lafd@gen-label l1b75@pat)) (l1b7a@lex (laf9@gen-lexical l1b75@pat))) (let ((l1b7d@body (ld9a@chi-expr (lb5d@add-subst (lb31@make-full-rib (list l1b75@pat) (list l1b79@lab)) l1b76@expr) (cons (cons l1b79@lab (lb8b@make-binding 'syntax (cons l1b7a@lex '0))) l1b6a@r) l1b6b@mr))) (list (lad4@la06@build-lambda '#f (list l1b7a@lex) l1b7d@body) l1b67@x)))) (l1b50@gen-clause l1b67@x l1b68@keys (cdr l1b69@clauses) l1b6a@r l1b6b@mr l1b75@pat '#t l1b76@expr))) l1b73@ls/false) (let ((l1b7f@t l1b71@t)) (let ((l1b81@ls/false (ld78@syntax-dispatch l1b7f@t '(any any any)))) (if l1b81@ls/false (apply (lambda (l1b83@pat l1b84@fender l1b85@expr) (l1b50@gen-clause l1b67@x l1b68@keys (cdr l1b69@clauses) l1b6a@r l1b6b@mr l1b83@pat l1b84@fender l1b85@expr)) l1b81@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1b7f@t))))))))))) (lambda (l1b53@e l1b54@r l1b55@mr) (let ((l1b59@t l1b53@e)) (let ((l1b5b@ls/false (ld78@syntax-dispatch l1b59@t '(_ any each-any . each-any)))) (if l1b5b@ls/false (apply (lambda (l1b5d@expr l1b5e@keys l1b5f@clauses) (begin (ld7e@verify-literals l1b5e@keys l1b53@e) (let ((l1b63@x (laf9@gen-lexical 'tmp))) (let ((l1b65@body (l1b52@gen-syntax-case l1b63@x l1b5e@keys l1b5f@clauses l1b54@r l1b55@mr))) (list (lad4@la06@build-lambda '#f (list l1b63@x) l1b65@body) (ld9a@chi-expr l1b5d@expr l1b54@r l1b55@mr)))))) l1b5b@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1b59@t))))))) (set! l2852@ld80@syntax-case-transformer ld80@syntax-case-transformer) (set! ld82@ellipsis-map (lambda (l1bd7@proc l1bd8@ls . l1bdb@ls*) (letrec* ((l1bde@who '...)) (begin (if (not (list? l1bd8@ls)) (assertion-violation l1bde@who '"not a list" l1bd8@ls) (void)) (if (not (null? l1bdb@ls*)) (let ((l1bdf@n (length l1bd8@ls))) (for-each (lambda (l1be1@x) (begin (if (not (list? l1be1@x)) (assertion-violation l1bde@who '"not a list" l1be1@x) (void)) (if (not (= (length l1be1@x) l1bdf@n)) (assertion-violation l1bde@who '"length mismatch" l1bd8@ls l1be1@x) (void)))) l1bdb@ls*)) (void)) (apply map l1bd7@proc l1bd8@ls l1bdb@ls*))))) (set! l2853@ld82@ellipsis-map ld82@ellipsis-map) (set! ld84@syntax-transformer (letrec* ((l1be4@gen-syntax (lambda (l1c5b@src l1c5c@e l1c5d@r l1c5e@maps l1c5f@ellipsis? l1c60@vec?) (let ((l1c67@t l1c5c@e)) (let ((l1c69@ls/false (ld78@syntax-dispatch l1c67@t 'any))) (if (and l1c69@ls/false (apply (lambda (l1c6b@dots) (l1c5f@ellipsis? l1c6b@dots)) l1c69@ls/false)) (apply (lambda (l1c6d@dots) (le58@syntax-violation '#f '"misplaced ellipsis in syntax form" l1c5b@src)) l1c69@ls/false) (let ((l1c6f@t l1c67@t)) (let ((l1c71@ls/false (ld78@syntax-dispatch l1c6f@t 'any))) (if (and l1c71@ls/false (apply (lambda (l1c73@id) (lb71@id? l1c73@id)) l1c71@ls/false)) (apply (lambda (l1c75@id) (let ((l1c77@label (lb87@id->label l1c5c@e))) (let ((l1c79@b (lb89@label->binding l1c77@label l1c5d@r))) (if (eq? (lb8d@binding-type l1c79@b) 'syntax) (call-with-values (lambda () (let ((l1c7f@var.lev (lb8f@binding-value l1c79@b))) (l1be6@gen-ref l1c5b@src (car l1c7f@var.lev) (cdr l1c7f@var.lev) l1c5e@maps))) (lambda (l1c81@l1c7c l1c82@l1c7e) (let ((l1c85@maps l1c82@l1c7e) (l1c86@var l1c81@l1c7c)) (values (list 'ref l1c86@var) l1c85@maps)))) (values (list 'quote l1c5c@e) l1c5e@maps))))) l1c71@ls/false) (let ((l1c89@t l1c6f@t)) (let ((l1c8b@ls/false (ld78@syntax-dispatch l1c89@t '(any any)))) (if (and l1c8b@ls/false (apply (lambda (l1c8d@dots l1c8e@e) (l1c5f@ellipsis? l1c8d@dots)) l1c8b@ls/false)) (apply (lambda (l1c91@dots l1c92@e) (if l1c60@vec? (le58@syntax-violation '#f '"misplaced ellipsis in syntax form" l1c5b@src) (l1be4@gen-syntax l1c5b@src l1c92@e l1c5d@r l1c5e@maps (lambda (l1c95@x) '#f) '#f))) l1c8b@ls/false) (let ((l1c97@t l1c89@t)) (let ((l1c99@ls/false (ld78@syntax-dispatch l1c97@t '(any any . any)))) (if (and l1c99@ls/false (apply (lambda (l1c9b@x l1c9c@dots l1c9d@y) (l1c5f@ellipsis? l1c9c@dots)) l1c99@ls/false)) (apply (lambda (l1ca1@x l1ca2@dots l1ca3@y) (let l1cb9@f ((l1ca7@y l1ca3@y) (l1ca8@k (lambda (l1cab@maps) (call-with-values (lambda () (l1be4@gen-syntax l1c5b@src l1ca1@x l1c5d@r (cons '() l1cab@maps) l1c5f@ellipsis? '#f)) (lambda (l1cb1@l1cae l1cb2@l1cb0) (let ((l1cb5@maps l1cb2@l1cb0) (l1cb6@x l1cb1@l1cae)) (if (null? (car l1cb5@maps)) (le58@syntax-violation '#f '"extra ellipsis in syntax form" l1c5b@src) (values (l1bec@gen-map l1cb6@x (car l1cb5@maps)) (cdr l1cb5@maps))))))))) (let ((l1cbb@t l1ca7@y)) (let ((l1cbd@ls/false (ld78@syntax-dispatch l1cbb@t '()))) (if l1cbd@ls/false (apply (lambda () (l1ca8@k l1c5e@maps)) l1cbd@ls/false) (let ((l1cbf@t l1cbb@t)) (let ((l1cc1@ls/false (ld78@syntax-dispatch l1cbf@t '(any . any)))) (if (and l1cc1@ls/false (apply (lambda (l1cc3@dots l1cc4@y) (l1c5f@ellipsis? l1cc3@dots)) l1cc1@ls/false)) (apply (lambda (l1cc7@dots l1cc8@y) (l1cb9@f l1cc8@y (lambda (l1ccb@maps) (call-with-values (lambda () (l1ca8@k (cons '() l1ccb@maps))) (lambda (l1cd1@l1cce l1cd2@l1cd0) (let ((l1cd5@maps l1cd2@l1cd0) (l1cd6@x l1cd1@l1cce)) (if (null? (car l1cd5@maps)) (le58@syntax-violation '#f '"extra ellipsis in syntax form" l1c5b@src) (values (l1bea@gen-mappend l1cd6@x (car l1cd5@maps)) (cdr l1cd5@maps))))))))) l1cc1@ls/false) (let ((l1cd9@t l1cbf@t)) (let ((l1cdb@ls/false (ld78@syntax-dispatch l1cd9@t '_))) (if l1cdb@ls/false (apply (lambda () (call-with-values (lambda () (l1be4@gen-syntax l1c5b@src l1ca7@y l1c5d@r l1c5e@maps l1c5f@ellipsis? l1c60@vec?)) (lambda (l1ce1@l1cde l1ce2@l1ce0) (let ((l1ce5@maps l1ce2@l1ce0) (l1ce6@y l1ce1@l1cde)) (call-with-values (lambda () (l1ca8@k l1ce5@maps)) (lambda (l1ced@l1cea l1cee@l1cec) (let ((l1cf1@maps l1cee@l1cec) (l1cf2@x l1ced@l1cea)) (values (l1be8@gen-append l1cf2@x l1ce6@y) l1cf1@maps)))))))) l1cdb@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1cd9@t)))))))))))) l1c99@ls/false) (let ((l1cf5@t l1c97@t)) (let ((l1cf7@ls/false (ld78@syntax-dispatch l1cf5@t '(any . any)))) (if l1cf7@ls/false (apply (lambda (l1cf9@x l1cfa@y) (call-with-values (lambda () (l1be4@gen-syntax l1c5b@src l1cf9@x l1c5d@r l1c5e@maps l1c5f@ellipsis? '#f)) (lambda (l1d01@l1cfe l1d02@l1d00) (let ((l1d05@maps l1d02@l1d00) (l1d06@xnew l1d01@l1cfe)) (call-with-values (lambda () (l1be4@gen-syntax l1c5b@src l1cfa@y l1c5d@r l1d05@maps l1c5f@ellipsis? l1c60@vec?)) (lambda (l1d0d@l1d0a l1d0e@l1d0c) (let ((l1d11@maps l1d0e@l1d0c) (l1d12@ynew l1d0d@l1d0a)) (values (l1bee@gen-cons l1c5c@e l1cf9@x l1cfa@y l1d06@xnew l1d12@ynew) l1d11@maps)))))))) l1cf7@ls/false) (let ((l1d15@t l1cf5@t)) (let ((l1d17@ls/false (ld78@syntax-dispatch l1d15@t '#(vector each-any)))) (if l1d17@ls/false (apply (lambda (l1d19@ls) (call-with-values (lambda () (l1be4@gen-syntax l1c5b@src l1d19@ls l1c5d@r l1c5e@maps l1c5f@ellipsis? '#t)) (lambda (l1d1f@l1d1c l1d20@l1d1e) (let ((l1d23@maps l1d20@l1d1e) (l1d24@lsnew l1d1f@l1d1c)) (values (l1bf0@gen-vector l1c5c@e l1d19@ls l1d24@lsnew) l1d23@maps))))) l1d17@ls/false) (let ((l1d27@t l1d15@t)) (let ((l1d29@ls/false (ld78@syntax-dispatch l1d27@t '_))) (if l1d29@ls/false (apply (lambda () (values (list 'quote l1c5c@e) l1c5e@maps)) l1d29@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1d27@t)))))))))))))))))))))))) (l1be6@gen-ref (lambda (l1c41@src l1c42@var l1c43@level l1c44@maps) (if (= l1c43@level '0) (values l1c42@var l1c44@maps) (if (null? l1c44@maps) (le58@syntax-violation '#f '"missing ellipsis in syntax form" l1c41@src) (call-with-values (lambda () (l1be6@gen-ref l1c41@src l1c42@var (- l1c43@level '1) (cdr l1c44@maps))) (lambda (l1c4d@l1c4a l1c4e@l1c4c) (let ((l1c51@outer-maps l1c4e@l1c4c) (l1c52@outer-var l1c4d@l1c4a)) (let ((l1c55@t (assq l1c52@outer-var (car l1c44@maps)))) (if l1c55@t ((lambda (l1c57@b) (values (cdr l1c57@b) l1c44@maps)) l1c55@t) (let ((l1c59@inner-var (laf9@gen-lexical 'tmp))) (values l1c59@inner-var (cons (cons (cons l1c52@outer-var l1c59@inner-var) (car l1c44@maps)) l1c51@outer-maps)))))))))))) (l1be8@gen-append (lambda (l1c3d@x l1c3e@y) (if (fast-equal? l1c3e@y ''()) l1c3d@x (list 'append l1c3d@x l1c3e@y)))) (l1bea@gen-mappend (lambda (l1c39@e l1c3a@map-env) (list 'apply '(primitive append) (l1bec@gen-map l1c39@e l1c3a@map-env)))) (l1bec@gen-map (lambda (l1c27@e l1c28@map-env) (let ((l1c2b@formals (map cdr l1c28@map-env)) (l1c2c@actuals (map (lambda (l1c2f@x) (list 'ref (car l1c2f@x))) l1c28@map-env))) (if (eq? (car l1c27@e) 'ref) (car l1c2c@actuals) (if (for-all (lambda (l1c31@x) (and (eq? (car l1c31@x) 'ref) (memq (cadr l1c31@x) l1c2b@formals))) (cdr l1c27@e)) (let ((l1c33@args (map (let ((l1c35@r (map cons l1c2b@formals l1c2c@actuals))) (lambda (l1c37@x) (cdr (assq (cadr l1c37@x) l1c35@r)))) (cdr l1c27@e)))) (cons 'map (cons (list 'primitive (car l1c27@e)) l1c33@args))) (cons* 'map (list 'lambda l1c2b@formals l1c27@e) l1c2c@actuals)))))) (l1bee@gen-cons (lambda (l1c17@e l1c18@x l1c19@y l1c1a@xnew l1c1b@ynew) (let ((l1c21@t (car l1c1b@ynew))) (if (memv l1c21@t '(quote)) (if (eq? (car l1c1a@xnew) 'quote) (let ((l1c23@xnew (cadr l1c1a@xnew)) (l1c24@ynew (cadr l1c1b@ynew))) (if (and (eq? l1c23@xnew l1c18@x) (eq? l1c24@ynew l1c19@y)) (list 'quote l1c17@e) (list 'quote (cons l1c23@xnew l1c24@ynew)))) (if (null? (cadr l1c1b@ynew)) (list 'list l1c1a@xnew) (list 'cons l1c1a@xnew l1c1b@ynew))) (if (memv l1c21@t '(list)) (cons 'list (cons l1c1a@xnew (cdr l1c1b@ynew))) (list 'cons l1c1a@xnew l1c1b@ynew)))))) (l1bf0@gen-vector (lambda (l1c11@e l1c12@ls l1c13@lsnew) (if (eq? (car l1c13@lsnew) 'quote) (if (eq? (cadr l1c13@lsnew) l1c12@ls) (list 'quote l1c11@e) (list 'quote (list->vector (cadr l1c13@lsnew)))) (if (eq? (car l1c13@lsnew) 'list) (cons 'vector (cdr l1c13@lsnew)) (list 'list->vector l1c13@lsnew))))) (l1bf2@regen (lambda (l1c0b@x) (let ((l1c0d@t (car l1c0b@x))) (if (memv l1c0d@t '(ref)) (cadr l1c0b@x) (if (memv l1c0d@t '(primitive)) (list 'primitive (cadr l1c0b@x)) (if (memv l1c0d@t '(quote)) (list 'quote (cadr l1c0b@x)) (if (memv l1c0d@t '(lambda)) (lad4@la06@build-lambda '#f (cadr l1c0b@x) (l1bf2@regen (caddr l1c0b@x))) (if (memv l1c0d@t '(map)) (let ((l1c0f@ls (map l1bf2@regen (cdr l1c0b@x)))) (cons '(primitive ellipsis-map) l1c0f@ls)) (cons (list 'primitive (car l1c0b@x)) (map l1bf2@regen (cdr l1c0b@x)))))))))))) (lambda (l1bf3@e l1bf4@r l1bf5@mr) (let ((l1bf9@t l1bf3@e)) (let ((l1bfb@ls/false (ld78@syntax-dispatch l1bf9@t '(_ any)))) (if l1bfb@ls/false (apply (lambda (l1bfd@x) (call-with-values (lambda () (l1be4@gen-syntax l1bf3@e l1bfd@x l1bf4@r '() ld7a@ellipsis? '#f)) (lambda (l1c03@l1c00 l1c04@l1c02) (let ((l1c07@maps l1c04@l1c02) (l1c08@e l1c03@l1c00)) (l1bf2@regen l1c08@e))))) l1bfb@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1bf9@t))))))) (set! l2854@ld84@syntax-transformer ld84@syntax-transformer) (set! ld86@core-macro-transformer (lambda (l1d2b@name) (let ((l1d2d@t l1d2b@name)) (if (memv l1d2d@t '(quote)) ld28@quote-transformer (if (memv l1d2d@t '(lambda)) ld2c@lambda-transformer (if (memv l1d2d@t '(case-lambda)) ld2a@case-lambda-transformer (if (memv l1d2d@t '(letrec)) ld10@letrec-transformer (if (memv l1d2d@t '(letrec*)) ld12@letrec*-transformer (if (memv l1d2d@t '(let)) ld0e@let-transformer (if (memv l1d2d@t '(if)) ld20@if-transformer (if (memv l1d2d@t '(and)) ld22@and-transformer (if (memv l1d2d@t '(or)) ld24@or-transformer (if (memv l1d2d@t '(foreign-call)) ld74@foreign-call-transformer (if (memv l1d2d@t '(syntax-case)) ld80@syntax-case-transformer (if (memv l1d2d@t '(syntax)) ld84@syntax-transformer (if (memv l1d2d@t '(type-descriptor)) ld16@type-descriptor-transformer (if (memv l1d2d@t '(record-type-descriptor)) ld18@record-type-descriptor-transformer (if (memv l1d2d@t '(record-constructor-descriptor)) ld1a@record-constructor-descriptor-transformer (if (memv l1d2d@t '(fluid-let-syntax)) ld14@fluid-let-syntax-transformer (assertion-violation 'macro-transformer '"BUG: cannot find transformer" l1d2b@name)))))))))))))))))))) (set! l2855@ld86@core-macro-transformer ld86@core-macro-transformer) (set! ld88@symbol-macro (lambda (l1d2f@x l1d30@set) (let ((l1d33@t l1d2f@x)) (let ((l1d35@ls/false (ld78@syntax-dispatch l1d33@t '(_ any)))) (if (and l1d35@ls/false (apply (lambda (l1d37@name) (and (lb71@id? l1d37@name) (memq (lb73@id->sym l1d37@name) l1d30@set))) l1d35@ls/false)) (apply (lambda (l1d39@name) (ld2e@bless (list 'quote l1d39@name))) l1d35@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1d33@t)))))) (set! l2856@ld88@symbol-macro ld88@symbol-macro) (set! ld8a@macro-transformer (lambda (l1d3b@x) (if (procedure? l1d3b@x) l1d3b@x (if (symbol? l1d3b@x) (let ((l1d3d@t l1d3b@x)) (if (memv l1d3d@t '(define-record-type)) ld6c@define-record-type-macro (if (memv l1d3d@t '(define-struct)) ld6a@define-struct-macro (if (memv l1d3d@t '(include)) ld60@include-macro (if (memv l1d3d@t '(cond)) ld5c@cond-macro (if (memv l1d3d@t '(let)) ld34@let-macro (if (memv l1d3d@t '(do)) ld54@do-macro (if (memv l1d3d@t '(or)) ld58@or-macro (if (memv l1d3d@t '(and)) ld5a@and-macro (if (memv l1d3d@t '(let*)) ld56@let*-macro (if (memv l1d3d@t '(let-values)) ld36@let-values-macro (if (memv l1d3d@t '(let*-values)) ld38@let*-values-macro (if (memv l1d3d@t '(syntax-rules)) ld64@syntax-rules-macro (if (memv l1d3d@t '(quasiquote)) ld66@quasiquote-macro (if (memv l1d3d@t '(quasisyntax)) ld68@quasisyntax-macro (if (memv l1d3d@t '(with-syntax)) ld30@with-syntax-macro (if (memv l1d3d@t '(when)) ld1c@when-macro (if (memv l1d3d@t '(unless)) ld1e@unless-macro (if (memv l1d3d@t '(case)) ld26@case-macro (if (memv l1d3d@t '(identifier-syntax)) ld52@identifier-syntax-macro (if (memv l1d3d@t '(time)) ld4a@time-macro (if (memv l1d3d@t '(delay)) ld4c@delay-macro (if (memv l1d3d@t '(assert)) ld4e@assert-macro (if (memv l1d3d@t '(endianness)) ld50@endianness-macro (if (memv l1d3d@t '(guard)) ld46@guard-macro (if (memv l1d3d@t '(define-enumeration)) ld48@define-enumeration-macro (if (memv l1d3d@t '(trace-lambda)) ld3a@trace-lambda-macro (if (memv l1d3d@t '(trace-define)) ld3c@trace-define-macro (if (memv l1d3d@t '(trace-define-syntax)) ld3e@trace-define-syntax-macro (if (memv l1d3d@t '(trace-let-syntax)) ld42@trace-let-syntax-macro (if (memv l1d3d@t '(trace-letrec-syntax)) ld44@trace-letrec-syntax-macro (if (memv l1d3d@t '(define-condition-type)) ld6e@define-condition-type-macro (if (memv l1d3d@t '(parameterize)) ld72@parameterize-macro (if (memv l1d3d@t '(include-into)) ld62@include-into-macro (if (memv l1d3d@t '(eol-style)) (lambda (l1d3f@x) (ld88@symbol-macro l1d3f@x '(none lf cr crlf nel crnel ls))) (if (memv l1d3d@t '(error-handling-mode)) (lambda (l1d41@x) (ld88@symbol-macro l1d41@x '(ignore raise replace))) (if (memv l1d3d@t '(buffer-mode)) (lambda (l1d43@x) (ld88@symbol-macro l1d43@x '(none line block))) (if (memv l1d3d@t '(file-options)) laec@file-options-macro (if (memv l1d3d@t '(... => _ else unquote unquote-splicing unsyntax unsyntax-splicing fields mutable immutable parent protocol sealed opaque nongenerative parent-rtd)) ld70@incorrect-usage-macro (error 'macro-transformer '"BUG: invalid macro" l1d3b@x)))))))))))))))))))))))))))))))))))))))) (error 'core-macro-transformer '"BUG: invalid macro" l1d3b@x))))) (set! l2857@ld8a@macro-transformer ld8a@macro-transformer) (set! ld8c@local-macro-transformer (lambda (l1d45@x) (car l1d45@x))) (set! l2858@ld8c@local-macro-transformer ld8c@local-macro-transformer) (set! ld8e@do-macro-call (lambda (l1d47@transformer l1d48@expr) (let ((l1d4b@out (l1d47@transformer (lb5b@add-mark lb55@anti-mark l1d48@expr '#f)))) (begin (let l1d4f@f ((l1d4d@x l1d4b@out)) (if (not (lb3d@stx? l1d4d@x)) (if (pair? l1d4d@x) (begin (l1d4f@f (car l1d4d@x)) (l1d4f@f (cdr l1d4d@x))) (if (vector? l1d4d@x) (vector-for-each l1d4f@f l1d4d@x) (if (symbol? l1d4d@x) (le58@syntax-violation '#f '"raw symbol encountered in output of macro" l1d48@expr l1d4d@x) (void)))) (void))) (lb5b@add-mark (lb53@gen-mark) l1d4b@out l1d48@expr))))) (set! l2859@ld8e@do-macro-call ld8e@do-macro-call) (set! ld90@chi-macro (lambda (l1d51@p l1d52@e) (ld8e@do-macro-call (ld8a@macro-transformer l1d51@p) l1d52@e))) (set! l285a@ld90@chi-macro ld90@chi-macro) (set! ld92@chi-local-macro (lambda (l1d55@p l1d56@e) (ld8e@do-macro-call (ld8c@local-macro-transformer l1d55@p) l1d56@e))) (set! l285b@ld92@chi-local-macro ld92@chi-local-macro) (set! ld94@chi-global-macro (lambda (l1d59@p l1d5a@e) (let ((l1d5d@lib (car l1d59@p)) (l1d5e@loc (cdr l1d59@p))) (begin (l98e@l7dd@visit-library l1d5d@lib) (let ((l1d61@x (symbol-value l1d5e@loc))) (let ((l1d63@transformer (if (procedure? l1d61@x) l1d61@x (assertion-violation 'chi-global-macro '"BUG: not a procedure" l1d61@x)))) (ld8e@do-macro-call l1d63@transformer l1d5a@e))))))) (set! l285c@ld94@chi-global-macro ld94@chi-global-macro) (set! ld96@chi-expr* (lambda (l1d65@e* l1d66@r l1d67@mr) (if (null? l1d65@e*) '() (let ((l1d6b@e (ld9a@chi-expr (car l1d65@e*) l1d66@r l1d67@mr))) (cons l1d6b@e (ld96@chi-expr* (cdr l1d65@e*) l1d66@r l1d67@mr)))))) (set! l285d@ld96@chi-expr* ld96@chi-expr*) (set! ld98@chi-application (lambda (l1d6d@e l1d6e@r l1d6f@mr) (let ((l1d73@t l1d6d@e)) (let ((l1d75@ls/false (ld78@syntax-dispatch l1d73@t '(any . each-any)))) (if l1d75@ls/false (apply (lambda (l1d77@rator l1d78@rands) (let ((l1d7b@rator (ld9a@chi-expr l1d77@rator l1d6e@r l1d6f@mr))) (cons l1d7b@rator (ld96@chi-expr* l1d78@rands l1d6e@r l1d6f@mr)))) l1d75@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1d73@t)))))) (set! l285e@ld98@chi-application ld98@chi-application) (set! ld9a@chi-expr (lambda (l1d7d@e l1d7e@r l1d7f@mr) (call-with-values (lambda () (lb93@syntax-type l1d7d@e l1d7e@r)) (lambda (l1d89@l1d84 l1d8a@l1d86 l1d8b@l1d88) (let ((l1d8f@kwd l1d8b@l1d88) (l1d90@value l1d8a@l1d86) (l1d91@type l1d89@l1d84)) (let ((l1d95@t l1d91@type)) (if (memv l1d95@t '(core-macro)) (let ((l1d97@transformer (ld86@core-macro-transformer l1d90@value))) (l1d97@transformer l1d7d@e l1d7e@r l1d7f@mr)) (if (memv l1d95@t '(global)) (let ((l1d99@lib (car l1d90@value))) (let ((l1d9b@loc (cdr l1d90@value))) (begin ((lde0@inv-collector) l1d99@lib) l1d9b@loc))) (if (memv l1d95@t '(core-prim)) (let ((l1d9d@name l1d90@value)) (list 'primitive l1d9d@name)) (if (memv l1d95@t '(call)) (ld98@chi-application l1d7d@e l1d7e@r l1d7f@mr) (if (memv l1d95@t '(lexical)) (let ((l1d9f@lex (ld02@lexical-var l1d90@value))) l1d9f@lex) (if (memv l1d95@t '(global-macro global-macro!)) (ld9a@chi-expr (ld94@chi-global-macro l1d90@value l1d7d@e) l1d7e@r l1d7f@mr) (if (memv l1d95@t '(local-macro local-macro!)) (ld9a@chi-expr (ld92@chi-local-macro l1d90@value l1d7d@e) l1d7e@r l1d7f@mr) (if (memv l1d95@t '(macro macro!)) (ld9a@chi-expr (ld90@chi-macro l1d90@value l1d7d@e) l1d7e@r l1d7f@mr) (if (memv l1d95@t '(constant)) (let ((l1da1@datum l1d90@value)) (list 'quote l1da1@datum)) (if (memv l1d95@t '(set!)) (ld9c@chi-set! l1d7d@e l1d7e@r l1d7f@mr) (if (memv l1d95@t '(begin)) (let ((l1da3@t l1d7d@e)) (let ((l1da5@ls/false (ld78@syntax-dispatch l1da3@t '(_ any . each-any)))) (if l1da5@ls/false (apply (lambda (l1da7@x l1da8@x*) (lad6@la36@build-sequence '#f (ld96@chi-expr* (cons l1da7@x l1da8@x*) l1d7e@r l1d7f@mr))) l1da5@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1da3@t)))) (if (memv l1d95@t '(let-syntax letrec-syntax)) (let ((l1dab@t l1d7d@e)) (let ((l1dad@ls/false (ld78@syntax-dispatch l1dab@t '(_ #(each (any any)) any . each-any)))) (if (and l1dad@ls/false (apply (lambda (l1daf@xlhs* l1db0@xrhs* l1db1@xbody l1db2@xbody*) (if (not (lb79@valid-bound-ids? l1daf@xlhs*)) (le58@syntax-violation '#f '"invalid identifiers" l1d7d@e) (void))) l1dad@ls/false)) (apply (lambda (l1db7@xlhs* l1db8@xrhs* l1db9@xbody l1dba@xbody*) (let ((l1dbf@xlab* (map lafd@gen-label l1db7@xlhs*))) (let ((l1dc1@xrib (lb31@make-full-rib l1db7@xlhs* l1dbf@xlab*))) (let ((l1dc3@xb* (map (lambda (l1dc5@x) (lba9@make-eval-transformer (ldd2@expand-transformer (if (eq? l1d91@type 'let-syntax) l1dc5@x (lb5d@add-subst l1dc1@xrib l1dc5@x)) l1d7f@mr))) l1db8@xrhs*))) (lad6@la36@build-sequence '#f (ld96@chi-expr* (map (lambda (l1dc7@x) (lb5d@add-subst l1dc1@xrib l1dc7@x)) (cons l1db9@xbody l1dba@xbody*)) (append (map cons l1dbf@xlab* l1dc3@xb*) l1d7e@r) (append (map cons l1dbf@xlab* l1dc3@xb*) l1d7f@mr))))))) l1dad@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1dab@t)))) (if (memv l1d95@t '(displaced-lexical)) (le58@syntax-violation '#f '"identifier out of context" l1d7d@e) (if (memv l1d95@t '(syntax)) (le58@syntax-violation '#f '"reference to pattern variable outside a syntax form" l1d7d@e) (if (memv l1d95@t '(define define-syntax module import library)) (le58@syntax-violation '#f (string-append (let ((l1dc9@t l1d91@type)) (if (memv l1dc9@t '(define)) '"a definition" (if (memv l1dc9@t '(define-syntax)) '"a define-syntax" (if (memv l1dc9@t '(module)) '"a module definition" (if (memv l1dc9@t '(library)) '"a library definition" (if (memv l1dc9@t '(import)) '"an import declaration" (if (memv l1dc9@t '(export)) '"an export declaration" '"a non-expression"))))))) '" was found where an expression was expected") l1d7d@e) (if (memv l1d95@t '(mutable)) (le58@syntax-violation '#f '"attempt to reference an unexportable variable" l1d7d@e) (le58@syntax-violation '#f '"invalid expression" l1d7d@e))))))))))))))))))))))) (set! l285f@ld9a@chi-expr ld9a@chi-expr) (set! ld9c@chi-set! (lambda (l1dcb@e l1dcc@r l1dcd@mr) (let ((l1dd1@t l1dcb@e)) (let ((l1dd3@ls/false (ld78@syntax-dispatch l1dd1@t '(_ any any)))) (if (and l1dd3@ls/false (apply (lambda (l1dd5@x l1dd6@v) (lb71@id? l1dd5@x)) l1dd3@ls/false)) (apply (lambda (l1dd9@x l1dda@v) (call-with-values (lambda () (lb93@syntax-type l1dd9@x l1dcc@r)) (lambda (l1de3@l1dde l1de4@l1de0 l1de5@l1de2) (let ((l1de9@kwd l1de5@l1de2) (l1dea@value l1de4@l1de0) (l1deb@type l1de3@l1dde)) (let ((l1def@t l1deb@type)) (if (memv l1def@t '(lexical)) (begin (ld06@set-lexical-mutable! l1dea@value '#t) (list 'set! (ld02@lexical-var l1dea@value) (ld9a@chi-expr l1dda@v l1dcc@r l1dcd@mr))) (if (memv l1def@t '(core-prim)) (le58@syntax-violation '#f '"cannot modify imported core primitive" l1dcb@e) (if (memv l1def@t '(global)) (le58@syntax-violation '#f '"attempt to modify imported binding" l1dcb@e) (if (memv l1def@t '(global-macro!)) (ld9a@chi-expr (ld94@chi-global-macro l1dea@value l1dcb@e) l1dcc@r l1dcd@mr) (if (memv l1def@t '(local-macro!)) (ld9a@chi-expr (ld92@chi-local-macro l1dea@value l1dcb@e) l1dcc@r l1dcd@mr) (if (memv l1def@t '(mutable)) (le58@syntax-violation '#f '"attempt to assign to an unexportable variable" l1dcb@e) (le58@syntax-violation '#f '"invalid syntax" l1dcb@e)))))))))))) l1dd3@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1dd1@t)))))) (set! l2860@ld9c@chi-set! ld9c@chi-set!) (set! ld9e@verify-formals (lambda (l1df1@fmls l1df2@stx) (let ((l1df5@t l1df1@fmls)) (let ((l1df7@ls/false (ld78@syntax-dispatch l1df5@t 'each-any))) (if l1df7@ls/false (apply (lambda (l1df9@x*) (if (not (lb79@valid-bound-ids? l1df9@x*)) (ld32@invalid-fmls-error l1df2@stx l1df1@fmls) (void))) l1df7@ls/false) (let ((l1dfb@t l1df5@t)) (let ((l1dfd@ls/false (ld78@syntax-dispatch l1dfb@t '#(each+ any () any)))) (if l1dfd@ls/false (apply (lambda (l1dff@x* l1e00@x) (if (not (lb79@valid-bound-ids? (cons l1e00@x l1dff@x*))) (ld32@invalid-fmls-error l1df2@stx l1df1@fmls) (void))) l1dfd@ls/false) (let ((l1e03@t l1dfb@t)) (let ((l1e05@ls/false (ld78@syntax-dispatch l1e03@t '_))) (if l1e05@ls/false (apply (lambda () (le58@syntax-violation '#f '"invalid syntax" l1df2@stx)) l1e05@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1e03@t)))))))))))) (set! l2861@ld9e@verify-formals ld9e@verify-formals) (set! lda0@chi-lambda-clause (lambda (l1e07@stx l1e08@fmls l1e09@body* l1e0a@r l1e0b@mr) (let ((l1e11@t l1e08@fmls)) (let ((l1e13@ls/false (ld78@syntax-dispatch l1e11@t 'each-any))) (if l1e13@ls/false (apply (lambda (l1e15@x*) (begin (ld9e@verify-formals l1e08@fmls l1e07@stx) (let ((l1e17@lex* (map laf9@gen-lexical l1e15@x*)) (l1e18@lab* (map lafd@gen-label l1e15@x*))) (values l1e17@lex* (ldb0@chi-internal (lb5d@add-subst (lb31@make-full-rib l1e15@x* l1e18@lab*) l1e09@body*) (ld0a@add-lexicals l1e18@lab* l1e17@lex* l1e0a@r) l1e0b@mr))))) l1e13@ls/false) (let ((l1e1b@t l1e11@t)) (let ((l1e1d@ls/false (ld78@syntax-dispatch l1e1b@t '#(each+ any () any)))) (if l1e1d@ls/false (apply (lambda (l1e1f@x* l1e20@x) (begin (ld9e@verify-formals l1e08@fmls l1e07@stx) (let ((l1e23@lex* (map laf9@gen-lexical l1e1f@x*)) (l1e24@lab* (map lafd@gen-label l1e1f@x*)) (l1e25@lex (laf9@gen-lexical l1e20@x)) (l1e26@lab (lafd@gen-label l1e20@x))) (values (append l1e23@lex* l1e25@lex) (ldb0@chi-internal (lb5d@add-subst (lb31@make-full-rib (cons l1e20@x l1e1f@x*) (cons l1e26@lab l1e24@lab*)) l1e09@body*) (ld0a@add-lexicals (cons l1e26@lab l1e24@lab*) (cons l1e25@lex l1e23@lex*) l1e0a@r) l1e0b@mr))))) l1e1d@ls/false) (let ((l1e2b@t l1e1b@t)) (let ((l1e2d@ls/false (ld78@syntax-dispatch l1e2b@t '_))) (if l1e2d@ls/false (apply (lambda () (le58@syntax-violation '#f '"invalid syntax" l1e08@fmls)) l1e2d@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1e2b@t)))))))))))) (set! l2862@lda0@chi-lambda-clause lda0@chi-lambda-clause) (set! lda2@chi-lambda-clause* (lambda (l1e2f@stx l1e30@fmls* l1e31@body** l1e32@r l1e33@mr) (if (null? l1e30@fmls*) (values '() '()) (call-with-values (lambda () (lda0@chi-lambda-clause l1e2f@stx (car l1e30@fmls*) (car l1e31@body**) l1e32@r l1e33@mr)) (lambda (l1e3d@l1e3a l1e3e@l1e3c) (let ((l1e41@b l1e3e@l1e3c) (l1e42@a l1e3d@l1e3a)) (call-with-values (lambda () (lda2@chi-lambda-clause* l1e2f@stx (cdr l1e30@fmls*) (cdr l1e31@body**) l1e32@r l1e33@mr)) (lambda (l1e49@l1e46 l1e4a@l1e48) (let ((l1e4d@b* l1e4a@l1e48) (l1e4e@a* l1e49@l1e46)) (values (cons l1e42@a l1e4e@a*) (cons l1e41@b l1e4d@b*))))))))))) (set! l2863@lda2@chi-lambda-clause* lda2@chi-lambda-clause*) (set! lda4@chi-defun (lambda (l1e51@x l1e52@r l1e53@mr) (let ((l1e57@fmls (car l1e51@x)) (l1e58@body* (cdr l1e51@x))) (call-with-values (lambda () (lda0@chi-lambda-clause l1e57@fmls l1e57@fmls l1e58@body* l1e52@r l1e53@mr)) (lambda (l1e5f@l1e5c l1e60@l1e5e) (let ((l1e63@body l1e60@l1e5e) (l1e64@fmls l1e5f@l1e5c)) (lad4@la06@build-lambda '#f l1e64@fmls l1e63@body))))))) (set! l2864@lda4@chi-defun lda4@chi-defun) (set! lda6@chi-rhs (lambda (l1e67@rhs l1e68@r l1e69@mr) (let ((l1e6d@t (car l1e67@rhs))) (if (memv l1e6d@t '(defun)) (lda4@chi-defun (cdr l1e67@rhs) l1e68@r l1e69@mr) (if (memv l1e6d@t '(expr)) (let ((l1e6f@expr (cdr l1e67@rhs))) (ld9a@chi-expr l1e6f@expr l1e68@r l1e69@mr)) (if (memv l1e6d@t '(top-expr)) (let ((l1e71@expr (cdr l1e67@rhs))) (lad6@la36@build-sequence '#f (list (ld9a@chi-expr l1e71@expr l1e68@r l1e69@mr) (lad7@la38@build-void)))) (assertion-violation 'chi-rhs '"BUG: invalid rhs" l1e67@rhs))))))) (set! l2865@lda6@chi-rhs lda6@chi-rhs) (set! lda8@expand-interaction-rhs*/init* (lambda (l1e73@lhs* l1e74@rhs* l1e75@init* l1e76@r l1e77@mr) (let l1e81@f ((l1e7d@lhs* l1e73@lhs*) (l1e7e@rhs* l1e74@rhs*)) (if (null? l1e7d@lhs*) (map (lambda (l1e83@x) (ld9a@chi-expr l1e83@x l1e76@r l1e77@mr)) l1e75@init*) (let ((l1e85@lhs (car l1e7d@lhs*)) (l1e86@rhs (car l1e7e@rhs*))) (let ((l1e89@t (car l1e86@rhs))) (if (memv l1e89@t '(defun)) (let ((l1e8b@rhs (lda4@chi-defun (cdr l1e86@rhs) l1e76@r l1e77@mr))) (cons (list 'set! l1e85@lhs l1e8b@rhs) (l1e81@f (cdr l1e7d@lhs*) (cdr l1e7e@rhs*)))) (if (memv l1e89@t '(expr)) (let ((l1e8d@rhs (ld9a@chi-expr (cdr l1e86@rhs) l1e76@r l1e77@mr))) (cons (list 'set! l1e85@lhs l1e8d@rhs) (l1e81@f (cdr l1e7d@lhs*) (cdr l1e7e@rhs*)))) (if (memv l1e89@t '(top-expr)) (let ((l1e8f@e (ld9a@chi-expr (cdr l1e86@rhs) l1e76@r l1e77@mr))) (cons l1e8f@e (l1e81@f (cdr l1e7d@lhs*) (cdr l1e7e@rhs*)))) (error 'expand-interaction '"invallid" l1e86@rhs)))))))))) (set! l2866@lda8@expand-interaction-rhs*/init* lda8@expand-interaction-rhs*/init*) (set! ldaa@chi-rhs* (lambda (l1e91@rhs* l1e92@r l1e93@mr) (let l1e99@f ((l1e97@ls l1e91@rhs*)) (if (null? l1e97@ls) '() (let ((l1e9b@a (lda6@chi-rhs (car l1e97@ls) l1e92@r l1e93@mr))) (cons l1e9b@a (l1e99@f (cdr l1e97@ls)))))))) (set! l2867@ldaa@chi-rhs* ldaa@chi-rhs*) (set! ldac@find-bound=? (lambda (l1e9d@x l1e9e@lhs* l1e9f@rhs*) (if (null? l1e9e@lhs*) '#f (if (lb75@bound-id=? l1e9d@x (car l1e9e@lhs*)) (car l1e9f@rhs*) (ldac@find-bound=? l1e9d@x (cdr l1e9e@lhs*) (cdr l1e9f@rhs*)))))) (set! l2868@ldac@find-bound=? ldac@find-bound=?) (set! ldae@find-dups (lambda (l1ea3@ls) (let l1ea9@f ((l1ea5@ls l1ea3@ls) (l1ea6@dups '())) (if (null? l1ea5@ls) l1ea6@dups (let ((l1eab@t (ldac@find-bound=? (car l1ea5@ls) (cdr l1ea5@ls) (cdr l1ea5@ls)))) (if l1eab@t ((lambda (l1ead@x) (l1ea9@f (cdr l1ea5@ls) (cons (list (car l1ea5@ls) l1ead@x) l1ea6@dups))) l1eab@t) (l1ea9@f (cdr l1ea5@ls) l1ea6@dups))))))) (set! l2869@ldae@find-dups ldae@find-dups) (set! ldb0@chi-internal (lambda (l1eaf@e* l1eb0@r l1eb1@mr) (let ((l1eb5@rib (lb25@make-empty-rib))) (call-with-values (lambda () (ldd0@chi-body* (map (lambda (l1ec7@x) (lb5d@add-subst l1eb5@rib l1ec7@x)) (lb6f@syntax->list l1eaf@e*)) l1eb0@r l1eb1@mr '() '() '() '() '() l1eb5@rib '#f)) (lambda (l1ec9@l1eb8 l1eca@l1eba l1ecb@l1ebc l1ecc@l1ebe l1ecd@l1ec0 l1ece@l1ec2 l1ecf@l1ec4 l1ed0@l1ec6) (let ((l1ed9@_exp* l1ed0@l1ec6) (l1eda@kwd* l1ecf@l1ec4) (l1edb@mod** l1ece@l1ec2) (l1edc@rhs* l1ecd@l1ec0) (l1edd@lex* l1ecc@l1ebe) (l1ede@mr l1ecb@l1ebc) (l1edf@r l1eca@l1eba) (l1ee0@e* l1ec9@l1eb8)) (begin (if (null? l1ee0@e*) (le58@syntax-violation '#f '"no expression in body" l1ee0@e*) (void)) (let ((l1ee9@init* (ld96@chi-expr* (append (apply append (reverse l1edb@mod**)) l1ee0@e*) l1edf@r l1ede@mr))) (let ((l1eeb@rhs* (ldaa@chi-rhs* l1edc@rhs* l1edf@r l1ede@mr))) (ladb@la40@build-letrec* '#f (reverse l1edd@lex*) (reverse l1eeb@rhs*) (lad6@la36@build-sequence '#f l1ee9@init*))))))))))) (set! l286a@ldb0@chi-internal ldb0@chi-internal) (set! ldb2@parse-module (lambda (l1eed@e) (let ((l1eef@t l1eed@e)) (let ((l1ef1@ls/false (ld78@syntax-dispatch l1eef@t '(_ each-any . each-any)))) (if l1ef1@ls/false (apply (lambda (l1ef3@export* l1ef4@b*) (begin (if (not (for-all lb71@id? l1ef3@export*)) (le58@syntax-violation '#f '"module exports must be identifiers" l1eed@e) (void)) (values '#f (list->vector l1ef3@export*) l1ef4@b*))) l1ef1@ls/false) (let ((l1ef7@t l1eef@t)) (let ((l1ef9@ls/false (ld78@syntax-dispatch l1ef7@t '(_ any each-any . each-any)))) (if l1ef9@ls/false (apply (lambda (l1efb@name l1efc@export* l1efd@b*) (begin (if (not (lb71@id? l1efb@name)) (le58@syntax-violation '#f '"module name must be an identifier" l1eed@e) (void)) (if (not (for-all lb71@id? l1efc@export*)) (le58@syntax-violation '#f '"module exports must be identifiers" l1eed@e) (void)) (values l1efb@name (list->vector l1efc@export*) l1efd@b*))) l1ef9@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1ef7@t))))))))) (set! l286b@ldb2@parse-module ldb2@parse-module) (set! ldbc@module-interface? (lambda (l1f01@x) (and (simple-struct? l1f01@x) (eq? (simple-struct-name l1f01@x) 'module-interface)))) (set! l286c@ldbc@module-interface? ldbc@module-interface?) (set! ldbe@module-interface-first-mark (lambda (l1f03@x) (simple-struct-ref l1f03@x '0))) (set! l286d@ldbe@module-interface-first-mark ldbe@module-interface-first-mark) (set! ldc0@set-module-interface-first-mark! (lambda (l1f05@x l1f06@val) (simple-struct-set! l1f05@x '0 l1f06@val))) (set! l286e@ldc0@set-module-interface-first-mark! ldc0@set-module-interface-first-mark!) (set! ldc2@module-interface-exp-id-vec (lambda (l1f09@x) (simple-struct-ref l1f09@x '1))) (set! l286f@ldc2@module-interface-exp-id-vec ldc2@module-interface-exp-id-vec) (set! ldc4@set-module-interface-exp-id-vec! (lambda (l1f0b@x l1f0c@val) (simple-struct-set! l1f0b@x '1 l1f0c@val))) (set! l2870@ldc4@set-module-interface-exp-id-vec! ldc4@set-module-interface-exp-id-vec!) (set! ldc6@module-interface-exp-lab-vec (lambda (l1f0f@x) (simple-struct-ref l1f0f@x '2))) (set! l2871@ldc6@module-interface-exp-lab-vec ldc6@module-interface-exp-lab-vec) (set! ldc8@set-module-interface-exp-lab-vec! (lambda (l1f11@x l1f12@val) (simple-struct-set! l1f11@x '2 l1f12@val))) (set! l2872@ldc8@set-module-interface-exp-lab-vec! ldc8@set-module-interface-exp-lab-vec!) (set! ldca@dummy '3) (set! l2873@ldca@dummy ldca@dummy) (set! ldcc@module-interface-exp-id* (lambda (l1f15@iface l1f16@id) (letrec* ((l1f1a@diff-marks (lambda (l1f21@ls l1f22@x) (begin (if (null? l1f21@ls) (error 'diff-marks '"BUG: should not happen") (void)) (let ((l1f25@a (car l1f21@ls))) (if (eq? l1f25@a l1f22@x) '() (cons l1f25@a (l1f1a@diff-marks (cdr l1f21@ls) l1f22@x)))))))) (let ((l1f1b@diff (l1f1a@diff-marks (lb43@stx-mark* l1f16@id) (ldbe@module-interface-first-mark l1f15@iface))) (l1f1c@id-vec (ldc2@module-interface-exp-id-vec l1f15@iface))) (if (null? l1f1b@diff) l1f1c@id-vec (vector-map (lambda (l1f1f@x) (make-simple-struct 'stx '5 (list (lb3f@stx-expr l1f1f@x) (append l1f1b@diff (lb43@stx-mark* l1f1f@x)) '() '()))) l1f1c@id-vec)))))) (set! l2874@ldcc@module-interface-exp-id* ldcc@module-interface-exp-id*) (set! ldce@chi-internal-module (lambda (l1f27@e l1f28@r l1f29@mr l1f2a@lex* l1f2b@rhs* l1f2c@mod** l1f2d@kwd*) (call-with-values (lambda () (ldb2@parse-module l1f27@e)) (lambda (l1f3b@l1f36 l1f3c@l1f38 l1f3d@l1f3a) (let ((l1f41@e* l1f3d@l1f3a) (l1f42@exp-id* l1f3c@l1f38) (l1f43@name l1f3b@l1f36)) (let ((l1f47@rib (lb25@make-empty-rib))) (let ((l1f49@e* (map (lambda (l1f4b@x) (lb5d@add-subst l1f47@rib l1f4b@x)) (lb6f@syntax->list l1f41@e*)))) (call-with-values (lambda () (ldd0@chi-body* l1f49@e* l1f28@r l1f29@mr l1f2a@lex* l1f2b@rhs* l1f2c@mod** l1f2d@kwd* '() l1f47@rib '#f)) (lambda (l1f5d@l1f4e l1f5e@l1f50 l1f5f@l1f52 l1f60@l1f54 l1f61@l1f56 l1f62@l1f58 l1f63@l1f5a l1f64@l1f5c) (let ((l1f6d@_exp* l1f64@l1f5c) (l1f6e@kwd* l1f63@l1f5a) (l1f6f@mod** l1f62@l1f58) (l1f70@rhs* l1f61@l1f56) (l1f71@lex* l1f60@l1f54) (l1f72@mr l1f5f@l1f52) (l1f73@r l1f5e@l1f50) (l1f74@e* l1f5d@l1f4e)) (let ((l1f7d@exp-lab* (vector-map (lambda (l1f81@x) (or (lb87@id->label (make-simple-struct 'stx '5 (list (lb73@id->sym l1f81@x) (lb43@stx-mark* l1f81@x) (list l1f47@rib) '()))) (le58@syntax-violation '#f '"cannot find module export" l1f81@x))) l1f42@exp-id*)) (l1f7e@mod** (cons l1f74@e* l1f6f@mod**))) (if (not l1f43@name) (values l1f71@lex* l1f70@rhs* l1f42@exp-id* l1f7d@exp-lab* l1f73@r l1f72@mr l1f7e@mod** l1f6e@kwd*) (let ((l1f83@lab (lafd@gen-label 'module)) (l1f84@iface (make-simple-struct 'module-interface '4 (list (car (lb43@stx-mark* l1f43@name)) (vector-map (lambda (l1f87@x) (make-simple-struct 'stx '5 (list (lb3f@stx-expr l1f87@x) (lb43@stx-mark* l1f87@x) '() '()))) l1f42@exp-id*) l1f7d@exp-lab*)))) (values l1f71@lex* l1f70@rhs* (vector l1f43@name) (vector l1f83@lab) (cons (cons l1f83@lab (cons '$module l1f84@iface)) l1f73@r) (cons (cons l1f83@lab (cons '$module l1f84@iface)) l1f72@mr) l1f7e@mod** l1f6e@kwd*)))))))))))))) (set! l2875@ldce@chi-internal-module ldce@chi-internal-module) (set! ldd0@chi-body* (lambda (l1f89@e* l1f8a@r l1f8b@mr l1f8c@lex* l1f8d@rhs* l1f8e@mod** l1f8f@kwd* l1f90@exp* l1f91@rib l1f92@top?) (if (null? l1f89@e*) (values l1f89@e* l1f8a@r l1f8b@mr l1f8c@lex* l1f8d@rhs* l1f8e@mod** l1f8f@kwd* l1f90@exp*) (let ((l1f9d@e (car l1f89@e*))) (call-with-values (lambda () (lb93@syntax-type l1f9d@e l1f8a@r)) (lambda (l1fa5@l1fa0 l1fa6@l1fa2 l1fa7@l1fa4) (let ((l1fab@kwd l1fa7@l1fa4) (l1fac@value l1fa6@l1fa2) (l1fad@type l1fa5@l1fa0)) (let ((l1fb1@kwd* (if (lb71@id? l1fab@kwd) (cons l1fab@kwd l1f8f@kwd*) l1f8f@kwd*))) (let ((l1fb3@t l1fad@type)) (if (memv l1fb3@t '(define)) (call-with-values (lambda () (lcfa@parse-define l1f9d@e)) (lambda (l1fb9@l1fb6 l1fba@l1fb8) (let ((l1fbd@rhs l1fba@l1fb8) (l1fbe@id l1fb9@l1fb6)) (begin (if (lb7d@bound-id-member? l1fbe@id l1fb1@kwd*) (le58@syntax-violation '#f '"cannot redefine keyword" l1f9d@e) (void)) (call-with-values (lambda () (lb01@gen-define-label+loc l1fbe@id l1f91@rib)) (lambda (l1fc5@l1fc2 l1fc6@l1fc4) (let ((l1fc9@lex l1fc6@l1fc4) (l1fca@lab l1fc5@l1fc2)) (begin (lb27@extend-rib! l1f91@rib l1fbe@id l1fca@lab) (ldd0@chi-body* (cdr l1f89@e*) (ld08@add-lexical l1fca@lab l1fc9@lex l1f8a@r) l1f8b@mr (cons l1fc9@lex l1f8c@lex*) (cons l1fbd@rhs l1f8d@rhs*) l1f8e@mod** l1fb1@kwd* l1f90@exp* l1f91@rib l1f92@top?))))))))) (if (memv l1fb3@t '(define-syntax)) (call-with-values (lambda () (lcfc@parse-define-syntax l1f9d@e)) (lambda (l1fd1@l1fce l1fd2@l1fd0) (let ((l1fd5@rhs l1fd2@l1fd0) (l1fd6@id l1fd1@l1fce)) (begin (if (lb7d@bound-id-member? l1fd6@id l1fb1@kwd*) (le58@syntax-violation '#f '"cannot redefine keyword" l1f9d@e) (void)) (let ((l1fd9@lab (lb03@gen-define-label l1fd6@id l1f91@rib)) (l1fda@expanded-rhs (ldd2@expand-transformer l1fd5@rhs l1f8b@mr))) (begin (lb27@extend-rib! l1f91@rib l1fd6@id l1fd9@lab) (let ((l1fdd@b (lba9@make-eval-transformer l1fda@expanded-rhs))) (ldd0@chi-body* (cdr l1f89@e*) (cons (cons l1fd9@lab l1fdd@b) l1f8a@r) (cons (cons l1fd9@lab l1fdd@b) l1f8b@mr) l1f8c@lex* l1f8d@rhs* l1f8e@mod** l1fb1@kwd* l1f90@exp* l1f91@rib l1f92@top?)))))))) (if (memv l1fb3@t '(let-syntax letrec-syntax)) (let ((l1fdf@t l1f9d@e)) (let ((l1fe1@ls/false (ld78@syntax-dispatch l1fdf@t '(_ #(each (any any)) . each-any)))) (if (and l1fe1@ls/false (apply (lambda (l1fe3@xlhs* l1fe4@xrhs* l1fe5@xbody*) (if (not (lb79@valid-bound-ids? l1fe3@xlhs*)) (le58@syntax-violation '#f '"invalid identifiers" l1f9d@e) (void))) l1fe1@ls/false)) (apply (lambda (l1fe9@xlhs* l1fea@xrhs* l1feb@xbody*) (let ((l1fef@xlab* (map lafd@gen-label l1fe9@xlhs*))) (let ((l1ff1@xrib (lb31@make-full-rib l1fe9@xlhs* l1fef@xlab*))) (let ((l1ff3@xb* (map (lambda (l1ff5@x) (lba9@make-eval-transformer (ldd2@expand-transformer (if (eq? l1fad@type 'let-syntax) l1ff5@x (lb5d@add-subst l1ff1@xrib l1ff5@x)) l1f8b@mr))) l1fea@xrhs*))) (ldd0@chi-body* (append (map (lambda (l1ff7@x) (lb5d@add-subst l1ff1@xrib l1ff7@x)) l1feb@xbody*) (cdr l1f89@e*)) (append (map cons l1fef@xlab* l1ff3@xb*) l1f8a@r) (append (map cons l1fef@xlab* l1ff3@xb*) l1f8b@mr) l1f8c@lex* l1f8d@rhs* l1f8e@mod** l1fb1@kwd* l1f90@exp* l1f91@rib l1f92@top?))))) l1fe1@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1fdf@t)))) (if (memv l1fb3@t '(begin)) (let ((l1ff9@t l1f9d@e)) (let ((l1ffb@ls/false (ld78@syntax-dispatch l1ff9@t '(_ . each-any)))) (if l1ffb@ls/false (apply (lambda (l1ffd@x*) (ldd0@chi-body* (append l1ffd@x* (cdr l1f89@e*)) l1f8a@r l1f8b@mr l1f8c@lex* l1f8d@rhs* l1f8e@mod** l1fb1@kwd* l1f90@exp* l1f91@rib l1f92@top?)) l1ffb@ls/false) (le58@syntax-violation '#f '"invalid syntax" l1ff9@t)))) (if (memv l1fb3@t '(global-macro global-macro!)) (ldd0@chi-body* (cons (lb5d@add-subst l1f91@rib (ld94@chi-global-macro l1fac@value l1f9d@e)) (cdr l1f89@e*)) l1f8a@r l1f8b@mr l1f8c@lex* l1f8d@rhs* l1f8e@mod** l1fb1@kwd* l1f90@exp* l1f91@rib l1f92@top?) (if (memv l1fb3@t '(local-macro local-macro!)) (ldd0@chi-body* (cons (lb5d@add-subst l1f91@rib (ld92@chi-local-macro l1fac@value l1f9d@e)) (cdr l1f89@e*)) l1f8a@r l1f8b@mr l1f8c@lex* l1f8d@rhs* l1f8e@mod** l1fb1@kwd* l1f90@exp* l1f91@rib l1f92@top?) (if (memv l1fb3@t '(macro macro!)) (ldd0@chi-body* (cons (lb5d@add-subst l1f91@rib (ld90@chi-macro l1fac@value l1f9d@e)) (cdr l1f89@e*)) l1f8a@r l1f8b@mr l1f8c@lex* l1f8d@rhs* l1f8e@mod** l1fb1@kwd* l1f90@exp* l1f91@rib l1f92@top?) (if (memv l1fb3@t '(module)) (call-with-values (lambda () (ldce@chi-internal-module l1f9d@e l1f8a@r l1f8b@mr l1f8c@lex* l1f8d@rhs* l1f8e@mod** l1fb1@kwd*)) (lambda (l200f@l2000 l2010@l2002 l2011@l2004 l2012@l2006 l2013@l2008 l2014@l200a l2015@l200c l2016@l200e) (let ((l201f@kwd* l2016@l200e) (l2020@mod** l2015@l200c) (l2021@mr l2014@l200a) (l2022@r l2013@l2008) (l2023@m-exp-lab* l2012@l2006) (l2024@m-exp-id* l2011@l2004) (l2025@rhs* l2010@l2002) (l2026@lex* l200f@l2000)) (begin (vector-for-each (lambda (l202f@id l2030@lab) (lb27@extend-rib! l1f91@rib l202f@id l2030@lab)) l2024@m-exp-id* l2023@m-exp-lab*) (ldd0@chi-body* (cdr l1f89@e*) l2022@r l2021@mr l2026@lex* l2025@rhs* l2020@mod** l201f@kwd* l1f90@exp* l1f91@rib l1f92@top?))))) (if (memv l1fb3@t '(library)) (begin (le3a@library-expander (lb85@stx->datum l1f9d@e)) (ldd0@chi-body* (cdr l1f89@e*) l1f8a@r l1f8b@mr l1f8c@lex* l1f8d@rhs* l1f8e@mod** l1fb1@kwd* l1f90@exp* l1f91@rib l1f92@top?)) (if (memv l1fb3@t '(export)) (let ((l2033@t l1f9d@e)) (let ((l2035@ls/false (ld78@syntax-dispatch l2033@t '(_ . each-any)))) (if l2035@ls/false (apply (lambda (l2037@exp-decl*) (ldd0@chi-body* (cdr l1f89@e*) l1f8a@r l1f8b@mr l1f8c@lex* l1f8d@rhs* l1f8e@mod** l1fb1@kwd* (append l2037@exp-decl* l1f90@exp*) l1f91@rib l1f92@top?)) l2035@ls/false) (le58@syntax-violation '#f '"invalid syntax" l2033@t)))) (if (memv l1fb3@t '(import)) (letrec* ((l203a@module-import? (lambda (l208d@e) (let ((l208f@t l208d@e)) (let ((l2091@ls/false (ld78@syntax-dispatch l208f@t '(_ any)))) (if (and l2091@ls/false (apply (lambda (l2093@id) (lb71@id? l2093@id)) l2091@ls/false)) (apply (lambda (l2095@id) '#t) l2091@ls/false) (let ((l2097@t l208f@t)) (let ((l2099@ls/false (ld78@syntax-dispatch l2097@t '(_ . each-any)))) (if l2099@ls/false (apply (lambda (l209b@imp*) '#f) l2099@ls/false) (let ((l209d@t l2097@t)) (let ((l209f@ls/false (ld78@syntax-dispatch l209d@t '_))) (if l209f@ls/false (apply (lambda () (le58@syntax-violation '#f '"malformed import form" l208d@e)) l209f@ls/false) (le58@syntax-violation '#f '"invalid syntax" l209d@t)))))))))))) (l203c@module-import (lambda (l206b@e l206c@r) (let ((l206f@t l206b@e)) (let ((l2071@ls/false (ld78@syntax-dispatch l206f@t '(_ any)))) (if (and l2071@ls/false (apply (lambda (l2073@id) (lb71@id? l2073@id)) l2071@ls/false)) (apply (lambda (l2075@id) (call-with-values (lambda () (lb93@syntax-type l2075@id l206c@r)) (lambda (l207d@l2078 l207e@l207a l207f@l207c) (let ((l2083@kwd l207f@l207c) (l2084@value l207e@l207a) (l2085@type l207d@l2078)) (let ((l2089@t l2085@type)) (if (memv l2089@t '($module)) (let ((l208b@iface l2084@value)) (values (ldcc@module-interface-exp-id* l208b@iface l2075@id) (ldc6@module-interface-exp-lab-vec l208b@iface))) (le58@syntax-violation '#f '"invalid import" l206b@e))))))) l2071@ls/false) (le58@syntax-violation '#f '"invalid syntax" l206f@t)))))) (l203e@library-import (lambda (l204f@e) (let ((l2051@t l204f@e)) (let ((l2053@ls/false (ld78@syntax-dispatch l2051@t '(any . each-any)))) (if l2053@ls/false (apply (lambda (l2055@ctxt l2056@imp*) (call-with-values (lambda () (ldda@parse-import-spec* (le5e@syntax->datum l2056@imp*))) (lambda (l205d@l205a l205e@l205c) (let ((l2061@subst-labels l205e@l205c) (l2062@subst-names l205d@l205a)) (values (vector-map (lambda (l2065@name) (lb51@datum->stx l2055@ctxt l2065@name)) l2062@subst-names) l2061@subst-labels))))) l2053@ls/false) (let ((l2067@t l2051@t)) (let ((l2069@ls/false (ld78@syntax-dispatch l2067@t '_))) (if l2069@ls/false (apply (lambda () (le58@syntax-violation '#f '"invalid import form" l204f@e)) l2069@ls/false) (le58@syntax-violation '#f '"invalid syntax" l2067@t)))))))))) (begin (call-with-values (lambda () (if (l203a@module-import? l1f9d@e) (l203c@module-import l1f9d@e l1f8a@r) (l203e@library-import l1f9d@e))) (lambda (l2043@l2040 l2044@l2042) (let ((l2047@lab* l2044@l2042) (l2048@id* l2043@l2040)) (vector-for-each (lambda (l204b@id l204c@lab) (lb27@extend-rib! l1f91@rib l204b@id l204c@lab)) l2048@id* l2047@lab*)))) (ldd0@chi-body* (cdr l1f89@e*) l1f8a@r l1f8b@mr l1f8c@lex* l1f8d@rhs* l1f8e@mod** l1fb1@kwd* l1f90@exp* l1f91@rib l1f92@top?))) (if l1f92@top? (ldd0@chi-body* (cdr l1f89@e*) l1f8a@r l1f8b@mr (cons (laf9@gen-lexical 'dummy) l1f8c@lex*) (cons (cons 'top-expr l1f9d@e) l1f8d@rhs*) l1f8e@mod** l1fb1@kwd* l1f90@exp* l1f91@rib l1f92@top?) (values l1f89@e* l1f8a@r l1f8b@mr l1f8c@lex* l1f8d@rhs* l1f8e@mod** l1fb1@kwd* l1f90@exp*)))))))))))))))))))))) (set! l2876@ldd0@chi-body* ldd0@chi-body*) (set! ldd2@expand-transformer (lambda (l20a1@expr l20a2@r) (let ((l20a5@rtc (ldde@make-collector))) (let ((l20a7@expanded-rhs (let ((l20b1@l20aa lde0@inv-collector) (l20b2@l20ac lde2@vis-collector) (l20b3@l20ae l20a5@rtc) (l20b4@l20b0 (lambda (l20b9@x) (values)))) (let ((l20bb@swap (lambda () (begin (let ((l20bd@t (l20b1@l20aa))) (begin (l20b1@l20aa l20b3@l20ae) (set! l20b3@l20ae l20bd@t))) (let ((l20bf@t (l20b2@l20ac))) (begin (l20b2@l20ac l20b4@l20b0) (set! l20b4@l20b0 l20bf@t))))))) (dynamic-wind l20bb@swap (lambda () (ld9a@chi-expr l20a1@expr l20a2@r l20a2@r)) l20bb@swap))))) (begin (for-each (let ((l20c1@mark-visit (lde2@vis-collector))) (lambda (l20c3@x) (begin (l98d@l7db@invoke-library l20c3@x) (l20c1@mark-visit l20c3@x)))) (l20a5@rtc)) l20a7@expanded-rhs))))) (set! l2877@ldd2@expand-transformer ldd2@expand-transformer) (set! ldd4@parse-exports (lambda (l20c5@exp*) (let l20cd@f ((l20c7@exp* l20c5@exp*) (l20c8@int* '()) (l20c9@ext* '())) (if (null? l20c7@exp*) (begin (if (not (lb79@valid-bound-ids? l20c9@ext*)) (le58@syntax-violation 'export '"invalid exports" (ldae@find-dups l20c9@ext*)) (void)) (values (map le5e@syntax->datum l20c9@ext*) l20c8@int*)) (let ((l20cf@t (car l20c7@exp*))) (let ((l20d1@ls/false (ld78@syntax-dispatch l20cf@t '(any . #(each (any any)))))) (if l20d1@ls/false (apply (lambda (l20d3@rename l20d4@i* l20d5@e*) (begin (if (not (and (eq? (le5e@syntax->datum l20d3@rename) 'rename) (for-all lb71@id? l20d4@i*) (for-all lb71@id? l20d5@e*))) (le58@syntax-violation 'export '"invalid export specifier" (car l20c7@exp*)) (void)) (l20cd@f (cdr l20c7@exp*) (append l20d4@i* l20c8@int*) (append l20d5@e* l20c9@ext*)))) l20d1@ls/false) (let ((l20d9@t l20cf@t)) (let ((l20db@ls/false (ld78@syntax-dispatch l20d9@t 'any))) (if l20db@ls/false (apply (lambda (l20dd@ie) (begin (if (not (lb71@id? l20dd@ie)) (le58@syntax-violation 'export '"invalid export" l20dd@ie) (void)) (l20cd@f (cdr l20c7@exp*) (cons l20dd@ie l20c8@int*) (cons l20dd@ie l20c9@ext*)))) l20db@ls/false) (le58@syntax-violation '#f '"invalid syntax" l20d9@t))))))))))) (set! l2878@ldd4@parse-exports ldd4@parse-exports) (set! ldd6@parse-library-name (lambda (l20df@spec) (letrec* ((l20e2@parse (lambda (l20ef@x) (let ((l20f1@t l20ef@x)) (let ((l20f3@ls/false (ld78@syntax-dispatch l20f1@t '(each-any)))) (if (and l20f3@ls/false (apply (lambda (l20f5@v*) (for-all (lambda (l20f7@x) (let ((l20f9@x (le5e@syntax->datum l20f7@x))) (and (integer? l20f9@x) (exact? l20f9@x)))) l20f5@v*)) l20f3@ls/false)) (apply (lambda (l20fb@v*) (values '() (map le5e@syntax->datum l20fb@v*))) l20f3@ls/false) (let ((l20fd@t l20f1@t)) (let ((l20ff@ls/false (ld78@syntax-dispatch l20fd@t '(any . any)))) (if (and l20ff@ls/false (apply (lambda (l2101@x l2102@rest) (symbol? (le5e@syntax->datum l2101@x))) l20ff@ls/false)) (apply (lambda (l2105@x l2106@rest) (call-with-values (lambda () (l20e2@parse l2106@rest)) (lambda (l210d@l210a l210e@l210c) (let ((l2111@v* l210e@l210c) (l2112@x* l210d@l210a)) (values (cons (le5e@syntax->datum l2105@x) l2112@x*) l2111@v*))))) l20ff@ls/false) (let ((l2115@t l20fd@t)) (let ((l2117@ls/false (ld78@syntax-dispatch l2115@t '()))) (if l2117@ls/false (apply (lambda () (values '() '())) l2117@ls/false) (let ((l2119@t l2115@t)) (let ((l211b@ls/false (ld78@syntax-dispatch l2119@t '_))) (if l211b@ls/false (apply (lambda () (le58@syntax-violation '#f '"invalid library name" l20df@spec)) l211b@ls/false) (le58@syntax-violation '#f '"invalid syntax" l2119@t)))))))))))))))) (call-with-values (lambda () (l20e2@parse l20df@spec)) (lambda (l20e7@l20e4 l20e8@l20e6) (let ((l20eb@ver* l20e8@l20e6) (l20ec@name* l20e7@l20e4)) (begin (if (null? l20ec@name*) (le58@syntax-violation '#f '"empty library name" l20df@spec) (void)) (values l20ec@name* l20eb@ver*)))))))) (set! l2879@ldd6@parse-library-name ldd6@parse-library-name) (set! ldd8@parse-library (lambda (l211d@e) (let ((l211f@t l211d@e)) (let ((l2121@ls/false (ld78@syntax-dispatch l211f@t '(any each-any (any . each-any) (any . each-any) . each-any)))) (if (and l2121@ls/false (apply (lambda (l2123@library l2124@name* l2125@export l2126@exp* l2127@import l2128@imp* l2129@b*) (and (eq? (le5e@syntax->datum l2125@export) 'export) (eq? (le5e@syntax->datum l2127@import) 'import) (eq? (le5e@syntax->datum l2123@library) 'library))) l2121@ls/false)) (apply (lambda (l2131@library l2132@name* l2133@export l2134@exp* l2135@import l2136@imp* l2137@b*) (values l2132@name* l2134@exp* l2136@imp* l2137@b*)) l2121@ls/false) (let ((l213f@t l211f@t)) (let ((l2141@ls/false (ld78@syntax-dispatch l213f@t '_))) (if l2141@ls/false (apply (lambda () (le58@syntax-violation '#f '"malformed library" l211d@e)) l2141@ls/false) (le58@syntax-violation '#f '"invalid syntax" l213f@t))))))))) (set! l287a@ldd8@parse-library ldd8@parse-library) (set! ldda@parse-import-spec* (letrec* ((l2144@idsyn? (lambda (l234d@x) (symbol? (le5e@syntax->datum l234d@x)))) (l2146@dup-error (lambda (l234b@name) (le58@syntax-violation 'import '"two imports with different bindings" l234b@name))) (l2148@merge-substs (lambda (l2339@s l233a@subst) (letrec* ((l233e@insert-to-subst (lambda (l233f@a l2340@subst) (let ((l2343@name (car l233f@a)) (l2344@label (cdr l233f@a))) (let ((l2347@t (assq l2343@name l2340@subst))) (if l2347@t ((lambda (l2349@x) (if (eq? (cdr l2349@x) l2344@label) l2340@subst (l2146@dup-error l2343@name))) l2347@t) (cons l233f@a l2340@subst))))))) (if (null? l2339@s) l233a@subst (l233e@insert-to-subst (car l2339@s) (l2148@merge-substs (cdr l2339@s) l233a@subst)))))) (l214a@exclude* (lambda (l2309@sym* l230a@subst) (letrec* ((l230e@exclude (lambda (l2327@sym l2328@subst) (if (null? l2328@subst) (le58@syntax-violation 'import '"cannot rename unbound identifier" l2327@sym) (if (eq? l2327@sym (caar l2328@subst)) (values (cdar l2328@subst) (cdr l2328@subst)) (let ((l232b@a (car l2328@subst))) (call-with-values (lambda () (l230e@exclude l2327@sym (cdr l2328@subst))) (lambda (l2331@l232e l2332@l2330) (let ((l2335@subst l2332@l2330) (l2336@old l2331@l232e)) (values l2336@old (cons l232b@a l2335@subst))))))))))) (if (null? l2309@sym*) (values '() l230a@subst) (call-with-values (lambda () (l230e@exclude (car l2309@sym*) l230a@subst)) (lambda (l2313@l2310 l2314@l2312) (let ((l2317@subst l2314@l2312) (l2318@old l2313@l2310)) (call-with-values (lambda () (l214a@exclude* (cdr l2309@sym*) l2317@subst)) (lambda (l231f@l231c l2320@l231e) (let ((l2323@subst l2320@l231e) (l2324@old* l231f@l231c)) (values (cons l2318@old l2324@old*) l2323@subst))))))))))) (l214c@find* (lambda (l2301@sym* l2302@subst) (map (lambda (l2305@x) (let ((l2307@t (assq l2305@x l2302@subst))) (if l2307@t (cdr l2307@t) (le58@syntax-violation 'import '"cannot find identifier" l2305@x)))) l2301@sym*))) (l214e@rem* (lambda (l22f9@sym* l22fa@subst) (let l22ff@f ((l22fd@subst l22fa@subst)) (if (null? l22fd@subst) '() (if (memq (caar l22fd@subst) l22f9@sym*) (l22ff@f (cdr l22fd@subst)) (cons (car l22fd@subst) (l22ff@f (cdr l22fd@subst)))))))) (l2150@remove-dups (lambda (l22f7@ls) (if (null? l22f7@ls) '() (if (memq (car l22f7@ls) (cdr l22f7@ls)) (l2150@remove-dups (cdr l22f7@ls)) (cons (car l22f7@ls) (l2150@remove-dups (cdr l22f7@ls))))))) (l2152@parse-library-name (lambda (l220f@spec) (letrec* ((l2212@subversion? (lambda (l22f3@x) (let ((l22f5@x (le5e@syntax->datum l22f3@x))) (and (integer? l22f5@x) (exact? l22f5@x) (>= l22f5@x '0))))) (l2214@subversion-pred (lambda (l2293@x*) (let ((l2295@t l2293@x*)) (let ((l2297@ls/false (ld78@syntax-dispatch l2295@t 'any))) (if (and l2297@ls/false (apply (lambda (l2299@n) (l2212@subversion? l2299@n)) l2297@ls/false)) (apply (lambda (l229b@n) (lambda (l229d@x) (= l229d@x (le5e@syntax->datum l229b@n)))) l2297@ls/false) (let ((l229f@t l2295@t)) (let ((l22a1@ls/false (ld78@syntax-dispatch l229f@t '(any . each-any)))) (if (and l22a1@ls/false (apply (lambda (l22a3@p? l22a4@sub*) (eq? (le5e@syntax->datum l22a3@p?) 'and)) l22a1@ls/false)) (apply (lambda (l22a7@p? l22a8@sub*) (let ((l22ab@p* (map l2214@subversion-pred l22a8@sub*))) (lambda (l22ad@x) (for-all (lambda (l22af@p) (l22af@p l22ad@x)) l22ab@p*)))) l22a1@ls/false) (let ((l22b1@t l229f@t)) (let ((l22b3@ls/false (ld78@syntax-dispatch l22b1@t '(any . each-any)))) (if (and l22b3@ls/false (apply (lambda (l22b5@p? l22b6@sub*) (eq? (le5e@syntax->datum l22b5@p?) 'or)) l22b3@ls/false)) (apply (lambda (l22b9@p? l22ba@sub*) (let ((l22bd@p* (map l2214@subversion-pred l22ba@sub*))) (lambda (l22bf@x) (exists (lambda (l22c1@p) (l22c1@p l22bf@x)) l22bd@p*)))) l22b3@ls/false) (let ((l22c3@t l22b1@t)) (let ((l22c5@ls/false (ld78@syntax-dispatch l22c3@t '(any any)))) (if (and l22c5@ls/false (apply (lambda (l22c7@p? l22c8@sub) (eq? (le5e@syntax->datum l22c7@p?) 'not)) l22c5@ls/false)) (apply (lambda (l22cb@p? l22cc@sub) (let ((l22cf@p (l2214@subversion-pred l22cc@sub))) (lambda (l22d1@x) (not (l22cf@p l22d1@x))))) l22c5@ls/false) (let ((l22d3@t l22c3@t)) (let ((l22d5@ls/false (ld78@syntax-dispatch l22d3@t '(any any)))) (if (and l22d5@ls/false (apply (lambda (l22d7@p? l22d8@n) (and (eq? (le5e@syntax->datum l22d7@p?) '<=) (l2212@subversion? l22d8@n))) l22d5@ls/false)) (apply (lambda (l22db@p? l22dc@n) (lambda (l22df@x) (<= l22df@x (le5e@syntax->datum l22dc@n)))) l22d5@ls/false) (let ((l22e1@t l22d3@t)) (let ((l22e3@ls/false (ld78@syntax-dispatch l22e1@t '(any any)))) (if (and l22e3@ls/false (apply (lambda (l22e5@p? l22e6@n) (and (eq? (le5e@syntax->datum l22e5@p?) '>=) (l2212@subversion? l22e6@n))) l22e3@ls/false)) (apply (lambda (l22e9@p? l22ea@n) (lambda (l22ed@x) (>= l22ed@x (le5e@syntax->datum l22ea@n)))) l22e3@ls/false) (let ((l22ef@t l22e1@t)) (let ((l22f1@ls/false (ld78@syntax-dispatch l22ef@t '_))) (if l22f1@ls/false (apply (lambda () (le58@syntax-violation 'import '"invalid sub-version spec" l220f@spec l2293@x*)) l22f1@ls/false) (le58@syntax-violation '#f '"invalid syntax" l22ef@t)))))))))))))))))))))))) (l2216@version-pred (lambda (l2243@x*) (let ((l2245@t l2243@x*)) (let ((l2247@ls/false (ld78@syntax-dispatch l2245@t '()))) (if l2247@ls/false (apply (lambda () (lambda (l2249@x) '#t)) l2247@ls/false) (let ((l224b@t l2245@t)) (let ((l224d@ls/false (ld78@syntax-dispatch l224b@t '(any . each-any)))) (if (and l224d@ls/false (apply (lambda (l224f@c l2250@ver*) (eq? (le5e@syntax->datum l224f@c) 'and)) l224d@ls/false)) (apply (lambda (l2253@c l2254@ver*) (let ((l2257@p* (map l2216@version-pred l2254@ver*))) (lambda (l2259@x) (for-all (lambda (l225b@p) (l225b@p l2259@x)) l2257@p*)))) l224d@ls/false) (let ((l225d@t l224b@t)) (let ((l225f@ls/false (ld78@syntax-dispatch l225d@t '(any . each-any)))) (if (and l225f@ls/false (apply (lambda (l2261@c l2262@ver*) (eq? (le5e@syntax->datum l2261@c) 'or)) l225f@ls/false)) (apply (lambda (l2265@c l2266@ver*) (let ((l2269@p* (map l2216@version-pred l2266@ver*))) (lambda (l226b@x) (exists (lambda (l226d@p) (l226d@p l226b@x)) l2269@p*)))) l225f@ls/false) (let ((l226f@t l225d@t)) (let ((l2271@ls/false (ld78@syntax-dispatch l226f@t '(any any)))) (if (and l2271@ls/false (apply (lambda (l2273@c l2274@ver) (eq? (le5e@syntax->datum l2273@c) 'not)) l2271@ls/false)) (apply (lambda (l2277@c l2278@ver) (let ((l227b@p (l2216@version-pred l2278@ver))) (lambda (l227d@x) (not (l227b@p l227d@x))))) l2271@ls/false) (let ((l227f@t l226f@t)) (let ((l2281@ls/false (ld78@syntax-dispatch l227f@t 'each-any))) (if l2281@ls/false (apply (lambda (l2283@sub*) (let ((l2285@p* (map l2214@subversion-pred l2283@sub*))) (lambda (l2287@x) (let l228d@f ((l2289@p* l2285@p*) (l228a@x l2287@x)) (if (null? l2289@p*) '#t (if (null? l228a@x) '#f (and ((car l2289@p*) (car l228a@x)) (l228d@f (cdr l2289@p*) (cdr l228a@x))))))))) l2281@ls/false) (let ((l228f@t l227f@t)) (let ((l2291@ls/false (ld78@syntax-dispatch l228f@t '_))) (if l2291@ls/false (apply (lambda () (le58@syntax-violation 'import '"invalid version spec" l220f@spec l2243@x*)) l2291@ls/false) (le58@syntax-violation '#f '"invalid syntax" l228f@t)))))))))))))))))))))) (let l2219@f ((l2217@x l220f@spec)) (let ((l221b@t l2217@x)) (let ((l221d@ls/false (ld78@syntax-dispatch l221b@t '(each-any)))) (if l221d@ls/false (apply (lambda (l221f@version-spec*) (values '() (l2216@version-pred l221f@version-spec*))) l221d@ls/false) (let ((l2221@t l221b@t)) (let ((l2223@ls/false (ld78@syntax-dispatch l2221@t '(any . any)))) (if (and l2223@ls/false (apply (lambda (l2225@x l2226@x*) (l2144@idsyn? l2225@x)) l2223@ls/false)) (apply (lambda (l2229@x l222a@x*) (call-with-values (lambda () (l2219@f l222a@x*)) (lambda (l2231@l222e l2232@l2230) (let ((l2235@pred l2232@l2230) (l2236@name l2231@l222e)) (values (cons (le5e@syntax->datum l2229@x) l2236@name) l2235@pred))))) l2223@ls/false) (let ((l2239@t l2221@t)) (let ((l223b@ls/false (ld78@syntax-dispatch l2239@t '()))) (if l223b@ls/false (apply (lambda () (values '() (lambda (l223d@x) '#t))) l223b@ls/false) (let ((l223f@t l2239@t)) (let ((l2241@ls/false (ld78@syntax-dispatch l223f@t '_))) (if l2241@ls/false (apply (lambda () (le58@syntax-violation '#f '"invalid import spec" l220f@spec)) l2241@ls/false) (le58@syntax-violation '#f '"invalid syntax" l223f@t))))))))))))))))) (l2154@import-library (lambda (l21ff@spec*) (call-with-values (lambda () (l2152@parse-library-name l21ff@spec*)) (lambda (l2205@l2202 l2206@l2204) (let ((l2209@pred l2206@l2204) (l220a@name l2205@l2202)) (begin (if (null? l220a@name) (le58@syntax-violation 'import '"empty library name" l21ff@spec*) (void)) (let ((l220d@lib (l986@l7cd@find-library-by-name l220a@name))) (begin (if (not l220d@lib) (le58@syntax-violation 'import '"cannot find library with required name" l220a@name) (void)) (if (not (l2209@pred (l960@l781@library-version l220d@lib))) (le58@syntax-violation 'import '"library does not satisfy version specification" l21ff@spec* l220d@lib) (void)) ((lde4@imp-collector) l220d@lib) (l968@l791@library-subst l220d@lib))))))))) (l2156@get-import (lambda (l2171@spec) (let ((l2173@t l2171@spec)) (let ((l2175@ls/false (ld78@syntax-dispatch l2173@t '(any . each-any)))) (if (and l2175@ls/false (apply (lambda (l2177@x l2178@x*) (not (memq (le5e@syntax->datum l2177@x) '(for rename except only prefix library)))) l2175@ls/false)) (apply (lambda (l217b@x l217c@x*) (l2154@import-library (cons l217b@x l217c@x*))) l2175@ls/false) (let ((l217f@t l2173@t)) (let ((l2181@ls/false (ld78@syntax-dispatch l217f@t '(any any . #(each (any any)))))) (if (and l2181@ls/false (apply (lambda (l2183@rename l2184@isp l2185@old* l2186@new*) (and (eq? (le5e@syntax->datum l2183@rename) 'rename) (for-all l2144@idsyn? l2185@old*) (for-all l2144@idsyn? l2186@new*))) l2181@ls/false)) (apply (lambda (l218b@rename l218c@isp l218d@old* l218e@new*) (let ((l2193@subst (l2156@get-import l218c@isp)) (l2194@old* (map le5e@syntax->datum l218d@old*)) (l2195@new* (map le5e@syntax->datum l218e@new*))) (let ((l2199@old-label* (l214c@find* l2194@old* l2193@subst))) (let ((l219b@subst (l214e@rem* l2194@old* l2193@subst))) (l2148@merge-substs (map cons l2195@new* l2199@old-label*) l219b@subst))))) l2181@ls/false) (let ((l219d@t l217f@t)) (let ((l219f@ls/false (ld78@syntax-dispatch l219d@t '(any any . each-any)))) (if (and l219f@ls/false (apply (lambda (l21a1@except l21a2@isp l21a3@sym*) (and (eq? (le5e@syntax->datum l21a1@except) 'except) (for-all l2144@idsyn? l21a3@sym*))) l219f@ls/false)) (apply (lambda (l21a7@except l21a8@isp l21a9@sym*) (let ((l21ad@subst (l2156@get-import l21a8@isp))) (l214e@rem* (map le5e@syntax->datum l21a9@sym*) l21ad@subst))) l219f@ls/false) (let ((l21af@t l219d@t)) (let ((l21b1@ls/false (ld78@syntax-dispatch l21af@t '(any any . each-any)))) (if (and l21b1@ls/false (apply (lambda (l21b3@only l21b4@isp l21b5@sym*) (and (eq? (le5e@syntax->datum l21b3@only) 'only) (for-all l2144@idsyn? l21b5@sym*))) l21b1@ls/false)) (apply (lambda (l21b9@only l21ba@isp l21bb@sym*) (let ((l21bf@subst (l2156@get-import l21ba@isp)) (l21c0@sym* (map le5e@syntax->datum l21bb@sym*))) (let ((l21c3@sym* (l2150@remove-dups l21c0@sym*))) (let ((l21c5@lab* (l214c@find* l21c3@sym* l21bf@subst))) (map cons l21c3@sym* l21c5@lab*))))) l21b1@ls/false) (let ((l21c7@t l21af@t)) (let ((l21c9@ls/false (ld78@syntax-dispatch l21c7@t '(any any any)))) (if (and l21c9@ls/false (apply (lambda (l21cb@prefix l21cc@isp l21cd@p) (and (eq? (le5e@syntax->datum l21cb@prefix) 'prefix) (l2144@idsyn? l21cd@p))) l21c9@ls/false)) (apply (lambda (l21d1@prefix l21d2@isp l21d3@p) (let ((l21d7@subst (l2156@get-import l21d2@isp)) (l21d8@prefix (symbol->string (le5e@syntax->datum l21d3@p)))) (map (lambda (l21db@x) (cons (string->symbol (string-append l21d8@prefix (symbol->string (car l21db@x)))) (cdr l21db@x))) l21d7@subst))) l21c9@ls/false) (let ((l21dd@t l21c7@t)) (let ((l21df@ls/false (ld78@syntax-dispatch l21dd@t '(any each-any)))) (if (and l21df@ls/false (apply (lambda (l21e1@library l21e2@spec*) (eq? (le5e@syntax->datum l21e1@library) 'library)) l21df@ls/false)) (apply (lambda (l21e5@library l21e6@spec*) (l2154@import-library l21e6@spec*)) l21df@ls/false) (let ((l21e9@t l21dd@t)) (let ((l21eb@ls/false (ld78@syntax-dispatch l21e9@t '(any any . any)))) (if (and l21eb@ls/false (apply (lambda (l21ed@for l21ee@isp l21ef@rest) (eq? (le5e@syntax->datum l21ed@for) 'for)) l21eb@ls/false)) (apply (lambda (l21f3@for l21f4@isp l21f5@rest) (l2156@get-import l21f4@isp)) l21eb@ls/false) (let ((l21f9@t l21e9@t)) (let ((l21fb@ls/false (ld78@syntax-dispatch l21f9@t 'any))) (if l21fb@ls/false (apply (lambda (l21fd@spec) (le58@syntax-violation 'import '"invalid import spec" l21fd@spec)) l21fb@ls/false) (le58@syntax-violation '#f '"invalid syntax" l21f9@t))))))))))))))))))))))))))) (l2158@add-imports! (lambda (l2161@imp l2162@h) (let ((l2165@subst (l2156@get-import l2161@imp))) (for-each (lambda (l2167@x) (let ((l2169@name (car l2167@x)) (l216a@label (cdr l2167@x))) (let ((l216d@t (hashtable-ref l2162@h l2169@name '#f))) (if l216d@t ((lambda (l216f@l) (if (not (eq? l216f@l l216a@label)) (l2146@dup-error l2169@name) (void))) l216d@t) (hashtable-set! l2162@h l2169@name l216a@label))))) l2165@subst))))) (lambda (l2159@imp*) (let l215f@f ((l215b@imp* l2159@imp*) (l215c@h (make-eq-hashtable))) (if (null? l215b@imp*) (hashtable-entries l215c@h) (begin (l2158@add-imports! (car l215b@imp*) l215c@h) (l215f@f (cdr l215b@imp*) l215c@h))))))) (set! l287b@ldda@parse-import-spec* ldda@parse-import-spec*) (set! lddc@make-top-rib (lambda (l234f@names l2350@labels) (let ((l2353@rib (lb25@make-empty-rib))) (begin (vector-for-each (lambda (l2355@name l2356@label) (begin (if (not (symbol? l2355@name)) (error 'make-top-rib '"BUG: not a symbol" l2355@name) (void)) (lb29@extend-rib/nc! l2353@rib (make-simple-struct 'stx '5 (list l2355@name laf5@top-mark* '() '())) l2356@label))) l234f@names l2350@labels) l2353@rib)))) (set! l287c@lddc@make-top-rib lddc@make-top-rib) (set! ldde@make-collector (lambda () (let ((l2359@ls '())) (lambda l235d (let ((l235e (length l235d))) (if (= l235e '0) (apply (lambda () l2359@ls) l235d) (if (= l235e '1) (apply (lambda (l235b@x) (set! l2359@ls (laee@set-cons l235b@x l2359@ls))) l235d) (error 'apply '"invalid arg count")))))))) (set! l287d@ldde@make-collector ldde@make-collector) (set! lde0@inv-collector (l6c1@l59f@make-parameter (lambda l235f@args (assertion-violation 'inv-collector '"BUG: not initialized")) (lambda (l2361@x) (begin (if (not (procedure? l2361@x)) (assertion-violation 'inv-collector '"BUG: not a procedure" l2361@x) (void)) l2361@x)))) (set! l287e@lde0@inv-collector lde0@inv-collector) (set! lde2@vis-collector (l6c1@l59f@make-parameter (lambda l2363@args (assertion-violation 'vis-collector '"BUG: not initialized")) (lambda (l2365@x) (begin (if (not (procedure? l2365@x)) (assertion-violation 'vis-collector '"BUG: not a procedure" l2365@x) (void)) l2365@x)))) (set! l287f@lde2@vis-collector lde2@vis-collector) (set! lde4@imp-collector (l6c1@l59f@make-parameter (lambda l2367@args (assertion-violation 'imp-collector '"BUG: not initialized")) (lambda (l2369@x) (begin (if (not (procedure? l2369@x)) (assertion-violation 'imp-collector '"BUG: not a procedure" l2369@x) (void)) l2369@x)))) (set! l2880@lde4@imp-collector lde4@imp-collector) (set! lde6@chi-library-internal (lambda (l236b@e* l236c@rib l236d@top?) (call-with-values (lambda () (ldd0@chi-body* l236b@e* '() '() '() '() '() '() '() l236c@rib l236d@top?)) (lambda (l2381@l2372 l2382@l2374 l2383@l2376 l2384@l2378 l2385@l237a l2386@l237c l2387@l237e l2388@l2380) (let ((l2391@exp* l2388@l2380) (l2392@_kwd* l2387@l237e) (l2393@mod** l2386@l237c) (l2394@rhs* l2385@l237a) (l2395@lex* l2384@l2378) (l2396@mr l2383@l2376) (l2397@r l2382@l2374) (l2398@e* l2381@l2372)) (values (append (apply append (reverse l2393@mod**)) l2398@e*) l2397@r l2396@mr (reverse l2395@lex*) (reverse l2394@rhs*) l2391@exp*)))))) (set! l2881@lde6@chi-library-internal lde6@chi-library-internal) (set! lde8@chi-interaction-expr (lambda (l23a1@e l23a2@rib l23a3@r) (call-with-values (lambda () (ldd0@chi-body* (list l23a1@e) l23a3@r l23a3@r '() '() '() '() '() l23a2@rib '#t)) (lambda (l23b7@l23a8 l23b8@l23aa l23b9@l23ac l23ba@l23ae l23bb@l23b0 l23bc@l23b2 l23bd@l23b4 l23be@l23b6) (let ((l23c7@_exp* l23be@l23b6) (l23c8@_kwd* l23bd@l23b4) (l23c9@mod** l23bc@l23b2) (l23ca@rhs* l23bb@l23b0) (l23cb@lex* l23ba@l23ae) (l23cc@mr l23b9@l23ac) (l23cd@r l23b8@l23aa) (l23ce@e* l23b7@l23a8)) (let ((l23d7@e* (lda8@expand-interaction-rhs*/init* (reverse l23cb@lex*) (reverse l23ca@rhs*) (append (apply append (reverse l23c9@mod**)) l23ce@e*) l23cd@r l23cc@mr))) (let ((l23d9@e (if (null? l23d7@e*) (lad7@la38@build-void) (if (null? (cdr l23d7@e*)) (car l23d7@e*) (lad6@la36@build-sequence '#f l23d7@e*))))) (values l23d9@e l23cd@r)))))))) (set! l2882@lde8@chi-interaction-expr lde8@chi-interaction-expr) (set! ldea@library-body-expander (lambda (l23db@name l23dc@main-exp* l23dd@imp* l23de@b* l23df@top?) (letrec* ((l23e6@itc (ldde@make-collector))) (let ((l23ef@l23e8 lde4@imp-collector) (l23f0@l23ea le68@top-level-context) (l23f1@l23ec l23e6@itc) (l23f2@l23ee '#f)) (let ((l23f7@swap (lambda () (begin (let ((l23f9@t (l23ef@l23e8))) (begin (l23ef@l23e8 l23f1@l23ec) (set! l23f1@l23ec l23f9@t))) (let ((l23fb@t (l23f0@l23ea))) (begin (l23f0@l23ea l23f2@l23ee) (set! l23f2@l23ee l23fb@t))))))) (dynamic-wind l23f7@swap (lambda () (call-with-values (lambda () (ldda@parse-import-spec* l23dd@imp*)) (lambda (l2401@l23fe l2402@l2400) (let ((l2405@subst-labels l2402@l2400) (l2406@subst-names l2401@l23fe)) (let ((l2409@rib (lddc@make-top-rib l2406@subst-names l2405@subst-labels))) (letrec* ((l240c@wrap (lambda (l2487@x) (make-simple-struct 'stx '5 (list l2487@x laf5@top-mark* (list l2409@rib) '()))))) (let ((l240d@b* (map l240c@wrap l23de@b*)) (l240e@main-exp* (map l240c@wrap l23dc@main-exp*)) (l240f@rtc (ldde@make-collector)) (l2410@vtc (ldde@make-collector))) (let ((l241d@l2416 lde0@inv-collector) (l241e@l2418 lde2@vis-collector) (l241f@l241a l240f@rtc) (l2420@l241c l2410@vtc)) (let ((l2425@swap (lambda () (begin (let ((l2427@t (l241d@l2416))) (begin (l241d@l2416 l241f@l241a) (set! l241f@l241a l2427@t))) (let ((l2429@t (l241e@l2418))) (begin (l241e@l2418 l2420@l241c) (set! l2420@l241c l2429@t))))))) (dynamic-wind l2425@swap (lambda () (call-with-values (lambda () (lde6@chi-library-internal l240d@b* l2409@rib l23df@top?)) (lambda (l2437@l242c l2438@l242e l2439@l2430 l243a@l2432 l243b@l2434 l243c@l2436) (let ((l2443@internal-exp* l243c@l2436) (l2444@rhs* l243b@l2434) (l2445@lex* l243a@l2432) (l2446@mr l2439@l2430) (l2447@r l2438@l242e) (l2448@init* l2437@l242c)) (call-with-values (lambda () (ldd4@parse-exports (append l240e@main-exp* l2443@internal-exp*))) (lambda (l2453@l2450 l2454@l2452) (let ((l2457@exp-id* l2454@l2452) (l2458@exp-name* l2453@l2450)) (begin (lb2d@seal-rib! l2409@rib) (let ((l245b@init* (ld96@chi-expr* l2448@init* l2447@r l2446@mr))) (let ((l245d@rhs* (ldaa@chi-rhs* l2444@rhs* l2447@r l2446@mr))) (begin (lb2f@unseal-rib! l2409@rib) (let ((l245f@loc* (map lafb@gen-global l2445@lex*)) (l2460@export-subst (le42@make-export-subst l2458@exp-name* l2457@exp-id*))) (letrec* ((l2464@errstr '"attempt to export mutated variable")) (call-with-values (lambda () (le44@make-export-env/macros l2445@lex* l245f@loc* l2447@r)) (lambda (l246b@l2466 l246c@l2468 l246d@l246a) (let ((l2471@macro* l246d@l246a) (l2472@global* l246c@l2468) (l2473@export-env l246b@l2466)) (begin (for-each (lambda (l2477@s) (let ((l2479@name (car l2477@s)) (l247a@label (cdr l2477@s))) (let ((l247d@p (assq l247a@label l2473@export-env))) (if l247d@p (let ((l247f@b (cdr l247d@p))) (let ((l2481@type (car l247f@b))) (if (eq? l2481@type 'mutable) (le58@syntax-violation 'export l2464@errstr l2479@name) (void)))) (void))))) l2460@export-subst) (let ((l2483@invoke-body (ladc@la42@build-library-letrec* '#f l23db@name l2445@lex* l245f@loc* l245d@rhs* (if (null? l245b@init*) (lad7@la38@build-void) (lad6@la36@build-sequence '#f l245b@init*)))) (l2484@invoke-definitions (map lad3@l995@build-global-define (map cdr l2472@global*)))) (values (l23e6@itc) (l240f@rtc) (l2410@vtc) (lad6@la36@build-sequence '#f (append l2484@invoke-definitions (list l2483@invoke-body))) l2471@macro* l2460@export-subst l2473@export-env))))))))))))))))))) l2425@swap)))))))))) l23f7@swap)))))) (set! l2883@ldea@library-body-expander ldea@library-body-expander) (set! ldec@core-library-expander (lambda (l2489@e l248a@verify-name) (call-with-values (lambda () (ldd8@parse-library l2489@e)) (lambda (l2495@l248e l2496@l2490 l2497@l2492 l2498@l2494) (let ((l249d@b* l2498@l2494) (l249e@imp* l2497@l2492) (l249f@exp* l2496@l2490) (l24a0@name* l2495@l248e)) (call-with-values (lambda () (ldd6@parse-library-name l24a0@name*)) (lambda (l24a9@l24a6 l24aa@l24a8) (let ((l24ad@ver l24aa@l24a8) (l24ae@name l24a9@l24a6)) (begin (l248a@verify-name l24ae@name) (call-with-values (lambda () (ldea@library-body-expander l24ae@name l249f@exp* l249e@imp* l249d@b* '#f)) (lambda (l24bf@l24b2 l24c0@l24b4 l24c1@l24b6 l24c2@l24b8 l24c3@l24ba l24c4@l24bc l24c5@l24be) (let ((l24cd@export-env l24c5@l24be) (l24ce@export-subst l24c4@l24bc) (l24cf@visit-code l24c3@l24ba) (l24d0@invoke-code l24c2@l24b8) (l24d1@visit-req* l24c1@l24b6) (l24d2@invoke-req* l24c0@l24b4) (l24d3@imp* l24bf@l24b2)) (values l24ae@name l24ad@ver l24d3@imp* l24d2@invoke-req* l24d1@visit-req* l24d0@invoke-code l24cf@visit-code l24ce@export-subst l24cd@export-env))))))))))))) (set! l2884@ldec@core-library-expander ldec@core-library-expander) (set! ldee@parse-top-level-program (lambda (l24db@e*) (let ((l24dd@t l24db@e*)) (let ((l24df@ls/false (ld78@syntax-dispatch l24dd@t '((any . each-any) . each-any)))) (if (and l24df@ls/false (apply (lambda (l24e1@import l24e2@imp* l24e3@b*) (eq? (le5e@syntax->datum l24e1@import) 'import)) l24df@ls/false)) (apply (lambda (l24e7@import l24e8@imp* l24e9@b*) (values l24e8@imp* l24e9@b*)) l24df@ls/false) (let ((l24ed@t l24dd@t)) (let ((l24ef@ls/false (ld78@syntax-dispatch l24ed@t '((any . any) . any)))) (if (and l24ef@ls/false (apply (lambda (l24f1@import l24f2@x l24f3@y) (eq? (le5e@syntax->datum l24f1@import) 'import)) l24ef@ls/false)) (apply (lambda (l24f7@import l24f8@x l24f9@y) (le58@syntax-violation 'expander '"invalid syntax of top-level program" (lb6b@syntax-car l24db@e*))) l24ef@ls/false) (let ((l24fd@t l24ed@t)) (let ((l24ff@ls/false (ld78@syntax-dispatch l24fd@t '_))) (if l24ff@ls/false (apply (lambda () (assertion-violation 'expander '"top-level program is missing an (import ---) clause")) l24ff@ls/false) (le58@syntax-violation '#f '"invalid syntax" l24fd@t)))))))))))) (set! l2885@ldee@parse-top-level-program ldee@parse-top-level-program) (set! ldf0@top-level-expander (lambda (l2501@e*) (call-with-values (lambda () (ldee@parse-top-level-program l2501@e*)) (lambda (l2507@l2504 l2508@l2506) (let ((l250b@b* l2508@l2506) (l250c@imp* l2507@l2504)) (call-with-values (lambda () (ldea@library-body-expander '() '() l250c@imp* l250b@b* '#t)) (lambda (l251d@l2510 l251e@l2512 l251f@l2514 l2520@l2516 l2521@l2518 l2522@l251a l2523@l251c) (let ((l252b@export-env l2523@l251c) (l252c@export-subst l2522@l251a) (l252d@visit-code l2521@l2518) (l252e@invoke-code l2520@l2516) (l252f@visit-req* l251f@l2514) (l2530@invoke-req* l251e@l2512) (l2531@imp* l251d@l2510)) (values l2530@invoke-req* l252e@invoke-code))))))))) (set! l2886@ldf0@top-level-expander ldf0@top-level-expander) (set! ldf2@rp (l6be@l599@make-record-printer 'env (lambda (l2539@x l253a@p l253b@wr) (display '"#<environment>" l253a@p)))) (set! l2887@ldf2@rp ldf2@rp) (set! ldfc@env? (lambda (l253f@x) (and (simple-struct? l253f@x) (eq? (simple-struct-name l253f@x) 'env)))) (set! l2888@ldfc@env? ldfc@env?) (set! ldfe@env-names (lambda (l2541@x) (simple-struct-ref l2541@x '0))) (set! l2889@ldfe@env-names ldfe@env-names) (set! le00@set-env-names! (lambda (l2543@x l2544@val) (simple-struct-set! l2543@x '0 l2544@val))) (set! l288a@le00@set-env-names! le00@set-env-names!) (set! le02@env-labels (lambda (l2547@x) (simple-struct-ref l2547@x '1))) (set! l288b@le02@env-labels le02@env-labels) (set! le04@set-env-labels! (lambda (l2549@x l254a@val) (simple-struct-set! l2549@x '1 l254a@val))) (set! l288c@le04@set-env-labels! le04@set-env-labels!) (set! le06@env-itc (lambda (l254d@x) (simple-struct-ref l254d@x '2))) (set! l288d@le06@env-itc le06@env-itc) (set! le08@set-env-itc! (lambda (l254f@x l2550@val) (simple-struct-set! l254f@x '2 l2550@val))) (set! l288e@le08@set-env-itc! le08@set-env-itc!) (set! le0a@dummy '3) (set! l288f@le0a@dummy le0a@dummy) (set! le0c@rp (l6be@l599@make-record-printer 'interaction-env (lambda (l2553@x l2554@p l2555@wr) (display '"#<environment>" l2554@p)))) (set! l2890@le0c@rp le0c@rp) (set! le16@interaction-env? (lambda (l2559@x) (and (simple-struct? l2559@x) (eq? (simple-struct-name l2559@x) 'interaction-env)))) (set! l2891@le16@interaction-env? le16@interaction-env?) (set! le18@interaction-env-rib (lambda (l255b@x) (simple-struct-ref l255b@x '0))) (set! l2892@le18@interaction-env-rib le18@interaction-env-rib) (set! le1a@set-interaction-env-rib! (lambda (l255d@x l255e@val) (simple-struct-set! l255d@x '0 l255e@val))) (set! l2893@le1a@set-interaction-env-rib! le1a@set-interaction-env-rib!) (set! le1c@interaction-env-r (lambda (l2561@x) (simple-struct-ref l2561@x '1))) (set! l2894@le1c@interaction-env-r le1c@interaction-env-r) (set! le1e@set-interaction-env-r! (lambda (l2563@x l2564@val) (simple-struct-set! l2563@x '1 l2564@val))) (set! l2895@le1e@set-interaction-env-r! le1e@set-interaction-env-r!) (set! le20@interaction-env-locs (lambda (l2567@x) (simple-struct-ref l2567@x '2))) (set! l2896@le20@interaction-env-locs le20@interaction-env-locs) (set! le22@set-interaction-env-locs! (lambda (l2569@x l256a@val) (simple-struct-set! l2569@x '2 l256a@val))) (set! l2897@le22@set-interaction-env-locs! le22@set-interaction-env-locs!) (set! le24@dummy '3) (set! l2898@le24@dummy le24@dummy) (set! le26@interaction-environment-symbols (lambda () (le2e@environment-symbols (le66@interaction-environment)))) (set! l2899@le26@interaction-environment-symbols le26@interaction-environment-symbols) (set! le28@environment-bindings (lambda (l256d@e) (vector->list (vector-map (lambda (l256f@name l2570@label) (le2a@parse-binding (cons l256f@name (l98c@l7d9@imported-label->binding l2570@label)))) (ldfe@env-names l256d@e) (le02@env-labels l256d@e))))) (set! l289a@le28@environment-bindings le28@environment-bindings) (set! le2a@parse-binding (lambda (l2573@b) (cons (car l2573@b) (let ((l2575@t (cadr l2573@b))) (if (memv l2575@t '(core-prim global)) 'procedure (if (memv l2575@t '(core-macro macro global-macro)) 'syntax (if (memv l2575@t '($core-rtd)) 'record (if (eq? (car l2573@b) (cadr l2573@b)) 'syntax 'unknown)))))))) (set! l289b@le2a@parse-binding le2a@parse-binding) (set! le2c@environment? (lambda (l2577@x) (or (ldfc@env? l2577@x) (le16@interaction-env? l2577@x)))) (set! l289c@le2c@environment? le2c@environment?) (set! le2e@environment-symbols (lambda (l2579@x) (if (ldfc@env? l2579@x) (vector->list (ldfe@env-names l2579@x)) (if (le16@interaction-env? l2579@x) (map values (lb0f@rib-sym* (le18@interaction-env-rib l2579@x))) (assertion-violation 'environment-symbols '"not an environment" l2579@x))))) (set! l289d@le2e@environment-symbols le2e@environment-symbols) (set! le30@environment (lambda l257b@imp* (let ((l257d@itc (ldde@make-collector))) (let ((l2583@l2580 lde4@imp-collector) (l2584@l2582 l257d@itc)) (let ((l2587@swap (lambda () (let ((l2589@t (l2583@l2580))) (begin (l2583@l2580 l2584@l2582) (set! l2584@l2582 l2589@t)))))) (dynamic-wind l2587@swap (lambda () (call-with-values (lambda () (ldda@parse-import-spec* l257b@imp*)) (lambda (l258f@l258c l2590@l258e) (let ((l2593@subst-labels l2590@l258e) (l2594@subst-names l258f@l258c)) (make-simple-struct 'env '4 (list l2594@subst-names l2593@subst-labels l257d@itc)))))) l2587@swap)))))) (set! l289e@le30@environment le30@environment) (set! le32@null-environment (lambda (l2597@n) (begin (if (not (eqv? l2597@n '5)) (assertion-violation 'null-environment '"not 5" l2597@n) (void)) (le30@environment '(psyntax null-environment-5))))) (set! l289f@le32@null-environment le32@null-environment) (set! le34@scheme-report-environment (lambda (l2599@n) (begin (if (not (eqv? l2599@n '5)) (assertion-violation 'scheme-report-environment '"not 5" l2599@n) (void)) (le30@environment '(psyntax scheme-report-environment-5))))) (set! l28a0@le34@scheme-report-environment le34@scheme-report-environment) (set! le36@expand (lambda (l259b@x l259c@env) (if (ldfc@env? l259c@env) (let ((l259f@rib (lddc@make-top-rib (ldfe@env-names l259c@env) (le02@env-labels l259c@env)))) (let ((l25a1@x (make-simple-struct 'stx '5 (list l259b@x laf5@top-mark* (list l259f@rib) '()))) (l25a2@itc (le06@env-itc l259c@env)) (l25a3@rtc (ldde@make-collector)) (l25a4@vtc (ldde@make-collector))) (let ((l25a9@x (let ((l25bb@l25ac le68@top-level-context) (l25bc@l25ae lde0@inv-collector) (l25bd@l25b0 lde2@vis-collector) (l25be@l25b2 lde4@imp-collector) (l25bf@l25b4 '#f) (l25c0@l25b6 l25a3@rtc) (l25c1@l25b8 l25a4@vtc) (l25c2@l25ba l25a2@itc)) (let ((l25cb@swap (lambda () (begin (let ((l25cd@t (l25bb@l25ac))) (begin (l25bb@l25ac l25bf@l25b4) (set! l25bf@l25b4 l25cd@t))) (let ((l25cf@t (l25bc@l25ae))) (begin (l25bc@l25ae l25c0@l25b6) (set! l25c0@l25b6 l25cf@t))) (let ((l25d1@t (l25bd@l25b0))) (begin (l25bd@l25b0 l25c1@l25b8) (set! l25c1@l25b8 l25d1@t))) (let ((l25d3@t (l25be@l25b2))) (begin (l25be@l25b2 l25c2@l25ba) (set! l25c2@l25ba l25d3@t))))))) (dynamic-wind l25cb@swap (lambda () (ld9a@chi-expr l25a1@x '() '())) l25cb@swap))))) (begin (lb2d@seal-rib! l259f@rib) (values l25a9@x (l25a3@rtc)))))) (if (le16@interaction-env? l259c@env) (let ((l25d5@rib (le18@interaction-env-rib l259c@env)) (l25d6@r (le1c@interaction-env-r l259c@env)) (l25d7@rtc (ldde@make-collector))) (let ((l25db@x (make-simple-struct 'stx '5 (list l259b@x laf5@top-mark* (list l25d5@rib) '())))) (call-with-values (lambda () (let ((l25f1@l25e2 le68@top-level-context) (l25f2@l25e4 lde0@inv-collector) (l25f3@l25e6 lde2@vis-collector) (l25f4@l25e8 lde4@imp-collector) (l25f5@l25ea l259c@env) (l25f6@l25ec l25d7@rtc) (l25f7@l25ee (ldde@make-collector)) (l25f8@l25f0 (ldde@make-collector))) (let ((l2601@swap (lambda () (begin (let ((l2603@t (l25f1@l25e2))) (begin (l25f1@l25e2 l25f5@l25ea) (set! l25f5@l25ea l2603@t))) (let ((l2605@t (l25f2@l25e4))) (begin (l25f2@l25e4 l25f6@l25ec) (set! l25f6@l25ec l2605@t))) (let ((l2607@t (l25f3@l25e6))) (begin (l25f3@l25e6 l25f7@l25ee) (set! l25f7@l25ee l2607@t))) (let ((l2609@t (l25f4@l25e8))) (begin (l25f4@l25e8 l25f8@l25f0) (set! l25f8@l25f0 l2609@t))))))) (dynamic-wind l2601@swap (lambda () (lde8@chi-interaction-expr l25db@x l25d5@rib l25d6@r)) l2601@swap)))) (lambda (l260b@l25de l260c@l25e0) (let ((l260f@r^ l260c@l25e0) (l2610@e l260b@l25de)) (begin (le1e@set-interaction-env-r! l259c@env l260f@r^) (values l2610@e (l25d7@rtc)))))))) (assertion-violation 'expand '"not an environment" l259c@env))))) (set! l28a1@le36@expand le36@expand) (set! le38@eval (lambda (l2613@x l2614@env) (begin (if (not (le2c@environment? l2614@env)) (error 'eval '"not an environment" l2614@env) (void)) (call-with-values (lambda () (le36@expand l2613@x l2614@env)) (lambda (l261b@l2618 l261c@l261a) (let ((l261f@invoke-req* l261c@l261a) (l2620@x l261b@l2618)) (begin (for-each l98d@l7db@invoke-library l261f@invoke-req*) (eval-core (l717@l6cf@expanded->core l2620@x))))))))) (set! l28a2@le38@eval le38@eval) (set! le3a@library-expander (lambda l2691 (let ((l2692 (length l2691))) (if (= l2692 '3) (apply (lambda (l2623@x l2624@filename l2625@verify-name) (letrec* ((l262a@build-visit-code (lambda (l267f@macro*) (if (null? l267f@macro*) (lad7@la38@build-void) (lad6@la36@build-sequence '#f (map (lambda (l2681@x) (let ((l2683@loc (car l2681@x)) (l2684@src (cddr l2681@x))) (list 'set! l2683@loc l2684@src))) l267f@macro*))))) (l262c@visit! (lambda (l2677@macro*) (for-each (lambda (l2679@x) (let ((l267b@loc (car l2679@x)) (l267c@proc (cadr l2679@x))) (set-symbol-value! l267b@loc l267c@proc))) l2677@macro*)))) (call-with-values (lambda () (ldec@core-library-expander l2623@x l2625@verify-name)) (lambda (l263f@l262e l2640@l2630 l2641@l2632 l2642@l2634 l2643@l2636 l2644@l2638 l2645@l263a l2646@l263c l2647@l263e) (let ((l2651@export-env l2647@l263e) (l2652@export-subst l2646@l263c) (l2653@macro* l2645@l263a) (l2654@invoke-code l2644@l2638) (l2655@vis* l2643@l2636) (l2656@inv* l2642@l2634) (l2657@imp* l2641@l2632) (l2658@ver l2640@l2630) (l2659@name l263f@l262e)) (let ((l2663@id (gensym)) (l2664@name l2659@name) (l2665@ver l2658@ver) (l2666@imp* (map l991@l7e3@library-spec l2657@imp*)) (l2667@vis* (map l991@l7e3@library-spec l2655@vis*)) (l2668@inv* (map l991@l7e3@library-spec l2656@inv*)) (l2669@visit-proc (lambda () (l262c@visit! l2653@macro*))) (l266a@invoke-proc (lambda () (eval-core (l717@l6cf@expanded->core l2654@invoke-code)))) (l266b@visit-code (l262a@build-visit-code l2653@macro*)) (l266c@invoke-code l2654@invoke-code)) (begin (l98b@l7d7@install-library l2663@id l2664@name l2665@ver l2666@imp* l2667@vis* l2668@inv* l2652@export-subst l2651@export-env l2669@visit-proc l266a@invoke-proc l266b@visit-code l266c@invoke-code '#t l2624@filename) (values l2663@id l2664@name l2665@ver l2666@imp* l2667@vis* l2668@inv* l266c@invoke-code l266b@visit-code l2652@export-subst l2651@export-env)))))))) l2691) (if (= l2692 '2) (apply (lambda (l2687@x l2688@filename) (le3a@library-expander l2687@x l2688@filename (lambda (l268b@x) (values)))) l2691) (if (= l2692 '1) (apply (lambda (l268d@x) (le3a@library-expander l268d@x '#f (lambda (l268f@x) (values)))) l2691) (error 'apply '"invalid arg count"))))))) (set! l28a3@le3a@library-expander le3a@library-expander) (set! le3c@boot-library-expand (lambda (l2693@x) (call-with-values (lambda () (le3a@library-expander l2693@x)) (lambda (l26a9@l2696 l26aa@l2698 l26ab@l269a l26ac@l269c l26ad@l269e l26ae@l26a0 l26af@l26a2 l26b0@l26a4 l26b1@l26a6 l26b2@l26a8) (let ((l26bd@export-env l26b2@l26a8) (l26be@export-subst l26b1@l26a6) (l26bf@visit-code l26b0@l26a4) (l26c0@invoke-code l26af@l26a2) (l26c1@inv* l26ae@l26a0) (l26c2@vis* l26ad@l269e) (l26c3@imp* l26ac@l269c) (l26c4@ver l26ab@l269a) (l26c5@name l26aa@l2698) (l26c6@id l26a9@l2696)) (values l26c5@name l26c0@invoke-code l26be@export-subst l26bd@export-env)))))) (set! l28a4@le3c@boot-library-expand le3c@boot-library-expand) (set! le3e@rev-map-append (lambda (l26d1@f l26d2@ls l26d3@ac) (if (null? l26d2@ls) l26d3@ac (le3e@rev-map-append l26d1@f (cdr l26d2@ls) (cons (l26d1@f (car l26d2@ls)) l26d3@ac))))) (set! l28a5@le3e@rev-map-append le3e@rev-map-append) (set! le40@build-exports (lambda (l26d7@lex*+loc* l26d8@init*) (lad6@la36@build-sequence '#f (cons (lad7@la38@build-void) (le3e@rev-map-append (lambda (l26db@x) (list 'set! (cdr l26db@x) (car l26db@x))) l26d7@lex*+loc* l26d8@init*))))) (set! l28a6@le40@build-exports le40@build-exports) (set! le42@make-export-subst (lambda (l26dd@name* l26de@id*) (map (lambda (l26e1@name l26e2@id) (let ((l26e5@label (lb87@id->label l26e2@id))) (begin (if (not l26e5@label) (le58@syntax-violation '#f '"cannot export unbound identifier" l26e2@id) (void)) (cons l26e1@name l26e5@label)))) l26dd@name* l26de@id*))) (set! l28a7@le42@make-export-subst le42@make-export-subst) (set! le44@make-export-env/macros (lambda (l26e7@lex* l26e8@loc* l26e9@r) (letrec* ((l26ee@lookup (lambda (l270b@x) (let l2713@f ((l270d@x l270b@x) (l270e@lex* l26e7@lex*) (l270f@loc* l26e8@loc*)) (if (pair? l270e@lex*) (if (eq? l270d@x (car l270e@lex*)) (car l270f@loc*) (l2713@f l270d@x (cdr l270e@lex*) (cdr l270f@loc*))) (assertion-violation 'lookup-make-export '"BUG")))))) (let l26f7@f ((l26ef@r l26e9@r) (l26f0@env '()) (l26f1@global* '()) (l26f2@macro* '())) (if (null? l26ef@r) (values l26f0@env l26f1@global* l26f2@macro*) (let ((l26f9@x (car l26ef@r))) (let ((l26fb@label (car l26f9@x)) (l26fc@b (cdr l26f9@x))) (let ((l26ff@t (lb8d@binding-type l26fc@b))) (if (memv l26ff@t '(lexical)) (let ((l2701@v (lb8f@binding-value l26fc@b))) (let ((l2703@loc (l26ee@lookup (ld02@lexical-var l2701@v))) (l2704@type (if (ld04@lexical-mutable? l2701@v) 'mutable 'global))) (l26f7@f (cdr l26ef@r) (cons (cons* l26fb@label l2704@type l2703@loc) l26f0@env) (cons (cons (ld02@lexical-var l2701@v) l2703@loc) l26f1@global*) l26f2@macro*))) (if (memv l26ff@t '(local-macro)) (let ((l2707@loc (gensym))) (l26f7@f (cdr l26ef@r) (cons (cons* l26fb@label 'global-macro l2707@loc) l26f0@env) l26f1@global* (cons (cons l2707@loc (lb8f@binding-value l26fc@b)) l26f2@macro*))) (if (memv l26ff@t '(local-macro!)) (let ((l2709@loc (gensym))) (l26f7@f (cdr l26ef@r) (cons (cons* l26fb@label 'global-macro! l2709@loc) l26f0@env) l26f1@global* (cons (cons l2709@loc (lb8f@binding-value l26fc@b)) l26f2@macro*))) (if (memv l26ff@t '($rtd $module)) (l26f7@f (cdr l26ef@r) (cons l26f9@x l26f0@env) l26f1@global* l26f2@macro*) (assertion-violation 'expander '"BUG: do not know how to export" (lb8d@binding-type l26fc@b) (lb8f@binding-value l26fc@b)))))))))))))) (set! l28a8@le44@make-export-env/macros le44@make-export-env/macros) (set! le46@generate-temporaries (lambda (l2715@ls) (let ((l2717@t l2715@ls)) (let ((l2719@ls/false (ld78@syntax-dispatch l2717@t 'each-any))) (if l2719@ls/false (apply (lambda (l271b@ls) (map (lambda (l271d@x) (make-simple-struct 'stx '5 (list (let ((l271f@x (le5e@syntax->datum l271d@x))) (if (or (symbol? l271f@x) (string? l271f@x)) (gensym l271f@x) (gensym 't))) laf5@top-mark* '() '()))) l271b@ls)) l2719@ls/false) (let ((l2721@t l2717@t)) (let ((l2723@ls/false (ld78@syntax-dispatch l2721@t '_))) (if l2723@ls/false (apply (lambda () (assertion-violation 'generate-temporaries '"not a list")) l2723@ls/false) (le58@syntax-violation '#f '"invalid syntax" l2721@t))))))))) (set! l28a9@le46@generate-temporaries le46@generate-temporaries) (set! le48@free-identifier=? (lambda (l2725@x l2726@y) (if (lb71@id? l2725@x) (if (lb71@id? l2726@y) (lb77@free-id=? l2725@x l2726@y) (assertion-violation 'free-identifier=? '"not an identifier" l2726@y)) (assertion-violation 'free-identifier=? '"not an identifier" l2725@x)))) (set! l28aa@le48@free-identifier=? le48@free-identifier=?) (set! le4a@bound-identifier=? (lambda (l2729@x l272a@y) (if (lb71@id? l2729@x) (if (lb71@id? l272a@y) (lb75@bound-id=? l2729@x l272a@y) (assertion-violation 'bound-identifier=? '"not an identifier" l272a@y)) (assertion-violation 'bound-identifier=? '"not an identifier" l2729@x)))) (set! l28ab@le4a@bound-identifier=? le4a@bound-identifier=?) (set! le4c@make-source-condition (lambda (l272d@x) (letrec* ((l2737@l2732 (make-record-type-descriptor '&source-information &condition-rtd 'l2735 '#f '#f '#((immutable file-name) (immutable line)))) (l2739@l2734 '#f) (l273b@l2733 (make-record-constructor-descriptor l2737@l2732 &condition-rcd l2739@l2734)) (l273e@l2731 (record-predicate l2737@l2732)) (l2740@make-source-condition (record-constructor l273b@l2733)) (l2742@l272f (record-accessor l2737@l2732 '0)) (l2744@l2730 (record-accessor l2737@l2732 '1)) (l2746@source-condition? (condition-predicate l2737@l2732)) (l2748@source-filename (condition-accessor l2737@l2732 l2742@l272f)) (l274a@source-character (condition-accessor l2737@l2732 l2744@l2730))) (if (and (pair? l272d@x) (pair? (cdr l272d@x))) (l2740@make-source-condition (car l272d@x) (cadr l272d@x)) (condition))))) (set! l28ac@le4c@make-source-condition le4c@make-source-condition) (set! le4e@extract-position-condition (lambda (l274b@x) (le4c@make-source-condition (le50@expression-position l274b@x)))) (set! l28ad@le4e@extract-position-condition le4e@extract-position-condition) (set! le50@expression-position (lambda (l274d@x) (and (lb3d@stx? l274d@x) (let ((l274f@x (lb3f@stx-expr l274d@x))) (and (l6b5@l587@annotation? l274f@x) (l6b6@l589@annotation-source l274f@x)))))) (set! l28ae@le50@expression-position le50@expression-position) (set! le52@assertion-error (lambda (l2751@expr l2752@pos) (raise (condition (make-assertion-violation) (make-who-condition 'assert) (make-message-condition '"assertion failed") (make-irritants-condition (list l2751@expr)) (le4c@make-source-condition l2752@pos))))) (set! l28af@le52@assertion-error le52@assertion-error) (set! le54@syntax-error (lambda (l2755@x . l2757@args) (begin (if (not (for-all string? l2757@args)) (assertion-violation 'syntax-error '"invalid argument" l2757@args) (void)) (raise (condition (make-message-condition (if (null? l2757@args) '"invalid syntax" (apply string-append l2757@args))) (make-syntax-violation (le5e@syntax->datum l2755@x) '#f) (le4e@extract-position-condition l2755@x)))))) (set! l28b0@le54@syntax-error le54@syntax-error) (set! le56@syntax-violation* (lambda (l2759@who l275a@msg l275b@form l275c@condition-object) (begin (if (not (string? l275a@msg)) (assertion-violation 'syntax-violation '"message is not a string" l275a@msg) (void)) (let ((l2761@who (if (or (string? l2759@who) (symbol? l2759@who)) l2759@who (if (not l2759@who) (let ((l2763@t l275b@form)) (let ((l2765@ls/false (ld78@syntax-dispatch l2763@t 'any))) (if (and l2765@ls/false (apply (lambda (l2767@id) (lb71@id? l2767@id)) l2765@ls/false)) (apply (lambda (l2769@id) (le5e@syntax->datum l2769@id)) l2765@ls/false) (let ((l276b@t l2763@t)) (let ((l276d@ls/false (ld78@syntax-dispatch l276b@t '(any . any)))) (if (and l276d@ls/false (apply (lambda (l276f@id l2770@rest) (lb71@id? l276f@id)) l276d@ls/false)) (apply (lambda (l2773@id l2774@rest) (le5e@syntax->datum l2773@id)) l276d@ls/false) (let ((l2777@t l276b@t)) (let ((l2779@ls/false (ld78@syntax-dispatch l2777@t '_))) (if l2779@ls/false (apply (lambda () '#f) l2779@ls/false) (le58@syntax-violation '#f '"invalid syntax" l2777@t)))))))))) (assertion-violation 'syntax-violation '"invalid who argument" l2759@who))))) (raise (condition (if l2761@who (make-who-condition l2761@who) (condition)) (make-message-condition l275a@msg) l275c@condition-object (le4e@extract-position-condition l275b@form))))))) (set! l28b1@le56@syntax-violation* le56@syntax-violation*) (set! le58@syntax-violation (lambda l2789 (let ((l278a (length l2789))) (if (= l278a '3) (apply (lambda (l277b@who l277c@msg l277d@form) (le58@syntax-violation l277b@who l277c@msg l277d@form '#f)) l2789) (if (= l278a '4) (apply (lambda (l2781@who l2782@msg l2783@form l2784@subform) (le56@syntax-violation* l2781@who l2782@msg l2783@form (make-syntax-violation (le5e@syntax->datum l2783@form) (le5e@syntax->datum l2784@subform)))) l2789) (error 'apply '"invalid arg count")))))) (set! l28b2@le58@syntax-violation le58@syntax-violation) (set! le5a@identifier? (lambda (l278b@x) (lb71@id? l278b@x))) (set! l28b3@le5a@identifier? le5a@identifier?) (set! le5c@datum->syntax (lambda (l278d@id l278e@datum) (if (lb71@id? l278d@id) (lb51@datum->stx l278d@id l278e@datum) (assertion-violation 'datum->syntax '"not an identifier" l278d@id)))) (set! l28b4@le5c@datum->syntax le5c@datum->syntax) (set! le5e@syntax->datum (lambda (l2791@x) (lb85@stx->datum l2791@x))) (set! l28b5@le5e@syntax->datum le5e@syntax->datum) (set! le60@ungensym-all (lambda (l2793@code) (if (pair? l2793@code) (cons (le60@ungensym-all (car l2793@code)) (le60@ungensym-all (cdr l2793@code))) (if (symbol? l2793@code) (ungensym l2793@code) l2793@code)))) (set! l28b6@le60@ungensym-all le60@ungensym-all) (set! le62@compile-r6rs-top-level (lambda (l2795@x*) (call-with-values (lambda () (ldf0@top-level-expander l2795@x*)) (lambda (l279b@l2798 l279c@l279a) (let ((l279f@invoke-code l279c@l279a) (l27a0@lib* l279b@l2798)) (lambda () (begin (for-each l98d@l7db@invoke-library l27a0@lib*) (let ((l27a3@expanded (l717@l6cf@expanded->core l279f@invoke-code))) (begin (if (symbol-value 'debug-expand) (format '#t '"psyntax expanded=~a\n" (le60@ungensym-all l27a3@expanded)) (void)) (eval-core l27a3@expanded)))))))))) (set! l28b7@le62@compile-r6rs-top-level le62@compile-r6rs-top-level) (set! le64@pre-compile-r6rs-top-level (lambda (l27a5@x*) (call-with-values (lambda () (ldf0@top-level-expander l27a5@x*)) (lambda (l27ab@l27a8 l27ac@l27aa) (let ((l27af@invoke-code l27ac@l27aa) (l27b0@lib* l27ab@l27a8)) (begin (for-each l98d@l7db@invoke-library l27b0@lib*) (l6bf@l59b@compile-core (l717@l6cf@expanded->core l27af@invoke-code)))))))) (set! l28b8@le64@pre-compile-r6rs-top-level le64@pre-compile-r6rs-top-level) (set! le66@interaction-environment (let ((l27b3@the-env '#f)) (lambda () (or l27b3@the-env (let ((l27b5@lib (l986@l7cd@find-library-by-name '(mosh interaction))) (l27b6@rib (lb25@make-empty-rib))) (begin (let ((l27b9@subst (l968@l791@library-subst l27b5@lib))) (begin (lb11@set-rib-sym*! l27b6@rib (map car l27b9@subst)) (lb15@set-rib-mark**! l27b6@rib (map (lambda (l27bb@x) laf5@top-mark*) l27b9@subst)) (lb19@set-rib-label*! l27b6@rib (map cdr l27b9@subst)))) (let ((l27bd@env (make-simple-struct 'interaction-env '4 (list l27b6@rib '() '())))) (begin (set! l27b3@the-env l27bd@env) l27bd@env)))))))) (set! l28b9@le66@interaction-environment le66@interaction-environment) (set! le68@top-level-context (l6c1@l59f@make-parameter '#f)) (set! l28ba@le68@top-level-context le68@top-level-context) (l983@l7c7@current-library-expander le3a@library-expander))
(begin (begin (l714@l6c9@current-primitive-locations (lambda (l2e09@x) (let ((l2e0b@t (assq l2e09@x '((syntax-error . l28b0@le54@syntax-error) (syntax-dispatch . l284e@ld78@syntax-dispatch) (load . l2a3a@l28e1@load) (interaction-environment . l28b9@le66@interaction-environment) (library-path . l97b@l7b7@library-path) (mosh-cache-dir . l6c2@l5a1@mosh-cache-dir) (make-parameter . l6c1@l59f@make-parameter) (make-variable-transformer . l280b@lba3@make-variable-transformer) (identifier? . l28b3@le5a@identifier?) (generate-temporaries . l28a9@le46@generate-temporaries) (free-identifier=? . l28aa@le48@free-identifier=?) (syntax->datum . l28b5@le5e@syntax->datum) (datum->syntax . l28b4@le5c@datum->syntax) (bound-identifier=? . l28ab@le4a@bound-identifier=?) (scheme-report-environment . l28a0@le34@scheme-report-environment) (null-environment . l289f@le32@null-environment) (command-line . l2a37@l28db@command-line) (eval . l28a2@le38@eval) (environment . l289e@le30@environment) (syntax-violation . l28b2@le58@syntax-violation) (assertion-error . l28af@le52@assertion-error))))) (if l2e0b@t (cdr l2e0b@t) '#f)))) (l98b@l7d7@install-library 'l2de6 '(mosh interaction) '() '() '() '() '((regexp? . l2da6) (alist->eq-hash-table . l2da2) (format . l2d9f) (string-split . l2d94) (call-process . l2d8e) (set-current-directory! . l2d8a) (expand-path . l2d89) (current-directory . l2d88) (%spawn . l2d87) (%waitpid . l2d86) (simple-struct-name . l2d85) (simple-struct-set! . l2d84) (simple-struct-ref . l2d83) (make-simple-struct . l2d82) (simple-struct? . l2d81) (pointer-ref-c-int64 . l2d80) (pointer-ref-c-int32 . l2d7f) (pointer-ref-c-int16 . l2d7e) (pointer-ref-c-int8 . l2d7d) (pointer-ref-c-uint64 . l2d7c) (pointer-ref-c-uint32 . l2d7b) (pointer-ref-c-uint16 . l2d7a) (pointer-ref-c-uint8 . l2d79) (pointer-set-c-uint64! . l2d78) (pointer-set-c-uint32! . l2d77) (pointer-set-c-uint16! . l2d76) (pointer-set-c-uint8! . l2d75) (pointer-set-c-int64! . l2d74) (pointer-set-c-int32! . l2d73) (pointer-set-c-int16! . l2d72) (pointer-set-c-int8! . l2d71) (pointer-set-c-pointer! . l2d70) (pointer-set-c-double! . l2d6f) (pointer-set-c-float! . l2d6e) (pointer-set-c-long-long! . l2d6d) (pointer-set-c-long! . l2d6c) (pointer-set-c-int! . l2d6b) (pointer-set-c-short! . l2d6a) (pointer-set-c-char! . l2d69) (pointer-ref-c-pointer . l2d68) (pointer-ref-c-double . l2d67) (pointer-ref-c-float . l2d66) (pointer-ref-c-unsigned-long-long . l2d65) (pointer-ref-c-signed-long-long . l2d64) (pointer-ref-c-unsigned-long . l2d63) (pointer-ref-c-signed-long . l2d62) (pointer-ref-c-unsigned-int . l2d61) (pointer-ref-c-signed-int . l2d60) (pointer-ref-c-unsigned-short . l2d5f) (pointer-ref-c-signed-short . l2d5e) (pointer-ref-c-unsigned-char . l2d5d) (pointer-ref-c-signed-char . l2d5c) (pointer->integer . l2d5b) (integer->pointer . l2d5a) (pointer? . l2d59) (shared-errno . l2d58) (%ffi-supported? . l2d53) (%ffi-pointer->string . l2d52) (%ffi-call . l2d51) (%ffi-lookup . l2d50) (%ffi-open . l2d4f) (null-terminated-utf8->string . l2d4e) (null-terminated-bytevector->string . l2d4d) (%exec . l2d4c) (%fork . l2d4b) (%pipe . l2d4a) (p . l2d49) (whereis . l2d2d) (register . l2d2c) (vm-join! . l2d2b) (vm-set-value! . l2d2a) (vm? . l2d29) (main-vm? . l2d28) (vm-eval . l2d27) (vm-self . l2d26) (vm-start! . l2d25) (make-vm . l2d24) (mutex-try-lock! . l2d23) (mutex-unlock! . l2d22) (mutex-lock! . l2d21) (mutex? . l2d20) (make-mutex . l2d1f) (condition-variable-notify-all! . l2d1e) (condition-variable-notify! . l2d1d) (condition-variable-wait! . l2d1c) (make-condition-variable . l2d1b) (write/ss . l2d1a) (string-upcase . l2d02) (string-titlecase . l2d01) (string-normalize-nfkd . l2d00) (string-normalize-nfkc . l2cff) (string-normalize-nfd . l2cfe) (string-normalize-nfc . l2cfd) (string-foldcase . l2cfc) (string-downcase . l2cfb) (string-ci>? . l2cfa) (string-ci>=? . l2cf9) (string-ci=? . l2cf8) (string-ci<? . l2cf7) (string-ci<=? . l2cf6) (char-whitespace? . l2cf5) (char-upper-case? . l2cf4) (char-title-case? . l2cf3) (char-numeric? . l2cf2) (char-lower-case? . l2cf1) (char-general-category . l2cf0) (char-upcase . l2cef) (char-titlecase . l2cee) (char-foldcase . l2ced) (char-downcase . l2cec) (char-ci>? . l2ceb) (char-ci>=? . l2cea) (char-ci=? . l2ce9) (char-ci<? . l2ce8) (char-ci<=? . l2ce7) (char-alphabetic? . l2ce6) (make-variable-transformer . lba2) (identifier? . le59) (generate-temporaries . le45) (free-identifier=? . le47) (syntax->datum . le5d) (datum->syntax . le5b) (bound-identifier=? . le49) (record-type-descriptor? . l2ce5) (record-predicate . l2ce4) (record-mutator . l2ce3) (record-constructor . l2ce2) (record-accessor . l2ce1) (make-record-type-descriptor . l2ce0) (make-record-constructor-descriptor . l2cdf) (record? . l2cde) (record-type-uid . l2cdd) (record-type-sealed? . l2cdc) (record-type-parent . l2cdb) (record-type-opaque? . l2cda) (record-type-name . l2cd9) (record-type-generative? . l2cd8) (record-type-field-names . l2cd7) (record-rtd . l2cd6) (record-field-mutable? . l2cd5) (delete-file . l2cd4) (file-exists? . l2cd3) (vector-sort! . l2cd2) (vector-sort . l2cd1) (list-sort . l2cd0) (symbol-hash . l2ccf) (string-ci-hash . l2cce) (string-hash . l2ccd) (equal-hash . l2ccc) (hashtable-equivalence-function . l2ccb) (make-hashtable . l2cca) (hashtable-hash-function . l2cc9) (make-eqv-hashtable . l2cc8) (make-eq-hashtable . l2cc7) (hashtable? . l2cc6) (hashtable-update! . l2cc5) (hashtable-size . l2cc4) (hashtable-set! . l2cc3) (hashtable-ref . l2cc2) (hashtable-mutable? . l2cc1) (hashtable-keys . l2cc0) (hashtable-entries . l2cbf) (hashtable-delete! . l2cbe) (hashtable-copy . l2cbd) (hashtable-contains? . l2cbc) (hashtable-clear! . l2cbb) (call-with-output-file . l2cba) (call-with-input-file . l2cb9) (write-char . l2cb8) (write . l2cb7) (with-output-to-file . l2cb6) (with-input-from-file . l2cb5) (read-char . l2cb4) (read . l2cb3) (peek-char . l2cb2) (open-output-file . l2cb1) (open-input-file . l2cb0) (newline . l2caf) (display . l2cae) (close-output-port . l2cad) (close-input-port . l2cac) (eof-object? . l2cab) (eof-object . l2caa) (current-error-port . l2ca9) (current-output-port . l2ca8) (current-input-port . l2ca7) (output-port? . l2ca6) (input-port? . l2ca5) (utf-8-codec . l2ca4) (utf-16-codec . l2ca3) (transcoder-error-handling-mode . l2ca2) (transcoder-eol-style . l2ca1) (transcoder-codec . l2ca0) (transcoded-port . l2c9f) (textual-port? . l2c9e) (string->bytevector . l2c9d) (standard-output-port . l2c9c) (standard-input-port . l2c9b) (standard-error-port . l2c9a) (set-port-position! . l2c99) (put-u8 . l2c98) (put-string . l2c97) (put-datum . l2c96) (put-char . l2c95) (put-bytevector . l2c94) (port? . l2c93) (port-transcoder . l2c92) (port-position . l2c91) (port-has-set-port-position!? . l2c90) (port-has-port-position? . l2c8f) (port-eof? . l2c8e) (output-port-buffer-mode . l2c8d) (open-string-output-port . l2c8c) (open-string-input-port . l2c8b) (open-file-output-port . l2c8a) (open-file-input/output-port . l2c89) (open-file-input-port . l2c88) (open-bytevector-output-port . l2c87) (open-bytevector-input-port . l2c86) (native-transcoder . l2c85) (native-eol-style . l2c84) (make-transcoder . l2c83) (latin-1-codec . l2c82) (make-i/o-write-error . l2c81) (make-i/o-read-error . l2c80) (make-i/o-port-error . l2c7f) (make-i/o-invalid-position-error . l2c7e) (make-i/o-filename-error . l2c7d) (make-i/o-file-protection-error . l2c7c) (make-i/o-file-is-read-only-error . l2c7b) (make-i/o-file-does-not-exist-error . l2c7a) (make-i/o-file-already-exists-error . l2c79) (make-i/o-error . l2c78) (make-i/o-encoding-error . l2c77) (make-i/o-decoding-error . l2c76) (make-custom-textual-output-port . l2c75) (make-custom-textual-input/output-port . l2c74) (make-custom-textual-input-port . l2c73) (make-custom-binary-output-port . l2c72) (make-custom-binary-input/output-port . l2c71) (make-custom-binary-input-port . l2c70) (make-bytevector . l2c6f) (lookahead-u8 . l2c6e) (lookahead-char . l2c6d) (i/o-write-error? . l2c6c) (i/o-read-error? . l2c6b) (i/o-port-error? . l2c6a) (i/o-invalid-position-error? . l2c69) (i/o-filename-error? . l2c68) (i/o-file-protection-error? . l2c67) (i/o-file-is-read-only-error? . l2c66) (i/o-file-does-not-exist-error? . l2c65) (i/o-file-already-exists-error? . l2c64) (i/o-error? . l2c63) (i/o-error-position . l2c62) (i/o-error-port . l2c61) (i/o-error-filename . l2c60) (i/o-encoding-error? . l2c5f) (i/o-encoding-error-char . l2c5e) (i/o-decoding-error? . l2c5d) (get-u8 . l2c5c) (get-string-n! . l2c5b) (get-string-n . l2c5a) (get-string-all . l2c59) (get-line . l2c58) (get-datum . l2c57) (get-char . l2c56) (get-bytevector-some . l2c55) (get-bytevector-n! . l2c54) (get-bytevector-n . l2c53) (get-bytevector-all . l2c52) (flush-output-port . l2c51) (close-port . l2c50) (exit . l2c48) (command-line . l28da) (string-fill! . l2c47) (string-set! . l2c46) (set-cdr! . l2c45) (set-car! . l2c44) (remove . l2c43) (remv . l2c42) (remp . l2c41) (remq . l2c40) (partition . l2c3f) (memv . l2c3e) (memq . l2c3d) (memp . l2c3c) (member . l2c3b) (exists . l2c3a) (for-all . l2c39) (fold-right . l2c38) (fold-left . l2c37) (find . l2c36) (filter . l2c35) (cons* . l2c34) (assv . l2c33) (assq . l2c32) (assp . l2c31) (assoc . l2c30) (call-with-string-output-port . l2c2f) (call-with-port . l2c2e) (call-with-bytevector-output-port . l2c2d) (bytevector->string . l2c2c) (buffer-mode? . l2c2b) (binary-port? . l2c2a) (with-exception-handler . l2c29) (raise-continuable . l2c28) (raise . l2c27) (eval . le37) (environment . le2f) (make-enumeration . l2c26) (enum-set=? . l2c25) (enum-set-universe . l2c24) (enum-set-union . l2c23) (enum-set-subset? . l2c22) (enum-set-projection . l2c21) (enum-set-member? . l2c20) (enum-set-intersection . l2c1f) (enum-set-indexer . l2c1e) (enum-set-difference . l2c1d) (enum-set-constructor . l2c1c) (enum-set-complement . l2c1b) (enum-set->list . l2c1a) (who-condition? . l2c19) (warning? . l2c18) (violation? . l2c17) (undefined-violation? . l2c16) (syntax-violation? . l2c15) (syntax-violation-subform . l2c14) (syntax-violation-form . l2c13) (syntax-violation . le57) (simple-conditions . l2c12) (serious-condition? . l2c11) (non-continuable-violation? . l2c10) (message-condition? . l2c0f) (make-who-condition . l2c0e) (make-warning . l2c0d) (make-violation . l2c0c) (make-undefined-violation . l2c0b) (make-syntax-violation . l2c0a) (make-serious-condition . l2c09) (make-non-continuable-violation . l2c08) (make-message-condition . l2c07) (make-lexical-violation . l2c06) (make-irritants-condition . l2c05) (make-implementation-restriction-violation . l2c04) (make-error . l2c03) (make-assertion-violation . l2c02) (lexical-violation? . l2c01) (irritants-condition? . l2c00) (implementation-restriction-violation? . l2bff) (error? . l2bfe) (condition-who . l2bfd) (condition-predicate . l2bfc) (condition-message . l2bfb) (condition-irritants . l2bfa) (condition-accessor . l2bf9) (condition . l2bf8) (assertion-violation? . l2bf7) (condition? . l2bf6) (utf32->string . l2bf5) (utf16->string . l2bf4) (utf8->string . l2bf3) (uint-list->bytevector . l2bf2) (u8-list->bytevector . l2bf1) (string->utf8 . l2bf0) (string->utf32 . l2bef) (string->utf16 . l2bee) (sint-list->bytevector . l2bed) (native-endianness . l2bec) (bytevector? . l2beb) (bytevector=? . l2bea) (bytevector-uint-set! . l2be9) (bytevector-uint-ref . l2be8) (bytevector-u8-set! . l2be7) (bytevector-u8-ref . l2be6) (bytevector-u64-set! . l2be5) (bytevector-u64-ref . l2be4) (bytevector-u64-native-set! . l2be3) (bytevector-u64-native-ref . l2be2) (bytevector-u32-set! . l2be1) (bytevector-u32-ref . l2be0) (bytevector-u32-native-set! . l2bdf) (bytevector-u32-native-ref . l2bde) (bytevector-u16-set! . l2bdd) (bytevector-u16-ref . l2bdc) (bytevector-u16-native-set! . l2bdb) (bytevector-u16-native-ref . l2bda) (bytevector-sint-set! . l2bd9) (bytevector-sint-ref . l2bd8) (bytevector-s8-set! . l2bd7) (bytevector-s8-ref . l2bd6) (bytevector-s64-set! . l2bd5) (bytevector-s64-ref . l2bd4) (bytevector-s64-native-set! . l2bd3) (bytevector-s64-native-ref . l2bd2) (bytevector-s32-set! . l2bd1) (bytevector-s32-ref . l2bd0) (bytevector-s32-native-set! . l2bcf) (bytevector-s32-native-ref . l2bce) (bytevector-s16-set! . l2bcd) (bytevector-s16-ref . l2bcc) (bytevector-s16-native-set! . l2bcb) (bytevector-s16-native-ref . l2bca) (bytevector-length . l2bc9) (bytevector-ieee-single-ref . l2bc8) (bytevector-ieee-single-set! . l2bc7) (bytevector-ieee-single-native-set! . l2bc6) (bytevector-ieee-single-native-ref . l2bc5) (bytevector-ieee-double-set! . l2bc4) (bytevector-ieee-double-ref . l2bc3) (bytevector-ieee-double-native-set! . l2bc2) (bytevector-ieee-double-native-ref . l2bc1) (bytevector-fill! . l2bc0) (bytevector-copy! . l2bbf) (bytevector-copy . l2bbe) (bytevector->uint-list . l2bbd) (bytevector->u8-list . l2bbc) (bytevector->sint-list . l2bbb) (no-nans-violation? . l2bba) (no-infinities-violation? . l2bb9) (make-no-nans-violation . l2bb8) (make-no-infinities-violation . l2bb7) (real->flonum . l2bb6) (flzero? . l2bb5) (fltruncate . l2bb4) (fltan . l2bb3) (flsqrt . l2bb2) (flsin . l2bb1) (flround . l2bb0) (flpositive? . l2baf) (flonum? . l2bae) (flodd? . l2bad) (flnumerator . l2bac) (flnegative? . l2bab) (flnan? . l2baa) (flmod0 . l2ba9) (flmod . l2ba8) (flmin . l2ba7) (flmax . l2ba6) (fllog . l2ba5) (flinteger? . l2ba4) (flinfinite? . l2ba3) (flfloor . l2ba2) (flfinite? . l2ba1) (flexpt . l2ba0) (flexp . l2b9f) (fleven? . l2b9e) (fldiv0-and-mod0 . l2b9d) (fldiv0 . l2b9c) (fldiv-and-mod . l2b9b) (fldiv . l2b9a) (fldenominator . l2b99) (flcos . l2b98) (flceiling . l2b97) (flatan . l2b96) (flasin . l2b95) (flacos . l2b94) (flabs . l2b93) (fl>? . l2b92) (fl>=? . l2b91) (fl=? . l2b90) (fl<? . l2b8f) (fl<=? . l2b8e) (fl/ . l2b8d) (fl- . l2b8c) (fl+ . l2b8b) (fl* . l2b8a) (fixnum->flonum . l2b89) (fxzero? . l2b88) (fxxor . l2b87) (fxrotate-bit-field . l2b86) (fxreverse-bit-field . l2b85) (fxpositive? . l2b84) (fxodd? . l2b83) (fxnot . l2b82) (fxnegative? . l2b81) (fxmod0 . l2b80) (fxmod . l2b7f) (fxmin . l2b7e) (fxmax . l2b7d) (fxlength . l2b7c) (fxior . l2b7b) (fxif . l2b7a) (fxfirst-bit-set . l2b79) (fxeven? . l2b78) (fxdiv0-and-mod0 . l2b77) (fxdiv0 . l2b76) (fxdiv-and-mod . l2b75) (fxdiv . l2b74) (fxcopy-bit-field . l2b73) (fxcopy-bit . l2b72) (fxbit-set? . l2b71) (fxbit-field . l2b70) (fxbit-count . l2b6f) (fxarithmetic-shift-right . l2b6e) (fxarithmetic-shift-left . l2b6d) (fxarithmetic-shift . l2b6c) (fxand . l2b6b) (fx>? . l2b6a) (fx>=? . l2b69) (fx=? . l2b68) (fx<? . l2b67) (fx<=? . l2b66) (fx-/carry . l2b65) (fx- . l2b64) (fx+/carry . l2b63) (fx+ . l2b62) (fx*/carry . l2b61) (fx* . l2b60) (greatest-fixnum . l2b5f) (least-fixnum . l2b5e) (fixnum-width . l2b5d) (fixnum? . l2b5c) (bitwise-rotate-bit-field . l2b5b) (bitwise-reverse-bit-field . l2b5a) (bitwise-length . l2b59) (bitwise-if . l2b58) (bitwise-first-bit-set . l2b57) (bitwise-copy-bit-field . l2b56) (bitwise-copy-bit . l2b55) (bitwise-bit-set? . l2b54) (bitwise-bit-field . l2b53) (bitwise-bit-count . l2b52) (bitwise-xor . l2b51) (bitwise-ior . l2b50) (bitwise-and . l2b4f) (bitwise-not . l2b4e) (bitwise-arithmetic-shift-right . l2b4d) (bitwise-arithmetic-shift-left . l2b4c) (bitwise-arithmetic-shift . l2b4b) (zero? . l2b4a) (vector? . l2b49) (vector-set! . l2b48) (vector-ref . l2b47) (vector-map . l2b46) (vector-length . l2b45) (vector-for-each . l2b44) (vector-fill! . l2b43) (vector->list . l2b42) (vector . l2b41) (values . l2b40) (truncate . l2b3f) (tan . l2b3e) (symbol? . l2b3d) (symbol=? . l2b3c) (symbol->string . l2b3b) (substring . l2b3a) (string? . l2b39) (string>? . l2b38) (string>=? . l2b37) (string=? . l2b36) (string<? . l2b35) (string<=? . l2b34) (string-ref . l2b33) (string-length . l2b32) (string-for-each . l2b31) (string-copy . l2b30) (string-append . l2b2f) (string->symbol . l2b2e) (string->number . l2b2d) (string->list . l2b2c) (string . l2b2b) (sqrt . l2b2a) (sin . l2b29) (round . l2b28) (reverse . l2b27) (real? . l2b26) (real-valued? . l2b25) (real-part . l2b24) (rationalize . l2b23) (rational? . l2b22) (rational-valued? . l2b21) (procedure? . l2b20) (positive? . l2b1f) (pair? . l2b1e) (odd? . l2b1d) (numerator . l2b1c) (number? . l2b1b) (number->string . l2b1a) (null? . l2b19) (not . l2b18) (negative? . l2b17) (nan? . l2b16) (min . l2b15) (max . l2b14) (map . l2b13) (make-vector . l2b12) (make-string . l2b11) (make-rectangular . l2b10) (make-polar . l2b0f) (magnitude . l2b0e) (log . l2b0d) (list? . l2b0c) (list-tail . l2b0b) (list-ref . l2b0a) (list->vector . l2b09) (list->string . l2b08) (list . l2b07) (length . l2b06) (lcm . l2b05) (integer? . l2b04) (integer-valued? . l2b03) (integer->char . l2b02) (infinite? . l2b01) (inexact? . l2b00) (inexact . l2aff) (imag-part . l2afe) (gcd . l2afd) (for-each . l2afc) (floor . l2afb) (finite? . l2afa) (expt . l2af9) (exp . l2af8) (exact? . l2af7) (exact-integer-sqrt . l2af6) (exact . l2af5) (even? . l2af4) (error . l2af3) (eqv? . l2af2) (equal? . l2af1) (eq? . l2af0) (dynamic-wind . l2aef) (div0-and-mod0 . l2aee) (mod0 . l2aed) (div0 . l2aec) (div-and-mod . l2aeb) (mod . l2aea) (div . l2ae9) (denominator . l2ae8) (cos . l2ae7) (cons . l2ae6) (complex? . l2ae5) (char? . l2ae4) (char>? . l2ae3) (char>=? . l2ae2) (char=? . l2ae1) (char<? . l2ae0) (char<=? . l2adf) (char->integer . l2ade) (ceiling . l2add) (call-with-values . l2adc) (call/cc . l2adb) (call-with-current-continuation . l2ada) (cddddr . l2ad9) (cdddar . l2ad8) (cddadr . l2ad7) (cddaar . l2ad6) (cdaddr . l2ad5) (cdadar . l2ad4) (cdaadr . l2ad3) (cdaaar . l2ad2) (cadddr . l2ad1) (caddar . l2ad0) (cadadr . l2acf) (cadaar . l2ace) (caaddr . l2acd) (caadar . l2acc) (caaadr . l2acb) (caaaar . l2aca) (cdddr . l2ac9) (cddar . l2ac8) (cdadr . l2ac7) (cdaar . l2ac6) (caddr . l2ac5) (cadar . l2ac4) (caadr . l2ac3) (caaar . l2ac2) (cddr . l2ac1) (cdar . l2ac0) (cadr . l2abf) (caar . l2abe) (cdr . l2abd) (car . l2abc) (boolean? . l2abb) (boolean=? . l2aba) (atan . l2ab9) (assertion-violation . l2ab8) (asin . l2ab7) (apply . l2ab6) (append . l2ab5) (angle . l2ab4) (acos . l2ab3) (abs . l2ab2) (/ . l2ab1) (* . l2ab0) (- . l2aaf) (+ . l2aae) (>= . l2aad) (> . l2aac) (= . l2aab) (<= . l2aaa) (< . l2aa9) (library . l2aa8) (&no-nans . l2aa7) (&no-infinities . l2aa6) (&i/o-encoding . l2aa5) (&i/o-decoding . l2aa4) (&i/o-port . l2aa3) (&i/o-file-does-not-exist . l2aa2) (&i/o-file-already-exists . l2aa1) (&i/o-file-is-read-only . l2aa0) (&i/o-file-protection . l2a9f) (&i/o-filename . l2a9e) (&i/o-invalid-position . l2a9d) (&i/o-write . l2a9c) (&i/o-read . l2a9b) (&i/o . l2a9a) (&undefined . l2a99) (&syntax . l2a98) (&lexical . l2a97) (&implementation-restriction . l2a96) (&non-continuable . l2a95) (&who . l2a94) (&irritants . l2a93) (&assertion . l2a92) (&violation . l2a91) (&error . l2a90) (&serious . l2a8f) (&warning . l2a8e) (&message . l2a8d) (&condition . l2a8c) (define-condition-type . l2a8b) (define-enumeration . l2a8a) (define-record-type . l2a89) (parent-rtd . l2a88) (nongenerative . l2a87) (opaque . l2a86) (sealed . l2a85) (protocol . l2a84) (parent . l2a83) (immutable . l2a82) (mutable . l2a81) (fields . l2a80) (error-handling-mode . l2a7f) (file-options . l2a7e) (buffer-mode . l2a7d) (eol-style . l2a7c) (guard . l2a7b) (unsyntax-splicing . l2a78) (unsyntax . l2a77) (unquote-splicing . l2a76) (unquote . l2a75) (_ . l2a74) (else . l2a73) (=> . l2a72) (... . l2a71) (assert . l2a70) (endianness . l2a6f) (time . l2a6d) (do . l2a6c) (cond . l2a6b) (let* . l2a6a) (let*-values . l2a69) (let-values . l2a68) (identifier-syntax . l2a67) (with-syntax . l2a66) (quasisyntax . l2a65) (quasiquote . l2a64) (syntax-rules . l2a63) (include . l2a62) (record-constructor-descriptor . l2a60) (record-type-descriptor . l2a5f) (case . l2a5e) (unless . l2a5c) (when . l2a5b) (or . l2a5a) (and . l2a59) (if . l2a58) (let . l2a57) (letrec* . l2a56) (letrec . l2a55) (case-lambda . l2a53) (lambda . l2a52) (syntax . l2a51) (syntax-case . l2a50) (quote . l2a4f) (letrec-syntax . l2a4d) (let-syntax . l2a4c) (set! . l2a4b) (import . l2a4a) (begin . l2a49) (define-syntax . l2a47) (define . l2a46)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2de7 '(psyntax null-environment-5) '() '() '() '() '((make-promise . l2c49) (unquote-splicing . l2a76) (unquote . l2a75) (_ . l2a74) (else . l2a73) (=> . l2a72) (... . l2a71) (delay . l2a6e) (do . l2a6c) (cond . l2a6b) (let* . l2a6a) (quasiquote . l2a64) (syntax-rules . l2a63) (case . l2a5e) (or . l2a5a) (and . l2a59) (if . l2a58) (let . l2a57) (letrec . l2a55) (lambda . l2a52) (quote . l2a4f) (letrec-syntax . l2a4d) (let-syntax . l2a4c) (set! . l2a4b) (begin . l2a49) (define-syntax . l2a47) (define . l2a46)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2de8 '(psyntax scheme-report-environment-5) '() '() '() '() '((string-ci>? . l2cfa) (string-ci>=? . l2cf9) (string-ci=? . l2cf8) (string-ci<? . l2cf7) (string-ci<=? . l2cf6) (char-whitespace? . l2cf5) (char-upper-case? . l2cf4) (char-numeric? . l2cf2) (char-lower-case? . l2cf1) (char-upcase . l2cef) (char-downcase . l2cec) (char-ci>? . l2ceb) (char-ci>=? . l2cea) (char-ci=? . l2ce9) (char-ci<? . l2ce8) (char-ci<=? . l2ce7) (char-alphabetic? . l2ce6) (call-with-output-file . l2cba) (call-with-input-file . l2cb9) (write-char . l2cb8) (write . l2cb7) (with-output-to-file . l2cb6) (with-input-from-file . l2cb5) (read-char . l2cb4) (read . l2cb3) (peek-char . l2cb2) (open-output-file . l2cb1) (open-input-file . l2cb0) (newline . l2caf) (display . l2cae) (close-output-port . l2cad) (close-input-port . l2cac) (eof-object . l2caa) (current-output-port . l2ca8) (current-input-port . l2ca7) (output-port? . l2ca6) (input-port? . l2ca5) (scheme-report-environment . le33) (quotient . l2c4f) (null-environment . le31) (remainder . l2c4e) (modulo . l2c4d) (inexact->exact . l2c4c) (force . l2c4b) (exact->inexact . l2c4a) (make-promise . l2c49) (string-fill! . l2c47) (string-set! . l2c46) (set-cdr! . l2c45) (set-car! . l2c44) (memv . l2c3e) (memq . l2c3d) (member . l2c3b) (assv . l2c33) (assq . l2c32) (assoc . l2c30) (eval . le37) (zero? . l2b4a) (vector? . l2b49) (vector-set! . l2b48) (vector-ref . l2b47) (vector-length . l2b45) (vector-fill! . l2b43) (vector->list . l2b42) (vector . l2b41) (values . l2b40) (truncate . l2b3f) (tan . l2b3e) (symbol? . l2b3d) (symbol->string . l2b3b) (substring . l2b3a) (string? . l2b39) (string>? . l2b38) (string>=? . l2b37) (string=? . l2b36) (string<? . l2b35) (string<=? . l2b34) (string-ref . l2b33) (string-length . l2b32) (string-copy . l2b30) (string-append . l2b2f) (string->symbol . l2b2e) (string->number . l2b2d) (string->list . l2b2c) (string . l2b2b) (sqrt . l2b2a) (sin . l2b29) (round . l2b28) (reverse . l2b27) (real? . l2b26) (real-part . l2b24) (rationalize . l2b23) (rational? . l2b22) (procedure? . l2b20) (positive? . l2b1f) (pair? . l2b1e) (odd? . l2b1d) (numerator . l2b1c) (number? . l2b1b) (number->string . l2b1a) (not . l2b18) (negative? . l2b17) (min . l2b15) (max . l2b14) (map . l2b13) (make-vector . l2b12) (make-string . l2b11) (make-rectangular . l2b10) (make-polar . l2b0f) (magnitude . l2b0e) (log . l2b0d) (list? . l2b0c) (list-tail . l2b0b) (list-ref . l2b0a) (list->vector . l2b09) (list->string . l2b08) (list . l2b07) (length . l2b06) (lcm . l2b05) (integer? . l2b04) (integer->char . l2b02) (inexact? . l2b00) (imag-part . l2afe) (gcd . l2afd) (for-each . l2afc) (floor . l2afb) (expt . l2af9) (exp . l2af8) (exact? . l2af7) (even? . l2af4) (eqv? . l2af2) (equal? . l2af1) (eq? . l2af0) (dynamic-wind . l2aef) (denominator . l2ae8) (cos . l2ae7) (cons . l2ae6) (complex? . l2ae5) (char? . l2ae4) (char>? . l2ae3) (char>=? . l2ae2) (char=? . l2ae1) (char<? . l2ae0) (char<=? . l2adf) (char->integer . l2ade) (ceiling . l2add) (call-with-values . l2adc) (call-with-current-continuation . l2ada) (cddddr . l2ad9) (cdddar . l2ad8) (cddadr . l2ad7) (cddaar . l2ad6) (cdaddr . l2ad5) (cdadar . l2ad4) (cdaadr . l2ad3) (cdaaar . l2ad2) (cadddr . l2ad1) (caddar . l2ad0) (cadadr . l2acf) (cadaar . l2ace) (caaddr . l2acd) (caadar . l2acc) (caaadr . l2acb) (caaaar . l2aca) (cdddr . l2ac9) (cddar . l2ac8) (cdadr . l2ac7) (cdaar . l2ac6) (caddr . l2ac5) (cadar . l2ac4) (caadr . l2ac3) (caaar . l2ac2) (cddr . l2ac1) (cdar . l2ac0) (cadr . l2abf) (caar . l2abe) (cdr . l2abd) (car . l2abc) (boolean? . l2abb) (atan . l2ab9) (asin . l2ab7) (apply . l2ab6) (append . l2ab5) (angle . l2ab4) (acos . l2ab3) (abs . l2ab2) (/ . l2ab1) (* . l2ab0) (- . l2aaf) (+ . l2aae) (>= . l2aad) (> . l2aac) (= . l2aab) (<= . l2aaa) (< . l2aa9) (unquote-splicing . l2a76) (unquote . l2a75) (else . l2a73) (=> . l2a72) (... . l2a71) (delay . l2a6e) (do . l2a6c) (cond . l2a6b) (let* . l2a6a) (quasiquote . l2a64) (syntax-rules . l2a63) (case . l2a5e) (or . l2a5a) (and . l2a59) (if . l2a58) (let . l2a57) (letrec . l2a55) (lambda . l2a52) (quote . l2a4f) (letrec-syntax . l2a4d) (let-syntax . l2a4c) (set! . l2a4b) (begin . l2a49) (define-syntax . l2a47) (define . l2a46)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2de9 '(psyntax modules) '() '() '() '() '((module . l2a48)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2dea '(chez parameters) '() '() '() '() '() '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2deb '(rnrs) '(6) '() '() '() '((regexp? . l2da6) (string-upcase . l2d02) (string-titlecase . l2d01) (string-normalize-nfkd . l2d00) (string-normalize-nfkc . l2cff) (string-normalize-nfd . l2cfe) (string-normalize-nfc . l2cfd) (string-foldcase . l2cfc) (string-downcase . l2cfb) (string-ci>? . l2cfa) (string-ci>=? . l2cf9) (string-ci=? . l2cf8) (string-ci<? . l2cf7) (string-ci<=? . l2cf6) (char-whitespace? . l2cf5) (char-upper-case? . l2cf4) (char-title-case? . l2cf3) (char-numeric? . l2cf2) (char-lower-case? . l2cf1) (char-general-category . l2cf0) (char-upcase . l2cef) (char-titlecase . l2cee) (char-foldcase . l2ced) (char-downcase . l2cec) (char-ci>? . l2ceb) (char-ci>=? . l2cea) (char-ci=? . l2ce9) (char-ci<? . l2ce8) (char-ci<=? . l2ce7) (char-alphabetic? . l2ce6) (make-variable-transformer . lba2) (identifier? . le59) (generate-temporaries . le45) (free-identifier=? . le47) (syntax->datum . le5d) (datum->syntax . le5b) (bound-identifier=? . le49) (record-type-descriptor? . l2ce5) (record-predicate . l2ce4) (record-mutator . l2ce3) (record-constructor . l2ce2) (record-accessor . l2ce1) (make-record-type-descriptor . l2ce0) (make-record-constructor-descriptor . l2cdf) (record? . l2cde) (record-type-uid . l2cdd) (record-type-sealed? . l2cdc) (record-type-parent . l2cdb) (record-type-opaque? . l2cda) (record-type-name . l2cd9) (record-type-generative? . l2cd8) (record-type-field-names . l2cd7) (record-rtd . l2cd6) (record-field-mutable? . l2cd5) (delete-file . l2cd4) (file-exists? . l2cd3) (vector-sort! . l2cd2) (vector-sort . l2cd1) (list-sort . l2cd0) (symbol-hash . l2ccf) (string-ci-hash . l2cce) (string-hash . l2ccd) (equal-hash . l2ccc) (hashtable-equivalence-function . l2ccb) (make-hashtable . l2cca) (hashtable-hash-function . l2cc9) (make-eqv-hashtable . l2cc8) (make-eq-hashtable . l2cc7) (hashtable? . l2cc6) (hashtable-update! . l2cc5) (hashtable-size . l2cc4) (hashtable-set! . l2cc3) (hashtable-ref . l2cc2) (hashtable-mutable? . l2cc1) (hashtable-keys . l2cc0) (hashtable-entries . l2cbf) (hashtable-delete! . l2cbe) (hashtable-copy . l2cbd) (hashtable-contains? . l2cbc) (hashtable-clear! . l2cbb) (call-with-output-file . l2cba) (call-with-input-file . l2cb9) (write-char . l2cb8) (write . l2cb7) (with-output-to-file . l2cb6) (with-input-from-file . l2cb5) (read-char . l2cb4) (read . l2cb3) (peek-char . l2cb2) (open-output-file . l2cb1) (open-input-file . l2cb0) (newline . l2caf) (display . l2cae) (close-output-port . l2cad) (close-input-port . l2cac) (eof-object? . l2cab) (eof-object . l2caa) (current-error-port . l2ca9) (current-output-port . l2ca8) (current-input-port . l2ca7) (output-port? . l2ca6) (input-port? . l2ca5) (utf-8-codec . l2ca4) (utf-16-codec . l2ca3) (transcoder-error-handling-mode . l2ca2) (transcoder-eol-style . l2ca1) (transcoder-codec . l2ca0) (transcoded-port . l2c9f) (textual-port? . l2c9e) (string->bytevector . l2c9d) (standard-output-port . l2c9c) (standard-input-port . l2c9b) (standard-error-port . l2c9a) (set-port-position! . l2c99) (put-u8 . l2c98) (put-string . l2c97) (put-datum . l2c96) (put-char . l2c95) (put-bytevector . l2c94) (port? . l2c93) (port-transcoder . l2c92) (port-position . l2c91) (port-has-set-port-position!? . l2c90) (port-has-port-position? . l2c8f) (port-eof? . l2c8e) (output-port-buffer-mode . l2c8d) (open-string-output-port . l2c8c) (open-string-input-port . l2c8b) (open-file-output-port . l2c8a) (open-file-input/output-port . l2c89) (open-file-input-port . l2c88) (open-bytevector-output-port . l2c87) (open-bytevector-input-port . l2c86) (native-transcoder . l2c85) (native-eol-style . l2c84) (make-transcoder . l2c83) (latin-1-codec . l2c82) (make-i/o-write-error . l2c81) (make-i/o-read-error . l2c80) (make-i/o-port-error . l2c7f) (make-i/o-invalid-position-error . l2c7e) (make-i/o-filename-error . l2c7d) (make-i/o-file-protection-error . l2c7c) (make-i/o-file-is-read-only-error . l2c7b) (make-i/o-file-does-not-exist-error . l2c7a) (make-i/o-file-already-exists-error . l2c79) (make-i/o-error . l2c78) (make-i/o-encoding-error . l2c77) (make-i/o-decoding-error . l2c76) (make-custom-textual-output-port . l2c75) (make-custom-textual-input/output-port . l2c74) (make-custom-textual-input-port . l2c73) (make-custom-binary-output-port . l2c72) (make-custom-binary-input/output-port . l2c71) (make-custom-binary-input-port . l2c70) (make-bytevector . l2c6f) (lookahead-u8 . l2c6e) (lookahead-char . l2c6d) (i/o-write-error? . l2c6c) (i/o-read-error? . l2c6b) (i/o-port-error? . l2c6a) (i/o-invalid-position-error? . l2c69) (i/o-filename-error? . l2c68) (i/o-file-protection-error? . l2c67) (i/o-file-is-read-only-error? . l2c66) (i/o-file-does-not-exist-error? . l2c65) (i/o-file-already-exists-error? . l2c64) (i/o-error? . l2c63) (i/o-error-position . l2c62) (i/o-error-port . l2c61) (i/o-error-filename . l2c60) (i/o-encoding-error? . l2c5f) (i/o-encoding-error-char . l2c5e) (i/o-decoding-error? . l2c5d) (get-u8 . l2c5c) (get-string-n! . l2c5b) (get-string-n . l2c5a) (get-string-all . l2c59) (get-line . l2c58) (get-datum . l2c57) (get-char . l2c56) (get-bytevector-some . l2c55) (get-bytevector-n! . l2c54) (get-bytevector-n . l2c53) (get-bytevector-all . l2c52) (flush-output-port . l2c51) (close-port . l2c50) (exit . l2c48) (command-line . l28da) (remove . l2c43) (remv . l2c42) (remp . l2c41) (remq . l2c40) (partition . l2c3f) (memv . l2c3e) (memq . l2c3d) (memp . l2c3c) (member . l2c3b) (exists . l2c3a) (for-all . l2c39) (fold-right . l2c38) (fold-left . l2c37) (find . l2c36) (filter . l2c35) (cons* . l2c34) (assv . l2c33) (assq . l2c32) (assp . l2c31) (assoc . l2c30) (call-with-string-output-port . l2c2f) (call-with-port . l2c2e) (call-with-bytevector-output-port . l2c2d) (bytevector->string . l2c2c) (buffer-mode? . l2c2b) (binary-port? . l2c2a) (with-exception-handler . l2c29) (raise-continuable . l2c28) (raise . l2c27) (make-enumeration . l2c26) (enum-set=? . l2c25) (enum-set-universe . l2c24) (enum-set-union . l2c23) (enum-set-subset? . l2c22) (enum-set-projection . l2c21) (enum-set-member? . l2c20) (enum-set-intersection . l2c1f) (enum-set-indexer . l2c1e) (enum-set-difference . l2c1d) (enum-set-constructor . l2c1c) (enum-set-complement . l2c1b) (enum-set->list . l2c1a) (who-condition? . l2c19) (warning? . l2c18) (violation? . l2c17) (undefined-violation? . l2c16) (syntax-violation? . l2c15) (syntax-violation-subform . l2c14) (syntax-violation-form . l2c13) (syntax-violation . le57) (simple-conditions . l2c12) (serious-condition? . l2c11) (non-continuable-violation? . l2c10) (message-condition? . l2c0f) (make-who-condition . l2c0e) (make-warning . l2c0d) (make-violation . l2c0c) (make-undefined-violation . l2c0b) (make-syntax-violation . l2c0a) (make-serious-condition . l2c09) (make-non-continuable-violation . l2c08) (make-message-condition . l2c07) (make-lexical-violation . l2c06) (make-irritants-condition . l2c05) (make-implementation-restriction-violation . l2c04) (make-error . l2c03) (make-assertion-violation . l2c02) (lexical-violation? . l2c01) (irritants-condition? . l2c00) (implementation-restriction-violation? . l2bff) (error? . l2bfe) (condition-who . l2bfd) (condition-predicate . l2bfc) (condition-message . l2bfb) (condition-irritants . l2bfa) (condition-accessor . l2bf9) (condition . l2bf8) (assertion-violation? . l2bf7) (condition? . l2bf6) (utf32->string . l2bf5) (utf16->string . l2bf4) (utf8->string . l2bf3) (uint-list->bytevector . l2bf2) (u8-list->bytevector . l2bf1) (string->utf8 . l2bf0) (string->utf32 . l2bef) (string->utf16 . l2bee) (sint-list->bytevector . l2bed) (native-endianness . l2bec) (bytevector? . l2beb) (bytevector=? . l2bea) (bytevector-uint-set! . l2be9) (bytevector-uint-ref . l2be8) (bytevector-u8-set! . l2be7) (bytevector-u8-ref . l2be6) (bytevector-u64-set! . l2be5) (bytevector-u64-ref . l2be4) (bytevector-u64-native-set! . l2be3) (bytevector-u64-native-ref . l2be2) (bytevector-u32-set! . l2be1) (bytevector-u32-ref . l2be0) (bytevector-u32-native-set! . l2bdf) (bytevector-u32-native-ref . l2bde) (bytevector-u16-set! . l2bdd) (bytevector-u16-ref . l2bdc) (bytevector-u16-native-set! . l2bdb) (bytevector-u16-native-ref . l2bda) (bytevector-sint-set! . l2bd9) (bytevector-sint-ref . l2bd8) (bytevector-s8-set! . l2bd7) (bytevector-s8-ref . l2bd6) (bytevector-s64-set! . l2bd5) (bytevector-s64-ref . l2bd4) (bytevector-s64-native-set! . l2bd3) (bytevector-s64-native-ref . l2bd2) (bytevector-s32-set! . l2bd1) (bytevector-s32-ref . l2bd0) (bytevector-s32-native-set! . l2bcf) (bytevector-s32-native-ref . l2bce) (bytevector-s16-set! . l2bcd) (bytevector-s16-ref . l2bcc) (bytevector-s16-native-set! . l2bcb) (bytevector-s16-native-ref . l2bca) (bytevector-length . l2bc9) (bytevector-ieee-single-ref . l2bc8) (bytevector-ieee-single-set! . l2bc7) (bytevector-ieee-single-native-set! . l2bc6) (bytevector-ieee-single-native-ref . l2bc5) (bytevector-ieee-double-set! . l2bc4) (bytevector-ieee-double-ref . l2bc3) (bytevector-ieee-double-native-set! . l2bc2) (bytevector-ieee-double-native-ref . l2bc1) (bytevector-fill! . l2bc0) (bytevector-copy! . l2bbf) (bytevector-copy . l2bbe) (bytevector->uint-list . l2bbd) (bytevector->u8-list . l2bbc) (bytevector->sint-list . l2bbb) (no-nans-violation? . l2bba) (no-infinities-violation? . l2bb9) (make-no-nans-violation . l2bb8) (make-no-infinities-violation . l2bb7) (real->flonum . l2bb6) (flzero? . l2bb5) (fltruncate . l2bb4) (fltan . l2bb3) (flsqrt . l2bb2) (flsin . l2bb1) (flround . l2bb0) (flpositive? . l2baf) (flonum? . l2bae) (flodd? . l2bad) (flnumerator . l2bac) (flnegative? . l2bab) (flnan? . l2baa) (flmod0 . l2ba9) (flmod . l2ba8) (flmin . l2ba7) (flmax . l2ba6) (fllog . l2ba5) (flinteger? . l2ba4) (flinfinite? . l2ba3) (flfloor . l2ba2) (flfinite? . l2ba1) (flexpt . l2ba0) (flexp . l2b9f) (fleven? . l2b9e) (fldiv0-and-mod0 . l2b9d) (fldiv0 . l2b9c) (fldiv-and-mod . l2b9b) (fldiv . l2b9a) (fldenominator . l2b99) (flcos . l2b98) (flceiling . l2b97) (flatan . l2b96) (flasin . l2b95) (flacos . l2b94) (flabs . l2b93) (fl>? . l2b92) (fl>=? . l2b91) (fl=? . l2b90) (fl<? . l2b8f) (fl<=? . l2b8e) (fl/ . l2b8d) (fl- . l2b8c) (fl+ . l2b8b) (fl* . l2b8a) (fixnum->flonum . l2b89) (fxzero? . l2b88) (fxxor . l2b87) (fxrotate-bit-field . l2b86) (fxreverse-bit-field . l2b85) (fxpositive? . l2b84) (fxodd? . l2b83) (fxnot . l2b82) (fxnegative? . l2b81) (fxmod0 . l2b80) (fxmod . l2b7f) (fxmin . l2b7e) (fxmax . l2b7d) (fxlength . l2b7c) (fxior . l2b7b) (fxif . l2b7a) (fxfirst-bit-set . l2b79) (fxeven? . l2b78) (fxdiv0-and-mod0 . l2b77) (fxdiv0 . l2b76) (fxdiv-and-mod . l2b75) (fxdiv . l2b74) (fxcopy-bit-field . l2b73) (fxcopy-bit . l2b72) (fxbit-set? . l2b71) (fxbit-field . l2b70) (fxbit-count . l2b6f) (fxarithmetic-shift-right . l2b6e) (fxarithmetic-shift-left . l2b6d) (fxarithmetic-shift . l2b6c) (fxand . l2b6b) (fx>? . l2b6a) (fx>=? . l2b69) (fx=? . l2b68) (fx<? . l2b67) (fx<=? . l2b66) (fx-/carry . l2b65) (fx- . l2b64) (fx+/carry . l2b63) (fx+ . l2b62) (fx*/carry . l2b61) (fx* . l2b60) (greatest-fixnum . l2b5f) (least-fixnum . l2b5e) (fixnum-width . l2b5d) (fixnum? . l2b5c) (bitwise-rotate-bit-field . l2b5b) (bitwise-reverse-bit-field . l2b5a) (bitwise-length . l2b59) (bitwise-if . l2b58) (bitwise-first-bit-set . l2b57) (bitwise-copy-bit-field . l2b56) (bitwise-copy-bit . l2b55) (bitwise-bit-set? . l2b54) (bitwise-bit-field . l2b53) (bitwise-bit-count . l2b52) (bitwise-xor . l2b51) (bitwise-ior . l2b50) (bitwise-and . l2b4f) (bitwise-not . l2b4e) (bitwise-arithmetic-shift-right . l2b4d) (bitwise-arithmetic-shift-left . l2b4c) (bitwise-arithmetic-shift . l2b4b) (zero? . l2b4a) (vector? . l2b49) (vector-set! . l2b48) (vector-ref . l2b47) (vector-map . l2b46) (vector-length . l2b45) (vector-for-each . l2b44) (vector-fill! . l2b43) (vector->list . l2b42) (vector . l2b41) (values . l2b40) (truncate . l2b3f) (tan . l2b3e) (symbol? . l2b3d) (symbol=? . l2b3c) (symbol->string . l2b3b) (substring . l2b3a) (string? . l2b39) (string>? . l2b38) (string>=? . l2b37) (string=? . l2b36) (string<? . l2b35) (string<=? . l2b34) (string-ref . l2b33) (string-length . l2b32) (string-for-each . l2b31) (string-copy . l2b30) (string-append . l2b2f) (string->symbol . l2b2e) (string->number . l2b2d) (string->list . l2b2c) (string . l2b2b) (sqrt . l2b2a) (sin . l2b29) (round . l2b28) (reverse . l2b27) (real? . l2b26) (real-valued? . l2b25) (real-part . l2b24) (rationalize . l2b23) (rational? . l2b22) (rational-valued? . l2b21) (procedure? . l2b20) (positive? . l2b1f) (pair? . l2b1e) (odd? . l2b1d) (numerator . l2b1c) (number? . l2b1b) (number->string . l2b1a) (null? . l2b19) (not . l2b18) (negative? . l2b17) (nan? . l2b16) (min . l2b15) (max . l2b14) (map . l2b13) (make-vector . l2b12) (make-string . l2b11) (make-rectangular . l2b10) (make-polar . l2b0f) (magnitude . l2b0e) (log . l2b0d) (list? . l2b0c) (list-tail . l2b0b) (list-ref . l2b0a) (list->vector . l2b09) (list->string . l2b08) (list . l2b07) (length . l2b06) (lcm . l2b05) (integer? . l2b04) (integer-valued? . l2b03) (integer->char . l2b02) (infinite? . l2b01) (inexact? . l2b00) (inexact . l2aff) (imag-part . l2afe) (gcd . l2afd) (for-each . l2afc) (floor . l2afb) (finite? . l2afa) (expt . l2af9) (exp . l2af8) (exact? . l2af7) (exact-integer-sqrt . l2af6) (exact . l2af5) (even? . l2af4) (error . l2af3) (eqv? . l2af2) (equal? . l2af1) (eq? . l2af0) (dynamic-wind . l2aef) (div0-and-mod0 . l2aee) (mod0 . l2aed) (div0 . l2aec) (div-and-mod . l2aeb) (mod . l2aea) (div . l2ae9) (denominator . l2ae8) (cos . l2ae7) (cons . l2ae6) (complex? . l2ae5) (char? . l2ae4) (char>? . l2ae3) (char>=? . l2ae2) (char=? . l2ae1) (char<? . l2ae0) (char<=? . l2adf) (char->integer . l2ade) (ceiling . l2add) (call-with-values . l2adc) (call/cc . l2adb) (call-with-current-continuation . l2ada) (cddddr . l2ad9) (cdddar . l2ad8) (cddadr . l2ad7) (cddaar . l2ad6) (cdaddr . l2ad5) (cdadar . l2ad4) (cdaadr . l2ad3) (cdaaar . l2ad2) (cadddr . l2ad1) (caddar . l2ad0) (cadadr . l2acf) (cadaar . l2ace) (caaddr . l2acd) (caadar . l2acc) (caaadr . l2acb) (caaaar . l2aca) (cdddr . l2ac9) (cddar . l2ac8) (cdadr . l2ac7) (cdaar . l2ac6) (caddr . l2ac5) (cadar . l2ac4) (caadr . l2ac3) (caaar . l2ac2) (cddr . l2ac1) (cdar . l2ac0) (cadr . l2abf) (caar . l2abe) (cdr . l2abd) (car . l2abc) (boolean? . l2abb) (boolean=? . l2aba) (atan . l2ab9) (assertion-violation . l2ab8) (asin . l2ab7) (apply . l2ab6) (append . l2ab5) (angle . l2ab4) (acos . l2ab3) (abs . l2ab2) (/ . l2ab1) (* . l2ab0) (- . l2aaf) (+ . l2aae) (>= . l2aad) (> . l2aac) (= . l2aab) (<= . l2aaa) (< . l2aa9) (&no-nans . l2aa7) (&no-infinities . l2aa6) (&i/o-encoding . l2aa5) (&i/o-decoding . l2aa4) (&i/o-port . l2aa3) (&i/o-file-does-not-exist . l2aa2) (&i/o-file-already-exists . l2aa1) (&i/o-file-is-read-only . l2aa0) (&i/o-file-protection . l2a9f) (&i/o-filename . l2a9e) (&i/o-invalid-position . l2a9d) (&i/o-write . l2a9c) (&i/o-read . l2a9b) (&i/o . l2a9a) (&undefined . l2a99) (&syntax . l2a98) (&lexical . l2a97) (&implementation-restriction . l2a96) (&non-continuable . l2a95) (&who . l2a94) (&irritants . l2a93) (&assertion . l2a92) (&violation . l2a91) (&error . l2a90) (&serious . l2a8f) (&warning . l2a8e) (&message . l2a8d) (&condition . l2a8c) (define-condition-type . l2a8b) (define-enumeration . l2a8a) (define-record-type . l2a89) (parent-rtd . l2a88) (nongenerative . l2a87) (opaque . l2a86) (sealed . l2a85) (protocol . l2a84) (parent . l2a83) (immutable . l2a82) (mutable . l2a81) (fields . l2a80) (error-handling-mode . l2a7f) (file-options . l2a7e) (buffer-mode . l2a7d) (eol-style . l2a7c) (guard . l2a7b) (unsyntax-splicing . l2a78) (unsyntax . l2a77) (unquote-splicing . l2a76) (unquote . l2a75) (_ . l2a74) (else . l2a73) (=> . l2a72) (... . l2a71) (assert . l2a70) (endianness . l2a6f) (do . l2a6c) (cond . l2a6b) (let* . l2a6a) (let*-values . l2a69) (let-values . l2a68) (identifier-syntax . l2a67) (with-syntax . l2a66) (quasisyntax . l2a65) (quasiquote . l2a64) (syntax-rules . l2a63) (record-constructor-descriptor . l2a60) (record-type-descriptor . l2a5f) (case . l2a5e) (unless . l2a5c) (when . l2a5b) (or . l2a5a) (and . l2a59) (if . l2a58) (let . l2a57) (letrec* . l2a56) (letrec . l2a55) (case-lambda . l2a53) (lambda . l2a52) (syntax . l2a51) (syntax-case . l2a50) (quote . l2a4f) (letrec-syntax . l2a4d) (let-syntax . l2a4c) (set! . l2a4b) (begin . l2a49) (define-syntax . l2a47) (define . l2a46)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2dec '(rnrs r5rs) '(6) '() '() '() '((scheme-report-environment . le33) (quotient . l2c4f) (null-environment . le31) (remainder . l2c4e) (modulo . l2c4d) (inexact->exact . l2c4c) (force . l2c4b) (exact->inexact . l2c4a) (make-promise . l2c49) (delay . l2a6e)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2ded '(rnrs control) '(6) '() '() '() '((do . l2a6c) (unless . l2a5c) (when . l2a5b) (case-lambda . l2a53)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2dee '(rnrs eval) '(6) '() '() '() '((eval . le37) (environment . le2f)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2def '(rnrs mutable-pairs) '(6) '() '() '() '((set-cdr! . l2c45) (set-car! . l2c44)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2df0 '(rnrs mutable-strings) '(6) '() '() '() '((string-fill! . l2c47) (string-set! . l2c46)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2df1 '(rnrs programs) '(6) '() '() '() '((exit . l2c48) (command-line . l28da)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2df2 '(rnrs syntax-case) '(6) '() '() '() '((make-variable-transformer . lba2) (identifier? . le59) (generate-temporaries . le45) (free-identifier=? . le47) (syntax->datum . le5d) (datum->syntax . le5b) (bound-identifier=? . le49) (syntax-violation . le57) (unsyntax-splicing . l2a78) (unsyntax . l2a77) (_ . l2a74) (... . l2a71) (with-syntax . l2a66) (quasisyntax . l2a65) (syntax . l2a51) (syntax-case . l2a50)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2df3 '(rnrs files) '(6) '() '() '() '((delete-file . l2cd4) (file-exists? . l2cd3) (make-i/o-write-error . l2c81) (make-i/o-read-error . l2c80) (make-i/o-port-error . l2c7f) (make-i/o-invalid-position-error . l2c7e) (make-i/o-filename-error . l2c7d) (make-i/o-file-protection-error . l2c7c) (make-i/o-file-is-read-only-error . l2c7b) (make-i/o-file-does-not-exist-error . l2c7a) (make-i/o-file-already-exists-error . l2c79) (make-i/o-error . l2c78) (i/o-write-error? . l2c6c) (i/o-read-error? . l2c6b) (i/o-port-error? . l2c6a) (i/o-invalid-position-error? . l2c69) (i/o-filename-error? . l2c68) (i/o-file-protection-error? . l2c67) (i/o-file-is-read-only-error? . l2c66) (i/o-file-does-not-exist-error? . l2c65) (i/o-file-already-exists-error? . l2c64) (i/o-error? . l2c63) (i/o-error-position . l2c62) (i/o-error-port . l2c61) (i/o-error-filename . l2c60) (&i/o-port . l2aa3) (&i/o-file-does-not-exist . l2aa2) (&i/o-file-already-exists . l2aa1) (&i/o-file-is-read-only . l2aa0) (&i/o-file-protection . l2a9f) (&i/o-filename . l2a9e) (&i/o-invalid-position . l2a9d) (&i/o-write . l2a9c) (&i/o-read . l2a9b) (&i/o . l2a9a)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2df4 '(rnrs sorting) '(6) '() '() '() '((vector-sort! . l2cd2) (vector-sort . l2cd1) (list-sort . l2cd0)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2df5 '(rnrs base) '(6) '() '() '() '((zero? . l2b4a) (vector? . l2b49) (vector-set! . l2b48) (vector-ref . l2b47) (vector-map . l2b46) (vector-length . l2b45) (vector-for-each . l2b44) (vector-fill! . l2b43) (vector->list . l2b42) (vector . l2b41) (values . l2b40) (truncate . l2b3f) (tan . l2b3e) (symbol? . l2b3d) (symbol=? . l2b3c) (symbol->string . l2b3b) (substring . l2b3a) (string? . l2b39) (string>? . l2b38) (string>=? . l2b37) (string=? . l2b36) (string<? . l2b35) (string<=? . l2b34) (string-ref . l2b33) (string-length . l2b32) (string-for-each . l2b31) (string-copy . l2b30) (string-append . l2b2f) (string->symbol . l2b2e) (string->number . l2b2d) (string->list . l2b2c) (string . l2b2b) (sqrt . l2b2a) (sin . l2b29) (round . l2b28) (reverse . l2b27) (real? . l2b26) (real-valued? . l2b25) (real-part . l2b24) (rationalize . l2b23) (rational? . l2b22) (rational-valued? . l2b21) (procedure? . l2b20) (positive? . l2b1f) (pair? . l2b1e) (odd? . l2b1d) (numerator . l2b1c) (number? . l2b1b) (number->string . l2b1a) (null? . l2b19) (not . l2b18) (negative? . l2b17) (nan? . l2b16) (min . l2b15) (max . l2b14) (map . l2b13) (make-vector . l2b12) (make-string . l2b11) (make-rectangular . l2b10) (make-polar . l2b0f) (magnitude . l2b0e) (log . l2b0d) (list? . l2b0c) (list-tail . l2b0b) (list-ref . l2b0a) (list->vector . l2b09) (list->string . l2b08) (list . l2b07) (length . l2b06) (lcm . l2b05) (integer? . l2b04) (integer-valued? . l2b03) (integer->char . l2b02) (infinite? . l2b01) (inexact? . l2b00) (inexact . l2aff) (imag-part . l2afe) (gcd . l2afd) (for-each . l2afc) (floor . l2afb) (finite? . l2afa) (expt . l2af9) (exp . l2af8) (exact? . l2af7) (exact-integer-sqrt . l2af6) (exact . l2af5) (even? . l2af4) (error . l2af3) (eqv? . l2af2) (equal? . l2af1) (eq? . l2af0) (dynamic-wind . l2aef) (div0-and-mod0 . l2aee) (mod0 . l2aed) (div0 . l2aec) (div-and-mod . l2aeb) (mod . l2aea) (div . l2ae9) (denominator . l2ae8) (cos . l2ae7) (cons . l2ae6) (complex? . l2ae5) (char? . l2ae4) (char>? . l2ae3) (char>=? . l2ae2) (char=? . l2ae1) (char<? . l2ae0) (char<=? . l2adf) (char->integer . l2ade) (ceiling . l2add) (call-with-values . l2adc) (call/cc . l2adb) (call-with-current-continuation . l2ada) (cddddr . l2ad9) (cdddar . l2ad8) (cddadr . l2ad7) (cddaar . l2ad6) (cdaddr . l2ad5) (cdadar . l2ad4) (cdaadr . l2ad3) (cdaaar . l2ad2) (cadddr . l2ad1) (caddar . l2ad0) (cadadr . l2acf) (cadaar . l2ace) (caaddr . l2acd) (caadar . l2acc) (caaadr . l2acb) (caaaar . l2aca) (cdddr . l2ac9) (cddar . l2ac8) (cdadr . l2ac7) (cdaar . l2ac6) (caddr . l2ac5) (cadar . l2ac4) (caadr . l2ac3) (caaar . l2ac2) (cddr . l2ac1) (cdar . l2ac0) (cadr . l2abf) (caar . l2abe) (cdr . l2abd) (car . l2abc) (boolean? . l2abb) (boolean=? . l2aba) (atan . l2ab9) (assertion-violation . l2ab8) (asin . l2ab7) (apply . l2ab6) (append . l2ab5) (angle . l2ab4) (acos . l2ab3) (abs . l2ab2) (/ . l2ab1) (* . l2ab0) (- . l2aaf) (+ . l2aae) (>= . l2aad) (> . l2aac) (= . l2aab) (<= . l2aaa) (< . l2aa9) (unquote-splicing . l2a76) (unquote . l2a75) (_ . l2a74) (else . l2a73) (=> . l2a72) (... . l2a71) (assert . l2a70) (cond . l2a6b) (let* . l2a6a) (let*-values . l2a69) (let-values . l2a68) (identifier-syntax . l2a67) (quasiquote . l2a64) (syntax-rules . l2a63) (case . l2a5e) (or . l2a5a) (and . l2a59) (if . l2a58) (let . l2a57) (letrec* . l2a56) (letrec . l2a55) (lambda . l2a52) (quote . l2a4f) (letrec-syntax . l2a4d) (let-syntax . l2a4c) (set! . l2a4b) (begin . l2a49) (define-syntax . l2a47) (define . l2a46)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2df6 '(rnrs lists) '(6) '() '() '() '((remove . l2c43) (remv . l2c42) (remp . l2c41) (remq . l2c40) (partition . l2c3f) (memv . l2c3e) (memq . l2c3d) (memp . l2c3c) (member . l2c3b) (exists . l2c3a) (for-all . l2c39) (fold-right . l2c38) (fold-left . l2c37) (find . l2c36) (filter . l2c35) (cons* . l2c34) (assv . l2c33) (assq . l2c32) (assp . l2c31) (assoc . l2c30)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2df7 '(rnrs io simple) '(6) '() '() '() '((call-with-output-file . l2cba) (call-with-input-file . l2cb9) (write-char . l2cb8) (write . l2cb7) (with-output-to-file . l2cb6) (with-input-from-file . l2cb5) (read-char . l2cb4) (read . l2cb3) (peek-char . l2cb2) (open-output-file . l2cb1) (open-input-file . l2cb0) (newline . l2caf) (display . l2cae) (close-output-port . l2cad) (close-input-port . l2cac) (eof-object? . l2cab) (eof-object . l2caa) (current-error-port . l2ca9) (current-output-port . l2ca8) (current-input-port . l2ca7) (output-port? . l2ca6) (input-port? . l2ca5) (make-i/o-write-error . l2c81) (make-i/o-read-error . l2c80) (make-i/o-port-error . l2c7f) (make-i/o-invalid-position-error . l2c7e) (make-i/o-filename-error . l2c7d) (make-i/o-file-protection-error . l2c7c) (make-i/o-file-is-read-only-error . l2c7b) (make-i/o-file-does-not-exist-error . l2c7a) (make-i/o-file-already-exists-error . l2c79) (make-i/o-error . l2c78) (i/o-write-error? . l2c6c) (i/o-read-error? . l2c6b) (i/o-port-error? . l2c6a) (i/o-invalid-position-error? . l2c69) (i/o-filename-error? . l2c68) (i/o-file-protection-error? . l2c67) (i/o-file-is-read-only-error? . l2c66) (i/o-file-does-not-exist-error? . l2c65) (i/o-file-already-exists-error? . l2c64) (i/o-error? . l2c63) (i/o-error-position . l2c62) (i/o-error-port . l2c61) (i/o-error-filename . l2c60) (&i/o-port . l2aa3) (&i/o-file-does-not-exist . l2aa2) (&i/o-file-already-exists . l2aa1) (&i/o-file-is-read-only . l2aa0) (&i/o-file-protection . l2a9f) (&i/o-filename . l2a9e) (&i/o-invalid-position . l2a9d) (&i/o-write . l2a9c) (&i/o-read . l2a9b) (&i/o . l2a9a)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2df8 '(rnrs bytevectors) '(6) '() '() '() '((make-bytevector . l2c6f) (utf32->string . l2bf5) (utf16->string . l2bf4) (utf8->string . l2bf3) (uint-list->bytevector . l2bf2) (u8-list->bytevector . l2bf1) (string->utf8 . l2bf0) (string->utf32 . l2bef) (string->utf16 . l2bee) (sint-list->bytevector . l2bed) (native-endianness . l2bec) (bytevector? . l2beb) (bytevector=? . l2bea) (bytevector-uint-set! . l2be9) (bytevector-uint-ref . l2be8) (bytevector-u8-set! . l2be7) (bytevector-u8-ref . l2be6) (bytevector-u64-set! . l2be5) (bytevector-u64-ref . l2be4) (bytevector-u64-native-set! . l2be3) (bytevector-u64-native-ref . l2be2) (bytevector-u32-set! . l2be1) (bytevector-u32-ref . l2be0) (bytevector-u32-native-set! . l2bdf) (bytevector-u32-native-ref . l2bde) (bytevector-u16-set! . l2bdd) (bytevector-u16-ref . l2bdc) (bytevector-u16-native-set! . l2bdb) (bytevector-u16-native-ref . l2bda) (bytevector-sint-set! . l2bd9) (bytevector-sint-ref . l2bd8) (bytevector-s8-set! . l2bd7) (bytevector-s8-ref . l2bd6) (bytevector-s64-set! . l2bd5) (bytevector-s64-ref . l2bd4) (bytevector-s64-native-set! . l2bd3) (bytevector-s64-native-ref . l2bd2) (bytevector-s32-set! . l2bd1) (bytevector-s32-ref . l2bd0) (bytevector-s32-native-set! . l2bcf) (bytevector-s32-native-ref . l2bce) (bytevector-s16-set! . l2bcd) (bytevector-s16-ref . l2bcc) (bytevector-s16-native-set! . l2bcb) (bytevector-s16-native-ref . l2bca) (bytevector-length . l2bc9) (bytevector-ieee-single-ref . l2bc8) (bytevector-ieee-single-set! . l2bc7) (bytevector-ieee-single-native-set! . l2bc6) (bytevector-ieee-single-native-ref . l2bc5) (bytevector-ieee-double-set! . l2bc4) (bytevector-ieee-double-ref . l2bc3) (bytevector-ieee-double-native-set! . l2bc2) (bytevector-ieee-double-native-ref . l2bc1) (bytevector-fill! . l2bc0) (bytevector-copy! . l2bbf) (bytevector-copy . l2bbe) (bytevector->uint-list . l2bbd) (bytevector->u8-list . l2bbc) (bytevector->sint-list . l2bbb) (endianness . l2a6f)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2df9 '(rnrs unicode) '(6) '() '() '() '((string-upcase . l2d02) (string-titlecase . l2d01) (string-normalize-nfkd . l2d00) (string-normalize-nfkc . l2cff) (string-normalize-nfd . l2cfe) (string-normalize-nfc . l2cfd) (string-foldcase . l2cfc) (string-downcase . l2cfb) (string-ci>? . l2cfa) (string-ci>=? . l2cf9) (string-ci=? . l2cf8) (string-ci<? . l2cf7) (string-ci<=? . l2cf6) (char-whitespace? . l2cf5) (char-upper-case? . l2cf4) (char-title-case? . l2cf3) (char-numeric? . l2cf2) (char-lower-case? . l2cf1) (char-general-category . l2cf0) (char-upcase . l2cef) (char-titlecase . l2cee) (char-foldcase . l2ced) (char-downcase . l2cec) (char-ci>? . l2ceb) (char-ci>=? . l2cea) (char-ci=? . l2ce9) (char-ci<? . l2ce8) (char-ci<=? . l2ce7) (char-alphabetic? . l2ce6)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2dfa '(rnrs exceptions) '(6) '() '() '() '((with-exception-handler . l2c29) (raise-continuable . l2c28) (raise . l2c27) (guard . l2a7b) (else . l2a73) (=> . l2a72)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2dfb '(rnrs arithmetic bitwise) '(6) '() '() '() '((bitwise-rotate-bit-field . l2b5b) (bitwise-reverse-bit-field . l2b5a) (bitwise-length . l2b59) (bitwise-if . l2b58) (bitwise-first-bit-set . l2b57) (bitwise-copy-bit-field . l2b56) (bitwise-copy-bit . l2b55) (bitwise-bit-set? . l2b54) (bitwise-bit-field . l2b53) (bitwise-bit-count . l2b52) (bitwise-xor . l2b51) (bitwise-ior . l2b50) (bitwise-and . l2b4f) (bitwise-not . l2b4e) (bitwise-arithmetic-shift-right . l2b4d) (bitwise-arithmetic-shift-left . l2b4c) (bitwise-arithmetic-shift . l2b4b)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2dfc '(rnrs arithmetic fixnums) '(6) '() '() '() '((fxzero? . l2b88) (fxxor . l2b87) (fxrotate-bit-field . l2b86) (fxreverse-bit-field . l2b85) (fxpositive? . l2b84) (fxodd? . l2b83) (fxnot . l2b82) (fxnegative? . l2b81) (fxmod0 . l2b80) (fxmod . l2b7f) (fxmin . l2b7e) (fxmax . l2b7d) (fxlength . l2b7c) (fxior . l2b7b) (fxif . l2b7a) (fxfirst-bit-set . l2b79) (fxeven? . l2b78) (fxdiv0-and-mod0 . l2b77) (fxdiv0 . l2b76) (fxdiv-and-mod . l2b75) (fxdiv . l2b74) (fxcopy-bit-field . l2b73) (fxcopy-bit . l2b72) (fxbit-set? . l2b71) (fxbit-field . l2b70) (fxbit-count . l2b6f) (fxarithmetic-shift-right . l2b6e) (fxarithmetic-shift-left . l2b6d) (fxarithmetic-shift . l2b6c) (fxand . l2b6b) (fx>? . l2b6a) (fx>=? . l2b69) (fx=? . l2b68) (fx<? . l2b67) (fx<=? . l2b66) (fx-/carry . l2b65) (fx- . l2b64) (fx+/carry . l2b63) (fx+ . l2b62) (fx*/carry . l2b61) (fx* . l2b60) (greatest-fixnum . l2b5f) (least-fixnum . l2b5e) (fixnum-width . l2b5d) (fixnum? . l2b5c)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2dfd '(rnrs arithmetic flonums) '(6) '() '() '() '((no-nans-violation? . l2bba) (no-infinities-violation? . l2bb9) (make-no-nans-violation . l2bb8) (make-no-infinities-violation . l2bb7) (real->flonum . l2bb6) (flzero? . l2bb5) (fltruncate . l2bb4) (fltan . l2bb3) (flsqrt . l2bb2) (flsin . l2bb1) (flround . l2bb0) (flpositive? . l2baf) (flonum? . l2bae) (flodd? . l2bad) (flnumerator . l2bac) (flnegative? . l2bab) (flnan? . l2baa) (flmod0 . l2ba9) (flmod . l2ba8) (flmin . l2ba7) (flmax . l2ba6) (fllog . l2ba5) (flinteger? . l2ba4) (flinfinite? . l2ba3) (flfloor . l2ba2) (flfinite? . l2ba1) (flexpt . l2ba0) (flexp . l2b9f) (fleven? . l2b9e) (fldiv0-and-mod0 . l2b9d) (fldiv0 . l2b9c) (fldiv-and-mod . l2b9b) (fldiv . l2b9a) (fldenominator . l2b99) (flcos . l2b98) (flceiling . l2b97) (flatan . l2b96) (flasin . l2b95) (flacos . l2b94) (flabs . l2b93) (fl>? . l2b92) (fl>=? . l2b91) (fl=? . l2b90) (fl<? . l2b8f) (fl<=? . l2b8e) (fl/ . l2b8d) (fl- . l2b8c) (fl+ . l2b8b) (fl* . l2b8a) (fixnum->flonum . l2b89) (&no-nans . l2aa7) (&no-infinities . l2aa6)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2dfe '(rnrs hashtables) '(6) '() '() '() '((symbol-hash . l2ccf) (string-ci-hash . l2cce) (string-hash . l2ccd) (equal-hash . l2ccc) (hashtable-equivalence-function . l2ccb) (make-hashtable . l2cca) (hashtable-hash-function . l2cc9) (make-eqv-hashtable . l2cc8) (make-eq-hashtable . l2cc7) (hashtable? . l2cc6) (hashtable-update! . l2cc5) (hashtable-size . l2cc4) (hashtable-set! . l2cc3) (hashtable-ref . l2cc2) (hashtable-mutable? . l2cc1) (hashtable-keys . l2cc0) (hashtable-entries . l2cbf) (hashtable-delete! . l2cbe) (hashtable-copy . l2cbd) (hashtable-contains? . l2cbc) (hashtable-clear! . l2cbb)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2dff '(rnrs io ports) '(6) '() '() '() '((eof-object? . l2cab) (eof-object . l2caa) (current-error-port . l2ca9) (current-output-port . l2ca8) (current-input-port . l2ca7) (output-port? . l2ca6) (input-port? . l2ca5) (utf-8-codec . l2ca4) (utf-16-codec . l2ca3) (transcoder-error-handling-mode . l2ca2) (transcoder-eol-style . l2ca1) (transcoder-codec . l2ca0) (transcoded-port . l2c9f) (textual-port? . l2c9e) (string->bytevector . l2c9d) (standard-output-port . l2c9c) (standard-input-port . l2c9b) (standard-error-port . l2c9a) (set-port-position! . l2c99) (put-u8 . l2c98) (put-string . l2c97) (put-datum . l2c96) (put-char . l2c95) (put-bytevector . l2c94) (port? . l2c93) (port-transcoder . l2c92) (port-position . l2c91) (port-has-set-port-position!? . l2c90) (port-has-port-position? . l2c8f) (port-eof? . l2c8e) (output-port-buffer-mode . l2c8d) (open-string-output-port . l2c8c) (open-string-input-port . l2c8b) (open-file-output-port . l2c8a) (open-file-input/output-port . l2c89) (open-file-input-port . l2c88) (open-bytevector-output-port . l2c87) (open-bytevector-input-port . l2c86) (native-transcoder . l2c85) (native-eol-style . l2c84) (make-transcoder . l2c83) (latin-1-codec . l2c82) (make-i/o-write-error . l2c81) (make-i/o-read-error . l2c80) (make-i/o-port-error . l2c7f) (make-i/o-invalid-position-error . l2c7e) (make-i/o-filename-error . l2c7d) (make-i/o-file-protection-error . l2c7c) (make-i/o-file-is-read-only-error . l2c7b) (make-i/o-file-does-not-exist-error . l2c7a) (make-i/o-file-already-exists-error . l2c79) (make-i/o-error . l2c78) (make-i/o-encoding-error . l2c77) (make-i/o-decoding-error . l2c76) (make-custom-textual-output-port . l2c75) (make-custom-textual-input/output-port . l2c74) (make-custom-textual-input-port . l2c73) (make-custom-binary-output-port . l2c72) (make-custom-binary-input/output-port . l2c71) (make-custom-binary-input-port . l2c70) (lookahead-u8 . l2c6e) (lookahead-char . l2c6d) (i/o-write-error? . l2c6c) (i/o-read-error? . l2c6b) (i/o-port-error? . l2c6a) (i/o-invalid-position-error? . l2c69) (i/o-filename-error? . l2c68) (i/o-file-protection-error? . l2c67) (i/o-file-is-read-only-error? . l2c66) (i/o-file-does-not-exist-error? . l2c65) (i/o-file-already-exists-error? . l2c64) (i/o-error? . l2c63) (i/o-error-position . l2c62) (i/o-error-port . l2c61) (i/o-error-filename . l2c60) (i/o-encoding-error? . l2c5f) (i/o-encoding-error-char . l2c5e) (i/o-decoding-error? . l2c5d) (get-u8 . l2c5c) (get-string-n! . l2c5b) (get-string-n . l2c5a) (get-string-all . l2c59) (get-line . l2c58) (get-datum . l2c57) (get-char . l2c56) (get-bytevector-some . l2c55) (get-bytevector-n! . l2c54) (get-bytevector-n . l2c53) (get-bytevector-all . l2c52) (flush-output-port . l2c51) (close-port . l2c50) (call-with-string-output-port . l2c2f) (call-with-port . l2c2e) (call-with-bytevector-output-port . l2c2d) (bytevector->string . l2c2c) (buffer-mode? . l2c2b) (binary-port? . l2c2a) (&i/o-encoding . l2aa5) (&i/o-decoding . l2aa4) (&i/o-port . l2aa3) (&i/o-file-does-not-exist . l2aa2) (&i/o-file-already-exists . l2aa1) (&i/o-file-is-read-only . l2aa0) (&i/o-file-protection . l2a9f) (&i/o-filename . l2a9e) (&i/o-invalid-position . l2a9d) (&i/o-write . l2a9c) (&i/o-read . l2a9b) (&i/o . l2a9a) (error-handling-mode . l2a7f) (file-options . l2a7e) (buffer-mode . l2a7d) (eol-style . l2a7c)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2e00 '(rnrs enums) '(6) '() '() '() '((make-enumeration . l2c26) (enum-set=? . l2c25) (enum-set-universe . l2c24) (enum-set-union . l2c23) (enum-set-subset? . l2c22) (enum-set-projection . l2c21) (enum-set-member? . l2c20) (enum-set-intersection . l2c1f) (enum-set-indexer . l2c1e) (enum-set-difference . l2c1d) (enum-set-constructor . l2c1c) (enum-set-complement . l2c1b) (enum-set->list . l2c1a) (define-enumeration . l2a8a)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2e01 '(rnrs conditions) '(6) '() '() '() '((who-condition? . l2c19) (warning? . l2c18) (violation? . l2c17) (undefined-violation? . l2c16) (syntax-violation? . l2c15) (syntax-violation-subform . l2c14) (syntax-violation-form . l2c13) (syntax-violation . le57) (simple-conditions . l2c12) (serious-condition? . l2c11) (non-continuable-violation? . l2c10) (message-condition? . l2c0f) (make-who-condition . l2c0e) (make-warning . l2c0d) (make-violation . l2c0c) (make-undefined-violation . l2c0b) (make-syntax-violation . l2c0a) (make-serious-condition . l2c09) (make-non-continuable-violation . l2c08) (make-message-condition . l2c07) (make-lexical-violation . l2c06) (make-irritants-condition . l2c05) (make-implementation-restriction-violation . l2c04) (make-error . l2c03) (make-assertion-violation . l2c02) (lexical-violation? . l2c01) (irritants-condition? . l2c00) (implementation-restriction-violation? . l2bff) (error? . l2bfe) (condition-who . l2bfd) (condition-predicate . l2bfc) (condition-message . l2bfb) (condition-irritants . l2bfa) (condition-accessor . l2bf9) (condition . l2bf8) (assertion-violation? . l2bf7) (condition? . l2bf6) (&undefined . l2a99) (&syntax . l2a98) (&lexical . l2a97) (&implementation-restriction . l2a96) (&non-continuable . l2a95) (&who . l2a94) (&irritants . l2a93) (&assertion . l2a92) (&violation . l2a91) (&error . l2a90) (&serious . l2a8f) (&warning . l2a8e) (&message . l2a8d) (&condition . l2a8c) (define-condition-type . l2a8b)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2e02 '(rnrs records inspection) '(6) '() '() '() '((record? . l2cde) (record-type-uid . l2cdd) (record-type-sealed? . l2cdc) (record-type-parent . l2cdb) (record-type-opaque? . l2cda) (record-type-name . l2cd9) (record-type-generative? . l2cd8) (record-type-field-names . l2cd7) (record-rtd . l2cd6) (record-field-mutable? . l2cd5)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2e03 '(rnrs records procedural) '(6) '() '() '() '((record-type-descriptor? . l2ce5) (record-predicate . l2ce4) (record-mutator . l2ce3) (record-constructor . l2ce2) (record-accessor . l2ce1) (make-record-type-descriptor . l2ce0) (make-record-constructor-descriptor . l2cdf)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2e04 '(rnrs records syntactic) '(6) '() '() '() '((define-record-type . l2a89) (parent-rtd . l2a88) (nongenerative . l2a87) (opaque . l2a86) (sealed . l2a85) (protocol . l2a84) (parent . l2a83) (immutable . l2a82) (mutable . l2a81) (fields . l2a80) (record-constructor-descriptor . l2a60) (record-type-descriptor . l2a5f)) '() values values '#f '#f '#t '#f) (l98b@l7d7@install-library 'l2e05 '(psyntax system $all) '() '() '() '() '((&no-nans-rcd . l2de5) (&no-nans-rtd . l2de4) (&no-infinities-rcd . l2de3) (&no-infinities-rtd . l2de2) (&i/o-encoding-rcd . l2de1) (&i/o-encoding-rtd . l2de0) (&i/o-decoding-rcd . l2ddf) (&i/o-decoding-rtd . l2dde) (&i/o-port-rcd . l2ddd) (&i/o-port-rtd . l2ddc) (&i/o-file-does-not-exist-rcd . l2ddb) (&i/o-file-does-not-exist-rtd . l2dda) (&i/o-file-already-exists-rcd . l2dd9) (&i/o-file-already-exists-rtd . l2dd8) (&i/o-file-is-read-only-rcd . l2dd7) (&i/o-file-is-read-only-rtd . l2dd6) (&i/o-file-protection-rcd . l2dd5) (&i/o-file-protection-rtd . l2dd4) (&i/o-filename-rcd . l2dd3) (&i/o-filename-rtd . l2dd2) (&i/o-invalid-position-rcd . l2dd1) (&i/o-invalid-position-rtd . l2dd0) (&i/o-write-rcd . l2dcf) (&i/o-write-rtd . l2dce) (&i/o-read-rcd . l2dcd) (&i/o-read-rtd . l2dcc) (&i/o-rcd . l2dcb) (&i/o-rtd . l2dca) (&undefined-rcd . l2dc9) (&undefined-rtd . l2dc8) (&syntax-rcd . l2dc7) (&syntax-rtd . l2dc6) (&lexical-rcd . l2dc5) (&lexical-rtd . l2dc4) (&implementation-restriction-rcd . l2dc3) (&implementation-restriction-rtd . l2dc2) (&non-continuable-rcd . l2dc1) (&non-continuable-rtd . l2dc0) (&who-rcd . l2dbf) (&who-rtd . l2dbe) (&irritants-rcd . l2dbd) (&irritants-rtd . l2dbc) (&assertion-rcd . l2dbb) (&assertion-rtd . l2dba) (&violation-rcd . l2db9) (&violation-rtd . l2db8) (&error-rcd . l2db7) (&error-rtd . l2db6) (&serious-rcd . l2db5) (&serious-rtd . l2db4) (&warning-rcd . l2db3) (&warning-rtd . l2db2) (&message-rcd . l2db1) (&message-rtd . l2db0) (&condition-rcd . l2daf) (&condition-rtd . l2dae) (syntax-error . le53) (syntax-dispatch . ld77) (pretty-print . l2dad) (eval-core . l2dac) (set-symbol-value! . l2dab) (symbol-value . l2daa) (gensym . l2da9) (void . l2da8) (load . l28e0) (interaction-environment . le65) (char-ready? . l2da7) (regexp? . l2da6) (read-line . l2da5) (gensym-prefix-set! . l2da4) (ungensym . l2da3) (alist->eq-hash-table . l2da2) (assoc-ref . l2da1) (print . l2da0) (format . l2d9f) (host-os . l2d9e) (library-path . l7b6) (standard-library-path . l2d9d) (file-newer? . l2d9c) (stat-mtime . l2d9b) (write-to-file . l2d9a) (file->list . l2d99) (file->string . l2d98) (digit->integer . l2d97) (call-with-string-input-port . l2d96) (call-with-string-io . l2d95) (string-split . l2d94) (bytevector-for-each . l2d93) (string->regexp . l2d92) (rxmatch . l2d91) (regexp-replace-all . l2d90) (hashtable-for-each . l2d8f) (mosh-cache-dir . l5a0) (call-process . l2d8e) (local-tz-offset . l2d8d) (microseconds . l2d8c) (directory-list . l2d8b) (set-current-directory! . l2d8a) (expand-path . l2d89) (current-directory . l2d88) (%spawn . l2d87) (%waitpid . l2d86) (simple-struct-name . l2d85) (simple-struct-set! . l2d84) (simple-struct-ref . l2d83) (make-simple-struct . l2d82) (simple-struct? . l2d81) (pointer-ref-c-int64 . l2d80) (pointer-ref-c-int32 . l2d7f) (pointer-ref-c-int16 . l2d7e) (pointer-ref-c-int8 . l2d7d) (pointer-ref-c-uint64 . l2d7c) (pointer-ref-c-uint32 . l2d7b) (pointer-ref-c-uint16 . l2d7a) (pointer-ref-c-uint8 . l2d79) (pointer-set-c-uint64! . l2d78) (pointer-set-c-uint32! . l2d77) (pointer-set-c-uint16! . l2d76) (pointer-set-c-uint8! . l2d75) (pointer-set-c-int64! . l2d74) (pointer-set-c-int32! . l2d73) (pointer-set-c-int16! . l2d72) (pointer-set-c-int8! . l2d71) (pointer-set-c-pointer! . l2d70) (pointer-set-c-double! . l2d6f) (pointer-set-c-float! . l2d6e) (pointer-set-c-long-long! . l2d6d) (pointer-set-c-long! . l2d6c) (pointer-set-c-int! . l2d6b) (pointer-set-c-short! . l2d6a) (pointer-set-c-char! . l2d69) (pointer-ref-c-pointer . l2d68) (pointer-ref-c-double . l2d67) (pointer-ref-c-float . l2d66) (pointer-ref-c-unsigned-long-long . l2d65) (pointer-ref-c-signed-long-long . l2d64) (pointer-ref-c-unsigned-long . l2d63) (pointer-ref-c-signed-long . l2d62) (pointer-ref-c-unsigned-int . l2d61) (pointer-ref-c-signed-int . l2d60) (pointer-ref-c-unsigned-short . l2d5f) (pointer-ref-c-signed-short . l2d5e) (pointer-ref-c-unsigned-char . l2d5d) (pointer-ref-c-signed-char . l2d5c) (pointer->integer . l2d5b) (integer->pointer . l2d5a) (pointer? . l2d59) (shared-errno . l2d58) (%ffi-free-c-callback-trampoline . l2d57) (%ffi-make-c-callback-trampoline . l2d56) (%ffi-free . l2d55) (%ffi-malloc . l2d54) (%ffi-supported? . l2d53) (%ffi-pointer->string . l2d52) (%ffi-call . l2d51) (%ffi-lookup . l2d50) (%ffi-open . l2d4f) (null-terminated-utf8->string . l2d4e) (null-terminated-bytevector->string . l2d4d) (%exec . l2d4c) (%fork . l2d4b) (%pipe . l2d4a) (p . l2d49) (open-output-string . l2d48) (get-output-string . l2d47) (file-stat-ctime . l2d46) (file-stat-atime . l2d45) (file-stat-mtime . l2d44) (file-size-in-bytes . l2d43) (file-writable? . l2d42) (file-executable? . l2d41) (file-readable? . l2d40) (file-regular? . l2d3f) (file-symbolic-link? . l2d3e) (file-directory? . l2d3d) (create-symbolic-link . l2d3c) (rename-file . l2d3b) (delete-directory . l2d3a) (create-directory . l2d39) (create-mosh-cache-dir . l2d38) (get-environment-variables . l2d37) (current-exception-handler . l2d36) (get-environment-variable . l2d35) (join-wraps . l2d34) (id->real-label . l2d33) (same-marks? . l2d32) (same-marks*? . l2d31) (get-timeofday . l2d30) (get-command-line . l2d2f) (sys-display . l2d2e) (whereis . l2d2d) (register . l2d2c) (vm-join! . l2d2b) (vm-set-value! . l2d2a) (vm? . l2d29) (main-vm? . l2d28) (vm-eval . l2d27) (vm-self . l2d26) (vm-start! . l2d25) (make-vm . l2d24) (mutex-try-lock! . l2d23) (mutex-unlock! . l2d22) (mutex-lock! . l2d21) (mutex? . l2d20) (make-mutex . l2d1f) (condition-variable-notify-all! . l2d1e) (condition-variable-notify! . l2d1d) (condition-variable-wait! . l2d1c) (make-condition-variable . l2d1b) (write/ss . l2d1a) (mosh-executable-path . l2d19) (make-file-options . l2d18) (source-info . l2d17) (make-compiler-instruction . l2d16) (make-instruction . l2d15) (set-source-info! . l2d14) (bignum? . l2d13) (fast-equal? . l2d12) (fasl-read . l2d11) (fasl-write . l2d10) (time-usage . l2d0f) (os-constant . l2d0e) (disasm . l2d0d) (make-parameter . l59e) (socket-port . l2d0c) (socket-shutdown . l2d0b) (socket-close . l2d0a) (socket-send . l2d09) (socket-recv! . l2d08) (socket-recv . l2d07) (make-server-socket . l2d06) (make-client-socket . l2d05) (socket-accept . l2d04) (socket? . l2d03) (string-upcase . l2d02) (string-titlecase . l2d01) (string-normalize-nfkd . l2d00) (string-normalize-nfkc . l2cff) (string-normalize-nfd . l2cfe) (string-normalize-nfc . l2cfd) (string-foldcase . l2cfc) (string-downcase . l2cfb) (string-ci>? . l2cfa) (string-ci>=? . l2cf9) (string-ci=? . l2cf8) (string-ci<? . l2cf7) (string-ci<=? . l2cf6) (char-whitespace? . l2cf5) (char-upper-case? . l2cf4) (char-title-case? . l2cf3) (char-numeric? . l2cf2) (char-lower-case? . l2cf1) (char-general-category . l2cf0) (char-upcase . l2cef) (char-titlecase . l2cee) (char-foldcase . l2ced) (char-downcase . l2cec) (char-ci>? . l2ceb) (char-ci>=? . l2cea) (char-ci=? . l2ce9) (char-ci<? . l2ce8) (char-ci<=? . l2ce7) (char-alphabetic? . l2ce6) (make-variable-transformer . lba2) (identifier? . le59) (generate-temporaries . le45) (free-identifier=? . le47) (syntax->datum . le5d) (datum->syntax . le5b) (bound-identifier=? . le49) (record-type-descriptor? . l2ce5) (record-predicate . l2ce4) (record-mutator . l2ce3) (record-constructor . l2ce2) (record-accessor . l2ce1) (make-record-type-descriptor . l2ce0) (make-record-constructor-descriptor . l2cdf) (record? . l2cde) (record-type-uid . l2cdd) (record-type-sealed? . l2cdc) (record-type-parent . l2cdb) (record-type-opaque? . l2cda) (record-type-name . l2cd9) (record-type-generative? . l2cd8) (record-type-field-names . l2cd7) (record-rtd . l2cd6) (record-field-mutable? . l2cd5) (delete-file . l2cd4) (file-exists? . l2cd3) (vector-sort! . l2cd2) (vector-sort . l2cd1) (list-sort . l2cd0) (symbol-hash . l2ccf) (string-ci-hash . l2cce) (string-hash . l2ccd) (equal-hash . l2ccc) (hashtable-equivalence-function . l2ccb) (make-hashtable . l2cca) (hashtable-hash-function . l2cc9) (make-eqv-hashtable . l2cc8) (make-eq-hashtable . l2cc7) (hashtable? . l2cc6) (hashtable-update! . l2cc5) (hashtable-size . l2cc4) (hashtable-set! . l2cc3) (hashtable-ref . l2cc2) (hashtable-mutable? . l2cc1) (hashtable-keys . l2cc0) (hashtable-entries . l2cbf) (hashtable-delete! . l2cbe) (hashtable-copy . l2cbd) (hashtable-contains? . l2cbc) (hashtable-clear! . l2cbb) (call-with-output-file . l2cba) (call-with-input-file . l2cb9) (write-char . l2cb8) (write . l2cb7) (with-output-to-file . l2cb6) (with-input-from-file . l2cb5) (read-char . l2cb4) (read . l2cb3) (peek-char . l2cb2) (open-output-file . l2cb1) (open-input-file . l2cb0) (newline . l2caf) (display . l2cae) (close-output-port . l2cad) (close-input-port . l2cac) (eof-object? . l2cab) (eof-object . l2caa) (current-error-port . l2ca9) (current-output-port . l2ca8) (current-input-port . l2ca7) (output-port? . l2ca6) (input-port? . l2ca5) (utf-8-codec . l2ca4) (utf-16-codec . l2ca3) (transcoder-error-handling-mode . l2ca2) (transcoder-eol-style . l2ca1) (transcoder-codec . l2ca0) (transcoded-port . l2c9f) (textual-port? . l2c9e) (string->bytevector . l2c9d) (standard-output-port . l2c9c) (standard-input-port . l2c9b) (standard-error-port . l2c9a) (set-port-position! . l2c99) (put-u8 . l2c98) (put-string . l2c97) (put-datum . l2c96) (put-char . l2c95) (put-bytevector . l2c94) (port? . l2c93) (port-transcoder . l2c92) (port-position . l2c91) (port-has-set-port-position!? . l2c90) (port-has-port-position? . l2c8f) (port-eof? . l2c8e) (output-port-buffer-mode . l2c8d) (open-string-output-port . l2c8c) (open-string-input-port . l2c8b) (open-file-output-port . l2c8a) (open-file-input/output-port . l2c89) (open-file-input-port . l2c88) (open-bytevector-output-port . l2c87) (open-bytevector-input-port . l2c86) (native-transcoder . l2c85) (native-eol-style . l2c84) (make-transcoder . l2c83) (latin-1-codec . l2c82) (make-i/o-write-error . l2c81) (make-i/o-read-error . l2c80) (make-i/o-port-error . l2c7f) (make-i/o-invalid-position-error . l2c7e) (make-i/o-filename-error . l2c7d) (make-i/o-file-protection-error . l2c7c) (make-i/o-file-is-read-only-error . l2c7b) (make-i/o-file-does-not-exist-error . l2c7a) (make-i/o-file-already-exists-error . l2c79) (make-i/o-error . l2c78) (make-i/o-encoding-error . l2c77) (make-i/o-decoding-error . l2c76) (make-custom-textual-output-port . l2c75) (make-custom-textual-input/output-port . l2c74) (make-custom-textual-input-port . l2c73) (make-custom-binary-output-port . l2c72) (make-custom-binary-input/output-port . l2c71) (make-custom-binary-input-port . l2c70) (make-bytevector . l2c6f) (lookahead-u8 . l2c6e) (lookahead-char . l2c6d) (i/o-write-error? . l2c6c) (i/o-read-error? . l2c6b) (i/o-port-error? . l2c6a) (i/o-invalid-position-error? . l2c69) (i/o-filename-error? . l2c68) (i/o-file-protection-error? . l2c67) (i/o-file-is-read-only-error? . l2c66) (i/o-file-does-not-exist-error? . l2c65) (i/o-file-already-exists-error? . l2c64) (i/o-error? . l2c63) (i/o-error-position . l2c62) (i/o-error-port . l2c61) (i/o-error-filename . l2c60) (i/o-encoding-error? . l2c5f) (i/o-encoding-error-char . l2c5e) (i/o-decoding-error? . l2c5d) (get-u8 . l2c5c) (get-string-n! . l2c5b) (get-string-n . l2c5a) (get-string-all . l2c59) (get-line . l2c58) (get-datum . l2c57) (get-char . l2c56) (get-bytevector-some . l2c55) (get-bytevector-n! . l2c54) (get-bytevector-n . l2c53) (get-bytevector-all . l2c52) (flush-output-port . l2c51) (close-port . l2c50) (scheme-report-environment . le33) (quotient . l2c4f) (null-environment . le31) (remainder . l2c4e) (modulo . l2c4d) (inexact->exact . l2c4c) (force . l2c4b) (exact->inexact . l2c4a) (make-promise . l2c49) (exit . l2c48) (command-line . l28da) (string-fill! . l2c47) (string-set! . l2c46) (set-cdr! . l2c45) (set-car! . l2c44) (remove . l2c43) (remv . l2c42) (remp . l2c41) (remq . l2c40) (partition . l2c3f) (memv . l2c3e) (memq . l2c3d) (memp . l2c3c) (member . l2c3b) (exists . l2c3a) (for-all . l2c39) (fold-right . l2c38) (fold-left . l2c37) (find . l2c36) (filter . l2c35) (cons* . l2c34) (assv . l2c33) (assq . l2c32) (assp . l2c31) (assoc . l2c30) (call-with-string-output-port . l2c2f) (call-with-port . l2c2e) (call-with-bytevector-output-port . l2c2d) (bytevector->string . l2c2c) (buffer-mode? . l2c2b) (binary-port? . l2c2a) (with-exception-handler . l2c29) (raise-continuable . l2c28) (raise . l2c27) (eval . le37) (environment . le2f) (make-enumeration . l2c26) (enum-set=? . l2c25) (enum-set-universe . l2c24) (enum-set-union . l2c23) (enum-set-subset? . l2c22) (enum-set-projection . l2c21) (enum-set-member? . l2c20) (enum-set-intersection . l2c1f) (enum-set-indexer . l2c1e) (enum-set-difference . l2c1d) (enum-set-constructor . l2c1c) (enum-set-complement . l2c1b) (enum-set->list . l2c1a) (who-condition? . l2c19) (warning? . l2c18) (violation? . l2c17) (undefined-violation? . l2c16) (syntax-violation? . l2c15) (syntax-violation-subform . l2c14) (syntax-violation-form . l2c13) (syntax-violation . le57) (simple-conditions . l2c12) (serious-condition? . l2c11) (non-continuable-violation? . l2c10) (message-condition? . l2c0f) (make-who-condition . l2c0e) (make-warning . l2c0d) (make-violation . l2c0c) (make-undefined-violation . l2c0b) (make-syntax-violation . l2c0a) (make-serious-condition . l2c09) (make-non-continuable-violation . l2c08) (make-message-condition . l2c07) (make-lexical-violation . l2c06) (make-irritants-condition . l2c05) (make-implementation-restriction-violation . l2c04) (make-error . l2c03) (make-assertion-violation . l2c02) (lexical-violation? . l2c01) (irritants-condition? . l2c00) (implementation-restriction-violation? . l2bff) (error? . l2bfe) (condition-who . l2bfd) (condition-predicate . l2bfc) (condition-message . l2bfb) (condition-irritants . l2bfa) (condition-accessor . l2bf9) (condition . l2bf8) (assertion-violation? . l2bf7) (condition? . l2bf6) (utf32->string . l2bf5) (utf16->string . l2bf4) (utf8->string . l2bf3) (uint-list->bytevector . l2bf2) (u8-list->bytevector . l2bf1) (string->utf8 . l2bf0) (string->utf32 . l2bef) (string->utf16 . l2bee) (sint-list->bytevector . l2bed) (native-endianness . l2bec) (bytevector? . l2beb) (bytevector=? . l2bea) (bytevector-uint-set! . l2be9) (bytevector-uint-ref . l2be8) (bytevector-u8-set! . l2be7) (bytevector-u8-ref . l2be6) (bytevector-u64-set! . l2be5) (bytevector-u64-ref . l2be4) (bytevector-u64-native-set! . l2be3) (bytevector-u64-native-ref . l2be2) (bytevector-u32-set! . l2be1) (bytevector-u32-ref . l2be0) (bytevector-u32-native-set! . l2bdf) (bytevector-u32-native-ref . l2bde) (bytevector-u16-set! . l2bdd) (bytevector-u16-ref . l2bdc) (bytevector-u16-native-set! . l2bdb) (bytevector-u16-native-ref . l2bda) (bytevector-sint-set! . l2bd9) (bytevector-sint-ref . l2bd8) (bytevector-s8-set! . l2bd7) (bytevector-s8-ref . l2bd6) (bytevector-s64-set! . l2bd5) (bytevector-s64-ref . l2bd4) (bytevector-s64-native-set! . l2bd3) (bytevector-s64-native-ref . l2bd2) (bytevector-s32-set! . l2bd1) (bytevector-s32-ref . l2bd0) (bytevector-s32-native-set! . l2bcf) (bytevector-s32-native-ref . l2bce) (bytevector-s16-set! . l2bcd) (bytevector-s16-ref . l2bcc) (bytevector-s16-native-set! . l2bcb) (bytevector-s16-native-ref . l2bca) (bytevector-length . l2bc9) (bytevector-ieee-single-ref . l2bc8) (bytevector-ieee-single-set! . l2bc7) (bytevector-ieee-single-native-set! . l2bc6) (bytevector-ieee-single-native-ref . l2bc5) (bytevector-ieee-double-set! . l2bc4) (bytevector-ieee-double-ref . l2bc3) (bytevector-ieee-double-native-set! . l2bc2) (bytevector-ieee-double-native-ref . l2bc1) (bytevector-fill! . l2bc0) (bytevector-copy! . l2bbf) (bytevector-copy . l2bbe) (bytevector->uint-list . l2bbd) (bytevector->u8-list . l2bbc) (bytevector->sint-list . l2bbb) (no-nans-violation? . l2bba) (no-infinities-violation? . l2bb9) (make-no-nans-violation . l2bb8) (make-no-infinities-violation . l2bb7) (real->flonum . l2bb6) (flzero? . l2bb5) (fltruncate . l2bb4) (fltan . l2bb3) (flsqrt . l2bb2) (flsin . l2bb1) (flround . l2bb0) (flpositive? . l2baf) (flonum? . l2bae) (flodd? . l2bad) (flnumerator . l2bac) (flnegative? . l2bab) (flnan? . l2baa) (flmod0 . l2ba9) (flmod . l2ba8) (flmin . l2ba7) (flmax . l2ba6) (fllog . l2ba5) (flinteger? . l2ba4) (flinfinite? . l2ba3) (flfloor . l2ba2) (flfinite? . l2ba1) (flexpt . l2ba0) (flexp . l2b9f) (fleven? . l2b9e) (fldiv0-and-mod0 . l2b9d) (fldiv0 . l2b9c) (fldiv-and-mod . l2b9b) (fldiv . l2b9a) (fldenominator . l2b99) (flcos . l2b98) (flceiling . l2b97) (flatan . l2b96) (flasin . l2b95) (flacos . l2b94) (flabs . l2b93) (fl>? . l2b92) (fl>=? . l2b91) (fl=? . l2b90) (fl<? . l2b8f) (fl<=? . l2b8e) (fl/ . l2b8d) (fl- . l2b8c) (fl+ . l2b8b) (fl* . l2b8a) (fixnum->flonum . l2b89) (fxzero? . l2b88) (fxxor . l2b87) (fxrotate-bit-field . l2b86) (fxreverse-bit-field . l2b85) (fxpositive? . l2b84) (fxodd? . l2b83) (fxnot . l2b82) (fxnegative? . l2b81) (fxmod0 . l2b80) (fxmod . l2b7f) (fxmin . l2b7e) (fxmax . l2b7d) (fxlength . l2b7c) (fxior . l2b7b) (fxif . l2b7a) (fxfirst-bit-set . l2b79) (fxeven? . l2b78) (fxdiv0-and-mod0 . l2b77) (fxdiv0 . l2b76) (fxdiv-and-mod . l2b75) (fxdiv . l2b74) (fxcopy-bit-field . l2b73) (fxcopy-bit . l2b72) (fxbit-set? . l2b71) (fxbit-field . l2b70) (fxbit-count . l2b6f) (fxarithmetic-shift-right . l2b6e) (fxarithmetic-shift-left . l2b6d) (fxarithmetic-shift . l2b6c) (fxand . l2b6b) (fx>? . l2b6a) (fx>=? . l2b69) (fx=? . l2b68) (fx<? . l2b67) (fx<=? . l2b66) (fx-/carry . l2b65) (fx- . l2b64) (fx+/carry . l2b63) (fx+ . l2b62) (fx*/carry . l2b61) (fx* . l2b60) (greatest-fixnum . l2b5f) (least-fixnum . l2b5e) (fixnum-width . l2b5d) (fixnum? . l2b5c) (bitwise-rotate-bit-field . l2b5b) (bitwise-reverse-bit-field . l2b5a) (bitwise-length . l2b59) (bitwise-if . l2b58) (bitwise-first-bit-set . l2b57) (bitwise-copy-bit-field . l2b56) (bitwise-copy-bit . l2b55) (bitwise-bit-set? . l2b54) (bitwise-bit-field . l2b53) (bitwise-bit-count . l2b52) (bitwise-xor . l2b51) (bitwise-ior . l2b50) (bitwise-and . l2b4f) (bitwise-not . l2b4e) (bitwise-arithmetic-shift-right . l2b4d) (bitwise-arithmetic-shift-left . l2b4c) (bitwise-arithmetic-shift . l2b4b) (zero? . l2b4a) (vector? . l2b49) (vector-set! . l2b48) (vector-ref . l2b47) (vector-map . l2b46) (vector-length . l2b45) (vector-for-each . l2b44) (vector-fill! . l2b43) (vector->list . l2b42) (vector . l2b41) (values . l2b40) (truncate . l2b3f) (tan . l2b3e) (symbol? . l2b3d) (symbol=? . l2b3c) (symbol->string . l2b3b) (substring . l2b3a) (string? . l2b39) (string>? . l2b38) (string>=? . l2b37) (string=? . l2b36) (string<? . l2b35) (string<=? . l2b34) (string-ref . l2b33) (string-length . l2b32) (string-for-each . l2b31) (string-copy . l2b30) (string-append . l2b2f) (string->symbol . l2b2e) (string->number . l2b2d) (string->list . l2b2c) (string . l2b2b) (sqrt . l2b2a) (sin . l2b29) (round . l2b28) (reverse . l2b27) (real? . l2b26) (real-valued? . l2b25) (real-part . l2b24) (rationalize . l2b23) (rational? . l2b22) (rational-valued? . l2b21) (procedure? . l2b20) (positive? . l2b1f) (pair? . l2b1e) (odd? . l2b1d) (numerator . l2b1c) (number? . l2b1b) (number->string . l2b1a) (null? . l2b19) (not . l2b18) (negative? . l2b17) (nan? . l2b16) (min . l2b15) (max . l2b14) (map . l2b13) (make-vector . l2b12) (make-string . l2b11) (make-rectangular . l2b10) (make-polar . l2b0f) (magnitude . l2b0e) (log . l2b0d) (list? . l2b0c) (list-tail . l2b0b) (list-ref . l2b0a) (list->vector . l2b09) (list->string . l2b08) (list . l2b07) (length . l2b06) (lcm . l2b05) (integer? . l2b04) (integer-valued? . l2b03) (integer->char . l2b02) (infinite? . l2b01) (inexact? . l2b00) (inexact . l2aff) (imag-part . l2afe) (gcd . l2afd) (for-each . l2afc) (floor . l2afb) (finite? . l2afa) (expt . l2af9) (exp . l2af8) (exact? . l2af7) (exact-integer-sqrt . l2af6) (exact . l2af5) (even? . l2af4) (error . l2af3) (eqv? . l2af2) (equal? . l2af1) (eq? . l2af0) (dynamic-wind . l2aef) (div0-and-mod0 . l2aee) (mod0 . l2aed) (div0 . l2aec) (div-and-mod . l2aeb) (mod . l2aea) (div . l2ae9) (denominator . l2ae8) (cos . l2ae7) (cons . l2ae6) (complex? . l2ae5) (char? . l2ae4) (char>? . l2ae3) (char>=? . l2ae2) (char=? . l2ae1) (char<? . l2ae0) (char<=? . l2adf) (char->integer . l2ade) (ceiling . l2add) (call-with-values . l2adc) (call/cc . l2adb) (call-with-current-continuation . l2ada) (cddddr . l2ad9) (cdddar . l2ad8) (cddadr . l2ad7) (cddaar . l2ad6) (cdaddr . l2ad5) (cdadar . l2ad4) (cdaadr . l2ad3) (cdaaar . l2ad2) (cadddr . l2ad1) (caddar . l2ad0) (cadadr . l2acf) (cadaar . l2ace) (caaddr . l2acd) (caadar . l2acc) (caaadr . l2acb) (caaaar . l2aca) (cdddr . l2ac9) (cddar . l2ac8) (cdadr . l2ac7) (cdaar . l2ac6) (caddr . l2ac5) (cadar . l2ac4) (caadr . l2ac3) (caaar . l2ac2) (cddr . l2ac1) (cdar . l2ac0) (cadr . l2abf) (caar . l2abe) (cdr . l2abd) (car . l2abc) (boolean? . l2abb) (boolean=? . l2aba) (atan . l2ab9) (assertion-violation . l2ab8) (assertion-error . le51) (asin . l2ab7) (apply . l2ab6) (append . l2ab5) (angle . l2ab4) (acos . l2ab3) (abs . l2ab2) (/ . l2ab1) (* . l2ab0) (- . l2aaf) (+ . l2aae) (>= . l2aad) (> . l2aac) (= . l2aab) (<= . l2aaa) (< . l2aa9) (library . l2aa8) (&no-nans . l2aa7) (&no-infinities . l2aa6) (&i/o-encoding . l2aa5) (&i/o-decoding . l2aa4) (&i/o-port . l2aa3) (&i/o-file-does-not-exist . l2aa2) (&i/o-file-already-exists . l2aa1) (&i/o-file-is-read-only . l2aa0) (&i/o-file-protection . l2a9f) (&i/o-filename . l2a9e) (&i/o-invalid-position . l2a9d) (&i/o-write . l2a9c) (&i/o-read . l2a9b) (&i/o . l2a9a) (&undefined . l2a99) (&syntax . l2a98) (&lexical . l2a97) (&implementation-restriction . l2a96) (&non-continuable . l2a95) (&who . l2a94) (&irritants . l2a93) (&assertion . l2a92) (&violation . l2a91) (&error . l2a90) (&serious . l2a8f) (&warning . l2a8e) (&message . l2a8d) (&condition . l2a8c) (define-condition-type . l2a8b) (define-enumeration . l2a8a) (define-record-type . l2a89) (parent-rtd . l2a88) (nongenerative . l2a87) (opaque . l2a86) (sealed . l2a85) (protocol . l2a84) (parent . l2a83) (immutable . l2a82) (mutable . l2a81) (fields . l2a80) (error-handling-mode . l2a7f) (file-options . l2a7e) (buffer-mode . l2a7d) (eol-style . l2a7c) (guard . l2a7b) (trace-define . l2a7a) (trace-lambda . l2a79) (unsyntax-splicing . l2a78) (unsyntax . l2a77) (unquote-splicing . l2a76) (unquote . l2a75) (_ . l2a74) (else . l2a73) (=> . l2a72) (... . l2a71) (assert . l2a70) (endianness . l2a6f) (delay . l2a6e) (time . l2a6d) (do . l2a6c) (cond . l2a6b) (let* . l2a6a) (let*-values . l2a69) (let-values . l2a68) (identifier-syntax . l2a67) (with-syntax . l2a66) (quasisyntax . l2a65) (quasiquote . l2a64) (syntax-rules . l2a63) (include . l2a62) (define-struct . l2a61) (record-constructor-descriptor . l2a60) (record-type-descriptor . l2a5f) (case . l2a5e) (parameterize . l2a5d) (unless . l2a5c) (when . l2a5b) (or . l2a5a) (and . l2a59) (if . l2a58) (let . l2a57) (letrec* . l2a56) (letrec . l2a55) (type-descriptor . l2a54) (case-lambda . l2a53) (lambda . l2a52) (syntax . l2a51) (syntax-case . l2a50) (quote . l2a4f) (foreign-call . l2a4e) (letrec-syntax . l2a4d) (let-syntax . l2a4c) (set! . l2a4b) (import . l2a4a) (begin . l2a49) (module . l2a48) (define-syntax . l2a47) (define . l2a46)) '((l2de5 core-prim . &no-nans-rcd) (l2de4 core-prim . &no-nans-rtd) (l2de3 core-prim . &no-infinities-rcd) (l2de2 core-prim . &no-infinities-rtd) (l2de1 core-prim . &i/o-encoding-rcd) (l2de0 core-prim . &i/o-encoding-rtd) (l2ddf core-prim . &i/o-decoding-rcd) (l2dde core-prim . &i/o-decoding-rtd) (l2ddd core-prim . &i/o-port-rcd) (l2ddc core-prim . &i/o-port-rtd) (l2ddb core-prim . &i/o-file-does-not-exist-rcd) (l2dda core-prim . &i/o-file-does-not-exist-rtd) (l2dd9 core-prim . &i/o-file-already-exists-rcd) (l2dd8 core-prim . &i/o-file-already-exists-rtd) (l2dd7 core-prim . &i/o-file-is-read-only-rcd) (l2dd6 core-prim . &i/o-file-is-read-only-rtd) (l2dd5 core-prim . &i/o-file-protection-rcd) (l2dd4 core-prim . &i/o-file-protection-rtd) (l2dd3 core-prim . &i/o-filename-rcd) (l2dd2 core-prim . &i/o-filename-rtd) (l2dd1 core-prim . &i/o-invalid-position-rcd) (l2dd0 core-prim . &i/o-invalid-position-rtd) (l2dcf core-prim . &i/o-write-rcd) (l2dce core-prim . &i/o-write-rtd) (l2dcd core-prim . &i/o-read-rcd) (l2dcc core-prim . &i/o-read-rtd) (l2dcb core-prim . &i/o-rcd) (l2dca core-prim . &i/o-rtd) (l2dc9 core-prim . &undefined-rcd) (l2dc8 core-prim . &undefined-rtd) (l2dc7 core-prim . &syntax-rcd) (l2dc6 core-prim . &syntax-rtd) (l2dc5 core-prim . &lexical-rcd) (l2dc4 core-prim . &lexical-rtd) (l2dc3 core-prim . &implementation-restriction-rcd) (l2dc2 core-prim . &implementation-restriction-rtd) (l2dc1 core-prim . &non-continuable-rcd) (l2dc0 core-prim . &non-continuable-rtd) (l2dbf core-prim . &who-rcd) (l2dbe core-prim . &who-rtd) (l2dbd core-prim . &irritants-rcd) (l2dbc core-prim . &irritants-rtd) (l2dbb core-prim . &assertion-rcd) (l2dba core-prim . &assertion-rtd) (l2db9 core-prim . &violation-rcd) (l2db8 core-prim . &violation-rtd) (l2db7 core-prim . &error-rcd) (l2db6 core-prim . &error-rtd) (l2db5 core-prim . &serious-rcd) (l2db4 core-prim . &serious-rtd) (l2db3 core-prim . &warning-rcd) (l2db2 core-prim . &warning-rtd) (l2db1 core-prim . &message-rcd) (l2db0 core-prim . &message-rtd) (l2daf core-prim . &condition-rcd) (l2dae core-prim . &condition-rtd) (le53 core-prim . syntax-error) (ld77 core-prim . syntax-dispatch) (l2dad core-prim . pretty-print) (l2dac core-prim . eval-core) (l2dab core-prim . set-symbol-value!) (l2daa core-prim . symbol-value) (l2da9 core-prim . gensym) (l2da8 core-prim . void) (l28e0 core-prim . load) (le65 core-prim . interaction-environment) (l2da7 core-prim . char-ready?) (l2da6 core-prim . regexp?) (l2da5 core-prim . read-line) (l2da4 core-prim . gensym-prefix-set!) (l2da3 core-prim . ungensym) (l2da2 core-prim . alist->eq-hash-table) (l2da1 core-prim . assoc-ref) (l2da0 core-prim . print) (l2d9f core-prim . format) (l2d9e core-prim . host-os) (l7b6 core-prim . library-path) (l2d9d core-prim . standard-library-path) (l2d9c core-prim . file-newer?) (l2d9b core-prim . stat-mtime) (l2d9a core-prim . write-to-file) (l2d99 core-prim . file->list) (l2d98 core-prim . file->string) (l2d97 core-prim . digit->integer) (l2d96 core-prim . call-with-string-input-port) (l2d95 core-prim . call-with-string-io) (l2d94 core-prim . string-split) (l2d93 core-prim . bytevector-for-each) (l2d92 core-prim . string->regexp) (l2d91 core-prim . rxmatch) (l2d90 core-prim . regexp-replace-all) (l2d8f core-prim . hashtable-for-each) (l5a0 core-prim . mosh-cache-dir) (l2d8e core-prim . call-process) (l2d8d core-prim . local-tz-offset) (l2d8c core-prim . microseconds) (l2d8b core-prim . directory-list) (l2d8a core-prim . set-current-directory!) (l2d89 core-prim . expand-path) (l2d88 core-prim . current-directory) (l2d87 core-prim . %spawn) (l2d86 core-prim . %waitpid) (l2d85 core-prim . simple-struct-name) (l2d84 core-prim . simple-struct-set!) (l2d83 core-prim . simple-struct-ref) (l2d82 core-prim . make-simple-struct) (l2d81 core-prim . simple-struct?) (l2d80 core-prim . pointer-ref-c-int64) (l2d7f core-prim . pointer-ref-c-int32) (l2d7e core-prim . pointer-ref-c-int16) (l2d7d core-prim . pointer-ref-c-int8) (l2d7c core-prim . pointer-ref-c-uint64) (l2d7b core-prim . pointer-ref-c-uint32) (l2d7a core-prim . pointer-ref-c-uint16) (l2d79 core-prim . pointer-ref-c-uint8) (l2d78 core-prim . pointer-set-c-uint64!) (l2d77 core-prim . pointer-set-c-uint32!) (l2d76 core-prim . pointer-set-c-uint16!) (l2d75 core-prim . pointer-set-c-uint8!) (l2d74 core-prim . pointer-set-c-int64!) (l2d73 core-prim . pointer-set-c-int32!) (l2d72 core-prim . pointer-set-c-int16!) (l2d71 core-prim . pointer-set-c-int8!) (l2d70 core-prim . pointer-set-c-pointer!) (l2d6f core-prim . pointer-set-c-double!) (l2d6e core-prim . pointer-set-c-float!) (l2d6d core-prim . pointer-set-c-long-long!) (l2d6c core-prim . pointer-set-c-long!) (l2d6b core-prim . pointer-set-c-int!) (l2d6a core-prim . pointer-set-c-short!) (l2d69 core-prim . pointer-set-c-char!) (l2d68 core-prim . pointer-ref-c-pointer) (l2d67 core-prim . pointer-ref-c-double) (l2d66 core-prim . pointer-ref-c-float) (l2d65 core-prim . pointer-ref-c-unsigned-long-long) (l2d64 core-prim . pointer-ref-c-signed-long-long) (l2d63 core-prim . pointer-ref-c-unsigned-long) (l2d62 core-prim . pointer-ref-c-signed-long) (l2d61 core-prim . pointer-ref-c-unsigned-int) (l2d60 core-prim . pointer-ref-c-signed-int) (l2d5f core-prim . pointer-ref-c-unsigned-short) (l2d5e core-prim . pointer-ref-c-signed-short) (l2d5d core-prim . pointer-ref-c-unsigned-char) (l2d5c core-prim . pointer-ref-c-signed-char) (l2d5b core-prim . pointer->integer) (l2d5a core-prim . integer->pointer) (l2d59 core-prim . pointer?) (l2d58 core-prim . shared-errno) (l2d57 core-prim . %ffi-free-c-callback-trampoline) (l2d56 core-prim . %ffi-make-c-callback-trampoline) (l2d55 core-prim . %ffi-free) (l2d54 core-prim . %ffi-malloc) (l2d53 core-prim . %ffi-supported?) (l2d52 core-prim . %ffi-pointer->string) (l2d51 core-prim . %ffi-call) (l2d50 core-prim . %ffi-lookup) (l2d4f core-prim . %ffi-open) (l2d4e core-prim . null-terminated-utf8->string) (l2d4d core-prim . null-terminated-bytevector->string) (l2d4c core-prim . %exec) (l2d4b core-prim . %fork) (l2d4a core-prim . %pipe) (l2d49 core-prim . p) (l2d48 core-prim . open-output-string) (l2d47 core-prim . get-output-string) (l2d46 core-prim . file-stat-ctime) (l2d45 core-prim . file-stat-atime) (l2d44 core-prim . file-stat-mtime) (l2d43 core-prim . file-size-in-bytes) (l2d42 core-prim . file-writable?) (l2d41 core-prim . file-executable?) (l2d40 core-prim . file-readable?) (l2d3f core-prim . file-regular?) (l2d3e core-prim . file-symbolic-link?) (l2d3d core-prim . file-directory?) (l2d3c core-prim . create-symbolic-link) (l2d3b core-prim . rename-file) (l2d3a core-prim . delete-directory) (l2d39 core-prim . create-directory) (l2d38 core-prim . create-mosh-cache-dir) (l2d37 core-prim . get-environment-variables) (l2d36 core-prim . current-exception-handler) (l2d35 core-prim . get-environment-variable) (l2d34 core-prim . join-wraps) (l2d33 core-prim . id->real-label) (l2d32 core-prim . same-marks?) (l2d31 core-prim . same-marks*?) (l2d30 core-prim . get-timeofday) (l2d2f core-prim . get-command-line) (l2d2e core-prim . sys-display) (l2d2d core-prim . whereis) (l2d2c core-prim . register) (l2d2b core-prim . vm-join!) (l2d2a core-prim . vm-set-value!) (l2d29 core-prim . vm?) (l2d28 core-prim . main-vm?) (l2d27 core-prim . vm-eval) (l2d26 core-prim . vm-self) (l2d25 core-prim . vm-start!) (l2d24 core-prim . make-vm) (l2d23 core-prim . mutex-try-lock!) (l2d22 core-prim . mutex-unlock!) (l2d21 core-prim . mutex-lock!) (l2d20 core-prim . mutex?) (l2d1f core-prim . make-mutex) (l2d1e core-prim . condition-variable-notify-all!) (l2d1d core-prim . condition-variable-notify!) (l2d1c core-prim . condition-variable-wait!) (l2d1b core-prim . make-condition-variable) (l2d1a core-prim . write/ss) (l2d19 core-prim . mosh-executable-path) (l2d18 core-prim . make-file-options) (l2d17 core-prim . source-info) (l2d16 core-prim . make-compiler-instruction) (l2d15 core-prim . make-instruction) (l2d14 core-prim . set-source-info!) (l2d13 core-prim . bignum?) (l2d12 core-prim . fast-equal?) (l2d11 core-prim . fasl-read) (l2d10 core-prim . fasl-write) (l2d0f core-prim . time-usage) (l2d0e core-prim . os-constant) (l2d0d core-prim . disasm) (l59e core-prim . make-parameter) (l2d0c core-prim . socket-port) (l2d0b core-prim . socket-shutdown) (l2d0a core-prim . socket-close) (l2d09 core-prim . socket-send) (l2d08 core-prim . socket-recv!) (l2d07 core-prim . socket-recv) (l2d06 core-prim . make-server-socket) (l2d05 core-prim . make-client-socket) (l2d04 core-prim . socket-accept) (l2d03 core-prim . socket?) (l2d02 core-prim . string-upcase) (l2d01 core-prim . string-titlecase) (l2d00 core-prim . string-normalize-nfkd) (l2cff core-prim . string-normalize-nfkc) (l2cfe core-prim . string-normalize-nfd) (l2cfd core-prim . string-normalize-nfc) (l2cfc core-prim . string-foldcase) (l2cfb core-prim . string-downcase) (l2cfa core-prim . string-ci>?) (l2cf9 core-prim . string-ci>=?) (l2cf8 core-prim . string-ci=?) (l2cf7 core-prim . string-ci<?) (l2cf6 core-prim . string-ci<=?) (l2cf5 core-prim . char-whitespace?) (l2cf4 core-prim . char-upper-case?) (l2cf3 core-prim . char-title-case?) (l2cf2 core-prim . char-numeric?) (l2cf1 core-prim . char-lower-case?) (l2cf0 core-prim . char-general-category) (l2cef core-prim . char-upcase) (l2cee core-prim . char-titlecase) (l2ced core-prim . char-foldcase) (l2cec core-prim . char-downcase) (l2ceb core-prim . char-ci>?) (l2cea core-prim . char-ci>=?) (l2ce9 core-prim . char-ci=?) (l2ce8 core-prim . char-ci<?) (l2ce7 core-prim . char-ci<=?) (l2ce6 core-prim . char-alphabetic?) (lba2 core-prim . make-variable-transformer) (le59 core-prim . identifier?) (le45 core-prim . generate-temporaries) (le47 core-prim . free-identifier=?) (le5d core-prim . syntax->datum) (le5b core-prim . datum->syntax) (le49 core-prim . bound-identifier=?) (l2ce5 core-prim . record-type-descriptor?) (l2ce4 core-prim . record-predicate) (l2ce3 core-prim . record-mutator) (l2ce2 core-prim . record-constructor) (l2ce1 core-prim . record-accessor) (l2ce0 core-prim . make-record-type-descriptor) (l2cdf core-prim . make-record-constructor-descriptor) (l2cde core-prim . record?) (l2cdd core-prim . record-type-uid) (l2cdc core-prim . record-type-sealed?) (l2cdb core-prim . record-type-parent) (l2cda core-prim . record-type-opaque?) (l2cd9 core-prim . record-type-name) (l2cd8 core-prim . record-type-generative?) (l2cd7 core-prim . record-type-field-names) (l2cd6 core-prim . record-rtd) (l2cd5 core-prim . record-field-mutable?) (l2cd4 core-prim . delete-file) (l2cd3 core-prim . file-exists?) (l2cd2 core-prim . vector-sort!) (l2cd1 core-prim . vector-sort) (l2cd0 core-prim . list-sort) (l2ccf core-prim . symbol-hash) (l2cce core-prim . string-ci-hash) (l2ccd core-prim . string-hash) (l2ccc core-prim . equal-hash) (l2ccb core-prim . hashtable-equivalence-function) (l2cca core-prim . make-hashtable) (l2cc9 core-prim . hashtable-hash-function) (l2cc8 core-prim . make-eqv-hashtable) (l2cc7 core-prim . make-eq-hashtable) (l2cc6 core-prim . hashtable?) (l2cc5 core-prim . hashtable-update!) (l2cc4 core-prim . hashtable-size) (l2cc3 core-prim . hashtable-set!) (l2cc2 core-prim . hashtable-ref) (l2cc1 core-prim . hashtable-mutable?) (l2cc0 core-prim . hashtable-keys) (l2cbf core-prim . hashtable-entries) (l2cbe core-prim . hashtable-delete!) (l2cbd core-prim . hashtable-copy) (l2cbc core-prim . hashtable-contains?) (l2cbb core-prim . hashtable-clear!) (l2cba core-prim . call-with-output-file) (l2cb9 core-prim . call-with-input-file) (l2cb8 core-prim . write-char) (l2cb7 core-prim . write) (l2cb6 core-prim . with-output-to-file) (l2cb5 core-prim . with-input-from-file) (l2cb4 core-prim . read-char) (l2cb3 core-prim . read) (l2cb2 core-prim . peek-char) (l2cb1 core-prim . open-output-file) (l2cb0 core-prim . open-input-file) (l2caf core-prim . newline) (l2cae core-prim . display) (l2cad core-prim . close-output-port) (l2cac core-prim . close-input-port) (l2cab core-prim . eof-object?) (l2caa core-prim . eof-object) (l2ca9 core-prim . current-error-port) (l2ca8 core-prim . current-output-port) (l2ca7 core-prim . current-input-port) (l2ca6 core-prim . output-port?) (l2ca5 core-prim . input-port?) (l2ca4 core-prim . utf-8-codec) (l2ca3 core-prim . utf-16-codec) (l2ca2 core-prim . transcoder-error-handling-mode) (l2ca1 core-prim . transcoder-eol-style) (l2ca0 core-prim . transcoder-codec) (l2c9f core-prim . transcoded-port) (l2c9e core-prim . textual-port?) (l2c9d core-prim . string->bytevector) (l2c9c core-prim . standard-output-port) (l2c9b core-prim . standard-input-port) (l2c9a core-prim . standard-error-port) (l2c99 core-prim . set-port-position!) (l2c98 core-prim . put-u8) (l2c97 core-prim . put-string) (l2c96 core-prim . put-datum) (l2c95 core-prim . put-char) (l2c94 core-prim . put-bytevector) (l2c93 core-prim . port?) (l2c92 core-prim . port-transcoder) (l2c91 core-prim . port-position) (l2c90 core-prim . port-has-set-port-position!?) (l2c8f core-prim . port-has-port-position?) (l2c8e core-prim . port-eof?) (l2c8d core-prim . output-port-buffer-mode) (l2c8c core-prim . open-string-output-port) (l2c8b core-prim . open-string-input-port) (l2c8a core-prim . open-file-output-port) (l2c89 core-prim . open-file-input/output-port) (l2c88 core-prim . open-file-input-port) (l2c87 core-prim . open-bytevector-output-port) (l2c86 core-prim . open-bytevector-input-port) (l2c85 core-prim . native-transcoder) (l2c84 core-prim . native-eol-style) (l2c83 core-prim . make-transcoder) (l2c82 core-prim . latin-1-codec) (l2c81 core-prim . make-i/o-write-error) (l2c80 core-prim . make-i/o-read-error) (l2c7f core-prim . make-i/o-port-error) (l2c7e core-prim . make-i/o-invalid-position-error) (l2c7d core-prim . make-i/o-filename-error) (l2c7c core-prim . make-i/o-file-protection-error) (l2c7b core-prim . make-i/o-file-is-read-only-error) (l2c7a core-prim . make-i/o-file-does-not-exist-error) (l2c79 core-prim . make-i/o-file-already-exists-error) (l2c78 core-prim . make-i/o-error) (l2c77 core-prim . make-i/o-encoding-error) (l2c76 core-prim . make-i/o-decoding-error) (l2c75 core-prim . make-custom-textual-output-port) (l2c74 core-prim . make-custom-textual-input/output-port) (l2c73 core-prim . make-custom-textual-input-port) (l2c72 core-prim . make-custom-binary-output-port) (l2c71 core-prim . make-custom-binary-input/output-port) (l2c70 core-prim . make-custom-binary-input-port) (l2c6f core-prim . make-bytevector) (l2c6e core-prim . lookahead-u8) (l2c6d core-prim . lookahead-char) (l2c6c core-prim . i/o-write-error?) (l2c6b core-prim . i/o-read-error?) (l2c6a core-prim . i/o-port-error?) (l2c69 core-prim . i/o-invalid-position-error?) (l2c68 core-prim . i/o-filename-error?) (l2c67 core-prim . i/o-file-protection-error?) (l2c66 core-prim . i/o-file-is-read-only-error?) (l2c65 core-prim . i/o-file-does-not-exist-error?) (l2c64 core-prim . i/o-file-already-exists-error?) (l2c63 core-prim . i/o-error?) (l2c62 core-prim . i/o-error-position) (l2c61 core-prim . i/o-error-port) (l2c60 core-prim . i/o-error-filename) (l2c5f core-prim . i/o-encoding-error?) (l2c5e core-prim . i/o-encoding-error-char) (l2c5d core-prim . i/o-decoding-error?) (l2c5c core-prim . get-u8) (l2c5b core-prim . get-string-n!) (l2c5a core-prim . get-string-n) (l2c59 core-prim . get-string-all) (l2c58 core-prim . get-line) (l2c57 core-prim . get-datum) (l2c56 core-prim . get-char) (l2c55 core-prim . get-bytevector-some) (l2c54 core-prim . get-bytevector-n!) (l2c53 core-prim . get-bytevector-n) (l2c52 core-prim . get-bytevector-all) (l2c51 core-prim . flush-output-port) (l2c50 core-prim . close-port) (le33 core-prim . scheme-report-environment) (l2c4f core-prim . quotient) (le31 core-prim . null-environment) (l2c4e core-prim . remainder) (l2c4d core-prim . modulo) (l2c4c core-prim . inexact->exact) (l2c4b core-prim . force) (l2c4a core-prim . exact->inexact) (l2c49 core-prim . make-promise) (l2c48 core-prim . exit) (l28da core-prim . command-line) (l2c47 core-prim . string-fill!) (l2c46 core-prim . string-set!) (l2c45 core-prim . set-cdr!) (l2c44 core-prim . set-car!) (l2c43 core-prim . remove) (l2c42 core-prim . remv) (l2c41 core-prim . remp) (l2c40 core-prim . remq) (l2c3f core-prim . partition) (l2c3e core-prim . memv) (l2c3d core-prim . memq) (l2c3c core-prim . memp) (l2c3b core-prim . member) (l2c3a core-prim . exists) (l2c39 core-prim . for-all) (l2c38 core-prim . fold-right) (l2c37 core-prim . fold-left) (l2c36 core-prim . find) (l2c35 core-prim . filter) (l2c34 core-prim . cons*) (l2c33 core-prim . assv) (l2c32 core-prim . assq) (l2c31 core-prim . assp) (l2c30 core-prim . assoc) (l2c2f core-prim . call-with-string-output-port) (l2c2e core-prim . call-with-port) (l2c2d core-prim . call-with-bytevector-output-port) (l2c2c core-prim . bytevector->string) (l2c2b core-prim . buffer-mode?) (l2c2a core-prim . binary-port?) (l2c29 core-prim . with-exception-handler) (l2c28 core-prim . raise-continuable) (l2c27 core-prim . raise) (le37 core-prim . eval) (le2f core-prim . environment) (l2c26 core-prim . make-enumeration) (l2c25 core-prim . enum-set=?) (l2c24 core-prim . enum-set-universe) (l2c23 core-prim . enum-set-union) (l2c22 core-prim . enum-set-subset?) (l2c21 core-prim . enum-set-projection) (l2c20 core-prim . enum-set-member?) (l2c1f core-prim . enum-set-intersection) (l2c1e core-prim . enum-set-indexer) (l2c1d core-prim . enum-set-difference) (l2c1c core-prim . enum-set-constructor) (l2c1b core-prim . enum-set-complement) (l2c1a core-prim . enum-set->list) (l2c19 core-prim . who-condition?) (l2c18 core-prim . warning?) (l2c17 core-prim . violation?) (l2c16 core-prim . undefined-violation?) (l2c15 core-prim . syntax-violation?) (l2c14 core-prim . syntax-violation-subform) (l2c13 core-prim . syntax-violation-form) (le57 core-prim . syntax-violation) (l2c12 core-prim . simple-conditions) (l2c11 core-prim . serious-condition?) (l2c10 core-prim . non-continuable-violation?) (l2c0f core-prim . message-condition?) (l2c0e core-prim . make-who-condition) (l2c0d core-prim . make-warning) (l2c0c core-prim . make-violation) (l2c0b core-prim . make-undefined-violation) (l2c0a core-prim . make-syntax-violation) (l2c09 core-prim . make-serious-condition) (l2c08 core-prim . make-non-continuable-violation) (l2c07 core-prim . make-message-condition) (l2c06 core-prim . make-lexical-violation) (l2c05 core-prim . make-irritants-condition) (l2c04 core-prim . make-implementation-restriction-violation) (l2c03 core-prim . make-error) (l2c02 core-prim . make-assertion-violation) (l2c01 core-prim . lexical-violation?) (l2c00 core-prim . irritants-condition?) (l2bff core-prim . implementation-restriction-violation?) (l2bfe core-prim . error?) (l2bfd core-prim . condition-who) (l2bfc core-prim . condition-predicate) (l2bfb core-prim . condition-message) (l2bfa core-prim . condition-irritants) (l2bf9 core-prim . condition-accessor) (l2bf8 core-prim . condition) (l2bf7 core-prim . assertion-violation?) (l2bf6 core-prim . condition?) (l2bf5 core-prim . utf32->string) (l2bf4 core-prim . utf16->string) (l2bf3 core-prim . utf8->string) (l2bf2 core-prim . uint-list->bytevector) (l2bf1 core-prim . u8-list->bytevector) (l2bf0 core-prim . string->utf8) (l2bef core-prim . string->utf32) (l2bee core-prim . string->utf16) (l2bed core-prim . sint-list->bytevector) (l2bec core-prim . native-endianness) (l2beb core-prim . bytevector?) (l2bea core-prim . bytevector=?) (l2be9 core-prim . bytevector-uint-set!) (l2be8 core-prim . bytevector-uint-ref) (l2be7 core-prim . bytevector-u8-set!) (l2be6 core-prim . bytevector-u8-ref) (l2be5 core-prim . bytevector-u64-set!) (l2be4 core-prim . bytevector-u64-ref) (l2be3 core-prim . bytevector-u64-native-set!) (l2be2 core-prim . bytevector-u64-native-ref) (l2be1 core-prim . bytevector-u32-set!) (l2be0 core-prim . bytevector-u32-ref) (l2bdf core-prim . bytevector-u32-native-set!) (l2bde core-prim . bytevector-u32-native-ref) (l2bdd core-prim . bytevector-u16-set!) (l2bdc core-prim . bytevector-u16-ref) (l2bdb core-prim . bytevector-u16-native-set!) (l2bda core-prim . bytevector-u16-native-ref) (l2bd9 core-prim . bytevector-sint-set!) (l2bd8 core-prim . bytevector-sint-ref) (l2bd7 core-prim . bytevector-s8-set!) (l2bd6 core-prim . bytevector-s8-ref) (l2bd5 core-prim . bytevector-s64-set!) (l2bd4 core-prim . bytevector-s64-ref) (l2bd3 core-prim . bytevector-s64-native-set!) (l2bd2 core-prim . bytevector-s64-native-ref) (l2bd1 core-prim . bytevector-s32-set!) (l2bd0 core-prim . bytevector-s32-ref) (l2bcf core-prim . bytevector-s32-native-set!) (l2bce core-prim . bytevector-s32-native-ref) (l2bcd core-prim . bytevector-s16-set!) (l2bcc core-prim . bytevector-s16-ref) (l2bcb core-prim . bytevector-s16-native-set!) (l2bca core-prim . bytevector-s16-native-ref) (l2bc9 core-prim . bytevector-length) (l2bc8 core-prim . bytevector-ieee-single-ref) (l2bc7 core-prim . bytevector-ieee-single-set!) (l2bc6 core-prim . bytevector-ieee-single-native-set!) (l2bc5 core-prim . bytevector-ieee-single-native-ref) (l2bc4 core-prim . bytevector-ieee-double-set!) (l2bc3 core-prim . bytevector-ieee-double-ref) (l2bc2 core-prim . bytevector-ieee-double-native-set!) (l2bc1 core-prim . bytevector-ieee-double-native-ref) (l2bc0 core-prim . bytevector-fill!) (l2bbf core-prim . bytevector-copy!) (l2bbe core-prim . bytevector-copy) (l2bbd core-prim . bytevector->uint-list) (l2bbc core-prim . bytevector->u8-list) (l2bbb core-prim . bytevector->sint-list) (l2bba core-prim . no-nans-violation?) (l2bb9 core-prim . no-infinities-violation?) (l2bb8 core-prim . make-no-nans-violation) (l2bb7 core-prim . make-no-infinities-violation) (l2bb6 core-prim . real->flonum) (l2bb5 core-prim . flzero?) (l2bb4 core-prim . fltruncate) (l2bb3 core-prim . fltan) (l2bb2 core-prim . flsqrt) (l2bb1 core-prim . flsin) (l2bb0 core-prim . flround) (l2baf core-prim . flpositive?) (l2bae core-prim . flonum?) (l2bad core-prim . flodd?) (l2bac core-prim . flnumerator) (l2bab core-prim . flnegative?) (l2baa core-prim . flnan?) (l2ba9 core-prim . flmod0) (l2ba8 core-prim . flmod) (l2ba7 core-prim . flmin) (l2ba6 core-prim . flmax) (l2ba5 core-prim . fllog) (l2ba4 core-prim . flinteger?) (l2ba3 core-prim . flinfinite?) (l2ba2 core-prim . flfloor) (l2ba1 core-prim . flfinite?) (l2ba0 core-prim . flexpt) (l2b9f core-prim . flexp) (l2b9e core-prim . fleven?) (l2b9d core-prim . fldiv0-and-mod0) (l2b9c core-prim . fldiv0) (l2b9b core-prim . fldiv-and-mod) (l2b9a core-prim . fldiv) (l2b99 core-prim . fldenominator) (l2b98 core-prim . flcos) (l2b97 core-prim . flceiling) (l2b96 core-prim . flatan) (l2b95 core-prim . flasin) (l2b94 core-prim . flacos) (l2b93 core-prim . flabs) (l2b92 core-prim . fl>?) (l2b91 core-prim . fl>=?) (l2b90 core-prim . fl=?) (l2b8f core-prim . fl<?) (l2b8e core-prim . fl<=?) (l2b8d core-prim . fl/) (l2b8c core-prim . fl-) (l2b8b core-prim . fl+) (l2b8a core-prim . fl*) (l2b89 core-prim . fixnum->flonum) (l2b88 core-prim . fxzero?) (l2b87 core-prim . fxxor) (l2b86 core-prim . fxrotate-bit-field) (l2b85 core-prim . fxreverse-bit-field) (l2b84 core-prim . fxpositive?) (l2b83 core-prim . fxodd?) (l2b82 core-prim . fxnot) (l2b81 core-prim . fxnegative?) (l2b80 core-prim . fxmod0) (l2b7f core-prim . fxmod) (l2b7e core-prim . fxmin) (l2b7d core-prim . fxmax) (l2b7c core-prim . fxlength) (l2b7b core-prim . fxior) (l2b7a core-prim . fxif) (l2b79 core-prim . fxfirst-bit-set) (l2b78 core-prim . fxeven?) (l2b77 core-prim . fxdiv0-and-mod0) (l2b76 core-prim . fxdiv0) (l2b75 core-prim . fxdiv-and-mod) (l2b74 core-prim . fxdiv) (l2b73 core-prim . fxcopy-bit-field) (l2b72 core-prim . fxcopy-bit) (l2b71 core-prim . fxbit-set?) (l2b70 core-prim . fxbit-field) (l2b6f core-prim . fxbit-count) (l2b6e core-prim . fxarithmetic-shift-right) (l2b6d core-prim . fxarithmetic-shift-left) (l2b6c core-prim . fxarithmetic-shift) (l2b6b core-prim . fxand) (l2b6a core-prim . fx>?) (l2b69 core-prim . fx>=?) (l2b68 core-prim . fx=?) (l2b67 core-prim . fx<?) (l2b66 core-prim . fx<=?) (l2b65 core-prim . fx-/carry) (l2b64 core-prim . fx-) (l2b63 core-prim . fx+/carry) (l2b62 core-prim . fx+) (l2b61 core-prim . fx*/carry) (l2b60 core-prim . fx*) (l2b5f core-prim . greatest-fixnum) (l2b5e core-prim . least-fixnum) (l2b5d core-prim . fixnum-width) (l2b5c core-prim . fixnum?) (l2b5b core-prim . bitwise-rotate-bit-field) (l2b5a core-prim . bitwise-reverse-bit-field) (l2b59 core-prim . bitwise-length) (l2b58 core-prim . bitwise-if) (l2b57 core-prim . bitwise-first-bit-set) (l2b56 core-prim . bitwise-copy-bit-field) (l2b55 core-prim . bitwise-copy-bit) (l2b54 core-prim . bitwise-bit-set?) (l2b53 core-prim . bitwise-bit-field) (l2b52 core-prim . bitwise-bit-count) (l2b51 core-prim . bitwise-xor) (l2b50 core-prim . bitwise-ior) (l2b4f core-prim . bitwise-and) (l2b4e core-prim . bitwise-not) (l2b4d core-prim . bitwise-arithmetic-shift-right) (l2b4c core-prim . bitwise-arithmetic-shift-left) (l2b4b core-prim . bitwise-arithmetic-shift) (l2b4a core-prim . zero?) (l2b49 core-prim . vector?) (l2b48 core-prim . vector-set!) (l2b47 core-prim . vector-ref) (l2b46 core-prim . vector-map) (l2b45 core-prim . vector-length) (l2b44 core-prim . vector-for-each) (l2b43 core-prim . vector-fill!) (l2b42 core-prim . vector->list) (l2b41 core-prim . vector) (l2b40 core-prim . values) (l2b3f core-prim . truncate) (l2b3e core-prim . tan) (l2b3d core-prim . symbol?) (l2b3c core-prim . symbol=?) (l2b3b core-prim . symbol->string) (l2b3a core-prim . substring) (l2b39 core-prim . string?) (l2b38 core-prim . string>?) (l2b37 core-prim . string>=?) (l2b36 core-prim . string=?) (l2b35 core-prim . string<?) (l2b34 core-prim . string<=?) (l2b33 core-prim . string-ref) (l2b32 core-prim . string-length) (l2b31 core-prim . string-for-each) (l2b30 core-prim . string-copy) (l2b2f core-prim . string-append) (l2b2e core-prim . string->symbol) (l2b2d core-prim . string->number) (l2b2c core-prim . string->list) (l2b2b core-prim . string) (l2b2a core-prim . sqrt) (l2b29 core-prim . sin) (l2b28 core-prim . round) (l2b27 core-prim . reverse) (l2b26 core-prim . real?) (l2b25 core-prim . real-valued?) (l2b24 core-prim . real-part) (l2b23 core-prim . rationalize) (l2b22 core-prim . rational?) (l2b21 core-prim . rational-valued?) (l2b20 core-prim . procedure?) (l2b1f core-prim . positive?) (l2b1e core-prim . pair?) (l2b1d core-prim . odd?) (l2b1c core-prim . numerator) (l2b1b core-prim . number?) (l2b1a core-prim . number->string) (l2b19 core-prim . null?) (l2b18 core-prim . not) (l2b17 core-prim . negative?) (l2b16 core-prim . nan?) (l2b15 core-prim . min) (l2b14 core-prim . max) (l2b13 core-prim . map) (l2b12 core-prim . make-vector) (l2b11 core-prim . make-string) (l2b10 core-prim . make-rectangular) (l2b0f core-prim . make-polar) (l2b0e core-prim . magnitude) (l2b0d core-prim . log) (l2b0c core-prim . list?) (l2b0b core-prim . list-tail) (l2b0a core-prim . list-ref) (l2b09 core-prim . list->vector) (l2b08 core-prim . list->string) (l2b07 core-prim . list) (l2b06 core-prim . length) (l2b05 core-prim . lcm) (l2b04 core-prim . integer?) (l2b03 core-prim . integer-valued?) (l2b02 core-prim . integer->char) (l2b01 core-prim . infinite?) (l2b00 core-prim . inexact?) (l2aff core-prim . inexact) (l2afe core-prim . imag-part) (l2afd core-prim . gcd) (l2afc core-prim . for-each) (l2afb core-prim . floor) (l2afa core-prim . finite?) (l2af9 core-prim . expt) (l2af8 core-prim . exp) (l2af7 core-prim . exact?) (l2af6 core-prim . exact-integer-sqrt) (l2af5 core-prim . exact) (l2af4 core-prim . even?) (l2af3 core-prim . error) (l2af2 core-prim . eqv?) (l2af1 core-prim . equal?) (l2af0 core-prim . eq?) (l2aef core-prim . dynamic-wind) (l2aee core-prim . div0-and-mod0) (l2aed core-prim . mod0) (l2aec core-prim . div0) (l2aeb core-prim . div-and-mod) (l2aea core-prim . mod) (l2ae9 core-prim . div) (l2ae8 core-prim . denominator) (l2ae7 core-prim . cos) (l2ae6 core-prim . cons) (l2ae5 core-prim . complex?) (l2ae4 core-prim . char?) (l2ae3 core-prim . char>?) (l2ae2 core-prim . char>=?) (l2ae1 core-prim . char=?) (l2ae0 core-prim . char<?) (l2adf core-prim . char<=?) (l2ade core-prim . char->integer) (l2add core-prim . ceiling) (l2adc core-prim . call-with-values) (l2adb core-prim . call/cc) (l2ada core-prim . call-with-current-continuation) (l2ad9 core-prim . cddddr) (l2ad8 core-prim . cdddar) (l2ad7 core-prim . cddadr) (l2ad6 core-prim . cddaar) (l2ad5 core-prim . cdaddr) (l2ad4 core-prim . cdadar) (l2ad3 core-prim . cdaadr) (l2ad2 core-prim . cdaaar) (l2ad1 core-prim . cadddr) (l2ad0 core-prim . caddar) (l2acf core-prim . cadadr) (l2ace core-prim . cadaar) (l2acd core-prim . caaddr) (l2acc core-prim . caadar) (l2acb core-prim . caaadr) (l2aca core-prim . caaaar) (l2ac9 core-prim . cdddr) (l2ac8 core-prim . cddar) (l2ac7 core-prim . cdadr) (l2ac6 core-prim . cdaar) (l2ac5 core-prim . caddr) (l2ac4 core-prim . cadar) (l2ac3 core-prim . caadr) (l2ac2 core-prim . caaar) (l2ac1 core-prim . cddr) (l2ac0 core-prim . cdar) (l2abf core-prim . cadr) (l2abe core-prim . caar) (l2abd core-prim . cdr) (l2abc core-prim . car) (l2abb core-prim . boolean?) (l2aba core-prim . boolean=?) (l2ab9 core-prim . atan) (l2ab8 core-prim . assertion-violation) (le51 core-prim . assertion-error) (l2ab7 core-prim . asin) (l2ab6 core-prim . apply) (l2ab5 core-prim . append) (l2ab4 core-prim . angle) (l2ab3 core-prim . acos) (l2ab2 core-prim . abs) (l2ab1 core-prim . /) (l2ab0 core-prim . *) (l2aaf core-prim . -) (l2aae core-prim . +) (l2aad core-prim . >=) (l2aac core-prim . >) (l2aab core-prim . =) (l2aaa core-prim . <=) (l2aa9 core-prim . <) (l2aa8 core-prim . library) (l2aa7 $core-rtd &no-nans-rtd &no-nans-rcd) (l2aa6 $core-rtd &no-infinities-rtd &no-infinities-rcd) (l2aa5 $core-rtd &i/o-encoding-rtd &i/o-encoding-rcd) (l2aa4 $core-rtd &i/o-decoding-rtd &i/o-decoding-rcd) (l2aa3 $core-rtd &i/o-port-rtd &i/o-port-rcd) (l2aa2 $core-rtd &i/o-file-does-not-exist-rtd &i/o-file-does-not-exist-rcd) (l2aa1 $core-rtd &i/o-file-already-exists-rtd &i/o-file-already-exists-rcd) (l2aa0 $core-rtd &i/o-file-is-read-only-rtd &i/o-fie-is-read-only-rcd) (l2a9f $core-rtd &i/o-file-protection-rtd &i/o-file-protection-rcd) (l2a9e $core-rtd &i/o-filename-rtd &i/o-filename-rcd) (l2a9d $core-rtd &i/o-invalid-position-rtd &i/o-invalid-position-rcd) (l2a9c $core-rtd &i/o-write-rtd &i/o-write-rcd) (l2a9b $core-rtd &i/o-read-rtd &i/o-read-rcd) (l2a9a $core-rtd &i/o-rtd &i/o-rcd) (l2a99 $core-rtd &undefined-rtd &undefined-rcd) (l2a98 $core-rtd &syntax-rtd &syntax-rcd) (l2a97 $core-rtd &lexical-rtd &lexical-rcd) (l2a96 $core-rtd &implementation-restriction-rtd &implementation-restriction-rcd) (l2a95 $core-rtd &non-continuable-rtd &non-continuable-rcd) (l2a94 $core-rtd &who-rtd &who-rcd) (l2a93 $core-rtd &irritants-rtd &irritants-rcd) (l2a92 $core-rtd &assertion-rtd &assertion-rcd) (l2a91 $core-rtd &violation-rtd &violation-rcd) (l2a90 $core-rtd &error-rtd &error-rcd) (l2a8f $core-rtd &serious-rtd &serious-rcd) (l2a8e $core-rtd &warning-rtd &warning-rcd) (l2a8d $core-rtd &message-rtd &message-rcd) (l2a8c $core-rtd &condition-rtd &condition-rcd) (l2a8b macro . define-condition-type) (l2a8a macro . define-enumeration) (l2a89 macro . define-record-type) (l2a88 macro . parent-rtd) (l2a87 macro . nongenerative) (l2a86 macro . opaque) (l2a85 macro . sealed) (l2a84 macro . protocol) (l2a83 macro . parent) (l2a82 macro . immutable) (l2a81 macro . mutable) (l2a80 macro . fields) (l2a7f macro . error-handling-mode) (l2a7e macro . file-options) (l2a7d macro . buffer-mode) (l2a7c macro . eol-style) (l2a7b macro . guard) (l2a7a macro . trace-define) (l2a79 macro . trace-lambda) (l2a78 macro . unsyntax-splicing) (l2a77 macro . unsyntax) (l2a76 macro . unquote-splicing) (l2a75 macro . unquote) (l2a74 macro . _) (l2a73 macro . else) (l2a72 macro . =>) (l2a71 macro . ...) (l2a70 macro . assert) (l2a6f macro . endianness) (l2a6e macro . delay) (l2a6d macro . time) (l2a6c macro . do) (l2a6b macro . cond) (l2a6a macro . let*) (l2a69 macro . let*-values) (l2a68 macro . let-values) (l2a67 macro . identifier-syntax) (l2a66 macro . with-syntax) (l2a65 macro . quasisyntax) (l2a64 macro . quasiquote) (l2a63 macro . syntax-rules) (l2a62 macro . include) (l2a61 macro . define-struct) (l2a60 core-macro . record-constructor-descriptor) (l2a5f core-macro . record-type-descriptor) (l2a5e macro . case) (l2a5d macro . parameterize) (l2a5c macro . unless) (l2a5b macro . when) (l2a5a core-macro . or) (l2a59 core-macro . and) (l2a58 core-macro . if) (l2a57 core-macro . let) (l2a56 core-macro . letrec*) (l2a55 core-macro . letrec) (l2a54 core-macro . type-descriptor) (l2a53 core-macro . case-lambda) (l2a52 core-macro . lambda) (l2a51 core-macro . syntax) (l2a50 core-macro . syntax-case) (l2a4f core-macro . quote) (l2a4e core-macro . foreign-call) (l2a4d letrec-syntax) (l2a4c let-syntax) (l2a4b set!) (l2a4a import) (l2a49 begin) (l2a48 module) (l2a47 define-syntax) (l2a46 define)) values values '#f '#f '#f '#f) (l98b@l7d7@install-library 'l2e06 '(psyntax system $bootstrap) '() '() '() '() '((pretty-print . l2dad) (eval-core . l2dac) (set-symbol-value! . l2dab) (symbol-value . l2daa) (gensym . l2da9) (void . l2da8)) '() values values '#f '#f '#f '#f) (l98b@l7d7@install-library 'l2e07 '(mosh) '() '() '() '() '((set-symbol-value! . l2dab) (symbol-value . l2daa) (regexp? . l2da6) (read-line . l2da5) (ungensym . l2da3) (alist->eq-hash-table . l2da2) (assoc-ref . l2da1) (print . l2da0) (format . l2d9f) (host-os . l2d9e) (library-path . l7b6) (standard-library-path . l2d9d) (file-newer? . l2d9c) (stat-mtime . l2d9b) (digit->integer . l2d97) (call-with-string-input-port . l2d96) (call-with-string-io . l2d95) (string-split . l2d94) (bytevector-for-each . l2d93) (string->regexp . l2d92) (rxmatch . l2d91) (regexp-replace-all . l2d90) (hashtable-for-each . l2d8f) (set-current-directory! . l2d8a) (expand-path . l2d89) (current-directory . l2d88) (p . l2d49) (get-timeofday . l2d30) (get-command-line . l2d2f) (sys-display . l2d2e) (whereis . l2d2d) (register . l2d2c) (vm-join! . l2d2b) (vm-set-value! . l2d2a) (vm? . l2d29) (main-vm? . l2d28) (vm-eval . l2d27) (vm-self . l2d26) (vm-start! . l2d25) (make-vm . l2d24) (mutex-try-lock! . l2d23) (mutex-unlock! . l2d22) (mutex-lock! . l2d21) (mutex? . l2d20) (make-mutex . l2d1f) (condition-variable-notify-all! . l2d1e) (condition-variable-notify! . l2d1d) (condition-variable-wait! . l2d1c) (make-condition-variable . l2d1b) (write/ss . l2d1a) (mosh-executable-path . l2d19) (make-file-options . l2d18) (source-info . l2d17) (make-compiler-instruction . l2d16) (make-instruction . l2d15) (set-source-info! . l2d14) (bignum? . l2d13) (fast-equal? . l2d12) (fasl-read . l2d11) (fasl-write . l2d10) (time-usage . l2d0f) (os-constant . l2d0e) (time . l2a6d) (include . l2a62)) '() values values '#f '#f '#f '#f) (l98b@l7d7@install-library 'l2e08 '(system) '() '() '() '() '((gensym-prefix-set! . l2da4) (write-to-file . l2d9a) (file->list . l2d99) (file->string . l2d98) (mosh-cache-dir . l5a0) (call-process . l2d8e) (local-tz-offset . l2d8d) (microseconds . l2d8c) (directory-list . l2d8b) (expand-path . l2d89) (%spawn . l2d87) (%waitpid . l2d86) (simple-struct-name . l2d85) (simple-struct-set! . l2d84) (simple-struct-ref . l2d83) (make-simple-struct . l2d82) (simple-struct? . l2d81) (pointer-ref-c-int64 . l2d80) (pointer-ref-c-int32 . l2d7f) (pointer-ref-c-int16 . l2d7e) (pointer-ref-c-int8 . l2d7d) (pointer-ref-c-uint64 . l2d7c) (pointer-ref-c-uint32 . l2d7b) (pointer-ref-c-uint16 . l2d7a) (pointer-ref-c-uint8 . l2d79) (pointer-set-c-uint64! . l2d78) (pointer-set-c-uint32! . l2d77) (pointer-set-c-uint16! . l2d76) (pointer-set-c-uint8! . l2d75) (pointer-set-c-int64! . l2d74) (pointer-set-c-int32! . l2d73) (pointer-set-c-int16! . l2d72) (pointer-set-c-int8! . l2d71) (pointer-set-c-pointer! . l2d70) (pointer-set-c-double! . l2d6f) (pointer-set-c-float! . l2d6e) (pointer-set-c-long-long! . l2d6d) (pointer-set-c-long! . l2d6c) (pointer-set-c-int! . l2d6b) (pointer-set-c-short! . l2d6a) (pointer-set-c-char! . l2d69) (pointer-ref-c-pointer . l2d68) (pointer-ref-c-double . l2d67) (pointer-ref-c-float . l2d66) (pointer-ref-c-unsigned-long-long . l2d65) (pointer-ref-c-signed-long-long . l2d64) (pointer-ref-c-unsigned-long . l2d63) (pointer-ref-c-signed-long . l2d62) (pointer-ref-c-unsigned-int . l2d61) (pointer-ref-c-signed-int . l2d60) (pointer-ref-c-unsigned-short . l2d5f) (pointer-ref-c-signed-short . l2d5e) (pointer-ref-c-unsigned-char . l2d5d) (pointer-ref-c-signed-char . l2d5c) (pointer->integer . l2d5b) (integer->pointer . l2d5a) (pointer? . l2d59) (shared-errno . l2d58) (%ffi-free-c-callback-trampoline . l2d57) (%ffi-make-c-callback-trampoline . l2d56) (%ffi-free . l2d55) (%ffi-malloc . l2d54) (%ffi-supported? . l2d53) (%ffi-pointer->string . l2d52) (%ffi-call . l2d51) (%ffi-lookup . l2d50) (%ffi-open . l2d4f) (null-terminated-utf8->string . l2d4e) (null-terminated-bytevector->string . l2d4d) (%exec . l2d4c) (%fork . l2d4b) (%pipe . l2d4a) (open-output-string . l2d48) (get-output-string . l2d47) (file-stat-ctime . l2d46) (file-stat-atime . l2d45) (file-stat-mtime . l2d44) (file-size-in-bytes . l2d43) (file-writable? . l2d42) (file-executable? . l2d41) (file-readable? . l2d40) (file-regular? . l2d3f) (file-symbolic-link? . l2d3e) (file-directory? . l2d3d) (create-symbolic-link . l2d3c) (rename-file . l2d3b) (delete-directory . l2d3a) (create-directory . l2d39) (create-mosh-cache-dir . l2d38) (get-environment-variables . l2d37) (current-exception-handler . l2d36) (get-environment-variable . l2d35) (join-wraps . l2d34) (id->real-label . l2d33) (same-marks? . l2d32) (same-marks*? . l2d31) (disasm . l2d0d) (make-parameter . l59e) (socket-port . l2d0c) (socket-shutdown . l2d0b) (socket-close . l2d0a) (socket-send . l2d09) (socket-recv! . l2d08) (socket-recv . l2d07) (make-server-socket . l2d06) (make-client-socket . l2d05) (socket-accept . l2d04) (socket? . l2d03) (parameterize . l2a5d)) '() values values '#f '#f '#f '#f)))
(begin (set! l28c5@ref (unspecified)) (set! l28c7@x* (unspecified)) (set! l28c9@add-library-path! (unspecified)) (set! l28cb@parse-and-add-library-path (unspecified)) (set! l28cd@for-each-with-index (unspecified)) (set! l28cf@rpad (unspecified)) (set! l28d1@condition-printer (unspecified)) (set! l28d3@record->field-alist (unspecified)) (set! l28d5@map-with-index (unspecified)) (set! l28d7@repl (unspecified)) (set! l28d9@trace-printer (unspecified)) (set! l28db@command-line (unspecified)) (set! l28dd@local-library-path (unspecified)) (set! l28df@load/args (unspecified)) (set! l28e1@load (unspecified)) (set! l28e3@ironscheme-build (unspecified)) (set! l28e5@eval-top-level (unspecified)) (set! l28e7@compile-system-libraries (unspecified)) (set! l28e9@compile (unspecified)) (set! l28eb@compile->closure (unspecified)) (set! l28ed@pre-compile-r6rs-file (unspecified)) (set! l28ef@load-r6rs-top-level (unspecified)) (set! l28f1@load-r6rs-top-level-sexp (unspecified)) (set! l28f3@prefix-inc (unspecified)) (set! l28f5@prefix-inc! (unspecified)) (set! l28c5@ref (lambda (l2930@rtd l2931@i l2932@x) (let ((l2936@val ((record-accessor l2930@rtd l2931@i) l2932@x))) (if (symbol? l2936@val) (ungensym l2936@val) l2936@val)))) (set! l2a2c@l28c5@ref l28c5@ref) (set! l28c7@x* '()) (set! l2a2d@l28c7@x* l28c7@x*) (set! l28c9@add-library-path! (lambda (l2938@path) (l97b@l7b7@library-path (append (l97b@l7b7@library-path) (list l2938@path))))) (set! l2a2e@l28c9@add-library-path! l28c9@add-library-path!) (set! l28cb@parse-and-add-library-path (lambda (l293a@paths l293b@message) (letrec* ((l293f@separator (if (string=? (host-os) '"win32") '#\; '#\:))) (let ((l2940@t l293a@paths)) (if l2940@t ((lambda (l2942@paths) (for-each (lambda (l2944@path) (if (file-exists? l2944@path) (l28c9@add-library-path! (expand-path l2944@path)) (format (current-error-port) l293b@message l2944@path))) (string-split l2942@paths l293f@separator))) l2940@t) (void)))))) (set! l2a2f@l28cb@parse-and-add-library-path l28cb@parse-and-add-library-path) (set! l28cd@for-each-with-index (lambda (l2946@proc l2947@lst) (letrec ((l294a@loop (lambda (l294c@i l294d@lst) (if (null? l294d@lst) (if '#f '#f (void)) (begin (l2946@proc l294c@i (car l294d@lst)) (l294a@loop (+ l294c@i '1) (cdr l294d@lst))))))) (l294a@loop '1 l2947@lst)))) (set! l2a30@l28cd@for-each-with-index l28cd@for-each-with-index) (set! l28cf@rpad (lambda (l2950@str l2951@pad l2952@n) (let ((l2956@rest (- l2952@n (string-length (format '"~a" l2950@str))))) (let l295c@loop ((l2958@rest l2956@rest) (l2959@ret (format '"~a" l2950@str))) (if (<= l2958@rest '0) l2959@ret (l295c@loop (- l2958@rest '1) (string-append l2959@ret l2951@pad))))))) (set! l2a31@l28cf@rpad l28cf@rpad) (set! l28d1@condition-printer (lambda (l295e@e l295f@port) (letrec* ((l2963@max-condition-len (apply max (map (lambda (l2974@c) (string-length (symbol->string (record-type-name (record-rtd l2974@c))))) (simple-conditions l295e@e))))) (begin (display '" Condition components:\n" l295f@port) (l28cd@for-each-with-index (lambda (l2964@i l2965@x) (let ((l2968@rtd (record-rtd l2965@x)) (l2969@fields-alist (l28d3@record->field-alist l2965@x))) (begin (format l295f@port '" ~d. ~a" l2964@i (l28cf@rpad (symbol->string (record-type-name l2968@rtd)) '" " l2963@max-condition-len)) (if (null? l2969@fields-alist) (newline l295f@port) (void)) (let l2970@loop ((l296c@first '#t) (l296d@fields-alist l2969@fields-alist)) (if (null? l296d@fields-alist) '() (let ((l2972@field (car l296d@fields-alist))) (begin (if (not l296c@first) (display (l28cf@rpad '"" '" " (+ '4 l2963@max-condition-len)) l295f@port) (void)) (display '"       " l295f@port) (display (car l2972@field) l295f@port) (display '": " l295f@port) (write (cdr l2972@field) l295f@port) (newline l295f@port) (l2970@loop '#f (cdr l296d@fields-alist))))))))) (simple-conditions l295e@e)))))) (set! l2a32@l28d1@condition-printer l28d1@condition-printer) (set! l28d3@record->field-alist (lambda (l2976@r) (letrec* ((l2979@ref (lambda (l2984@rtd l2985@i l2986@x) (let ((l298a@val ((record-accessor l2984@rtd l2985@i) l2986@x))) (if (symbol? l298a@val) (ungensym l298a@val) l298a@val))))) (let l297e@loop ((l297a@ret '()) (l297b@rtd (record-rtd l2976@r))) (if l297b@rtd (l297e@loop (append l297a@ret (l28d5@map-with-index (lambda (l2980@i l2981@field) (cons l2981@field (l2979@ref l297b@rtd l2980@i l2976@r))) (vector->list (record-type-field-names l297b@rtd)))) (record-type-parent l297b@rtd)) l297a@ret))))) (set! l2a33@l28d3@record->field-alist l28d3@record->field-alist) (set! l28d5@map-with-index (lambda (l298c@proc l298d@lst) (let l2996@loop ((l2990@i '0) (l2991@lst l298d@lst) (l2992@ret '())) (if (null? l2991@lst) (reverse l2992@ret) (l2996@loop (+ l2990@i '1) (cdr l2991@lst) (cons (l298c@proc l2990@i (car l2991@lst)) l2992@ret)))))) (set! l2a34@l28d5@map-with-index l28d5@map-with-index) (set! l28d7@repl (lambda l2998@x (letrec* ((l299b@rec (lambda () (begin (display '"mosh> ") ((call/cc (lambda (l299e@l299c) (lambda () (with-exception-handler (lambda (l29a0@e) ((call/cc (lambda (l29a2@l299d) (l299e@l299c (lambda () (if '#t (begin (display '"\nUnhandled exception:\n\n" (current-error-port)) (if (condition? l29a0@e) (l28d1@condition-printer l29a0@e (current-error-port)) (format (current-error-port) '"  Non-condition object:\n     ~a\n" l29a0@e))) (l29a2@l299d (lambda () (raise-continuable l29a0@e)))))))))) (lambda () (let l29a8@loop ((l29a4@line (get-line (current-input-port))) (l29a5@accum '"")) (letrec* ((l29ab@parentheses-ok? (lambda (l29b6@text) (let l29be@loop ((l29b8@chars (string->list l29b6@text)) (l29b9@p0 '0) (l29ba@p1 '0)) (if (null? l29b8@chars) (= '0 l29b9@p0 l29ba@p1) (let ((l29c0@t (car l29b8@chars))) (if (memv l29c0@t '(#\()) (l29be@loop (cdr l29b8@chars) (+ l29b9@p0 '1) l29ba@p1) (if (memv l29c0@t '(#\))) (l29be@loop (cdr l29b8@chars) (- l29b9@p0 '1) l29ba@p1) (if (memv l29c0@t '(#\[)) (l29be@loop (cdr l29b8@chars) l29b9@p0 (+ l29ba@p1 '1)) (if (memv l29c0@t '(#\])) (l29be@loop (cdr l29b8@chars) l29b9@p0 (- l29ba@p1 '1)) (l29be@loop (cdr l29b8@chars) l29b9@p0 l29ba@p1)))))))))) (l29ad@eval-string-print (lambda (l29b0@text) (if (not (or (string=? '"\n" l29b0@text) (= '0 (string-length l29b0@text)))) (call-with-values (lambda () (l28e5@eval-top-level (call-with-port (open-string-input-port l29b0@text) read))) (lambda l29b2@out* (for-each (lambda (l29b4@out) (begin (write l29b4@out) (newline))) l29b2@out*))) (void))))) (if (eof-object? l29a4@line) (begin (l29ad@eval-string-print l29a5@accum) (exit)) (let ((l29ae@current (string-append l29a5@accum l29a4@line))) (if (l29ab@parentheses-ok? l29ae@current) (l29ad@eval-string-print l29ae@current) (l29a8@loop (get-line (current-input-port)) l29ae@current)))))))))))) (newline) (l299b@rec))))) (l299b@rec)))) (set! l2a35@l28d7@repl l28d7@repl) (set! l28d9@trace-printer (l6c1@l59f@make-parameter write)) (set! l2a36@l28d9@trace-printer l28d9@trace-printer) (set! l28db@command-line (l6c1@l59f@make-parameter (get-command-line))) (set! l2a37@l28db@command-line l28db@command-line) (set! l28dd@local-library-path (lambda (l29c2@filename) (l97b@l7b7@library-path))) (set! l2a38@l28dd@local-library-path l28dd@local-library-path) (set! l28df@load/args (lambda (l29c4@filename . l29c6@args) (begin (apply l28ef@load-r6rs-top-level l29c4@filename 'load l29c6@args) (void)))) (set! l2a39@l28df@load/args l28df@load/args) (set! l28e1@load (lambda (l29c8@filename) (begin (apply l28ef@load-r6rs-top-level l29c8@filename 'load (l28db@command-line)) (void)))) (set! l2a3a@l28e1@load l28e1@load) (set! l28e3@ironscheme-build (lambda () (l28e1@load '"ironscheme-buildscript.ss"))) (set! l2a3b@l28e3@ironscheme-build l28e3@ironscheme-build) (set! l28e5@eval-top-level (lambda (l29ca@x) (l28a2@le38@eval l29ca@x (l28b9@le66@interaction-environment)))) (set! l2a3c@l28e5@eval-top-level l28e5@eval-top-level) (set! l28e7@compile-system-libraries (lambda () (l28e5@eval-top-level '(begin (include "system-libraries.ss") (compile "system-libraries.ss"))))) (set! l2a3d@l28e7@compile-system-libraries l28e7@compile-system-libraries) (set! l28e9@compile (lambda (l29cc@filename) (l28ef@load-r6rs-top-level l29cc@filename 'compile))) (set! l2a3e@l28e9@compile l28e9@compile) (set! l28eb@compile->closure (lambda (l29ce@filename) (l28ef@load-r6rs-top-level l29ce@filename 'closure))) (set! l2a3f@l28eb@compile->closure l28eb@compile->closure) (set! l28ed@pre-compile-r6rs-file (lambda (l29d0@filename) (l28ef@load-r6rs-top-level l29d0@filename 'compile))) (set! l2a40@l28ed@pre-compile-r6rs-file l28ed@pre-compile-r6rs-file) (set! l28ef@load-r6rs-top-level (lambda (l29d2@filename l29d3@how . l29d6@args) (begin (l97b@l7b7@library-path (l28dd@local-library-path l29d2@filename)) (let ((l29d8@x* (with-input-from-file l29d2@filename (lambda () (let l29da@f () (let ((l29dc@x (l6b3@l583@read-annotated))) (if (eof-object? l29dc@x) '() (cons l29dc@x (l29da@f))))))))) (let ((l29de@t l29d3@how)) (if (memv l29de@t '(closure)) (l28b8@le64@pre-compile-r6rs-top-level l29d8@x*) (if (memv l29de@t '(load)) (begin (l28db@command-line (cons l29d2@filename (car l29d6@args))) (l6c2@l5a1@mosh-cache-dir (create-mosh-cache-dir)) (if (l6c2@l5a1@mosh-cache-dir) (gensym-prefix-set! (l28f5@prefix-inc! (string-append (l6c2@l5a1@mosh-cache-dir) '"/prefix.txt"))) (void)) (if (symbol-value '%clean-acc) (for-each (lambda (l29e0@file) ((call/cc (lambda (l29e4@l29e2) (lambda () (with-exception-handler (lambda (l29e6@c) ((call/cc (lambda (l29e8@l29e3) (l29e4@l29e2 (lambda () (if '#t '#t (l29e8@l29e3 (lambda () (raise-continuable l29e6@c)))))))))) (lambda () (delete-file (string-append (l6c2@l5a1@mosh-cache-dir) '"/" l29e0@file))))))))) (directory-list (l6c2@l5a1@mosh-cache-dir))) (void)) (let ((l29ea@compiled (l28b7@le62@compile-r6rs-top-level l29d8@x*))) (begin (if (and (l6c2@l5a1@mosh-cache-dir) (not (symbol-value '%disable-acc))) (l97f@l7bf@serialize-all l6bc@l595@serialize-library l718@l6d1@compile-core-expr) (void)) (l29ea@compiled)))) (if (memv l29de@t '(compile)) (begin (l28b7@le62@compile-r6rs-top-level l29d8@x*) (l97f@l7bf@serialize-all l6bc@l595@serialize-library l718@l6d1@compile-core-expr)) (if '#f '#f (void)))))))))) (set! l2a41@l28ef@load-r6rs-top-level l28ef@load-r6rs-top-level) (set! l28f1@load-r6rs-top-level-sexp (lambda (l29ec@import-spec l29ed@thunk) (let ((l29f8@l29f1 l97b@l7b7@library-path) (l29f9@l29f3 l6c2@l5a1@mosh-cache-dir) (l29fa@l29f5 (l28dd@local-library-path '"")) (l29fb@l29f7 (create-mosh-cache-dir))) (let ((l2a00@swap (lambda () (begin (let ((l2a02@t (l29f8@l29f1))) (begin (l29f8@l29f1 l29fa@l29f5) (set! l29fa@l29f5 l2a02@t))) (let ((l2a04@t (l29f9@l29f3))) (begin (l29f9@l29f3 l29fb@l29f7) (set! l29fb@l29f7 l2a04@t))))))) (dynamic-wind l2a00@swap (lambda () (begin (if (l6c2@l5a1@mosh-cache-dir) (gensym-prefix-set! (l28f5@prefix-inc! (string-append (l6c2@l5a1@mosh-cache-dir) '"/prefix.txt"))) (void)) (let ((l2a0a@l2a07 l28db@command-line) (l2a0b@l2a09 '())) (let ((l2a0e@swap (lambda () (let ((l2a10@t (l2a0a@l2a07))) (begin (l2a0a@l2a07 l2a0b@l2a09) (set! l2a0b@l2a09 l2a10@t)))))) (dynamic-wind l2a0e@swap (lambda () ((l28b7@le62@compile-r6rs-top-level (list (cons 'import l29ec@import-spec) (list l29ed@thunk))))) l2a0e@swap))))) l2a00@swap))))) (set! l2a42@l28f1@load-r6rs-top-level-sexp l28f1@load-r6rs-top-level-sexp) (set! l28f3@prefix-inc (lambda (l2a12@prefix-string) (let ((l2a14@prefix (symbol->string l2a12@prefix-string))) (let ((l2a16@len (string-length l2a14@prefix))) (let l2a1e@loop ((l2a18@i (- l2a16@len '1)) (l2a19@carry? '#t) (l2a1a@accum '())) (if (< l2a18@i '0) (string->symbol (list->string (if l2a19@carry? (cons '#\a l2a1a@accum) l2a1a@accum))) (if l2a19@carry? (let ((l2a20@next-integer (+ '1 (char->integer (string-ref l2a14@prefix l2a18@i))))) (if (= l2a20@next-integer '123) (l2a1e@loop (- l2a18@i '1) '#f (cons '#\A l2a1a@accum)) (if (= l2a20@next-integer '91) (l2a1e@loop (- l2a18@i '1) '#t (cons '#\a l2a1a@accum)) (l2a1e@loop (- l2a18@i '1) '#f (cons (integer->char l2a20@next-integer) l2a1a@accum))))) (l2a1e@loop (- l2a18@i '1) '#f (cons (string-ref l2a14@prefix l2a18@i) l2a1a@accum))))))))) (set! l2a43@l28f3@prefix-inc l28f3@prefix-inc) (set! l28f5@prefix-inc! (lambda (l2a22@file) (begin (if (not (file-exists? l2a22@file)) (call-with-output-file l2a22@file (lambda (l2a24@port) (write 'd l2a24@port))) (void)) (let ((l2a26@prefix (call-with-input-file l2a22@file read))) (if (main-vm?) (let ((l2a28@next-prefix (l28f3@prefix-inc l2a26@prefix))) (begin (call-with-port (open-file-output-port l2a22@file (make-file-options '(no-fail)) 'block (native-transcoder)) (lambda (l2a2a@port) (write l2a28@next-prefix l2a2a@port))) l2a26@prefix)) l2a26@prefix))))) (set! l2a44@l28f5@prefix-inc! l28f5@prefix-inc!) (begin (l980@l7c1@current-precompiled-library-loader l6bd@l597@load-serialized-library) (set-symbol-value! 'load l28e1@load) (set-symbol-value! 'pre-compile-r6rs-file l28ed@pre-compile-r6rs-file) (set-symbol-value! 'eval-r6rs l28e5@eval-top-level) (set-symbol-value! 'int-env-syms l2899@le26@interaction-environment-symbols) (set-symbol-value! 'expanded2core l717@l6cf@expanded->core) (set-symbol-value! 'trace-printer l28d9@trace-printer) (set-symbol-value! 'compile-r6rs-top-level 'compile-r6rs-top-level) (set-symbol-value! 'create-non-continuable-violation (lambda (l28f6@c) (condition (make-non-continuable-violation) (make-who-condition 'raise) (make-message-condition '"returned from non-continuable exception") (make-irritants-condition (list l28f6@c))))) (l28cb@parse-and-add-library-path (get-environment-variable '"MOSH_LOADPATH") '"** WARN in environment variable 'MOSH_LOADPATH': directory ~s not exist\n") (l28cb@parse-and-add-library-path (symbol-value '%loadpath) '"** WARN in command-line option '--loadpath': directory ~s not exist\n") (if (mosh-executable-path) (if (file-exists? (string-append (mosh-executable-path) '"/lib")) (l28c9@add-library-path! (string-append (mosh-executable-path) '"/lib")) (void)) (if (file-exists? (string-append (current-directory) '"/lib")) (l28c9@add-library-path! (string-append (current-directory) '"/lib")) (void))) (if (file-exists? (string-append (standard-library-path) '"/lib")) (l28c9@add-library-path! (string-append (standard-library-path) '"/lib")) (void)) (let ((l28f8@prefix (lambda (l28fa@ext l28fb@ls) (append (map (lambda (l28fe@x) (string-append l28fa@ext l28fe@x)) l28fb@ls) l28fb@ls)))) (l97c@l7b9@library-extensions (l28f8@prefix '".mosh" (l97c@l7b9@library-extensions)))) (current-exception-handler (lambda (l2900@c) (begin (if (condition? l2900@c) (l28d1@condition-printer l2900@c (current-error-port)) (format (current-error-port) '"\n Non-condition object:\n     ~a\n" l2900@c)) l2900@c))) (if ((call/cc (lambda (l2904@l2902) (lambda () (with-exception-handler (lambda (l2906@c) ((call/cc (lambda (l2908@l2903) (l2904@l2902 (lambda () (if '#t '#f (l2908@l2903 (lambda () (raise-continuable l2906@c)))))))))) (lambda () (symbol-value '%vm-import-spec))))))) (l28f1@load-r6rs-top-level-sexp (symbol-value '%vm-import-spec) (symbol-value '%vm-thunk)) (if (null? (l28db@command-line)) (let ((l2912@l290b l28db@command-line) (l2913@l290d l6c2@l5a1@mosh-cache-dir) (l2914@l290f '()) (l2915@l2911 (create-mosh-cache-dir))) (let ((l291a@swap (lambda () (begin (let ((l291c@t (l2912@l290b))) (begin (l2912@l290b l2914@l290f) (set! l2914@l290f l291c@t))) (let ((l291e@t (l2913@l290d))) (begin (l2913@l290d l2915@l2911) (set! l2915@l2911 l291e@t))))))) (dynamic-wind l291a@swap (lambda () (begin (if (l6c2@l5a1@mosh-cache-dir) (gensym-prefix-set! (l28f5@prefix-inc! (string-append (l6c2@l5a1@mosh-cache-dir) '"/prefix.txt"))) (void)) (l28d7@repl))) l291a@swap))) (begin (l97b@l7b7@library-path (l28dd@local-library-path (car (l28db@command-line)))) (set! l28c7@x* (with-input-from-file (car (l28db@command-line)) (lambda () (let l2920@f () (let ((l2922@x (l6b3@l583@read-annotated))) (if (eof-object? l2922@x) '() (cons l2922@x (l2920@f)))))))) (l28db@command-line (cons (car (l28db@command-line)) (cdr (l28db@command-line)))) (l6c2@l5a1@mosh-cache-dir (create-mosh-cache-dir)) (if (l6c2@l5a1@mosh-cache-dir) (gensym-prefix-set! (l28f5@prefix-inc! (string-append (l6c2@l5a1@mosh-cache-dir) '"/prefix.txt"))) (void)) (if (symbol-value '%clean-acc) (for-each (lambda (l2924@file) ((call/cc (lambda (l2928@l2926) (lambda () (with-exception-handler (lambda (l292a@c) ((call/cc (lambda (l292c@l2927) (l2928@l2926 (lambda () (if '#t '#t (l292c@l2927 (lambda () (raise-continuable l292a@c)))))))))) (lambda () (delete-file (string-append (l6c2@l5a1@mosh-cache-dir) '"/" l2924@file))))))))) (directory-list (l6c2@l5a1@mosh-cache-dir))) (void)) (let ((l292e@compiled (l28b7@le62@compile-r6rs-top-level l28c7@x*))) (begin (if (and (l6c2@l5a1@mosh-cache-dir) (not (symbol-value '%disable-acc))) (l97f@l7bf@serialize-all l6bc@l595@serialize-library l718@l6d1@compile-core-expr) (void)) (l292e@compiled))))))))
