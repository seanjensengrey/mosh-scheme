;;; Copyright (c) 2006, 2007 Abdulaziz Ghuloum and Kent Dybvig
;;; automatically generated from psyntax sources
;;; for copyright details, see psyntax/main.ss

(begin (set! B582@library-file-path->cache-path (unspecified)) (set! B584@read-annotated (unspecified)) (set! B586@annotation-stripped (unspecified)) (set! B588@annotation? (unspecified)) (set! B58a@annotation-source (unspecified)) (set! B58c@annotation-expression (unspecified)) (set! B58e@scm->fasl (unspecified)) (set! B590@fasl-save (unspecified)) (set! B592@fasl-load (unspecified)) (set! B594@verbose? (unspecified)) (set! B596@serialize-library (unspecified)) (set! B598@load-serialized-library (unspecified)) (set! B59a@make-record-printer (unspecified)) (set! B59c@compile-core (unspecified)) (set! B59e@read-library-source-file (unspecified)) (set! B5a0@make-parameter (unspecified)) (set! B5a2@mosh-cache-dir (unspecified)) (set! B638@file-options-spec (unspecified)) (set! B582@library-file-path->cache-path (lambda (B639@x) (call-with-values (lambda () (open-string-output-port)) (lambda (B63f@B63c B640@B63e) (let ((B643@extract B640@B63e) (B644@p B63f@B63c)) (letrec* ((B648@display-hex (lambda (B651@n) (if (<= '0 B651@n '9) (display B651@n B644@p) (display (integer->char (+ (char->integer '#\a) (- B651@n '10))) B644@p))))) (begin (let B64b@f ((B649@ls (string-split B639@x '#\/))) (if (not (null? B649@ls)) (begin (display '"_" B644@p) (for-each (lambda (B64d@c) (if (or (char<=? '#\a B64d@c '#\z) (char<=? '#\A B64d@c '#\Z) (char<=? '#\0 B64d@c '#\9) (memv B64d@c '(#\- #\. #\_ #\~))) (display B64d@c B644@p) (begin (display '"%" B644@p) (let ((B64f@n (char->integer B64d@c))) (begin (B648@display-hex (quotient B64f@n '16)) (B648@display-hex (remainder B64f@n '16))))))) (string->list (car B649@ls))) (B64b@f (cdr B649@ls))) (void))) (B643@extract)))))))) (set! B6b3@B582@library-file-path->cache-path B582@library-file-path->cache-path) (set! B584@read-annotated read) (set! B6b4@B584@read-annotated B584@read-annotated) (set! B586@annotation-stripped (lambda (B653@x) (B58c@annotation-expression B653@x))) (set! B6b5@B586@annotation-stripped B586@annotation-stripped) (set! B588@annotation? (lambda (B655@x) (source-info B655@x))) (set! B6b6@B588@annotation? B588@annotation?) (set! B58a@annotation-source (lambda (B657@x) (source-info B657@x))) (set! B6b7@B58a@annotation-source B58a@annotation-source) (set! B58c@annotation-expression (lambda (B659@x) (if (pair? B659@x) (cons (car B659@x) (cdr B659@x)) (if (procedure? B659@x) (set-source-info! B659@x '#f) B659@x)))) (set! B6b8@B58c@annotation-expression B58c@annotation-expression) (set! B58e@scm->fasl (lambda (B65b@filename) (string-append (B5a2@mosh-cache-dir) '"/" (B582@library-file-path->cache-path B65b@filename) '".mosh-fasl"))) (set! B6b9@B58e@scm->fasl B58e@scm->fasl) (set! B590@fasl-save (lambda (B65d@filename B65e@obj) (call-with-port (open-file-output-port B65d@filename) (lambda (B661@port) ((symbol-value 'fasl-write!) B65e@obj B661@port))))) (set! B6ba@B590@fasl-save B590@fasl-save) (set! B592@fasl-load (lambda (B663@filename) (call-with-port (open-file-input-port B663@filename) (symbol-value 'fasl-read!)))) (set! B6bb@B592@fasl-load B592@fasl-load) (set! B594@verbose? (symbol-value '%verbose)) (set! B6bc@B594@verbose? B594@verbose?) (set! B596@serialize-library (lambda (B665@filename B666@obj) (begin (if B594@verbose? (format (current-error-port) '"serialize-library ~a\n..." B665@filename) (void)) (let ((B669@expanded2core (symbol-value 'expanded2core))) (let ((B66b@compile (symbol-value 'compile-w/o-halt))) (let ((B66d@code B666@obj)) (let ((B66f@pivot (cddddr (cddddr B66d@code)))) (let ((B671@visit (B66b@compile (B669@expanded2core (car B66f@pivot))))) (begin (set-car! B66f@pivot B671@visit) (let ((B673@pivot (cdr B66f@pivot))) (let ((B675@invoke (B66b@compile (B669@expanded2core (car B673@pivot))))) (set-car! B673@pivot B675@invoke))))))))) (let ((B677@fasl-file (B58e@scm->fasl B665@filename))) (begin (if (file-exists? B677@fasl-file) (delete-file B677@fasl-file) (void)) ((call/cc (lambda (B67b@B679) (lambda () (with-exception-handler (lambda (B67d@c) ((call/cc (lambda (B67f@B67a) (B67b@B679 (lambda () (if '#t (begin (if B594@verbose? (format (current-error-port) '"Warning:serialize-library failed ~a\n" B665@filename) (void)) (if (file-exists? B677@fasl-file) (delete-file B677@fasl-file) (void)) '#f) (B67f@B67a (lambda () (raise-continuable B67d@c)))))))))) (lambda () (B590@fasl-save B677@fasl-file B666@obj)))))))))))) (set! B6bd@B596@serialize-library B596@serialize-library) (set! B598@load-serialized-library (lambda (B681@filename B682@obj) (and (B5a2@mosh-cache-dir) (let ((B685@fasl-file (B58e@scm->fasl B681@filename))) (if (and (file-exists? B685@fasl-file) ((symbol-value 'file-newer?) B685@fasl-file B681@filename)) (let ((B687@expanded2core (symbol-value 'expanded2core))) (let ((B689@eval-compiled-core (symbol-value 'eval-compiled!))) (let ((B68b@code (B592@fasl-load B685@fasl-file))) (let ((B68d@pivot (cddddr (cddddr B68b@code)))) (let ((B68f@visit (car B68d@pivot))) (let ((B691@visit-proc (lambda () (B689@eval-compiled-core B68f@visit)))) (begin (set-car! B68d@pivot B691@visit-proc) (let ((B693@pivot (cdr B68d@pivot))) (let ((B695@invoke (car B693@pivot))) (begin (set-car! B693@pivot (lambda () (B689@eval-compiled-core B695@invoke))) (apply B682@obj B68b@code))))))))))) '#f))))) (set! B6be@B598@load-serialized-library B598@load-serialized-library) (set! B59a@make-record-printer (lambda (B697@name B698@printer) (lambda B69b@x (begin (display '"record printer") (for-each display B69b@x))))) (set! B6bf@B59a@make-record-printer B59a@make-record-printer) (set! B59c@compile-core (lambda B69d@x (apply error 'comile-core '"not implementated" B69d@x))) (set! B6c0@B59c@compile-core B59c@compile-core) (set! B59e@read-library-source-file (lambda (B69f@file-name) (with-input-from-file B69f@file-name B584@read-annotated))) (set! B6c1@B59e@read-library-source-file B59e@read-library-source-file) (set! B5a0@make-parameter (lambda B6af (let ((B6b0 (length B6af))) (if (= B6b0 '1) (apply (lambda (B6a1@x) (B5a0@make-parameter B6a1@x (lambda (B6a3@x) B6a3@x))) B6af) (if (= B6b0 '2) (apply (lambda (B6a5@x B6a6@fender) (let ((B6a9@x (B6a6@fender B6a5@x))) (lambda B6ad (let ((B6ae (length B6ad))) (if (= B6ae '0) (apply (lambda () B6a9@x) B6ad) (if (= B6ae '1) (apply (lambda (B6ab@v) (set! B6a9@x (B6a6@fender B6ab@v))) B6ad) (error 'apply '"invalid arg count"))))))) B6af) (error 'apply '"invalid arg count")))))) (set! B6c2@B5a0@make-parameter B5a0@make-parameter) (set! B5a2@mosh-cache-dir (B5a0@make-parameter '#f)) (set! B6c3@B5a2@mosh-cache-dir B5a2@mosh-cache-dir) (set! B638@file-options-spec (lambda (B6b1@x) B6b1@x)) (set! B6c4@B638@file-options-spec B638@file-options-spec) (void))
(begin (set! B6ca@current-primitive-locations (unspecified)) (set! B6cc@mutable? (unspecified)) (set! B6ce@rewriter (unspecified)) (set! B6d0@expanded->core (unspecified)) (set! B6d2@compile-core-expr (unspecified)) (set! B6d4@pretty-print (unspecified)) (set! B6d6@compile-core-expr-to-port (unspecified)) (set! B6ca@current-primitive-locations (B6c2@B5a0@make-parameter (lambda (B6d7@x) '#f) (lambda (B6d9@p) B6d9@p))) (set! B715@B6ca@current-primitive-locations B6ca@current-primitive-locations) (set! B6cc@mutable? (lambda (B6db@x) (or (pair? B6db@x) (vector? B6db@x) (hashtable? B6db@x)))) (set! B716@B6cc@mutable? B6cc@mutable?) (set! B6ce@rewriter (lambda (B6dd@quote-hack?) (letrec* ((B6e0@f (lambda (B6e1@x) (if (pair? B6e1@x) (let ((B6e3@t (car B6e1@x))) (if (memv B6e3@t '(quote)) (if (and B6dd@quote-hack? (B6cc@mutable? (cadr B6e1@x))) (let ((B6e5@g (gensym))) (begin (set-symbol-value! B6e5@g (cadr B6e1@x)) B6e5@g)) B6e1@x) (if (memv B6e3@t '(case-lambda)) (cons 'case-lambda (map (lambda (B6e7@x) (cons (car B6e7@x) (map B6e0@f (cdr B6e7@x)))) (cdr B6e1@x))) (if (memv B6e3@t '(lambda)) (cons* 'lambda (cadr B6e1@x) (map B6e0@f (cddr B6e1@x))) (if (memv B6e3@t '(letrec)) (let ((B6e9@bindings (cadr B6e1@x)) (B6ea@body* (cddr B6e1@x))) (let ((B6ed@lhs* (map car B6e9@bindings)) (B6ee@rhs* (map cadr B6e9@bindings))) (cons* 'letrec (map list B6ed@lhs* (map B6e0@f B6ee@rhs*)) (map B6e0@f B6ea@body*)))) (if (memv B6e3@t '(letrec*)) (let ((B6f1@bindings (cadr B6e1@x)) (B6f2@body* (cddr B6e1@x))) (let ((B6f5@lhs* (map car B6f1@bindings)) (B6f6@rhs* (map cadr B6f1@bindings))) (cons* 'letrec* (map list B6f5@lhs* (map B6e0@f B6f6@rhs*)) (map B6e0@f B6f2@body*)))) (if (memv B6e3@t '(library-letrec*)) (let ((B6f9@name (cadr B6e1@x)) (B6fa@x (cdr B6e1@x))) (let ((B6fd@bindings (cadr B6fa@x)) (B6fe@body* (cddr B6fa@x))) (let ((B701@lhs* (map car B6fd@bindings)) (B702@lhs** (map cadr B6fd@bindings)) (B703@rhs* (map caddr B6fd@bindings))) (cons* 'library-letrec* B6f9@name (map list B701@lhs* B702@lhs** (map B6e0@f B703@rhs*)) (map B6e0@f B6fe@body*))))) (if (memv B6e3@t '(begin)) (cons 'begin (map B6e0@f (cdr B6e1@x))) (if (memv B6e3@t '(set!)) (list 'set! (cadr B6e1@x) (B6e0@f (caddr B6e1@x))) (if (memv B6e3@t '(primitive)) (let ((B707@op (cadr B6e1@x))) (let ((B709@t ((B6ca@current-primitive-locations) B707@op))) (if B709@t ((lambda (B70b@loc) B70b@loc) B709@t) B707@op))) (if (memv B6e3@t '(define)) B6e1@x (if (list? B6e1@x) (map B6e0@f B6e1@x) (error 'rewrite '"invalid form ~s ~s" B6e1@x (list? B6e1@x)))))))))))))) B6e1@x)))) B6e0@f))) (set! B717@B6ce@rewriter B6ce@rewriter) (set! B6d0@expanded->core (lambda (B70d@x) ((B6ce@rewriter '#f) B70d@x))) (set! B718@B6d0@expanded->core B6d0@expanded->core) (set! B6d2@compile-core-expr (lambda (B70f@x) ((B6ce@rewriter '#f) B70f@x))) (set! B719@B6d2@compile-core-expr B6d2@compile-core-expr) (set! B6d4@pretty-print write) (set! B71a@B6d4@pretty-print B6d4@pretty-print) (set! B6d6@compile-core-expr-to-port (lambda (B711@x B712@p) (B6d4@pretty-print ((B6ce@rewriter '#f) B711@x) B712@p))) (set! B71b@B6d6@compile-core-expr-to-port B6d6@compile-core-expr-to-port) (void))
(begin (void))
(begin (set! B76a@make-collection (unspecified)) (set! B76c@current-library-collection (unspecified)) (set! B76e@rp (unspecified)) (set! B778@library? (unspecified)) (set! B77a@library-id (unspecified)) (set! B77c@set-library-id! (unspecified)) (set! B77e@library-name (unspecified)) (set! B780@set-library-name! (unspecified)) (set! B782@library-version (unspecified)) (set! B784@set-library-version! (unspecified)) (set! B786@library-imp* (unspecified)) (set! B788@set-library-imp*! (unspecified)) (set! B78a@library-vis* (unspecified)) (set! B78c@set-library-vis*! (unspecified)) (set! B78e@library-inv* (unspecified)) (set! B790@set-library-inv*! (unspecified)) (set! B792@library-subst (unspecified)) (set! B794@set-library-subst! (unspecified)) (set! B796@library-env (unspecified)) (set! B798@set-library-env! (unspecified)) (set! B79a@library-visit-state (unspecified)) (set! B79c@set-library-visit-state! (unspecified)) (set! B79e@library-invoke-state (unspecified)) (set! B7a0@set-library-invoke-state! (unspecified)) (set! B7a2@library-visit-code (unspecified)) (set! B7a4@set-library-visit-code! (unspecified)) (set! B7a6@library-invoke-code (unspecified)) (set! B7a8@set-library-invoke-code! (unspecified)) (set! B7aa@library-visible? (unspecified)) (set! B7ac@set-library-visible?! (unspecified)) (set! B7ae@library-source-file-name (unspecified)) (set! B7b0@set-library-source-file-name! (unspecified)) (set! B7b2@dummy (unspecified)) (set! B7b4@find-dependencies (unspecified)) (set! B7b6@find-library-by (unspecified)) (set! B7b8@library-path (unspecified)) (set! B7ba@library-extensions (unspecified)) (set! B7bc@library-name->file-name (unspecified)) (set! B7be@file-locator (unspecified)) (set! B7c0@serialize-all (unspecified)) (set! B7c2@current-precompiled-library-loader (unspecified)) (set! B7c4@try-load-from-file (unspecified)) (set! B7c6@library-loader (unspecified)) (set! B7c8@current-library-expander (unspecified)) (set! B7ca@external-pending-libraries (unspecified)) (set! B7cc@find-external-library (unspecified)) (set! B7ce@find-library-by-name (unspecified)) (set! B7d0@library-exists? (unspecified)) (set! B7d2@find-library-by-spec/die (unspecified)) (set! B7d4@label->binding-table (unspecified)) (set! B7d6@install-library-record (unspecified)) (set! B7d8@install-library (unspecified)) (set! B7da@imported-label->binding (unspecified)) (set! B7dc@invoke-library (unspecified)) (set! B7de@visit-library (unspecified)) (set! B7e0@invoke-library-by-spec (unspecified)) (set! B7e2@installed-libraries (unspecified)) (set! B7e4@library-spec (unspecified)) (set! B76a@make-collection (lambda () (let ((B7e5@set '())) (letrec* ((B7e8@set-cons (lambda (B7ed@x B7ee@ls) (if (memq B7ed@x B7ee@ls) B7ee@ls (cons B7ed@x B7ee@ls))))) (lambda B7eb (let ((B7ec (length B7eb))) (if (= B7ec '0) (apply (lambda () B7e5@set) B7eb) (if (= B7ec '1) (apply (lambda (B7e9@x) (set! B7e5@set (B7e8@set-cons B7e9@x B7e5@set))) B7eb) (error 'apply '"invalid arg count"))))))))) (set! B959@B76a@make-collection B76a@make-collection) (set! B76c@current-library-collection (B6c2@B5a0@make-parameter (B76a@make-collection) (lambda (B7f1@x) (begin (if (not (procedure? B7f1@x)) (assertion-violation 'current-library-collection '"not a procedure" B7f1@x) (void)) B7f1@x)))) (set! B95a@B76c@current-library-collection B76c@current-library-collection) (set! B76e@rp (B6bf@B59a@make-record-printer 'library (lambda (B7f3@x B7f4@p B7f5@wr) (begin (if (not (B778@library? B7f3@x)) (assertion-violation 'record-type-printer '"not a library") (void)) (display (format '"#<library ~s>" (if (null? (B782@library-version B7f3@x)) (B77e@library-name B7f3@x) (append (B77e@library-name B7f3@x) (list (B782@library-version B7f3@x))))) B7f4@p))))) (set! B95b@B76e@rp B76e@rp) (set! B778@library? (lambda (B7f9@x) (and (simple-struct? B7f9@x) (eq? (simple-struct-name B7f9@x) 'library)))) (set! B95c@B778@library? B778@library?) (set! B77a@library-id (lambda (B7fb@x) (simple-struct-ref B7fb@x '0))) (set! B95d@B77a@library-id B77a@library-id) (set! B77c@set-library-id! (lambda (B7fd@x B7fe@val) (simple-struct-set! B7fd@x '0 B7fe@val))) (set! B95e@B77c@set-library-id! B77c@set-library-id!) (set! B77e@library-name (lambda (B801@x) (simple-struct-ref B801@x '1))) (set! B95f@B77e@library-name B77e@library-name) (set! B780@set-library-name! (lambda (B803@x B804@val) (simple-struct-set! B803@x '1 B804@val))) (set! B960@B780@set-library-name! B780@set-library-name!) (set! B782@library-version (lambda (B807@x) (simple-struct-ref B807@x '2))) (set! B961@B782@library-version B782@library-version) (set! B784@set-library-version! (lambda (B809@x B80a@val) (simple-struct-set! B809@x '2 B80a@val))) (set! B962@B784@set-library-version! B784@set-library-version!) (set! B786@library-imp* (lambda (B80d@x) (simple-struct-ref B80d@x '3))) (set! B963@B786@library-imp* B786@library-imp*) (set! B788@set-library-imp*! (lambda (B80f@x B810@val) (simple-struct-set! B80f@x '3 B810@val))) (set! B964@B788@set-library-imp*! B788@set-library-imp*!) (set! B78a@library-vis* (lambda (B813@x) (simple-struct-ref B813@x '4))) (set! B965@B78a@library-vis* B78a@library-vis*) (set! B78c@set-library-vis*! (lambda (B815@x B816@val) (simple-struct-set! B815@x '4 B816@val))) (set! B966@B78c@set-library-vis*! B78c@set-library-vis*!) (set! B78e@library-inv* (lambda (B819@x) (simple-struct-ref B819@x '5))) (set! B967@B78e@library-inv* B78e@library-inv*) (set! B790@set-library-inv*! (lambda (B81b@x B81c@val) (simple-struct-set! B81b@x '5 B81c@val))) (set! B968@B790@set-library-inv*! B790@set-library-inv*!) (set! B792@library-subst (lambda (B81f@x) (simple-struct-ref B81f@x '6))) (set! B969@B792@library-subst B792@library-subst) (set! B794@set-library-subst! (lambda (B821@x B822@val) (simple-struct-set! B821@x '6 B822@val))) (set! B96a@B794@set-library-subst! B794@set-library-subst!) (set! B796@library-env (lambda (B825@x) (simple-struct-ref B825@x '7))) (set! B96b@B796@library-env B796@library-env) (set! B798@set-library-env! (lambda (B827@x B828@val) (simple-struct-set! B827@x '7 B828@val))) (set! B96c@B798@set-library-env! B798@set-library-env!) (set! B79a@library-visit-state (lambda (B82b@x) (simple-struct-ref B82b@x '8))) (set! B96d@B79a@library-visit-state B79a@library-visit-state) (set! B79c@set-library-visit-state! (lambda (B82d@x B82e@val) (simple-struct-set! B82d@x '8 B82e@val))) (set! B96e@B79c@set-library-visit-state! B79c@set-library-visit-state!) (set! B79e@library-invoke-state (lambda (B831@x) (simple-struct-ref B831@x '9))) (set! B96f@B79e@library-invoke-state B79e@library-invoke-state) (set! B7a0@set-library-invoke-state! (lambda (B833@x B834@val) (simple-struct-set! B833@x '9 B834@val))) (set! B970@B7a0@set-library-invoke-state! B7a0@set-library-invoke-state!) (set! B7a2@library-visit-code (lambda (B837@x) (simple-struct-ref B837@x '10))) (set! B971@B7a2@library-visit-code B7a2@library-visit-code) (set! B7a4@set-library-visit-code! (lambda (B839@x B83a@val) (simple-struct-set! B839@x '10 B83a@val))) (set! B972@B7a4@set-library-visit-code! B7a4@set-library-visit-code!) (set! B7a6@library-invoke-code (lambda (B83d@x) (simple-struct-ref B83d@x '11))) (set! B973@B7a6@library-invoke-code B7a6@library-invoke-code) (set! B7a8@set-library-invoke-code! (lambda (B83f@x B840@val) (simple-struct-set! B83f@x '11 B840@val))) (set! B974@B7a8@set-library-invoke-code! B7a8@set-library-invoke-code!) (set! B7aa@library-visible? (lambda (B843@x) (simple-struct-ref B843@x '12))) (set! B975@B7aa@library-visible? B7aa@library-visible?) (set! B7ac@set-library-visible?! (lambda (B845@x B846@val) (simple-struct-set! B845@x '12 B846@val))) (set! B976@B7ac@set-library-visible?! B7ac@set-library-visible?!) (set! B7ae@library-source-file-name (lambda (B849@x) (simple-struct-ref B849@x '13))) (set! B977@B7ae@library-source-file-name B7ae@library-source-file-name) (set! B7b0@set-library-source-file-name! (lambda (B84b@x B84c@val) (simple-struct-set! B84b@x '13 B84c@val))) (set! B978@B7b0@set-library-source-file-name! B7b0@set-library-source-file-name!) (set! B7b2@dummy '3) (set! B979@B7b2@dummy B7b2@dummy) (set! B7b4@find-dependencies (lambda (B84f@ls) (if (null? B84f@ls) '() (assertion-violation 'find-dependencies '"cannot handle deps yet")))) (set! B97a@B7b4@find-dependencies B7b4@find-dependencies) (set! B7b6@find-library-by (lambda (B851@pred) (let B855@f ((B853@ls ((B76c@current-library-collection)))) (if (null? B853@ls) '#f (if (B851@pred (car B853@ls)) (car B853@ls) (B855@f (cdr B853@ls))))))) (set! B97b@B7b6@find-library-by B7b6@find-library-by) (set! B7b8@library-path (B6c2@B5a0@make-parameter '(".") (lambda (B857@x) (if (and (list? B857@x) (for-all string? B857@x)) (map (lambda (B859@x) B859@x) B857@x) (assertion-violation 'library-path '"not a list of strings" B857@x))))) (set! B97c@B7b8@library-path B7b8@library-path) (set! B7ba@library-extensions (B6c2@B5a0@make-parameter '(".sls" ".ss" ".scm") (lambda (B85b@x) (if (and (list? B85b@x) (for-all string? B85b@x)) (map (lambda (B85d@x) B85d@x) B85b@x) (assertion-violation 'library-extensions '"not a list of strings" B85b@x))))) (set! B97d@B7ba@library-extensions B7ba@library-extensions) (set! B7bc@library-name->file-name (lambda (B85f@x) (call-with-values (lambda () (open-string-output-port)) (lambda (B865@B862 B866@B864) (let ((B869@extract B866@B864) (B86a@p B865@B862)) (letrec* ((B86e@display-hex (lambda (B877@n) (if (<= '0 B877@n '9) (display B877@n B86a@p) (display (integer->char (+ (char->integer '#\a) (- B877@n '10))) B86a@p))))) (begin (let B871@f ((B86f@ls B85f@x)) (if (not (null? B86f@ls)) (begin (display '"/" B86a@p) (for-each (lambda (B873@c) (if (or (char<=? '#\a B873@c '#\z) (char<=? '#\A B873@c '#\Z) (char<=? '#\0 B873@c '#\9) (memv B873@c '(#\- #\. #\_ #\~))) (display B873@c B86a@p) (begin (display '"%" B86a@p) (let ((B875@n (char->integer B873@c))) (begin (B86e@display-hex (quotient B875@n '16)) (B86e@display-hex (remainder B875@n '16))))))) (string->list (symbol->string (car B86f@ls)))) (B871@f (cdr B86f@ls))) (void))) (B869@extract)))))))) (set! B97e@B7bc@library-name->file-name B7bc@library-name->file-name) (set! B7be@file-locator (B6c2@B5a0@make-parameter (lambda (B879@x) (let ((B87b@str (B7bc@library-name->file-name B879@x))) (let B883@f ((B87d@ls (B7b8@library-path)) (B87e@exts (B7ba@library-extensions)) (B87f@failed-list '())) (if (null? B87d@ls) (letrec* ((B88d@B888 (make-record-type-descriptor '&library-resolution &condition-rtd 'B88b '#f '#f '#((immutable library) (immutable files)))) (B88f@B88a '#f) (B891@B889 (make-record-constructor-descriptor B88d@B888 &condition-rcd B88f@B88a)) (B894@B887 (record-predicate B88d@B888)) (B896@make-library-resolution-condition (record-constructor B891@B889)) (B898@B885 (record-accessor B88d@B888 '0)) (B89a@B886 (record-accessor B88d@B888 '1)) (B89c@library-resolution-condition? (condition-predicate B88d@B888)) (B89e@condition-library (condition-accessor B88d@B888 B898@B885)) (B8a0@condition-files (condition-accessor B88d@B888 B89a@B886))) (raise (condition (make-error) (make-who-condition 'expander) (make-message-condition '"cannot locate library in library-path") (B896@make-library-resolution-condition B879@x (reverse B87f@failed-list))))) (if (null? B87e@exts) (B883@f (cdr B87d@ls) (B7ba@library-extensions) B87f@failed-list) (let ((B8a1@name (string-append (car B87d@ls) B87b@str (car B87e@exts)))) (if (file-exists? B8a1@name) B8a1@name (B883@f B87d@ls (cdr B87e@exts) (cons B8a1@name B87f@failed-list))))))))) (lambda (B8a3@f) (if (procedure? B8a3@f) B8a3@f (assertion-violation 'file-locator '"not a procedure" B8a3@f))))) (set! B97f@B7be@file-locator B7be@file-locator) (set! B7c0@serialize-all (lambda (B8a5@serialize B8a6@compile) (letrec* ((B8aa@library-desc (lambda (B8ad@x) (list (B77a@library-id B8ad@x) (B77e@library-name B8ad@x))))) (for-each (lambda (B8ab@x) (if (B7ae@library-source-file-name B8ab@x) (B8a5@serialize (B7ae@library-source-file-name B8ab@x) (list (B77a@library-id B8ab@x) (B77e@library-name B8ab@x) (B782@library-version B8ab@x) (map B8aa@library-desc (B786@library-imp* B8ab@x)) (map B8aa@library-desc (B78a@library-vis* B8ab@x)) (map B8aa@library-desc (B78e@library-inv* B8ab@x)) (B792@library-subst B8ab@x) (B796@library-env B8ab@x) (B8a6@compile (B7a2@library-visit-code B8ab@x)) (B8a6@compile (B7a6@library-invoke-code B8ab@x)) (B7aa@library-visible? B8ab@x))) (void))) ((B76c@current-library-collection)))))) (set! B980@B7c0@serialize-all B7c0@serialize-all) (set! B7c2@current-precompiled-library-loader (B6c2@B5a0@make-parameter (lambda (B8af@filename B8b0@sk) '#f))) (set! B981@B7c2@current-precompiled-library-loader B7c2@current-precompiled-library-loader) (set! B7c4@try-load-from-file (lambda (B8b3@filename) ((B7c2@current-precompiled-library-loader) B8b3@filename (lambda B8d9 (let ((B8da (length B8d9))) (if (= B8da '11) (apply (lambda (B8b5@id B8b6@name B8b7@ver B8b8@imp* B8b9@vis* B8ba@inv* B8bb@exp-subst B8bc@exp-env B8bd@visit-proc B8be@invoke-proc B8bf@visible?) (let B8cd@f ((B8cb@deps (append B8b8@imp* B8b9@vis* B8ba@inv*))) (if (null? B8cb@deps) (begin (B7d8@install-library B8b5@id B8b6@name B8b7@ver B8b8@imp* B8b9@vis* B8ba@inv* B8bb@exp-subst B8bc@exp-env B8bd@visit-proc B8be@invoke-proc '#f '#f B8bf@visible? '#f) '#t) (let ((B8cf@d (car B8cb@deps))) (let ((B8d1@label (car B8cf@d)) (B8d2@dname (cadr B8cf@d))) (let ((B8d5@l (B7ce@find-library-by-name B8d2@dname))) (if (and (B778@library? B8d5@l) (eq? B8d1@label (B77a@library-id B8d5@l))) (B8cd@f (cdr B8cb@deps)) (begin (if B6bc@B594@verbose? (format (current-error-port) '"WARNING: library ~s has an inconsistent dependency on library ~s; file ~s will be recompiled from source. l=~a label=~a (library-id l)=~a\n" B8b6@name B8d2@dname B8b3@filename B8d5@l B8d1@label (B77a@library-id B8d5@l)) (void)) '#f)))))))) B8d9) (if (>= B8da '0) (apply (lambda B8d7@others '#f) B8d9) (error 'apply '"invalid arg count")))))))) (set! B982@B7c4@try-load-from-file B7c4@try-load-from-file) (set! B7c6@library-loader (B6c2@B5a0@make-parameter (lambda (B8db@x) (let ((B8dd@file-name ((B7be@file-locator) B8db@x))) (if (not B8dd@file-name) (assertion-violation '#f '"cannot file library" B8db@x) (or (B7c4@try-load-from-file B8dd@file-name) ((B7c8@current-library-expander) (B6c1@B59e@read-library-source-file B8dd@file-name) B8dd@file-name (lambda (B8df@name) (if (not (fast-equal? B8df@name B8db@x)) (assertion-violation 'import (call-with-values (lambda () (open-string-output-port)) (lambda (B8e5@B8e2 B8e6@B8e4) (let ((B8e9@e B8e6@B8e4) (B8ea@p B8e5@B8e2)) (begin (display '"expected to find library " B8ea@p) (write B8db@x B8ea@p) (display '" in file " B8ea@p) (display B8dd@file-name B8ea@p) (display '", found " B8ea@p) (write B8df@name B8ea@p) (display '" instead" B8ea@p) (B8e9@e)))))) (void)))))))) (lambda (B8ed@f) (if (procedure? B8ed@f) B8ed@f (assertion-violation 'library-locator '"not a procedure" B8ed@f))))) (set! B983@B7c6@library-loader B7c6@library-loader) (set! B7c8@current-library-expander (B6c2@B5a0@make-parameter (lambda (B8ef@x) (assertion-violation 'library-expander '"not initialized")) (lambda (B8f1@f) (if (procedure? B8f1@f) B8f1@f (assertion-violation 'library-expander '"not a procedure" B8f1@f))))) (set! B984@B7c8@current-library-expander B7c8@current-library-expander) (set! B7ca@external-pending-libraries (B6c2@B5a0@make-parameter '())) (set! B985@B7ca@external-pending-libraries B7ca@external-pending-libraries) (set! B7cc@find-external-library (lambda (B8f3@name) (begin (if (member B8f3@name (B7ca@external-pending-libraries)) (assertion-violation '#f '"circular attempt to import library was detected" B8f3@name) (void)) (let ((B8f9@B8f6 B7ca@external-pending-libraries) (B8fa@B8f8 (cons B8f3@name (B7ca@external-pending-libraries)))) (let ((B8fd@swap (lambda () (let ((B8ff@t (B8f9@B8f6))) (begin (B8f9@B8f6 B8fa@B8f8) (set! B8fa@B8f8 B8ff@t)))))) (dynamic-wind B8fd@swap (lambda () (begin ((B7c6@library-loader) B8f3@name) (or (B7b6@find-library-by (lambda (B901@x) (fast-equal? (B77e@library-name B901@x) B8f3@name))) (assertion-violation '#f '"handling external library did not yield the correct library" B8f3@name)))) B8fd@swap)))))) (set! B986@B7cc@find-external-library B7cc@find-external-library) (set! B7ce@find-library-by-name (lambda (B903@name) (or (B7b6@find-library-by (lambda (B905@x) (fast-equal? (B77e@library-name B905@x) B903@name))) (B7cc@find-external-library B903@name)))) (set! B987@B7ce@find-library-by-name B7ce@find-library-by-name) (set! B7d0@library-exists? (lambda (B907@name) (and (B7b6@find-library-by (lambda (B909@x) (fast-equal? (B77e@library-name B909@x) B907@name))) '#t))) (set! B988@B7d0@library-exists? B7d0@library-exists?) (set! B7d2@find-library-by-spec/die (lambda (B90b@spec) (let ((B90d@id (car B90b@spec))) (or (B7b6@find-library-by (lambda (B90f@x) (eq? B90d@id (B77a@library-id B90f@x)))) (assertion-violation '#f '"cannot find library with required spec" B90b@spec))))) (set! B989@B7d2@find-library-by-spec/die B7d2@find-library-by-spec/die) (set! B7d4@label->binding-table (make-eq-hashtable)) (set! B98a@B7d4@label->binding-table B7d4@label->binding-table) (set! B7d6@install-library-record (lambda (B911@lib) (begin (let ((B913@exp-env (B796@library-env B911@lib))) (for-each (lambda (B915@x) (let ((B917@label (car B915@x)) (B918@binding (cdr B915@x))) (let ((B91b@binding (let ((B91d@t (car B918@binding))) (if (memv B91d@t '(global)) (cons 'global (cons B911@lib (cdr B918@binding))) (if (memv B91d@t '(global-macro)) (cons 'global-macro (cons B911@lib (cdr B918@binding))) (if (memv B91d@t '(global-macro!)) (cons 'global-macro! (cons B911@lib (cdr B918@binding))) B918@binding)))))) (begin (if (hashtable-ref B7d4@label->binding-table B917@label '#f) (begin (format (current-error-port) '"FATAL overwrite !! key=~a value=~a to ~a\n" B917@label (hashtable-ref B7d4@label->binding-table B917@label '#f) B91b@binding) (exit)) (void)) (hashtable-set! B7d4@label->binding-table B917@label B91b@binding))))) B913@exp-env)) ((B76c@current-library-collection) B911@lib)))) (set! B98b@B7d6@install-library-record B7d6@install-library-record) (set! B7d8@install-library (lambda (B91f@id B920@name B921@ver B922@imp* B923@vis* B924@inv* B925@exp-subst B926@exp-env B927@visit-proc B928@invoke-proc B929@visit-code B92a@invoke-code B92b@visible? B92c@source-file-name) (let ((B93b@imp-lib* (map B7d2@find-library-by-spec/die B922@imp*)) (B93c@vis-lib* (map B7d2@find-library-by-spec/die B923@vis*)) (B93d@inv-lib* (map B7d2@find-library-by-spec/die B924@inv*))) (begin (if (not (and (symbol? B91f@id) (list? B920@name) (list? B921@ver))) (assertion-violation 'install-library '"invalid spec with id/name/ver" B91f@id B920@name B921@ver) (void)) (if (B7d0@library-exists? B920@name) (assertion-violation 'install-library '"library is already installed" B920@name) (void)) (let ((B941@lib (make-simple-struct 'library '15 (list B91f@id B920@name B921@ver B93b@imp-lib* B93c@vis-lib* B93d@inv-lib* B925@exp-subst B926@exp-env B927@visit-proc B928@invoke-proc B929@visit-code B92a@invoke-code B92b@visible? B92c@source-file-name)))) (B7d6@install-library-record B941@lib)))))) (set! B98c@B7d8@install-library B7d8@install-library) (set! B7da@imported-label->binding (lambda (B943@lab) (hashtable-ref B7d4@label->binding-table B943@lab '#f))) (set! B98d@B7da@imported-label->binding B7da@imported-label->binding) (set! B7dc@invoke-library (lambda (B945@lib) (let ((B947@invoke (B79e@library-invoke-state B945@lib))) (if (procedure? B947@invoke) (begin (B7a0@set-library-invoke-state! B945@lib (lambda () (assertion-violation 'invoke '"circularity detected" B945@lib))) (for-each B7dc@invoke-library (B78e@library-inv* B945@lib)) (B7a0@set-library-invoke-state! B945@lib (lambda () (assertion-violation 'invoke '"first invoke did not return" B945@lib))) (B947@invoke) (B7a0@set-library-invoke-state! B945@lib '#t)) (void))))) (set! B98e@B7dc@invoke-library B7dc@invoke-library) (set! B7de@visit-library (lambda (B949@lib) (let ((B94b@visit (B79a@library-visit-state B949@lib))) (if (procedure? B94b@visit) (begin (B79c@set-library-visit-state! B949@lib (lambda () (assertion-violation 'visit '"circularity detected" B949@lib))) (for-each B7dc@invoke-library (B78a@library-vis* B949@lib)) (B79c@set-library-visit-state! B949@lib (lambda () (assertion-violation 'invoke '"first visit did not return" B949@lib))) (B94b@visit) (B79c@set-library-visit-state! B949@lib '#t)) (void))))) (set! B98f@B7de@visit-library B7de@visit-library) (set! B7e0@invoke-library-by-spec (lambda (B94d@spec) (B7dc@invoke-library (B7d2@find-library-by-spec/die B94d@spec)))) (set! B990@B7e0@invoke-library-by-spec B7e0@invoke-library-by-spec) (set! B7e2@installed-libraries (lambda B955 (let ((B956 (length B955))) (if (= B956 '1) (apply (lambda (B94f@all?) (let B953@f ((B951@ls ((B76c@current-library-collection)))) (if (null? B951@ls) '() (if (or B94f@all? (B7aa@library-visible? (car B951@ls))) (cons (car B951@ls) (B953@f (cdr B951@ls))) (B953@f (cdr B951@ls)))))) B955) (if (= B956 '0) (apply (lambda () (B7e2@installed-libraries '#f)) B955) (error 'apply '"invalid arg count")))))) (set! B991@B7e2@installed-libraries B7e2@installed-libraries) (set! B7e4@library-spec (lambda (B957@x) (begin (if (not (B778@library? B957@x)) (assertion-violation 'library-spec '"not a library" B957@x) (void)) (list (B77a@library-id B957@x) (B77e@library-name B957@x) (B782@library-version B957@x))))) (set! B992@B7e4@library-spec B7e4@library-spec) (void))
(begin (set! B996@build-global-define (unspecified)) (set! Ba07@build-lambda (unspecified)) (set! Ba09@build-case-lambda (unspecified)) (set! Ba37@build-sequence (unspecified)) (set! Ba39@build-void (unspecified)) (set! Ba3b@build-letrec (unspecified)) (set! Ba3d@build-let (unspecified)) (set! Ba3f@build-named-let (unspecified)) (set! Ba41@build-letrec* (unspecified)) (set! Ba43@build-library-letrec* (unspecified)) (set! Ba45@build-receive (unspecified)) (set! B996@build-global-define (lambda (Ba46@x) (Ba39@build-void))) (set! Bad4@B996@build-global-define B996@build-global-define) (set! Ba07@build-lambda (lambda (Ba48@ae Ba49@vars Ba4a@exp) (list 'lambda Ba49@vars Ba4a@exp))) (set! Bad5@Ba07@build-lambda Ba07@build-lambda) (set! Ba09@build-case-lambda (lambda (Ba4e@ae Ba4f@vars* Ba50@exp*) (letrec* ((Ba55@build-error (lambda (Ba8c@ae) (list '(primitive error) ''apply (list 'quote '"invalid arg count")))) (Ba57@build-pred (lambda (Ba74@ae Ba75@n Ba76@vars) (call-with-values (lambda () (let Ba82@f ((Ba7e@vars Ba76@vars) (Ba7f@count '0)) (if (pair? Ba7e@vars) (Ba82@f (cdr Ba7e@vars) (+ Ba7f@count '1)) (if (null? Ba7e@vars) (values Ba7f@count '=) (values Ba7f@count '>=))))) (lambda (Ba84@Ba7b Ba85@Ba7d) (let ((Ba88@pred Ba85@Ba7d) (Ba89@count Ba84@Ba7b)) (list (list 'primitive Ba88@pred) Ba75@n (list 'quote Ba89@count))))))) (Ba59@build-apply (lambda (Ba6c@ae Ba6d@g Ba6e@vars Ba6f@exp) (list '(primitive apply) (Ba07@build-lambda Ba6c@ae Ba6e@vars Ba6f@exp) Ba6d@g))) (Ba5b@expand-case-lambda (lambda (Ba5c@ae Ba5d@vars Ba5e@exp*) (let ((Ba62@g (gensym)) (Ba63@n (gensym))) (list 'lambda Ba62@g (Ba3d@build-let Ba5c@ae (list Ba63@n) (list (list '(primitive length) Ba62@g)) (let Ba6a@f ((Ba66@vars* Ba4f@vars*) (Ba67@exp* Ba5e@exp*)) (if (null? Ba66@vars*) (Ba55@build-error Ba5c@ae) (list 'if (Ba57@build-pred Ba5c@ae Ba63@n (car Ba66@vars*)) (Ba59@build-apply Ba5c@ae Ba62@g (car Ba66@vars*) (car Ba67@exp*)) (Ba6a@f (cdr Ba66@vars*) (cdr Ba67@exp*))))))))))) (if (= (length Ba50@exp*) '1) (Ba07@build-lambda Ba4e@ae (car Ba4f@vars*) (car Ba50@exp*)) (Ba5b@expand-case-lambda Ba4e@ae Ba4f@vars* Ba50@exp*))))) (set! Bad6@Ba09@build-case-lambda Ba09@build-case-lambda) (set! Ba37@build-sequence (lambda (Ba8e@ae Ba8f@exps) (let Ba94@loop ((Ba92@exps Ba8f@exps)) (if (null? (cdr Ba92@exps)) (car Ba92@exps) (if (equal? (car Ba92@exps) (Ba39@build-void)) (Ba94@loop (cdr Ba92@exps)) (cons 'begin Ba92@exps)))))) (set! Bad7@Ba37@build-sequence Ba37@build-sequence) (set! Ba39@build-void (lambda () '((primitive void)))) (set! Bad8@Ba39@build-void Ba39@build-void) (set! Ba3b@build-letrec (lambda (Ba96@ae Ba97@vars Ba98@val-exps Ba99@body-exp) (if (null? Ba97@vars) Ba99@body-exp (list 'letrec (map list Ba97@vars Ba98@val-exps) Ba99@body-exp)))) (set! Bad9@Ba3b@build-letrec Ba3b@build-letrec) (set! Ba3d@build-let (lambda (Ba9e@ae Ba9f@vars Baa0@val-exps Baa1@body-exp) (if (null? Ba9f@vars) Baa1@body-exp (list 'let (map list Ba9f@vars Baa0@val-exps) Baa1@body-exp)))) (set! Bada@Ba3d@build-let Ba3d@build-let) (set! Ba3f@build-named-let (lambda (Baa6@ae Baa7@name Baa8@vars Baa9@val-exps Baaa@body-exp) (list 'let Baa7@name (map list Baa8@vars Baa9@val-exps) Baaa@body-exp))) (set! Badb@Ba3f@build-named-let Ba3f@build-named-let) (set! Ba41@build-letrec* (lambda (Bab0@ae Bab1@vars Bab2@val-exps Bab3@body-exp) (if (null? Bab1@vars) Bab3@body-exp (list 'letrec* (map list Bab1@vars Bab2@val-exps) Bab3@body-exp)))) (set! Badc@Ba41@build-letrec* Ba41@build-letrec*) (set! Ba43@build-library-letrec* (lambda (Bab8@ae Bab9@name Baba@vars Babb@locs Babc@val-exps Babd@body-exp) (cons 'begin (append (map (lambda (Bac4@var) (cons 'set! (cons Bac4@var '((unspecified))))) Baba@vars) (append (apply append (map (lambda (Bac6@var Bac7@loc Bac8@val-exp) (list (list 'set! Bac6@var Bac8@val-exp) (list 'set! Bac7@loc Bac6@var))) Baba@vars Babb@locs Babc@val-exps)) (list Babd@body-exp)))))) (set! Badd@Ba43@build-library-letrec* Ba43@build-library-letrec*) (set! Ba45@build-receive (lambda (Bacc@ae Bacd@vars Bace@producer Bacf@body*) (begin (display '"************** in ") (cons 'receive (cons Bacd@vars (cons Bace@producer Bacf@body*)))))) (set! Bade@Ba45@build-receive Ba45@build-receive) (void))
(begin (set! Baed@file-options-macro (unspecified)) (set! Baef@set-cons (unspecified)) (set! Baf1@set-union (unspecified)) (set! Baf6@top-mark* (unspecified)) (set! Baf8@top-marked? (unspecified)) (set! Bafa@gen-lexical (unspecified)) (set! Bafc@gen-global (unspecified)) (set! Bafe@gen-label (unspecified)) (set! Bb00@gen-top-level-label (unspecified)) (set! Bb02@gen-define-label+loc (unspecified)) (set! Bb04@gen-define-label (unspecified)) (set! Bb0e@rib? (unspecified)) (set! Bb10@rib-sym* (unspecified)) (set! Bb12@set-rib-sym*! (unspecified)) (set! Bb14@rib-mark** (unspecified)) (set! Bb16@set-rib-mark**! (unspecified)) (set! Bb18@rib-label* (unspecified)) (set! Bb1a@set-rib-label*! (unspecified)) (set! Bb1c@rib-sealed/freq (unspecified)) (set! Bb1e@set-rib-sealed/freq! (unspecified)) (set! Bb20@rib-cache (unspecified)) (set! Bb22@set-rib-cache! (unspecified)) (set! Bb24@dummy (unspecified)) (set! Bb26@make-empty-rib (unspecified)) (set! Bb28@extend-rib! (unspecified)) (set! Bb2a@extend-rib/nc! (unspecified)) (set! Bb2c@make-rib-map (unspecified)) (set! Bb2e@seal-rib! (unspecified)) (set! Bb30@unseal-rib! (unspecified)) (set! Bb32@make-full-rib (unspecified)) (set! Bb34@rp (unspecified)) (set! Bb3e@stx? (unspecified)) (set! Bb40@stx-expr (unspecified)) (set! Bb42@set-stx-expr! (unspecified)) (set! Bb44@stx-mark* (unspecified)) (set! Bb46@set-stx-mark*! (unspecified)) (set! Bb48@stx-subst* (unspecified)) (set! Bb4a@set-stx-subst*! (unspecified)) (set! Bb4c@stx-ae* (unspecified)) (set! Bb4e@set-stx-ae*! (unspecified)) (set! Bb50@dummy (unspecified)) (set! Bb52@datum->stx (unspecified)) (set! Bb54@gen-mark (unspecified)) (set! Bb56@anti-mark (unspecified)) (set! Bb58@anti-mark? (unspecified)) (set! Bb5a@mkstx (unspecified)) (set! Bb5c@add-mark (unspecified)) (set! Bb5e@add-subst (unspecified)) (set! Bb60@syntax-kind? (unspecified)) (set! Bb62@syntax-vector->list (unspecified)) (set! Bb64@syntax-pair? (unspecified)) (set! Bb66@syntax-vector? (unspecified)) (set! Bb68@syntax-null? (unspecified)) (set! Bb6a@syntax-list? (unspecified)) (set! Bb6c@syntax-car (unspecified)) (set! Bb6e@syntax-cdr (unspecified)) (set! Bb70@syntax->list (unspecified)) (set! Bb72@id? (unspecified)) (set! Bb74@id->sym (unspecified)) (set! Bb76@bound-id=? (unspecified)) (set! Bb78@free-id=? (unspecified)) (set! Bb7a@valid-bound-ids? (unspecified)) (set! Bb7c@distinct-bound-ids? (unspecified)) (set! Bb7e@bound-id-member? (unspecified)) (set! Bb80@self-evaluating? (unspecified)) (set! Bb82@strip-annotations (unspecified)) (set! Bb84@strip (unspecified)) (set! Bb86@stx->datum (unspecified)) (set! Bb88@id->label (unspecified)) (set! Bb8a@label->binding (unspecified)) (set! Bb8c@make-binding (unspecified)) (set! Bb8e@binding-type (unspecified)) (set! Bb90@binding-value (unspecified)) (set! Bb92@raise-unbound-error (unspecified)) (set! Bb94@syntax-type (unspecified)) (set! Bba2@sanitize-binding (unspecified)) (set! Bba4@make-variable-transformer (unspecified)) (set! Bba6@variable-transformer? (unspecified)) (set! Bba8@variable-transformer-procedure (unspecified)) (set! Bbaa@make-eval-transformer (unspecified)) (set! Bcfb@parse-define (unspecified)) (set! Bcfd@parse-define-syntax (unspecified)) (set! Bcff@scheme-stx-hashtable (unspecified)) (set! Bd01@scheme-stx (unspecified)) (set! Bd03@lexical-var (unspecified)) (set! Bd05@lexical-mutable? (unspecified)) (set! Bd07@set-lexical-mutable! (unspecified)) (set! Bd09@add-lexical (unspecified)) (set! Bd0b@add-lexicals (unspecified)) (set! Bd0d@letrec-helper (unspecified)) (set! Bd0f@let-transformer (unspecified)) (set! Bd11@letrec-transformer (unspecified)) (set! Bd13@letrec*-transformer (unspecified)) (set! Bd15@fluid-let-syntax-transformer (unspecified)) (set! Bd17@type-descriptor-transformer (unspecified)) (set! Bd19@record-type-descriptor-transformer (unspecified)) (set! Bd1b@record-constructor-descriptor-transformer (unspecified)) (set! Bd1d@when-macro (unspecified)) (set! Bd1f@unless-macro (unspecified)) (set! Bd21@if-transformer (unspecified)) (set! Bd23@and-transformer (unspecified)) (set! Bd25@or-transformer (unspecified)) (set! Bd27@case-macro (unspecified)) (set! Bd29@quote-transformer (unspecified)) (set! Bd2b@case-lambda-transformer (unspecified)) (set! Bd2d@lambda-transformer (unspecified)) (set! Bd2f@bless (unspecified)) (set! Bd31@with-syntax-macro (unspecified)) (set! Bd33@invalid-fmls-error (unspecified)) (set! Bd35@let-macro (unspecified)) (set! Bd37@let-values-macro (unspecified)) (set! Bd39@let*-values-macro (unspecified)) (set! Bd3b@trace-lambda-macro (unspecified)) (set! Bd3d@trace-define-macro (unspecified)) (set! Bd3f@trace-define-syntax-macro (unspecified)) (set! Bd41@trace-let/rec-syntax (unspecified)) (set! Bd43@trace-let-syntax-macro (unspecified)) (set! Bd45@trace-letrec-syntax-macro (unspecified)) (set! Bd47@guard-macro (unspecified)) (set! Bd49@define-enumeration-macro (unspecified)) (set! Bd4b@time-macro (unspecified)) (set! Bd4d@delay-macro (unspecified)) (set! Bd4f@assert-macro (unspecified)) (set! Bd51@endianness-macro (unspecified)) (set! Bd53@identifier-syntax-macro (unspecified)) (set! Bd55@do-macro (unspecified)) (set! Bd57@let*-macro (unspecified)) (set! Bd59@or-macro (unspecified)) (set! Bd5b@and-macro (unspecified)) (set! Bd5d@cond-macro (unspecified)) (set! Bd5f@do-include (unspecified)) (set! Bd61@include-macro (unspecified)) (set! Bd63@include-into-macro (unspecified)) (set! Bd65@syntax-rules-macro (unspecified)) (set! Bd67@quasiquote-macro (unspecified)) (set! Bd69@quasisyntax-macro (unspecified)) (set! Bd6b@define-struct-macro (unspecified)) (set! Bd6d@define-record-type-macro (unspecified)) (set! Bd6f@define-condition-type-macro (unspecified)) (set! Bd71@incorrect-usage-macro (unspecified)) (set! Bd73@parameterize-macro (unspecified)) (set! Bd75@foreign-call-transformer (unspecified)) (set! Bd77@convert-pattern (unspecified)) (set! Bd79@syntax-dispatch (unspecified)) (set! Bd7b@ellipsis? (unspecified)) (set! Bd7d@underscore? (unspecified)) (set! Bd7f@verify-literals (unspecified)) (set! Bd81@syntax-case-transformer (unspecified)) (set! Bd83@ellipsis-map (unspecified)) (set! Bd85@syntax-transformer (unspecified)) (set! Bd87@core-macro-transformer (unspecified)) (set! Bd89@symbol-macro (unspecified)) (set! Bd8b@macro-transformer (unspecified)) (set! Bd8d@local-macro-transformer (unspecified)) (set! Bd8f@do-macro-call (unspecified)) (set! Bd91@chi-macro (unspecified)) (set! Bd93@chi-local-macro (unspecified)) (set! Bd95@chi-global-macro (unspecified)) (set! Bd97@chi-expr* (unspecified)) (set! Bd99@chi-application (unspecified)) (set! Bd9b@chi-expr (unspecified)) (set! Bd9d@chi-set! (unspecified)) (set! Bd9f@verify-formals (unspecified)) (set! Bda1@chi-lambda-clause (unspecified)) (set! Bda3@chi-lambda-clause* (unspecified)) (set! Bda5@chi-defun (unspecified)) (set! Bda7@chi-rhs (unspecified)) (set! Bda9@expand-interaction-rhs*/init* (unspecified)) (set! Bdab@chi-rhs* (unspecified)) (set! Bdad@find-bound=? (unspecified)) (set! Bdaf@find-dups (unspecified)) (set! Bdb1@chi-internal (unspecified)) (set! Bdb3@parse-module (unspecified)) (set! Bdbd@module-interface? (unspecified)) (set! Bdbf@module-interface-first-mark (unspecified)) (set! Bdc1@set-module-interface-first-mark! (unspecified)) (set! Bdc3@module-interface-exp-id-vec (unspecified)) (set! Bdc5@set-module-interface-exp-id-vec! (unspecified)) (set! Bdc7@module-interface-exp-lab-vec (unspecified)) (set! Bdc9@set-module-interface-exp-lab-vec! (unspecified)) (set! Bdcb@dummy (unspecified)) (set! Bdcd@module-interface-exp-id* (unspecified)) (set! Bdcf@chi-internal-module (unspecified)) (set! Bdd1@chi-body* (unspecified)) (set! Bdd3@expand-transformer (unspecified)) (set! Bdd5@parse-exports (unspecified)) (set! Bdd7@parse-library-name (unspecified)) (set! Bdd9@parse-library (unspecified)) (set! Bddb@parse-import-spec* (unspecified)) (set! Bddd@make-top-rib (unspecified)) (set! Bddf@make-collector (unspecified)) (set! Bde1@inv-collector (unspecified)) (set! Bde3@vis-collector (unspecified)) (set! Bde5@imp-collector (unspecified)) (set! Bde7@chi-library-internal (unspecified)) (set! Bde9@chi-interaction-expr (unspecified)) (set! Bdeb@library-body-expander (unspecified)) (set! Bded@core-library-expander (unspecified)) (set! Bdef@parse-top-level-program (unspecified)) (set! Bdf1@top-level-expander (unspecified)) (set! Bdf3@rp (unspecified)) (set! Bdfd@env? (unspecified)) (set! Bdff@env-names (unspecified)) (set! Be01@set-env-names! (unspecified)) (set! Be03@env-labels (unspecified)) (set! Be05@set-env-labels! (unspecified)) (set! Be07@env-itc (unspecified)) (set! Be09@set-env-itc! (unspecified)) (set! Be0b@dummy (unspecified)) (set! Be0d@rp (unspecified)) (set! Be17@interaction-env? (unspecified)) (set! Be19@interaction-env-rib (unspecified)) (set! Be1b@set-interaction-env-rib! (unspecified)) (set! Be1d@interaction-env-r (unspecified)) (set! Be1f@set-interaction-env-r! (unspecified)) (set! Be21@interaction-env-locs (unspecified)) (set! Be23@set-interaction-env-locs! (unspecified)) (set! Be25@dummy (unspecified)) (set! Be27@interaction-environment-symbols (unspecified)) (set! Be29@environment-bindings (unspecified)) (set! Be2b@parse-binding (unspecified)) (set! Be2d@environment? (unspecified)) (set! Be2f@environment-symbols (unspecified)) (set! Be31@environment (unspecified)) (set! Be33@null-environment (unspecified)) (set! Be35@scheme-report-environment (unspecified)) (set! Be37@expand (unspecified)) (set! Be39@eval (unspecified)) (set! Be3b@library-expander (unspecified)) (set! Be3d@boot-library-expand (unspecified)) (set! Be3f@rev-map-append (unspecified)) (set! Be41@build-exports (unspecified)) (set! Be43@make-export-subst (unspecified)) (set! Be45@make-export-env/macros (unspecified)) (set! Be47@generate-temporaries (unspecified)) (set! Be49@free-identifier=? (unspecified)) (set! Be4b@bound-identifier=? (unspecified)) (set! Be4d@make-source-condition (unspecified)) (set! Be4f@extract-position-condition (unspecified)) (set! Be51@expression-position (unspecified)) (set! Be53@assertion-error (unspecified)) (set! Be55@syntax-error (unspecified)) (set! Be57@syntax-violation* (unspecified)) (set! Be59@syntax-violation (unspecified)) (set! Be5b@identifier? (unspecified)) (set! Be5d@datum->syntax (unspecified)) (set! Be5f@syntax->datum (unspecified)) (set! Be61@ungensym-all (unspecified)) (set! Be63@compile-r6rs-top-level (unspecified)) (set! Be65@pre-compile-r6rs-top-level (unspecified)) (set! Be67@interaction-environment (unspecified)) (set! Be69@top-level-context (unspecified)) (set! Baed@file-options-macro (lambda (Be6a@x) (letrec* ((Be6d@valid-option? (lambda (Be76@x) (and (Bb72@id? Be76@x) (memq (Bb74@id->sym Be76@x) '(no-fail no-create no-truncate)))))) (let ((Be6e@t Be6a@x)) (let ((Be70@ls/false (Bd79@syntax-dispatch Be6e@t '(_ . each-any)))) (if (and Be70@ls/false (apply (lambda (Be72@opt*) (for-all Be6d@valid-option? Be72@opt*)) Be70@ls/false)) (apply (lambda (Be74@opt*) (Bd2f@bless (list 'make-file-options (list 'quote Be74@opt*)))) Be70@ls/false) (Be59@syntax-violation '#f '"invalid syntax" Be6e@t))))))) (set! B27c0@Baed@file-options-macro Baed@file-options-macro) (set! Baef@set-cons (lambda (Be78@x Be79@ls) (if (memq Be78@x Be79@ls) Be79@ls (cons Be78@x Be79@ls)))) (set! B27c1@Baef@set-cons Baef@set-cons) (set! Baf1@set-union (lambda (Be7c@ls1 Be7d@ls2) (if (null? Be7c@ls1) Be7d@ls2 (if (memq (car Be7c@ls1) Be7d@ls2) (Baf1@set-union (cdr Be7c@ls1) Be7d@ls2) (cons (car Be7c@ls1) (Baf1@set-union (cdr Be7c@ls1) Be7d@ls2)))))) (set! B27c2@Baf1@set-union Baf1@set-union) (set! Baf6@top-mark* '(top)) (set! B27c3@Baf6@top-mark* Baf6@top-mark*) (set! Baf8@top-marked? (lambda (Be80@m*) (memq 'top Be80@m*))) (set! B27c4@Baf8@top-marked? Baf8@top-marked?) (set! Bafa@gen-lexical (lambda (Be82@sym) (if (symbol? Be82@sym) (gensym Be82@sym) (if (Bb3e@stx? Be82@sym) (Bafa@gen-lexical (Bb74@id->sym Be82@sym)) (assertion-violation 'gen-lexical '"BUG: invalid arg" Be82@sym))))) (set! B27c5@Bafa@gen-lexical Bafa@gen-lexical) (set! Bafc@gen-global (lambda (Be84@x) (Bafa@gen-lexical Be84@x))) (set! B27c6@Bafc@gen-global Bafc@gen-global) (set! Bafe@gen-label (lambda (Be86@_) (gensym))) (set! B27c7@Bafe@gen-label Bafe@gen-label) (set! Bb00@gen-top-level-label (lambda (Be88@id Be89@rib) (letrec* ((Be8d@find (lambda (Be98@sym Be99@mark* Be9a@sym* Be9b@mark** Be9c@label*) (and (pair? Be9a@sym*) (if (and (eq? Be98@sym (car Be9a@sym*)) (same-marks? Be99@mark* (car Be9b@mark**))) (car Be9c@label*) (Be8d@find Be98@sym Be99@mark* (cdr Be9a@sym*) (cdr Be9b@mark**) (cdr Be9c@label*))))))) (let ((Be8e@sym (Bb74@id->sym Be88@id)) (Be8f@mark* (Bb44@stx-mark* Be88@id))) (let ((Be92@sym* (Bb10@rib-sym* Be89@rib))) (let ((Be94@t (and (memq Be8e@sym (Bb10@rib-sym* Be89@rib)) (Be8d@find Be8e@sym Be8f@mark* Be92@sym* (Bb14@rib-mark** Be89@rib) (Bb18@rib-label* Be89@rib))))) (if Be94@t ((lambda (Be96@label) (if (B98d@B7da@imported-label->binding Be96@label) (gensym) Be96@label)) Be94@t) (gensym)))))))) (set! B27c8@Bb00@gen-top-level-label Bb00@gen-top-level-label) (set! Bb02@gen-define-label+loc (lambda (Bea2@id Bea3@rib) (let ((Bea6@t (Be69@top-level-context))) (if Bea6@t ((lambda (Bea8@env) (let ((Beaa@label (Bb00@gen-top-level-label Bea2@id Bea3@rib)) (Beab@locs (Be21@interaction-env-locs Bea8@env))) (values Beaa@label (let ((Beae@t (assq Beaa@label Beab@locs))) (if Beae@t (cdr Beae@t) (let ((Beb0@loc (Bafa@gen-lexical Bea2@id))) (begin (Be23@set-interaction-env-locs! Bea8@env (cons (cons Beaa@label Beb0@loc) Beab@locs)) Beb0@loc))))))) Bea6@t) (values (gensym) (Bafa@gen-lexical Bea2@id)))))) (set! B27c9@Bb02@gen-define-label+loc Bb02@gen-define-label+loc) (set! Bb04@gen-define-label (lambda (Beb2@id Beb3@rib) (if (Be69@top-level-context) (Bb00@gen-top-level-label Beb2@id Beb3@rib) (gensym)))) (set! B27ca@Bb04@gen-define-label Bb04@gen-define-label) (set! Bb0e@rib? (lambda (Beb6@x) (and (simple-struct? Beb6@x) (eq? (simple-struct-name Beb6@x) 'rib)))) (set! B27cb@Bb0e@rib? Bb0e@rib?) (set! Bb10@rib-sym* (lambda (Beb8@x) (simple-struct-ref Beb8@x '0))) (set! B27cc@Bb10@rib-sym* Bb10@rib-sym*) (set! Bb12@set-rib-sym*! (lambda (Beba@x Bebb@val) (simple-struct-set! Beba@x '0 Bebb@val))) (set! B27cd@Bb12@set-rib-sym*! Bb12@set-rib-sym*!) (set! Bb14@rib-mark** (lambda (Bebe@x) (simple-struct-ref Bebe@x '1))) (set! B27ce@Bb14@rib-mark** Bb14@rib-mark**) (set! Bb16@set-rib-mark**! (lambda (Bec0@x Bec1@val) (simple-struct-set! Bec0@x '1 Bec1@val))) (set! B27cf@Bb16@set-rib-mark**! Bb16@set-rib-mark**!) (set! Bb18@rib-label* (lambda (Bec4@x) (simple-struct-ref Bec4@x '2))) (set! B27d0@Bb18@rib-label* Bb18@rib-label*) (set! Bb1a@set-rib-label*! (lambda (Bec6@x Bec7@val) (simple-struct-set! Bec6@x '2 Bec7@val))) (set! B27d1@Bb1a@set-rib-label*! Bb1a@set-rib-label*!) (set! Bb1c@rib-sealed/freq (lambda (Beca@x) (simple-struct-ref Beca@x '3))) (set! B27d2@Bb1c@rib-sealed/freq Bb1c@rib-sealed/freq) (set! Bb1e@set-rib-sealed/freq! (lambda (Becc@x Becd@val) (simple-struct-set! Becc@x '3 Becd@val))) (set! B27d3@Bb1e@set-rib-sealed/freq! Bb1e@set-rib-sealed/freq!) (set! Bb20@rib-cache (lambda (Bed0@x) (simple-struct-ref Bed0@x '4))) (set! B27d4@Bb20@rib-cache Bb20@rib-cache) (set! Bb22@set-rib-cache! (lambda (Bed2@x Bed3@val) (simple-struct-set! Bed2@x '4 Bed3@val))) (set! B27d5@Bb22@set-rib-cache! Bb22@set-rib-cache!) (set! Bb24@dummy '3) (set! B27d6@Bb24@dummy Bb24@dummy) (set! Bb26@make-empty-rib (lambda () (make-simple-struct 'rib '6 (list '() '() '() '#f '#f)))) (set! B27d7@Bb26@make-empty-rib Bb26@make-empty-rib) (set! Bb28@extend-rib! (lambda (Bed6@rib Bed7@id Bed8@label) (letrec* ((Bedd@find (lambda (Beea@sym Beeb@mark* Beec@sym* Beed@mark** Beee@label*) (and (pair? Beec@sym*) (if (and (eq? Beea@sym (car Beec@sym*)) (same-marks? Beeb@mark* (car Beed@mark**))) Beee@label* (Bedd@find Beea@sym Beeb@mark* (cdr Beec@sym*) (cdr Beed@mark**) (cdr Beee@label*))))))) (begin (if (Bb1c@rib-sealed/freq Bed6@rib) (assertion-violation 'extend-rib! '"BUG: rib is sealed" Bed6@rib) (void)) (let ((Bede@sym (Bb74@id->sym Bed7@id)) (Bedf@mark* (Bb44@stx-mark* Bed7@id))) (let ((Bee2@sym* (Bb10@rib-sym* Bed6@rib))) (let ((Bee4@t (and (memq Bede@sym (Bb10@rib-sym* Bed6@rib)) (Bedd@find Bede@sym Bedf@mark* Bee2@sym* (Bb14@rib-mark** Bed6@rib) (Bb18@rib-label* Bed6@rib))))) (if Bee4@t ((lambda (Bee6@p) (if (not (eq? Bed8@label (car Bee6@p))) (if (Be69@top-level-context) (set-car! Bee6@p Bed8@label) (Be59@syntax-violation '#f '"multiple definitions of identifier" Bed7@id)) (void))) Bee4@t) (begin (if (Bb20@rib-cache Bed6@rib) (hashtable-update! (Bb20@rib-cache Bed6@rib) Bede@sym (lambda (Bee8@e) (cons (cons Bedf@mark* Bed8@label) Bee8@e)) '()) (void)) (Bb12@set-rib-sym*! Bed6@rib (cons Bede@sym Bee2@sym*)) (Bb16@set-rib-mark**! Bed6@rib (cons Bedf@mark* (Bb14@rib-mark** Bed6@rib))) (Bb1a@set-rib-label*! Bed6@rib (cons Bed8@label (Bb18@rib-label* Bed6@rib)))))))))))) (set! B27d8@Bb28@extend-rib! Bb28@extend-rib!) (set! Bb2a@extend-rib/nc! (lambda (Bef4@rib Bef5@id Bef6@label) (let ((Befa@sym (Bb74@id->sym Bef5@id)) (Befb@mark* (Bb44@stx-mark* Bef5@id))) (let ((Befe@sym* (Bb10@rib-sym* Bef4@rib))) (begin (if (Bb20@rib-cache Bef4@rib) (hashtable-update! (Bb20@rib-cache Bef4@rib) Befa@sym (lambda (Bf00@e) (cons (cons Befb@mark* Bef6@label) Bf00@e)) '()) (void)) (Bb12@set-rib-sym*! Bef4@rib (cons Befa@sym Befe@sym*)) (Bb16@set-rib-mark**! Bef4@rib (cons Befb@mark* (Bb14@rib-mark** Bef4@rib))) (Bb1a@set-rib-label*! Bef4@rib (cons Bef6@label (Bb18@rib-label* Bef4@rib)))))))) (set! B27d9@Bb2a@extend-rib/nc! Bb2a@extend-rib/nc!) (set! Bb2c@make-rib-map (lambda (Bf02@sym*) (let ((Bf04@ht (make-eq-hashtable))) (let Bf0a@f ((Bf06@i '0) (Bf07@sym* Bf02@sym*)) (if (null? Bf07@sym*) Bf04@ht (begin (hashtable-update! Bf04@ht (car Bf07@sym*) (lambda (Bf0c@x) (cons Bf06@i Bf0c@x)) '()) (Bf0a@f (+ Bf06@i '1) (cdr Bf07@sym*)))))))) (set! B27da@Bb2c@make-rib-map Bb2c@make-rib-map) (set! Bb2e@seal-rib! (lambda (Bf0e@rib) (let ((Bf10@sym* (Bb10@rib-sym* Bf0e@rib))) (if (not (null? Bf10@sym*)) (begin (Bb12@set-rib-sym*! Bf0e@rib (list->vector Bf10@sym*)) (Bb16@set-rib-mark**! Bf0e@rib (list->vector (Bb14@rib-mark** Bf0e@rib))) (Bb1a@set-rib-label*! Bf0e@rib (list->vector (Bb18@rib-label* Bf0e@rib))) (Bb1e@set-rib-sealed/freq! Bf0e@rib (Bb2c@make-rib-map Bf10@sym*))) (void))))) (set! B27db@Bb2e@seal-rib! Bb2e@seal-rib!) (set! Bb30@unseal-rib! (lambda (Bf12@rib) (if (Bb1c@rib-sealed/freq Bf12@rib) (begin (Bb1e@set-rib-sealed/freq! Bf12@rib '#f) (Bb12@set-rib-sym*! Bf12@rib (vector->list (Bb10@rib-sym* Bf12@rib))) (Bb16@set-rib-mark**! Bf12@rib (vector->list (Bb14@rib-mark** Bf12@rib))) (Bb1a@set-rib-label*! Bf12@rib (vector->list (Bb18@rib-label* Bf12@rib)))) (void)))) (set! B27dc@Bb30@unseal-rib! Bb30@unseal-rib!) (set! Bb32@make-full-rib (lambda (Bf14@id* Bf15@label*) (let ((Bf18@r (make-simple-struct 'rib '6 (list (map Bb74@id->sym Bf14@id*) (map Bb44@stx-mark* Bf14@id*) Bf15@label* '#f '#f)))) (begin (Bb2e@seal-rib! Bf18@r) Bf18@r)))) (set! B27dd@Bb32@make-full-rib Bb32@make-full-rib) (set! Bb34@rp (B6bf@B59a@make-record-printer 'stx (lambda (Bf1a@x Bf1b@p Bf1c@wr) (begin (display '"#<syntax " Bf1b@p) (write (Bb86@stx->datum Bf1a@x) Bf1b@p) (let ((Bf20@expr (Bb40@stx-expr Bf1a@x))) (if (B6b6@B588@annotation? Bf20@expr) (let ((Bf22@src (B6b7@B58a@annotation-source Bf20@expr))) (if (pair? Bf22@src) (begin (display '" [" Bf1b@p) (display (cdr Bf22@src) Bf1b@p) (display '" of " Bf1b@p) (display (car Bf22@src) Bf1b@p) (display '"]" Bf1b@p)) (void))) (void))) (display '">" Bf1b@p))))) (set! B27de@Bb34@rp Bb34@rp) (set! Bb3e@stx? (lambda (Bf24@x) (and (simple-struct? Bf24@x) (eq? (simple-struct-name Bf24@x) 'stx)))) (set! B27df@Bb3e@stx? Bb3e@stx?) (set! Bb40@stx-expr (lambda (Bf26@x) (simple-struct-ref Bf26@x '0))) (set! B27e0@Bb40@stx-expr Bb40@stx-expr) (set! Bb42@set-stx-expr! (lambda (Bf28@x Bf29@val) (simple-struct-set! Bf28@x '0 Bf29@val))) (set! B27e1@Bb42@set-stx-expr! Bb42@set-stx-expr!) (set! Bb44@stx-mark* (lambda (Bf2c@x) (simple-struct-ref Bf2c@x '1))) (set! B27e2@Bb44@stx-mark* Bb44@stx-mark*) (set! Bb46@set-stx-mark*! (lambda (Bf2e@x Bf2f@val) (simple-struct-set! Bf2e@x '1 Bf2f@val))) (set! B27e3@Bb46@set-stx-mark*! Bb46@set-stx-mark*!) (set! Bb48@stx-subst* (lambda (Bf32@x) (simple-struct-ref Bf32@x '2))) (set! B27e4@Bb48@stx-subst* Bb48@stx-subst*) (set! Bb4a@set-stx-subst*! (lambda (Bf34@x Bf35@val) (simple-struct-set! Bf34@x '2 Bf35@val))) (set! B27e5@Bb4a@set-stx-subst*! Bb4a@set-stx-subst*!) (set! Bb4c@stx-ae* (lambda (Bf38@x) (simple-struct-ref Bf38@x '3))) (set! B27e6@Bb4c@stx-ae* Bb4c@stx-ae*) (set! Bb4e@set-stx-ae*! (lambda (Bf3a@x Bf3b@val) (simple-struct-set! Bf3a@x '3 Bf3b@val))) (set! B27e7@Bb4e@set-stx-ae*! Bb4e@set-stx-ae*!) (set! Bb50@dummy '3) (set! B27e8@Bb50@dummy Bb50@dummy) (set! Bb52@datum->stx (lambda (Bf3e@id Bf3f@datum) (make-simple-struct 'stx '5 (list Bf3f@datum (Bb44@stx-mark* Bf3e@id) (Bb48@stx-subst* Bf3e@id) (Bb4c@stx-ae* Bf3e@id))))) (set! B27e9@Bb52@datum->stx Bb52@datum->stx) (set! Bb54@gen-mark (lambda () (string '#\m))) (set! B27ea@Bb54@gen-mark Bb54@gen-mark) (set! Bb56@anti-mark '#f) (set! B27eb@Bb56@anti-mark Bb56@anti-mark) (set! Bb58@anti-mark? not) (set! B27ec@Bb58@anti-mark? Bb58@anti-mark?) (set! Bb5a@mkstx (lambda (Bf42@e Bf43@m* Bf44@s* Bf45@ae*) (if (and (Bb3e@stx? Bf42@e) (not (Baf8@top-marked? Bf43@m*))) (call-with-values (lambda () (join-wraps Bf43@m* Bf44@s* Bf45@ae* Bf42@e)) (lambda (Bf50@Bf4b Bf51@Bf4d Bf52@Bf4f) (let ((Bf56@ae* Bf52@Bf4f) (Bf57@s* Bf51@Bf4d) (Bf58@m* Bf50@Bf4b)) (make-simple-struct 'stx '5 (list (Bb40@stx-expr Bf42@e) Bf58@m* Bf57@s* Bf56@ae*))))) (make-simple-struct 'stx '5 (list Bf42@e Bf43@m* Bf44@s* Bf45@ae*))))) (set! B27ed@Bb5a@mkstx Bb5a@mkstx) (set! Bb5c@add-mark (lambda (Bf5c@m Bf5d@e Bf5e@ae) (Bb5a@mkstx Bf5d@e (list Bf5c@m) '(shift) (list Bf5e@ae)))) (set! B27ee@Bb5c@add-mark Bb5c@add-mark) (set! Bb5e@add-subst (lambda (Bf62@subst Bf63@e) (Bb5a@mkstx Bf63@e '() (list Bf62@subst) '()))) (set! B27ef@Bb5e@add-subst Bb5e@add-subst) (set! Bb60@syntax-kind? (lambda (Bf66@x Bf67@p?) (if (Bb3e@stx? Bf66@x) (Bb60@syntax-kind? (Bb40@stx-expr Bf66@x) Bf67@p?) (if (B6b6@B588@annotation? Bf66@x) (Bb60@syntax-kind? (B6b8@B58c@annotation-expression Bf66@x) Bf67@p?) (Bf67@p? Bf66@x))))) (set! B27f0@Bb60@syntax-kind? Bb60@syntax-kind?) (set! Bb62@syntax-vector->list (lambda (Bf6a@x) (if (Bb3e@stx? Bf6a@x) (let ((Bf6c@ls (Bb62@syntax-vector->list (Bb40@stx-expr Bf6a@x))) (Bf6d@m* (Bb44@stx-mark* Bf6a@x)) (Bf6e@s* (Bb48@stx-subst* Bf6a@x)) (Bf6f@ae* (Bb4c@stx-ae* Bf6a@x))) (map (lambda (Bf74@x) (Bb5a@mkstx Bf74@x Bf6d@m* Bf6e@s* Bf6f@ae*)) Bf6c@ls)) (if (B6b6@B588@annotation? Bf6a@x) (Bb62@syntax-vector->list (B6b8@B58c@annotation-expression Bf6a@x)) (if (vector? Bf6a@x) (vector->list Bf6a@x) (assertion-violation 'syntax-vector->list '"BUG: not a syntax vector" Bf6a@x)))))) (set! B27f1@Bb62@syntax-vector->list Bb62@syntax-vector->list) (set! Bb64@syntax-pair? (lambda (Bf76@x) (Bb60@syntax-kind? Bf76@x pair?))) (set! B27f2@Bb64@syntax-pair? Bb64@syntax-pair?) (set! Bb66@syntax-vector? (lambda (Bf78@x) (Bb60@syntax-kind? Bf78@x vector?))) (set! B27f3@Bb66@syntax-vector? Bb66@syntax-vector?) (set! Bb68@syntax-null? (lambda (Bf7a@x) (Bb60@syntax-kind? Bf7a@x null?))) (set! B27f4@Bb68@syntax-null? Bb68@syntax-null?) (set! Bb6a@syntax-list? (lambda (Bf7c@x) (or (Bb68@syntax-null? Bf7c@x) (and (Bb64@syntax-pair? Bf7c@x) (Bb6a@syntax-list? (Bb6e@syntax-cdr Bf7c@x)))))) (set! B27f5@Bb6a@syntax-list? Bb6a@syntax-list?) (set! Bb6c@syntax-car (lambda (Bf7e@x) (if (Bb3e@stx? Bf7e@x) (Bb5a@mkstx (Bb6c@syntax-car (Bb40@stx-expr Bf7e@x)) (Bb44@stx-mark* Bf7e@x) (Bb48@stx-subst* Bf7e@x) (Bb4c@stx-ae* Bf7e@x)) (if (B6b6@B588@annotation? Bf7e@x) (Bb6c@syntax-car (B6b8@B58c@annotation-expression Bf7e@x)) (if (pair? Bf7e@x) (car Bf7e@x) (assertion-violation 'syntax-car '"BUG: not a pair" Bf7e@x)))))) (set! B27f6@Bb6c@syntax-car Bb6c@syntax-car) (set! Bb6e@syntax-cdr (lambda (Bf80@x) (if (Bb3e@stx? Bf80@x) (Bb5a@mkstx (Bb6e@syntax-cdr (Bb40@stx-expr Bf80@x)) (Bb44@stx-mark* Bf80@x) (Bb48@stx-subst* Bf80@x) (Bb4c@stx-ae* Bf80@x)) (if (B6b6@B588@annotation? Bf80@x) (Bb6e@syntax-cdr (B6b8@B58c@annotation-expression Bf80@x)) (if (pair? Bf80@x) (cdr Bf80@x) (assertion-violation 'syntax-cdr '"BUG: not a pair" Bf80@x)))))) (set! B27f7@Bb6e@syntax-cdr Bb6e@syntax-cdr) (set! Bb70@syntax->list (lambda (Bf82@x) (if (Bb64@syntax-pair? Bf82@x) (cons (Bb6c@syntax-car Bf82@x) (Bb70@syntax->list (Bb6e@syntax-cdr Bf82@x))) (if (Bb68@syntax-null? Bf82@x) '() (assertion-violation 'syntax->list '"BUG: invalid argument" Bf82@x))))) (set! B27f8@Bb70@syntax->list Bb70@syntax->list) (set! Bb72@id? (lambda (Bf84@x) (and (Bb3e@stx? Bf84@x) (symbol? (Bb40@stx-expr Bf84@x))))) (set! B27f9@Bb72@id? Bb72@id?) (set! Bb74@id->sym (lambda (Bf86@x) (Bb40@stx-expr Bf86@x))) (set! B27fa@Bb74@id->sym Bb74@id->sym) (set! Bb76@bound-id=? (lambda (Bf88@x Bf89@y) (and (eq? (Bb74@id->sym Bf88@x) (Bb74@id->sym Bf89@y)) (same-marks? (Bb44@stx-mark* Bf88@x) (Bb44@stx-mark* Bf89@y))))) (set! B27fb@Bb76@bound-id=? Bb76@bound-id=?) (set! Bb78@free-id=? (lambda (Bf8c@i Bf8d@j) (let ((Bf90@t0 (id->real-label Bf8c@i)) (Bf91@t1 (id->real-label Bf8d@j))) (if (or Bf90@t0 Bf91@t1) (eq? Bf90@t0 Bf91@t1) (eq? (Bb74@id->sym Bf8c@i) (Bb74@id->sym Bf8d@j)))))) (set! B27fc@Bb78@free-id=? Bb78@free-id=?) (set! Bb7a@valid-bound-ids? (lambda (Bf94@id*) (and (for-all Bb72@id? Bf94@id*) (Bb7c@distinct-bound-ids? Bf94@id*)))) (set! B27fd@Bb7a@valid-bound-ids? Bb7a@valid-bound-ids?) (set! Bb7c@distinct-bound-ids? (lambda (Bf96@id*) (or (null? Bf96@id*) (and (not (Bb7e@bound-id-member? (car Bf96@id*) (cdr Bf96@id*))) (Bb7c@distinct-bound-ids? (cdr Bf96@id*)))))) (set! B27fe@Bb7c@distinct-bound-ids? Bb7c@distinct-bound-ids?) (set! Bb7e@bound-id-member? (lambda (Bf98@id Bf99@id*) (and (pair? Bf99@id*) (or (Bb76@bound-id=? Bf98@id (car Bf99@id*)) (Bb7e@bound-id-member? Bf98@id (cdr Bf99@id*)))))) (set! B27ff@Bb7e@bound-id-member? Bb7e@bound-id-member?) (set! Bb80@self-evaluating? (lambda (Bf9c@x) (or (number? Bf9c@x) (string? Bf9c@x) (char? Bf9c@x) (boolean? Bf9c@x) (regexp? Bf9c@x) (bytevector? Bf9c@x)))) (set! B2800@Bb80@self-evaluating? Bb80@self-evaluating?) (set! Bb82@strip-annotations (lambda (Bf9e@x) (if (pair? Bf9e@x) (cons (Bb82@strip-annotations (car Bf9e@x)) (Bb82@strip-annotations (cdr Bf9e@x))) (if (vector? Bf9e@x) (vector-map Bb82@strip-annotations Bf9e@x) (if (B6b6@B588@annotation? Bf9e@x) (B6b5@B586@annotation-stripped Bf9e@x) Bf9e@x))))) (set! B2801@Bb82@strip-annotations Bb82@strip-annotations) (set! Bb84@strip (lambda (Bfa0@x Bfa1@m*) (if (Baf8@top-marked? Bfa1@m*) (if (or (B6b6@B588@annotation? Bfa0@x) (and (pair? Bfa0@x) (B6b6@B588@annotation? (car Bfa0@x))) (and (vector? Bfa0@x) (> (vector-length Bfa0@x) '0) (B6b6@B588@annotation? (vector-ref Bfa0@x '0)))) (Bb82@strip-annotations Bfa0@x) Bfa0@x) (let Bfa6@f ((Bfa4@x Bfa0@x)) (if (Bb3e@stx? Bfa4@x) (begin (if (pair? (Bb40@stx-expr Bfa4@x)) (begin (set-source-info! (Bb40@stx-expr Bfa4@x) '#f) (set-source-info! (cdr (Bb40@stx-expr Bfa4@x)) '#f) (set-source-info! (car (Bb40@stx-expr Bfa4@x)) '#f)) (void)) (Bb84@strip (Bb40@stx-expr Bfa4@x) (Bb44@stx-mark* Bfa4@x))) (if (B6b6@B588@annotation? Bfa4@x) (B6b5@B586@annotation-stripped Bfa4@x) (if (pair? Bfa4@x) (let ((Bfa8@a (Bfa6@f (car Bfa4@x))) (Bfa9@d (Bfa6@f (cdr Bfa4@x)))) (if (and (eq? Bfa8@a (car Bfa4@x)) (eq? Bfa9@d (cdr Bfa4@x))) Bfa4@x (cons Bfa8@a Bfa9@d))) (if (vector? Bfa4@x) (let ((Bfac@old (vector->list Bfa4@x))) (let ((Bfae@new (map Bfa6@f Bfac@old))) (if (for-all eq? Bfac@old Bfae@new) Bfa4@x (list->vector Bfae@new)))) Bfa4@x)))))))) (set! B2802@Bb84@strip Bb84@strip) (set! Bb86@stx->datum (lambda (Bfb0@x) (Bb84@strip Bfb0@x '()))) (set! B2803@Bb86@stx->datum Bb86@stx->datum) (set! Bb88@id->label (lambda (Bfb2@id) (or (id->real-label Bfb2@id) (let ((Bfb4@t (Be69@top-level-context))) (if Bfb4@t ((lambda (Bfb6@env) (let ((Bfb8@rib (Be19@interaction-env-rib Bfb6@env))) (call-with-values (lambda () (Bb02@gen-define-label+loc Bfb2@id Bfb8@rib)) (lambda (Bfbe@Bfbb Bfbf@Bfbd) (let ((Bfc2@loc_ Bfbf@Bfbd) (Bfc3@lab Bfbe@Bfbb)) (begin (Bb28@extend-rib! Bfb8@rib Bfb2@id Bfc3@lab) Bfc3@lab)))))) Bfb4@t) '#f))))) (set! B2804@Bb88@id->label Bb88@id->label) (set! Bb8a@label->binding (lambda (Bfc6@x Bfc7@r) (let ((Bfca@t (B98d@B7da@imported-label->binding Bfc6@x))) (if Bfca@t ((lambda (Bfcc@b) (if (and (pair? Bfcc@b) (eq? (car Bfcc@b) '$core-rtd)) (cons '$rtd (map Bd2f@bless (cdr Bfcc@b))) (if (and (pair? Bfcc@b) (eq? (car Bfcc@b) 'global-rtd)) (let ((Bfce@lib (cadr Bfcc@b)) (Bfcf@loc (cddr Bfcc@b))) (cons '$rtd (symbol-value Bfcf@loc))) Bfcc@b))) Bfca@t) (let ((Bfd2@t (assq Bfc6@x Bfc7@r))) (if Bfd2@t (cdr Bfd2@t) (let ((Bfd4@t (Be69@top-level-context))) (if Bfd4@t ((lambda (Bfd6@env) (let ((Bfd8@t (assq Bfc6@x (Be21@interaction-env-locs Bfd6@env)))) (if Bfd8@t ((lambda (Bfda@p) (cons* 'lexical (cdr Bfda@p) '#f)) Bfd8@t) '(displaced-lexical . #f)))) Bfd4@t) '(displaced-lexical . #f))))))))) (set! B2805@Bb8a@label->binding Bb8a@label->binding) (set! Bb8c@make-binding cons) (set! B2806@Bb8c@make-binding Bb8c@make-binding) (set! Bb8e@binding-type car) (set! B2807@Bb8e@binding-type Bb8e@binding-type) (set! Bb90@binding-value cdr) (set! B2808@Bb90@binding-value Bb90@binding-value) (set! Bb92@raise-unbound-error (lambda (Bfdc@id) (Be57@syntax-violation* '#f '"unbound identifier" Bfdc@id (make-undefined-violation)))) (set! B2809@Bb92@raise-unbound-error Bb92@raise-unbound-error) (set! Bb94@syntax-type (lambda (Bfde@e Bfdf@r) (if (Bb72@id? Bfde@e) (let ((Bfe2@id Bfde@e)) (let ((Bfe4@label (Bb88@id->label Bfe2@id))) (let ((Bfe6@b (Bb8a@label->binding Bfe4@label Bfdf@r))) (let ((Bfe8@type (Bb8e@binding-type Bfe6@b))) (begin (if (not Bfe4@label) (Bb92@raise-unbound-error Bfe2@id) (void)) (let ((Bfea@t Bfe8@type)) (if (memv Bfea@t '(lexical core-prim macro macro! global local-macro local-macro! global-macro global-macro! displaced-lexical syntax import export $module $core-rtd library mutable)) (values Bfe8@type (Bb90@binding-value Bfe6@b) Bfe2@id) (values 'other '#f '#f)))))))) (if (Bb64@syntax-pair? Bfde@e) (let ((Bfec@id (Bb6c@syntax-car Bfde@e))) (if (Bb72@id? Bfec@id) (let ((Bfee@label (Bb88@id->label Bfec@id))) (let ((Bff0@b (Bb8a@label->binding Bfee@label Bfdf@r))) (let ((Bff2@type (Bb8e@binding-type Bff0@b))) (begin (if (not Bfee@label) (Bb92@raise-unbound-error Bfec@id) (void)) (let ((Bff4@t Bff2@type)) (if (memv Bff4@t '(define define-syntax core-macro begin macro macro! local-macro local-macro! global-macro global-macro! module library set! let-syntax letrec-syntax import export $core-rtd)) (values Bff2@type (Bb90@binding-value Bff0@b) Bfec@id) (values 'call '#f '#f))))))) (values 'call '#f '#f))) (let ((Bff6@d (Bb86@stx->datum Bfde@e))) (if (Bb80@self-evaluating? Bff6@d) (values 'constant Bff6@d '#f) (values 'other '#f '#f))))))) (set! B280a@Bb94@syntax-type Bb94@syntax-type) (set! Bba2@sanitize-binding (lambda (Bff8@x Bff9@src) (if (procedure? Bff8@x) (cons* 'local-macro Bff8@x Bff9@src) (if (and (pair? Bff8@x) (eq? (car Bff8@x) 'macro!) (procedure? (cdr Bff8@x))) (cons* 'local-macro! (cdr Bff8@x) Bff9@src) (if (and (pair? Bff8@x) (eq? (car Bff8@x) '$rtd)) Bff8@x (assertion-violation 'expand '"invalid transformer" Bff8@x)))))) (set! B280b@Bba2@sanitize-binding Bba2@sanitize-binding) (set! Bba4@make-variable-transformer (lambda (Bffc@x) (if (procedure? Bffc@x) (cons 'macro! Bffc@x) (assertion-violation 'make-variable-transformer '"not a procedure" Bffc@x)))) (set! B280c@Bba4@make-variable-transformer Bba4@make-variable-transformer) (set! Bba6@variable-transformer? (lambda (Bffe@x) (and (pair? Bffe@x) (eq? (car Bffe@x) 'macro!) (procedure? (cdr Bffe@x))))) (set! B280d@Bba6@variable-transformer? Bba6@variable-transformer?) (set! Bba8@variable-transformer-procedure (lambda (B1000@x) (if (Bba6@variable-transformer? B1000@x) (cdr B1000@x) (assertion-violation 'variable-transformer-procedure '"not a variable transformer" B1000@x)))) (set! B280e@Bba8@variable-transformer-procedure Bba8@variable-transformer-procedure) (set! Bbaa@make-eval-transformer (lambda (B1002@x) (Bba2@sanitize-binding (eval-core (B718@B6d0@expanded->core B1002@x)) B1002@x))) (set! B280f@Bbaa@make-eval-transformer Bbaa@make-eval-transformer) (set! Bcfb@parse-define (lambda (B1004@x) (let ((B1006@t B1004@x)) (let ((B1008@ls/false (Bd79@syntax-dispatch B1006@t '(_ (any . any) any . each-any)))) (if (and B1008@ls/false (apply (lambda (B100a@id B100b@fmls B100c@b B100d@b*) (Bb72@id? B100a@id)) B1008@ls/false)) (apply (lambda (B1012@id B1013@fmls B1014@b B1015@b*) (begin (Bd9f@verify-formals B1013@fmls B1004@x) (values B1012@id (cons 'defun (cons B1013@fmls (cons B1014@b B1015@b*)))))) B1008@ls/false) (let ((B101a@t B1006@t)) (let ((B101c@ls/false (Bd79@syntax-dispatch B101a@t '(_ any any)))) (if (and B101c@ls/false (apply (lambda (B101e@id B101f@val) (Bb72@id? B101e@id)) B101c@ls/false)) (apply (lambda (B1022@id B1023@val) (values B1022@id (cons 'expr B1023@val))) B101c@ls/false) (let ((B1026@t B101a@t)) (let ((B1028@ls/false (Bd79@syntax-dispatch B1026@t '(_ any)))) (if (and B1028@ls/false (apply (lambda (B102a@id) (Bb72@id? B102a@id)) B1028@ls/false)) (apply (lambda (B102c@id) (values B102c@id (cons 'expr (Bd2f@bless '(void))))) B1028@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1026@t)))))))))))) (set! B2810@Bcfb@parse-define Bcfb@parse-define) (set! Bcfd@parse-define-syntax (lambda (B102e@x) (let ((B1030@t B102e@x)) (let ((B1032@ls/false (Bd79@syntax-dispatch B1030@t '(_ any any)))) (if (and B1032@ls/false (apply (lambda (B1034@id B1035@val) (Bb72@id? B1034@id)) B1032@ls/false)) (apply (lambda (B1038@id B1039@val) (values B1038@id B1039@val)) B1032@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1030@t)))))) (set! B2811@Bcfd@parse-define-syntax Bcfd@parse-define-syntax) (set! Bcff@scheme-stx-hashtable (make-eq-hashtable)) (set! B2812@Bcff@scheme-stx-hashtable Bcff@scheme-stx-hashtable) (set! Bd01@scheme-stx (lambda (B103c@sym) (or (hashtable-ref Bcff@scheme-stx-hashtable B103c@sym '#f) (let ((B103e@subst (B969@B792@library-subst (B987@B7ce@find-library-by-name '(psyntax system $all))))) (let ((B1040@stx (make-simple-struct 'stx '5 (list B103c@sym Baf6@top-mark* '() '())))) (let ((B1042@stx (let ((B1044@t (assq B103c@sym B103e@subst))) (if B1044@t ((lambda (B1046@x) (let ((B1048@name (car B1046@x)) (B1049@label (cdr B1046@x))) (Bb5e@add-subst (make-simple-struct 'rib '6 (list (list B1048@name) (list Baf6@top-mark*) (list B1049@label) '#f '#f)) B1040@stx))) B1044@t) B1040@stx)))) (begin (hashtable-set! Bcff@scheme-stx-hashtable B103c@sym B1042@stx) B1042@stx))))))) (set! B2813@Bd01@scheme-stx Bd01@scheme-stx) (set! Bd03@lexical-var car) (set! B2814@Bd03@lexical-var Bd03@lexical-var) (set! Bd05@lexical-mutable? cdr) (set! B2815@Bd05@lexical-mutable? Bd05@lexical-mutable?) (set! Bd07@set-lexical-mutable! set-cdr!) (set! B2816@Bd07@set-lexical-mutable! Bd07@set-lexical-mutable!) (set! Bd09@add-lexical (lambda (B104c@lab B104d@lex B104e@r) (cons (cons* B104c@lab 'lexical B104d@lex '#f) B104e@r))) (set! B2817@Bd09@add-lexical Bd09@add-lexical) (set! Bd0b@add-lexicals (lambda (B1052@lab* B1053@lex* B1054@r) (if (null? B1052@lab*) B1054@r (Bd0b@add-lexicals (cdr B1052@lab*) (cdr B1053@lex*) (Bd09@add-lexical (car B1052@lab*) (car B1053@lex*) B1054@r))))) (set! B2818@Bd0b@add-lexicals Bd0b@add-lexicals) (set! Bd0d@letrec-helper (lambda (B1058@e B1059@r B105a@mr B105b@build) (let ((B1060@t B1058@e)) (let ((B1062@ls/false (Bd79@syntax-dispatch B1060@t '(_ #(each (any any)) any . each-any)))) (if B1062@ls/false (apply (lambda (B1064@lhs* B1065@rhs* B1066@b B1067@b*) (if (not (Bb7a@valid-bound-ids? B1064@lhs*)) (Bd33@invalid-fmls-error B1058@e B1064@lhs*) (let ((B106c@lex* (map Bafa@gen-lexical B1064@lhs*)) (B106d@lab* (map Bafe@gen-label B1064@lhs*))) (let ((B1070@rib (Bb32@make-full-rib B1064@lhs* B106d@lab*)) (B1071@r (Bd0b@add-lexicals B106d@lab* B106c@lex* B1059@r))) (let ((B1074@body (Bdb1@chi-internal (Bb5e@add-subst B1070@rib (cons B1066@b B1067@b*)) B1071@r B105a@mr)) (B1075@rhs* (Bd97@chi-expr* (map (lambda (B1078@x) (Bb5e@add-subst B1070@rib B1078@x)) B1065@rhs*) B1071@r B105a@mr))) (B105b@build '#f B106c@lex* B1075@rhs* B1074@body)))))) B1062@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1060@t)))))) (set! B2819@Bd0d@letrec-helper Bd0d@letrec-helper) (set! Bd0f@let-transformer (lambda (B107a@e B107b@r B107c@mr) (let ((B1080@t B107a@e)) (let ((B1082@ls/false (Bd79@syntax-dispatch B1080@t '(_ #(each (any any)) any . each-any)))) (if B1082@ls/false (apply (lambda (B1084@lhs* B1085@rhs* B1086@b B1087@b*) (if (not (Bb7a@valid-bound-ids? B1084@lhs*)) (Bd33@invalid-fmls-error B107a@e B1084@lhs*) (let ((B108c@lex* (map Bafa@gen-lexical B1084@lhs*)) (B108d@lab* (map Bafe@gen-label B1084@lhs*)) (B108e@rhs* (Bd97@chi-expr* B1085@rhs* B107b@r B107c@mr))) (let ((B1092@rib (Bb32@make-full-rib B1084@lhs* B108d@lab*)) (B1093@r (Bd0b@add-lexicals B108d@lab* B108c@lex* B107b@r))) (let ((B1096@body (Bdb1@chi-internal (Bb5e@add-subst B1092@rib (cons B1086@b B1087@b*)) B1093@r B107c@mr))) (Bada@Ba3d@build-let '#f B108c@lex* B108e@rhs* B1096@body)))))) B1082@ls/false) (let ((B1098@t B1080@t)) (let ((B109a@ls/false (Bd79@syntax-dispatch B1098@t '(_ any #(each (any any)) any . each-any)))) (if B109a@ls/false (apply (lambda (B109c@loop B109d@lhs* B109e@rhs* B109f@b B10a0@b*) (if (not (Bb7a@valid-bound-ids? B109d@lhs*)) (Bd33@invalid-fmls-error B107a@e B109d@lhs*) (let ((B10a6@lex* (map Bafa@gen-lexical B109d@lhs*)) (B10a7@lab* (map Bafe@gen-label B109d@lhs*)) (B10a8@rhs* (Bd97@chi-expr* B109e@rhs* B107b@r B107c@mr)) (B10a9@loop-lex (Bafa@gen-lexical B109c@loop)) (B10aa@loop-lab (Bafe@gen-label B109c@loop))) (let ((B10b0@loop-rib (Bb32@make-full-rib (list B109c@loop) (list B10aa@loop-lab))) (B10b1@rib (Bb32@make-full-rib B109d@lhs* B10a7@lab*)) (B10b2@r (Bd0b@add-lexicals (cons B10aa@loop-lab B10a7@lab*) (cons B10a9@loop-lex B10a6@lex*) B107b@r))) (let ((B10b6@body (Bdb1@chi-internal (Bb5e@add-subst B10b0@loop-rib (Bb5e@add-subst B10b1@rib (cons B109f@b B10a0@b*))) B10b2@r B107c@mr))) (Badb@Ba3f@build-named-let '#f B10a9@loop-lex B10a6@lex* B10a8@rhs* B10b6@body)))))) B109a@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1098@t))))))))) (set! B281a@Bd0f@let-transformer Bd0f@let-transformer) (set! Bd11@letrec-transformer (lambda (B10b8@e B10b9@r B10ba@mr) (Bd0d@letrec-helper B10b8@e B10b9@r B10ba@mr Bad9@Ba3b@build-letrec))) (set! B281b@Bd11@letrec-transformer Bd11@letrec-transformer) (set! Bd13@letrec*-transformer (lambda (B10be@e B10bf@r B10c0@mr) (Bd0d@letrec-helper B10be@e B10bf@r B10c0@mr Badc@Ba41@build-letrec*))) (set! B281c@Bd13@letrec*-transformer Bd13@letrec*-transformer) (set! Bd15@fluid-let-syntax-transformer (lambda (B10c4@e B10c5@r B10c6@mr) (letrec* ((B10cb@lookup (lambda (B10de@x) (or (Bb88@id->label B10de@x) (Be59@syntax-violation '#f '"unbound identifier" B10c4@e B10de@x))))) (let ((B10cc@t B10c4@e)) (let ((B10ce@ls/false (Bd79@syntax-dispatch B10cc@t '(_ #(each (any any)) any . each-any)))) (if B10ce@ls/false (apply (lambda (B10d0@lhs* B10d1@rhs* B10d2@b B10d3@b*) (if (not (Bb7a@valid-bound-ids? B10d0@lhs*)) (Bd33@invalid-fmls-error B10c4@e B10d0@lhs*) (let ((B10d8@lab* (map B10cb@lookup B10d0@lhs*)) (B10d9@rhs* (map (lambda (B10dc@x) (Bbaa@make-eval-transformer (Bdd3@expand-transformer B10dc@x B10c6@mr))) B10d1@rhs*))) (Bdb1@chi-internal (cons B10d2@b B10d3@b*) (append (map cons B10d8@lab* B10d9@rhs*) B10c5@r) (append (map cons B10d8@lab* B10d9@rhs*) B10c6@mr))))) B10ce@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B10cc@t))))))) (set! B281d@Bd15@fluid-let-syntax-transformer Bd15@fluid-let-syntax-transformer) (set! Bd17@type-descriptor-transformer (lambda (B10e0@e B10e1@r B10e2@mr) (let ((B10e6@t B10e0@e)) (let ((B10e8@ls/false (Bd79@syntax-dispatch B10e6@t '(_ any)))) (if (and B10e8@ls/false (apply (lambda (B10ea@id) (Bb72@id? B10ea@id)) B10e8@ls/false)) (apply (lambda (B10ec@id) (let ((B10ee@lab (Bb88@id->label B10ec@id))) (let ((B10f0@b (Bb8a@label->binding B10ee@lab B10e1@r))) (let ((B10f2@type (Bb8e@binding-type B10f0@b))) (begin (if (not B10ee@lab) (Bb92@raise-unbound-error B10ec@id) (void)) (if (not (and (eq? B10f2@type '$rtd) (not (list? (Bb90@binding-value B10f0@b))))) (Be59@syntax-violation '#f '"not a record type" B10e0@e) (void)) (list 'quote (Bb90@binding-value B10f0@b))))))) B10e8@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B10e6@t)))))) (set! B281e@Bd17@type-descriptor-transformer Bd17@type-descriptor-transformer) (set! Bd19@record-type-descriptor-transformer (lambda (B10f4@e B10f5@r B10f6@mr) (let ((B10fa@t B10f4@e)) (let ((B10fc@ls/false (Bd79@syntax-dispatch B10fa@t '(_ any)))) (if (and B10fc@ls/false (apply (lambda (B10fe@id) (Bb72@id? B10fe@id)) B10fc@ls/false)) (apply (lambda (B1100@id) (let ((B1102@lab (Bb88@id->label B1100@id))) (let ((B1104@b (Bb8a@label->binding B1102@lab B10f5@r))) (let ((B1106@type (Bb8e@binding-type B1104@b))) (begin (if (not B1102@lab) (Bb92@raise-unbound-error B1100@id) (void)) (if (not (and (eq? B1106@type '$rtd) (list? (Bb90@binding-value B1104@b)))) (Be59@syntax-violation '#f '"not a record type" B10f4@e) (void)) (Bd9b@chi-expr (car (Bb90@binding-value B1104@b)) B10f5@r B10f6@mr)))))) B10fc@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B10fa@t)))))) (set! B281f@Bd19@record-type-descriptor-transformer Bd19@record-type-descriptor-transformer) (set! Bd1b@record-constructor-descriptor-transformer (lambda (B1108@e B1109@r B110a@mr) (let ((B110e@t B1108@e)) (let ((B1110@ls/false (Bd79@syntax-dispatch B110e@t '(_ any)))) (if (and B1110@ls/false (apply (lambda (B1112@id) (Bb72@id? B1112@id)) B1110@ls/false)) (apply (lambda (B1114@id) (let ((B1116@lab (Bb88@id->label B1114@id))) (let ((B1118@b (Bb8a@label->binding B1116@lab B1109@r))) (let ((B111a@type (Bb8e@binding-type B1118@b))) (begin (if (not B1116@lab) (Bb92@raise-unbound-error B1114@id) (void)) (if (not (and (eq? B111a@type '$rtd) (list? (Bb90@binding-value B1118@b)))) (Be59@syntax-violation '#f '"invalid type" B1108@e) (void)) (Bd9b@chi-expr (cadr (Bb90@binding-value B1118@b)) B1109@r B110a@mr)))))) B1110@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B110e@t)))))) (set! B2820@Bd1b@record-constructor-descriptor-transformer Bd1b@record-constructor-descriptor-transformer) (set! Bd1d@when-macro (lambda (B111c@e) (let ((B111e@t B111c@e)) (let ((B1120@ls/false (Bd79@syntax-dispatch B111e@t '(_ any any . each-any)))) (if B1120@ls/false (apply (lambda (B1122@test B1123@e B1124@e*) (Bd2f@bless (list 'if B1122@test (cons 'begin (cons B1123@e B1124@e*))))) B1120@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B111e@t)))))) (set! B2821@Bd1d@when-macro Bd1d@when-macro) (set! Bd1f@unless-macro (lambda (B1128@e) (let ((B112a@t B1128@e)) (let ((B112c@ls/false (Bd79@syntax-dispatch B112a@t '(_ any any . each-any)))) (if B112c@ls/false (apply (lambda (B112e@test B112f@e B1130@e*) (Bd2f@bless (list 'if (list 'not B112e@test) (cons 'begin (cons B112f@e B1130@e*))))) B112c@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B112a@t)))))) (set! B2822@Bd1f@unless-macro Bd1f@unless-macro) (set! Bd21@if-transformer (lambda (B1134@e B1135@r B1136@mr) (let ((B113a@t B1134@e)) (let ((B113c@ls/false (Bd79@syntax-dispatch B113a@t '(_ any any any)))) (if B113c@ls/false (apply (lambda (B113e@e0 B113f@e1 B1140@e2) (list 'if (Bd9b@chi-expr B113e@e0 B1135@r B1136@mr) (Bd9b@chi-expr B113f@e1 B1135@r B1136@mr) (Bd9b@chi-expr B1140@e2 B1135@r B1136@mr))) B113c@ls/false) (let ((B1144@t B113a@t)) (let ((B1146@ls/false (Bd79@syntax-dispatch B1144@t '(_ any any)))) (if B1146@ls/false (apply (lambda (B1148@e0 B1149@e1) (list 'if (Bd9b@chi-expr B1148@e0 B1135@r B1136@mr) (Bd9b@chi-expr B1149@e1 B1135@r B1136@mr) (Bad8@Ba39@build-void))) B1146@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1144@t))))))))) (set! B2823@Bd21@if-transformer Bd21@if-transformer) (set! Bd23@and-transformer (lambda (B114c@e B114d@r B114e@mr) (let ((B1152@t B114c@e)) (let ((B1154@ls/false (Bd79@syntax-dispatch B1152@t '(_ . each-any)))) (if B1154@ls/false (apply (lambda (B1156@e*) (cons 'and (Bd97@chi-expr* B1156@e* B114d@r B114e@mr))) B1154@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1152@t)))))) (set! B2824@Bd23@and-transformer Bd23@and-transformer) (set! Bd25@or-transformer (lambda (B1158@e B1159@r B115a@mr) (let ((B115e@t B1158@e)) (let ((B1160@ls/false (Bd79@syntax-dispatch B115e@t '(_ . each-any)))) (if B1160@ls/false (apply (lambda (B1162@e*) (cons 'or (Bd97@chi-expr* B1162@e* B1159@r B115a@mr))) B1160@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B115e@t)))))) (set! B2825@Bd25@or-transformer Bd25@or-transformer) (set! Bd27@case-macro (lambda (B1164@e) (letrec* ((B1167@build-last (lambda (B118e@cls) (let ((B1190@t B118e@cls)) (let ((B1192@ls/false (Bd79@syntax-dispatch B1190@t '(#(scheme-id else) any . each-any)))) (if B1192@ls/false (apply (lambda (B1194@e B1195@e*) (cons 'begin (cons B1194@e B1195@e*))) B1192@ls/false) (let ((B1198@t B1190@t)) (let ((B119a@ls/false (Bd79@syntax-dispatch B1198@t '_))) (if B119a@ls/false (apply (lambda () (B1169@build-one B118e@cls '(if #f #f))) B119a@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1198@t))))))))) (B1169@build-one (lambda (B1180@cls B1181@k) (let ((B1184@t B1180@cls)) (let ((B1186@ls/false (Bd79@syntax-dispatch B1184@t '(each-any any . each-any)))) (if B1186@ls/false (apply (lambda (B1188@d* B1189@e B118a@e*) (list 'if (list 'memv 't (list 'quote B1188@d*)) (cons 'begin (cons B1189@e B118a@e*)) B1181@k)) B1186@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1184@t))))))) (let ((B116a@t B1164@e)) (let ((B116c@ls/false (Bd79@syntax-dispatch B116a@t '(_ any)))) (if B116c@ls/false (apply (lambda (B116e@expr) (Bd2f@bless (cons 'let (cons (list (list 't B116e@expr)) '((if #f #f)))))) B116c@ls/false) (let ((B1170@t B116a@t)) (let ((B1172@ls/false (Bd79@syntax-dispatch B1170@t '(_ any any . each-any)))) (if B1172@ls/false (apply (lambda (B1174@expr B1175@cls B1176@cls*) (Bd2f@bless (list 'let (list (list 't B1174@expr)) (let B117e@f ((B117a@cls B1175@cls) (B117b@cls* B1176@cls*)) (if (null? B117b@cls*) (B1167@build-last B117a@cls) (B1169@build-one B117a@cls (B117e@f (car B117b@cls*) (cdr B117b@cls*)))))))) B1172@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1170@t)))))))))) (set! B2826@Bd27@case-macro Bd27@case-macro) (set! Bd29@quote-transformer (lambda (B119c@e B119d@r B119e@mr) (let ((B11a2@t B119c@e)) (let ((B11a4@ls/false (Bd79@syntax-dispatch B11a2@t '(_ any)))) (if B11a4@ls/false (apply (lambda (B11a6@datum) (list 'quote (Bb86@stx->datum B11a6@datum))) B11a4@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B11a2@t)))))) (set! B2827@Bd29@quote-transformer Bd29@quote-transformer) (set! Bd2b@case-lambda-transformer (lambda (B11a8@e B11a9@r B11aa@mr) (let ((B11ae@t B11a8@e)) (let ((B11b0@ls/false (Bd79@syntax-dispatch B11ae@t '(_ . #(each (any any . each-any)))))) (if B11b0@ls/false (apply (lambda (B11b2@fmls* B11b3@b* B11b4@b**) (call-with-values (lambda () (Bda3@chi-lambda-clause* B11a8@e B11b2@fmls* (map cons B11b3@b* B11b4@b**) B11a9@r B11aa@mr)) (lambda (B11bc@B11b9 B11bd@B11bb) (let ((B11c0@body* B11bd@B11bb) (B11c1@fmls* B11bc@B11b9)) (Bad6@Ba09@build-case-lambda '#f B11c1@fmls* B11c0@body*))))) B11b0@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B11ae@t)))))) (set! B2828@Bd2b@case-lambda-transformer Bd2b@case-lambda-transformer) (set! Bd2d@lambda-transformer (lambda (B11c4@e B11c5@r B11c6@mr) (let ((B11ca@t B11c4@e)) (let ((B11cc@ls/false (Bd79@syntax-dispatch B11ca@t '(_ any any . each-any)))) (if B11cc@ls/false (apply (lambda (B11ce@fmls B11cf@b B11d0@b*) (call-with-values (lambda () (Bda1@chi-lambda-clause B11c4@e B11ce@fmls (cons B11cf@b B11d0@b*) B11c5@r B11c6@mr)) (lambda (B11d8@B11d5 B11d9@B11d7) (let ((B11dc@body B11d9@B11d7) (B11dd@fmls B11d8@B11d5)) (Bad5@Ba07@build-lambda '#f B11dd@fmls B11dc@body))))) B11cc@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B11ca@t)))))) (set! B2829@Bd2d@lambda-transformer Bd2d@lambda-transformer) (set! Bd2f@bless (lambda (B11e0@x) (Bb5a@mkstx (let B11e4@f ((B11e2@x B11e0@x)) (if (Bb3e@stx? B11e2@x) B11e2@x (if (pair? B11e2@x) (cons (B11e4@f (car B11e2@x)) (B11e4@f (cdr B11e2@x))) (if (symbol? B11e2@x) (Bd01@scheme-stx B11e2@x) (if (vector? B11e2@x) (vector-map B11e4@f B11e2@x) B11e2@x))))) '() '() '()))) (set! B282a@Bd2f@bless Bd2f@bless) (set! Bd31@with-syntax-macro (lambda (B11e6@e) (let ((B11e8@t B11e6@e)) (let ((B11ea@ls/false (Bd79@syntax-dispatch B11e8@t '(_ #(each (any any)) any . each-any)))) (if B11ea@ls/false (apply (lambda (B11ec@pat* B11ed@expr* B11ee@b B11ef@b*) (let ((B11f4@idn* (let B11f8@f ((B11f6@pat* B11ec@pat*)) (if (null? B11f6@pat*) '() (call-with-values (lambda () (Bd77@convert-pattern (car B11f6@pat*) '())) (lambda (B11fe@B11fb B11ff@B11fd) (let ((B1202@idn* B11ff@B11fd) (B1203@pat B11fe@B11fb)) (append B1202@idn* (B11f8@f (cdr B11f6@pat*)))))))))) (begin (Bd9f@verify-formals (map car B11f4@idn*) B11e6@e) (let ((B1206@t* (Be47@generate-temporaries B11ed@expr*))) (Bd2f@bless (list 'let (map list B1206@t* B11ed@expr*) (let B120c@f ((B1208@pat* B11ec@pat*) (B1209@t* B1206@t*)) (if (null? B1208@pat*) (cons 'begin (cons '#f (cons B11ee@b B11ef@b*))) (list 'syntax-case (car B1209@t*) '() (list (car B1208@pat*) (B120c@f (cdr B1208@pat*) (cdr B1209@t*))) (list '_ (list 'assertion-violation ''with-syntax '"pattern does not match value" (list 'quote (car B1208@pat*)) (car B1209@t*)))))))))))) B11ea@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B11e8@t)))))) (set! B282b@Bd31@with-syntax-macro Bd31@with-syntax-macro) (set! Bd33@invalid-fmls-error (lambda (B120e@stx B120f@fmls) (let ((B1212@t B120f@fmls)) (let ((B1214@ls/false (Bd79@syntax-dispatch B1212@t '#(each+ any () any)))) (if B1214@ls/false (apply (lambda (B1216@id* B1217@last) (let B121c@f ((B121a@id* (if (Bb72@id? B1217@last) (cons B1217@last B1216@id*) (if (Bb68@syntax-null? B1217@last) B1216@id* (Be59@syntax-violation '#f '"not an identifier" B120e@stx B1217@last))))) (if (null? B121a@id*) (values) (if (not (Bb72@id? (car B121a@id*))) (Be59@syntax-violation '#f '"not an identifier" B120e@stx (car B121a@id*)) (begin (B121c@f (cdr B121a@id*)) (if (Bb7e@bound-id-member? (car B121a@id*) (cdr B121a@id*)) (Be59@syntax-violation '#f '"duplicate binding" B120e@stx (car B121a@id*)) (void))))))) B1214@ls/false) (let ((B121e@t B1212@t)) (let ((B1220@ls/false (Bd79@syntax-dispatch B121e@t '_))) (if B1220@ls/false (apply (lambda () (Be59@syntax-violation '#f '"malformed binding form" B120e@stx B120f@fmls)) B1220@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B121e@t))))))))) (set! B282c@Bd33@invalid-fmls-error Bd33@invalid-fmls-error) (set! Bd35@let-macro (lambda (B1222@stx) (let ((B1224@t B1222@stx)) (let ((B1226@ls/false (Bd79@syntax-dispatch B1224@t '(_ #(each (any any)) any . each-any)))) (if B1226@ls/false (apply (lambda (B1228@lhs* B1229@rhs* B122a@b B122b@b*) (if (Bb7a@valid-bound-ids? B1228@lhs*) (Bd2f@bless (cons (cons 'lambda (cons B1228@lhs* (cons B122a@b B122b@b*))) B1229@rhs*)) (Bd33@invalid-fmls-error B1222@stx B1228@lhs*))) B1226@ls/false) (let ((B1230@t B1224@t)) (let ((B1232@ls/false (Bd79@syntax-dispatch B1230@t '(_ any #(each (any any)) any . each-any)))) (if (and B1232@ls/false (apply (lambda (B1234@f B1235@lhs* B1236@rhs* B1237@b B1238@b*) (Bb72@id? B1234@f)) B1232@ls/false)) (apply (lambda (B123e@f B123f@lhs* B1240@rhs* B1241@b B1242@b*) (if (Bb7a@valid-bound-ids? B123f@lhs*) (Bd2f@bless (cons (list 'letrec (list (list B123e@f (cons 'lambda (cons B123f@lhs* (cons B1241@b B1242@b*))))) B123e@f) B1240@rhs*)) (Bd33@invalid-fmls-error B1222@stx B123f@lhs*))) B1232@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1230@t))))))))) (set! B282d@Bd35@let-macro Bd35@let-macro) (set! Bd37@let-values-macro (lambda (B1248@stx) (letrec* ((B124b@rename (lambda (B12b0@x B12b1@old* B12b2@new*) (begin (if (not (Bb72@id? B12b0@x)) (Be59@syntax-violation '#f '"not an indentifier" B1248@stx B12b0@x) (void)) (if (Bb7e@bound-id-member? B12b0@x B12b1@old*) (Be59@syntax-violation '#f '"duplicate binding" B1248@stx B12b0@x) (void)) (let ((B12b6@y (gensym (Be5f@syntax->datum B12b0@x)))) (values B12b6@y (cons B12b0@x B12b1@old*) (cons B12b6@y B12b2@new*)))))) (B124d@rename* (lambda (B129e@x* B129f@old* B12a0@new*) (if (null? B129e@x*) (values '() B129f@old* B12a0@new*) (call-with-values (lambda () (B124b@rename (car B129e@x*) B129f@old* B12a0@new*)) (lambda (B12a4@x B12a5@old* B12a6@new*) (call-with-values (lambda () (B124d@rename* (cdr B129e@x*) B12a5@old* B12a6@new*)) (lambda (B12aa@x* B12ab@old* B12ac@new*) (values (cons B12a4@x B12aa@x*) B12ab@old* B12ac@new*))))))))) (let ((B124e@t B1248@stx)) (let ((B1250@ls/false (Bd79@syntax-dispatch B124e@t '(_ () any . each-any)))) (if B1250@ls/false (apply (lambda (B1252@b B1253@b*) (cons* (Bd2f@bless 'let) '() B1252@b B1253@b*)) B1250@ls/false) (let ((B1256@t B124e@t)) (let ((B1258@ls/false (Bd79@syntax-dispatch B1256@t '(_ #(each (any any)) any . each-any)))) (if B1258@ls/false (apply (lambda (B125a@lhs* B125b@rhs* B125c@b B125d@b*) (Bd2f@bless (let B126a@f ((B1262@lhs* B125a@lhs*) (B1263@rhs* B125b@rhs*) (B1264@old* '()) (B1265@new* '())) (if (null? B1262@lhs*) (cons 'let (cons (map list B1264@old* B1265@new*) (cons B125c@b B125d@b*))) (let ((B126c@t (car B1262@lhs*))) (let ((B126e@ls/false (Bd79@syntax-dispatch B126c@t 'each-any))) (if B126e@ls/false (apply (lambda (B1270@x*) (call-with-values (lambda () (B124d@rename* B1270@x* B1264@old* B1265@new*)) (lambda (B1278@B1273 B1279@B1275 B127a@B1277) (let ((B127e@new* B127a@B1277) (B127f@old* B1279@B1275) (B1280@y* B1278@B1273)) (list 'call-with-values (list 'lambda '() (car B1263@rhs*)) (list 'lambda B1280@y* (B126a@f (cdr B1262@lhs*) (cdr B1263@rhs*) B127f@old* B127e@new*))))))) B126e@ls/false) (let ((B1284@t B126c@t)) (let ((B1286@ls/false (Bd79@syntax-dispatch B1284@t '#(each+ any () any)))) (if B1286@ls/false (apply (lambda (B1288@x* B1289@x) (call-with-values (lambda () (B124b@rename B1289@x B1264@old* B1265@new*)) (lambda (B128c@y B128d@old* B128e@new*) (call-with-values (lambda () (B124d@rename* B1288@x* B128d@old* B128e@new*)) (lambda (B1292@y* B1293@old* B1294@new*) (list 'call-with-values (list 'lambda '() (car B1263@rhs*)) (list 'lambda (append B1292@y* B128c@y) (B126a@f (cdr B1262@lhs*) (cdr B1263@rhs*) B1293@old* B1294@new*)))))))) B1286@ls/false) (let ((B1298@t B1284@t)) (let ((B129a@ls/false (Bd79@syntax-dispatch B1298@t 'any))) (if B129a@ls/false (apply (lambda (B129c@others) (Be59@syntax-violation '#f '"malformed bindings" B1248@stx B129c@others)) B129a@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1298@t)))))))))))))) B1258@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1256@t)))))))))) (set! B282e@Bd37@let-values-macro Bd37@let-values-macro) (set! Bd39@let*-values-macro (lambda (B12b8@stx) (letrec* ((B12bb@check (lambda (B12ea@x*) (if (not (null? B12ea@x*)) (let ((B12ec@x (car B12ea@x*))) (begin (if (not (Bb72@id? B12ec@x)) (Be59@syntax-violation '#f '"not an identifier" B12b8@stx B12ec@x) (void)) (B12bb@check (cdr B12ea@x*)) (if (Bb7e@bound-id-member? B12ec@x (cdr B12ea@x*)) (Be59@syntax-violation '#f '"duplicate identifier" B12b8@stx B12ec@x) (void)))) (void))))) (let ((B12bc@t B12b8@stx)) (let ((B12be@ls/false (Bd79@syntax-dispatch B12bc@t '(_ () any . each-any)))) (if B12be@ls/false (apply (lambda (B12c0@b B12c1@b*) (cons* (Bd2f@bless 'let) '() B12c0@b B12c1@b*)) B12be@ls/false) (let ((B12c4@t B12bc@t)) (let ((B12c6@ls/false (Bd79@syntax-dispatch B12c4@t '(_ #(each (any any)) any . each-any)))) (if B12c6@ls/false (apply (lambda (B12c8@lhs* B12c9@rhs* B12ca@b B12cb@b*) (Bd2f@bless (let B12d4@f ((B12d0@lhs* B12c8@lhs*) (B12d1@rhs* B12c9@rhs*)) (if (null? B12d0@lhs*) (cons 'begin (cons B12ca@b B12cb@b*)) (let ((B12d6@t (car B12d0@lhs*))) (let ((B12d8@ls/false (Bd79@syntax-dispatch B12d6@t 'each-any))) (if B12d8@ls/false (apply (lambda (B12da@x*) (begin (B12bb@check B12da@x*) (list 'call-with-values (list 'lambda '() (car B12d1@rhs*)) (list 'lambda B12da@x* (B12d4@f (cdr B12d0@lhs*) (cdr B12d1@rhs*)))))) B12d8@ls/false) (let ((B12dc@t B12d6@t)) (let ((B12de@ls/false (Bd79@syntax-dispatch B12dc@t '#(each+ any () any)))) (if B12de@ls/false (apply (lambda (B12e0@x* B12e1@x) (begin (B12bb@check (cons B12e1@x B12e0@x*)) (list 'call-with-values (list 'lambda '() (car B12d1@rhs*)) (list 'lambda (append B12e0@x* B12e1@x) (B12d4@f (cdr B12d0@lhs*) (cdr B12d1@rhs*)))))) B12de@ls/false) (let ((B12e4@t B12dc@t)) (let ((B12e6@ls/false (Bd79@syntax-dispatch B12e4@t 'any))) (if B12e6@ls/false (apply (lambda (B12e8@others) (Be59@syntax-violation '#f '"malformed bindings" B12b8@stx B12e8@others)) B12e6@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B12e4@t)))))))))))))) B12c6@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B12c4@t)))))))))) (set! B282f@Bd39@let*-values-macro Bd39@let*-values-macro) (set! Bd3b@trace-lambda-macro (lambda (B12ee@stx) (let ((B12f0@t B12ee@stx)) (let ((B12f2@ls/false (Bd79@syntax-dispatch B12f0@t '(_ any each-any any . each-any)))) (if B12f2@ls/false (apply (lambda (B12f4@who B12f5@fmls B12f6@b B12f7@b*) (if (Bb7a@valid-bound-ids? B12f5@fmls) (Bd2f@bless (list 'make-traced-procedure (list 'quote B12f4@who) (cons 'lambda (cons B12f5@fmls (cons B12f6@b B12f7@b*))))) (Bd33@invalid-fmls-error B12ee@stx B12f5@fmls))) B12f2@ls/false) (let ((B12fc@t B12f0@t)) (let ((B12fe@ls/false (Bd79@syntax-dispatch B12fc@t '(_ any #(each+ any () any) any . each-any)))) (if B12fe@ls/false (apply (lambda (B1300@who B1301@fmls B1302@last B1303@b B1304@b*) (if (Bb7a@valid-bound-ids? (cons B1302@last B1301@fmls)) (Bd2f@bless (list 'make-traced-procedure (list 'quote B1300@who) (cons 'lambda (cons (append B1301@fmls B1302@last) (cons B1303@b B1304@b*))))) (Bd33@invalid-fmls-error B12ee@stx (append B1301@fmls B1302@last)))) B12fe@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B12fc@t))))))))) (set! B2830@Bd3b@trace-lambda-macro Bd3b@trace-lambda-macro) (set! Bd3d@trace-define-macro (lambda (B130a@stx) (let ((B130c@t B130a@stx)) (let ((B130e@ls/false (Bd79@syntax-dispatch B130c@t '(_ (any . each-any) any . each-any)))) (if B130e@ls/false (apply (lambda (B1310@who B1311@fmls B1312@b B1313@b*) (if (Bb7a@valid-bound-ids? B1311@fmls) (Bd2f@bless (list 'define B1310@who (list 'make-traced-procedure (list 'quote B1310@who) (cons 'lambda (cons B1311@fmls (cons B1312@b B1313@b*)))))) (Bd33@invalid-fmls-error B130a@stx B1311@fmls))) B130e@ls/false) (let ((B1318@t B130c@t)) (let ((B131a@ls/false (Bd79@syntax-dispatch B1318@t '(_ (any . #(each+ any () any)) any . each-any)))) (if B131a@ls/false (apply (lambda (B131c@who B131d@fmls B131e@last B131f@b B1320@b*) (if (Bb7a@valid-bound-ids? (cons B131e@last B131d@fmls)) (Bd2f@bless (list 'define B131c@who (list 'make-traced-procedure (list 'quote B131c@who) (cons 'lambda (cons (append B131d@fmls B131e@last) (cons B131f@b B1320@b*)))))) (Bd33@invalid-fmls-error B130a@stx (append B131d@fmls B131e@last)))) B131a@ls/false) (let ((B1326@t B1318@t)) (let ((B1328@ls/false (Bd79@syntax-dispatch B1326@t '(_ any any)))) (if B1328@ls/false (apply (lambda (B132a@who B132b@expr) (if (Bb72@id? B132a@who) (Bd2f@bless (list 'define B132a@who (list 'let (list (list 'v B132b@expr)) (cons 'if (cons '(procedure? v) (cons (cons 'make-traced-procedure (cons (list 'quote B132a@who) '(v))) '((assertion-violation 'trace-define "not a procedure" v)))))))) (Be59@syntax-violation '#f '"invalid name" B130a@stx))) B1328@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1326@t)))))))))))) (set! B2831@Bd3d@trace-define-macro Bd3d@trace-define-macro) (set! Bd3f@trace-define-syntax-macro (lambda (B132e@stx) (let ((B1330@t B132e@stx)) (let ((B1332@ls/false (Bd79@syntax-dispatch B1330@t '(_ any any)))) (if B1332@ls/false (apply (lambda (B1334@who B1335@expr) (if (Bb72@id? B1334@who) (Bd2f@bless (list 'define-syntax B1334@who (list 'make-traced-macro (list 'quote B1334@who) B1335@expr))) (Be59@syntax-violation '#f '"invalid name" B132e@stx))) B1332@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1330@t)))))) (set! B2832@Bd3f@trace-define-syntax-macro Bd3f@trace-define-syntax-macro) (set! Bd41@trace-let/rec-syntax (lambda (B1338@who) (lambda (B133a@stx) (let ((B133c@t B133a@stx)) (let ((B133e@ls/false (Bd79@syntax-dispatch B133c@t '(_ #(each (any any)) any . each-any)))) (if B133e@ls/false (apply (lambda (B1340@lhs* B1341@rhs* B1342@b B1343@b*) (if (Bb7a@valid-bound-ids? B1340@lhs*) (let ((B1348@rhs* (map (lambda (B134a@lhs B134b@rhs) (list 'make-traced-macro (list 'quote B134a@lhs) B134b@rhs)) B1340@lhs* B1341@rhs*))) (Bd2f@bless (cons B1338@who (cons (map list B1340@lhs* B1348@rhs*) (cons B1342@b B1343@b*))))) (Bd33@invalid-fmls-error B133a@stx B1340@lhs*))) B133e@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B133c@t))))))) (set! B2833@Bd41@trace-let/rec-syntax Bd41@trace-let/rec-syntax) (set! Bd43@trace-let-syntax-macro (Bd41@trace-let/rec-syntax 'let-syntax)) (set! B2834@Bd43@trace-let-syntax-macro Bd43@trace-let-syntax-macro) (set! Bd45@trace-letrec-syntax-macro (Bd41@trace-let/rec-syntax 'letrec-syntax)) (set! B2835@Bd45@trace-letrec-syntax-macro Bd45@trace-letrec-syntax-macro) (set! Bd47@guard-macro (lambda (B134e@x) (letrec* ((B1351@gen-clauses (lambda (B1368@con B1369@outerk B136a@clause*) (letrec* ((B136f@f (lambda (B13a8@x B13a9@k) (let ((B13ac@t B13a8@x)) (let ((B13ae@ls/false (Bd79@syntax-dispatch B13ac@t '(any #(scheme-id =>) any)))) (if B13ae@ls/false (apply (lambda (B13b0@e B13b1@p) (let ((B13b4@t (gensym))) (list 'let (list (list B13b4@t B13b0@e)) (list 'if B13b4@t (list B13b1@p B13b4@t) B13a9@k)))) B13ae@ls/false) (let ((B13b6@t B13ac@t)) (let ((B13b8@ls/false (Bd79@syntax-dispatch B13b6@t '(any)))) (if B13b8@ls/false (apply (lambda (B13ba@e) (let ((B13bc@t (gensym))) (list 'let (list (list B13bc@t B13ba@e)) (list 'if B13bc@t B13bc@t B13a9@k)))) B13b8@ls/false) (let ((B13be@t B13b6@t)) (let ((B13c0@ls/false (Bd79@syntax-dispatch B13be@t '(any any . each-any)))) (if B13c0@ls/false (apply (lambda (B13c2@e B13c3@v B13c4@v*) (list 'if B13c2@e (cons 'begin (cons B13c3@v B13c4@v*)) B13a9@k)) B13c0@ls/false) (let ((B13c8@t B13be@t)) (let ((B13ca@ls/false (Bd79@syntax-dispatch B13c8@t '_))) (if B13ca@ls/false (apply (lambda () (Be59@syntax-violation '#f '"invalid guard clause" B13a8@x)) B13ca@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B13c8@t))))))))))))))) (B1371@f* (lambda (B137e@x*) (let ((B1380@t B137e@x*)) (let ((B1382@ls/false (Bd79@syntax-dispatch B1380@t '()))) (if B1382@ls/false (apply (lambda () (let ((B1384@g (gensym))) (values (list B1384@g (list 'lambda '() (list 'raise-continuable B1368@con))) B1384@g))) B1382@ls/false) (let ((B1386@t B1380@t)) (let ((B1388@ls/false (Bd79@syntax-dispatch B1386@t '((#(scheme-id else) any . each-any))))) (if B1388@ls/false (apply (lambda (B138a@e B138b@e*) (values (cons 'begin (cons B138a@e B138b@e*)) '#f)) B1388@ls/false) (let ((B138e@t B1386@t)) (let ((B1390@ls/false (Bd79@syntax-dispatch B138e@t '(any . any)))) (if B1390@ls/false (apply (lambda (B1392@cls B1393@cls*) (call-with-values (lambda () (B1371@f* B1393@cls*)) (lambda (B139a@B1397 B139b@B1399) (let ((B139e@g B139b@B1399) (B139f@e B139a@B1397)) (values (B136f@f B1392@cls B139f@e) B139e@g))))) B1390@ls/false) (let ((B13a2@t B138e@t)) (let ((B13a4@ls/false (Bd79@syntax-dispatch B13a2@t 'any))) (if B13a4@ls/false (apply (lambda (B13a6@others) (Be59@syntax-violation '#f '"invalid guard clause" B13a6@others)) B13a4@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B13a2@t)))))))))))))))) (call-with-values (lambda () (B1371@f* B136a@clause*)) (lambda (B1376@B1373 B1377@B1375) (let ((B137a@raisek B1377@B1375) (B137b@code B1376@B1373)) (if B137a@raisek (list (list 'call/cc (list 'lambda (list B137a@raisek) (list B1369@outerk (list 'lambda '() B137b@code))))) (list B1369@outerk (list 'lambda '() B137b@code)))))))))) (let ((B1352@t B134e@x)) (let ((B1354@ls/false (Bd79@syntax-dispatch B1352@t '(_ (any . each-any) any . each-any)))) (if (and B1354@ls/false (apply (lambda (B1356@con B1357@clause* B1358@b B1359@b*) (Bb72@id? B1356@con)) B1354@ls/false)) (apply (lambda (B135e@con B135f@clause* B1360@b B1361@b*) (let ((B1366@outerk (gensym))) (Bd2f@bless (list (list 'call/cc (list 'lambda (list B1366@outerk) (list 'lambda '() (list 'with-exception-handler (list 'lambda (list B135e@con) (B1351@gen-clauses B135e@con B1366@outerk B135f@clause*)) (cons 'lambda (cons '() (cons B1360@b B1361@b*))))))))))) B1354@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1352@t))))))) (set! B2836@Bd47@guard-macro Bd47@guard-macro) (set! Bd49@define-enumeration-macro (lambda (B13cc@stx) (letrec* ((B13cf@set? (lambda (B13e8@x) (or (null? B13e8@x) (and (not (memq (car B13e8@x) (cdr B13e8@x))) (B13cf@set? (cdr B13e8@x)))))) (B13d1@remove-dups (lambda (B13e6@ls) (if (null? B13e6@ls) '() (cons (car B13e6@ls) (B13d1@remove-dups (remq (car B13e6@ls) (cdr B13e6@ls)))))))) (let ((B13d2@t B13cc@stx)) (let ((B13d4@ls/false (Bd79@syntax-dispatch B13d2@t '(_ any each-any any)))) (if (and B13d4@ls/false (apply (lambda (B13d6@name B13d7@id* B13d8@maker) (and (Bb72@id? B13d6@name) (Bb72@id? B13d8@maker) (for-all Bb72@id? B13d7@id*))) B13d4@ls/false)) (apply (lambda (B13dc@name B13dd@id* B13de@maker) (let ((B13e2@name* (B13d1@remove-dups (Be5f@syntax->datum B13dd@id*))) (B13e3@mk (gensym))) (Bd2f@bless (list 'begin (list 'define B13e3@mk (list 'enum-set-constructor (list 'make-enumeration (list 'quote B13e2@name*)))) (list 'define-syntax B13dc@name (list 'lambda '(x) (list 'syntax-case 'x '() (list '(_ n) '(identifier? (syntax n)) (list 'if (list 'memq '(syntax->datum (syntax n)) (list 'quote B13e2@name*)) '(syntax 'n) (cons 'syntax-violation (cons (list 'quote B13dc@name) '("not a member of set" x (syntax n))))))))) (list 'define-syntax B13de@maker (list 'lambda '(x) (list 'syntax-case 'x '() (list '(_ n* ...) (list 'begin (cons 'for-each (cons (list 'lambda '(n) (list 'unless '(identifier? n) (cons 'syntax-violation (cons (list 'quote B13de@maker) '("non-identifier argument" x n)))) (list 'unless (list 'memq '(syntax->datum n) (list 'quote B13e2@name*)) (cons 'syntax-violation (cons (list 'quote B13de@maker) '("not a member of set" x n))))) '((syntax (n* ...))))) (list 'syntax (cons B13e3@mk '('(n* ...))))))))))))) B13d4@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B13d2@t))))))) (set! B2837@Bd49@define-enumeration-macro Bd49@define-enumeration-macro) (set! Bd4b@time-macro (lambda (B13ea@stx) (let ((B13ec@t B13ea@stx)) (let ((B13ee@ls/false (Bd79@syntax-dispatch B13ec@t '(_ any)))) (if B13ee@ls/false (apply (lambda (B13f0@expr) (Bd2f@bless (cons 'let* (cons (cons '(start (time-usage)) (cons (list 'result (list (list 'lambda '() B13f0@expr))) '((end (time-usage)) (used (map - end start)) (real (car used)) (user (cadr used)) (sys (caddr used))))) '((format #t "~%;;~a real ~a user ~a sys~%~!" real user sys) result))))) B13ee@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B13ec@t)))))) (set! B2838@Bd4b@time-macro Bd4b@time-macro) (set! Bd4d@delay-macro (lambda (B13f2@stx) (let ((B13f4@t B13f2@stx)) (let ((B13f6@ls/false (Bd79@syntax-dispatch B13f4@t '(_ any)))) (if B13f6@ls/false (apply (lambda (B13f8@expr) (Bd2f@bless (list 'make-promise (list 'lambda '() B13f8@expr)))) B13f6@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B13f4@t)))))) (set! B2839@Bd4d@delay-macro Bd4d@delay-macro) (set! Bd4f@assert-macro (lambda (B13fa@stx) (let ((B13fc@t B13fa@stx)) (let ((B13fe@ls/false (Bd79@syntax-dispatch B13fc@t '(_ any)))) (if B13fe@ls/false (apply (lambda (B1400@expr) (let ((B1402@pos (or (Be51@expression-position B13fa@stx) (Be51@expression-position B1400@expr)))) (Bd2f@bless (list 'let (list (list 'x B1400@expr)) (list 'if 'x 'x (list 'assertion-error (list 'quote B1400@expr) (list 'quote B1402@pos))))))) B13fe@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B13fc@t)))))) (set! B283a@Bd4f@assert-macro Bd4f@assert-macro) (set! Bd51@endianness-macro (lambda (B1404@stx) (let ((B1406@t B1404@stx)) (let ((B1408@ls/false (Bd79@syntax-dispatch B1406@t '(_ any)))) (if B1408@ls/false (apply (lambda (B140a@e) (let ((B140c@t (Be5f@syntax->datum B140a@e))) (if (memv B140c@t '(little)) (Bd2f@bless ''little) (if (memv B140c@t '(big)) (Bd2f@bless ''big) (Be59@syntax-violation '#f '"endianness must be big or little" B1404@stx))))) B1408@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1406@t)))))) (set! B283b@Bd51@endianness-macro Bd51@endianness-macro) (set! Bd53@identifier-syntax-macro (lambda (B140e@stx) (let ((B1410@t B140e@stx)) (let ((B1412@ls/false (Bd79@syntax-dispatch B1410@t '(_ any)))) (if B1412@ls/false (apply (lambda (B1414@expr) (Bd2f@bless (list 'lambda '(x) (list 'syntax-case 'x '() (list 'id '(identifier? (syntax id)) (list 'syntax B1414@expr)) (list '(id e* ...) '(identifier? (syntax id)) (cons 'cons (cons (list 'syntax B1414@expr) '((syntax (e* ...)))))))))) B1412@ls/false) (let ((B1416@t B1410@t)) (let ((B1418@ls/false (Bd79@syntax-dispatch B1416@t '(_ (any any) ((#(scheme-id set!) any any) any))))) (if (and B1418@ls/false (apply (lambda (B141a@id1 B141b@expr1 B141c@id2 B141d@expr2 B141e@expr3) (and (Bb72@id? B141a@id1) (Bb72@id? B141c@id2) (Bb72@id? B141d@expr2))) B1418@ls/false)) (apply (lambda (B1424@id1 B1425@expr1 B1426@id2 B1427@expr2 B1428@expr3) (Bd2f@bless (list 'cons ''macro! (list 'lambda '(x) (list 'syntax-case 'x '(set!) (list 'id '(identifier? (syntax id)) (list 'syntax B1425@expr1)) (list (list 'set! 'id B1427@expr2) (list 'syntax B1428@expr3)) (list '(id e* ...) '(identifier? (syntax id)) (list 'syntax (cons B1425@expr1 '(e* ...))))))))) B1418@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1416@t))))))))) (set! B283c@Bd53@identifier-syntax-macro Bd53@identifier-syntax-macro) (set! Bd55@do-macro (lambda (B142e@stx) (letrec* ((B1431@bind (lambda (B1448@x) (let ((B144a@t B1448@x)) (let ((B144c@ls/false (Bd79@syntax-dispatch B144a@t '(any any)))) (if B144c@ls/false (apply (lambda (B144e@x B144f@init) (list B144e@x B144f@init B144e@x)) B144c@ls/false) (let ((B1452@t B144a@t)) (let ((B1454@ls/false (Bd79@syntax-dispatch B1452@t '(any any any)))) (if B1454@ls/false (apply (lambda (B1456@x B1457@init B1458@step) (list B1456@x B1457@init B1458@step)) B1454@ls/false) (let ((B145c@t B1452@t)) (let ((B145e@ls/false (Bd79@syntax-dispatch B145c@t '_))) (if B145e@ls/false (apply (lambda () (Be59@syntax-violation '#f '"invalid binding" B142e@stx)) B145e@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B145c@t))))))))))))) (let ((B1432@t B142e@stx)) (let ((B1434@ls/false (Bd79@syntax-dispatch B1432@t '(_ each-any (any . each-any) . each-any)))) (if B1434@ls/false (apply (lambda (B1436@binding* B1437@test B1438@expr* B1439@command*) (let ((B143e@t (map B1431@bind B1436@binding*))) (let ((B1440@ls/false (Bd79@syntax-dispatch B143e@t '#(each (any any any))))) (if B1440@ls/false (apply (lambda (B1442@x* B1443@init* B1444@step*) (if (Bb7a@valid-bound-ids? B1442@x*) (Bd2f@bless (list 'letrec (list (list 'loop (list 'lambda B1442@x* (list 'if B1437@test (cons 'begin (cons '(if #f #f) B1438@expr*)) (cons 'begin (append B1439@command* (list (cons 'loop B1444@step*)))))))) (cons 'loop B1443@init*))) (Be59@syntax-violation '#f '"invalid bindings" B142e@stx))) B1440@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B143e@t))))) B1434@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1432@t))))))) (set! B283d@Bd55@do-macro Bd55@do-macro) (set! Bd57@let*-macro (lambda (B1460@stx) (let ((B1462@t B1460@stx)) (let ((B1464@ls/false (Bd79@syntax-dispatch B1462@t '(_ #(each (any any)) any . each-any)))) (if (and B1464@ls/false (apply (lambda (B1466@lhs* B1467@rhs* B1468@b B1469@b*) (for-all Bb72@id? B1466@lhs*)) B1464@ls/false)) (apply (lambda (B146e@lhs* B146f@rhs* B1470@b B1471@b*) (Bd2f@bless (let B1478@f ((B1476@x* (map list B146e@lhs* B146f@rhs*))) (if (null? B1476@x*) (cons 'let (cons '() (cons B1470@b B1471@b*))) (list 'let (list (car B1476@x*)) (B1478@f (cdr B1476@x*))))))) B1464@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1462@t)))))) (set! B283e@Bd57@let*-macro Bd57@let*-macro) (set! Bd59@or-macro (lambda (B147a@stx) (let ((B147c@t B147a@stx)) (let ((B147e@ls/false (Bd79@syntax-dispatch B147c@t '(_)))) (if B147e@ls/false (apply (lambda () '#f) B147e@ls/false) (let ((B1480@t B147c@t)) (let ((B1482@ls/false (Bd79@syntax-dispatch B1480@t '(_ any . each-any)))) (if B1482@ls/false (apply (lambda (B1484@e B1485@e*) (Bd2f@bless (let B148c@f ((B1488@e B1484@e) (B1489@e* B1485@e*)) (if (null? B1489@e*) (list 'begin '#f B1488@e) (list 'let (list (list 't B1488@e)) (list 'if 't 't (B148c@f (car B1489@e*) (cdr B1489@e*)))))))) B1482@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1480@t))))))))) (set! B283f@Bd59@or-macro Bd59@or-macro) (set! Bd5b@and-macro (lambda (B148e@stx) (let ((B1490@t B148e@stx)) (let ((B1492@ls/false (Bd79@syntax-dispatch B1490@t '(_)))) (if B1492@ls/false (apply (lambda () '#t) B1492@ls/false) (let ((B1494@t B1490@t)) (let ((B1496@ls/false (Bd79@syntax-dispatch B1494@t '(_ any . each-any)))) (if B1496@ls/false (apply (lambda (B1498@e B1499@e*) (Bd2f@bless (let B14a0@f ((B149c@e B1498@e) (B149d@e* B1499@e*)) (if (null? B149d@e*) (list 'begin '#f B149c@e) (cons 'if (cons B149c@e (cons (B14a0@f (car B149d@e*) (cdr B149d@e*)) '(#f)))))))) B1496@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1494@t))))))))) (set! B2840@Bd5b@and-macro Bd5b@and-macro) (set! Bd5d@cond-macro (lambda (B14a2@stx) (let ((B14a4@t B14a2@stx)) (let ((B14a6@ls/false (Bd79@syntax-dispatch B14a4@t '(_ any . each-any)))) (if B14a6@ls/false (apply (lambda (B14a8@cls B14a9@cls*) (Bd2f@bless (let B14b0@f ((B14ac@cls B14a8@cls) (B14ad@cls* B14a9@cls*)) (if (null? B14ad@cls*) (let ((B14b2@t B14ac@cls)) (let ((B14b4@ls/false (Bd79@syntax-dispatch B14b2@t '(#(scheme-id else) any . each-any)))) (if B14b4@ls/false (apply (lambda (B14b6@e B14b7@e*) (cons 'begin (cons B14b6@e B14b7@e*))) B14b4@ls/false) (let ((B14ba@t B14b2@t)) (let ((B14bc@ls/false (Bd79@syntax-dispatch B14ba@t '(any #(scheme-id =>) any)))) (if B14bc@ls/false (apply (lambda (B14be@e B14bf@p) (list 'let (list (list 't B14be@e)) (list 'if 't (cons B14bf@p '(t))))) B14bc@ls/false) (let ((B14c2@t B14ba@t)) (let ((B14c4@ls/false (Bd79@syntax-dispatch B14c2@t '(any)))) (if B14c4@ls/false (apply (lambda (B14c6@e) (cons 'or (cons B14c6@e '((if #f #f))))) B14c4@ls/false) (let ((B14c8@t B14c2@t)) (let ((B14ca@ls/false (Bd79@syntax-dispatch B14c8@t '(any . each-any)))) (if B14ca@ls/false (apply (lambda (B14cc@e B14cd@e*) (list 'if B14cc@e (cons 'begin B14cd@e*))) B14ca@ls/false) (let ((B14d0@t B14c8@t)) (let ((B14d2@ls/false (Bd79@syntax-dispatch B14d0@t '_))) (if B14d2@ls/false (apply (lambda () (Be59@syntax-violation '#f '"invalid last clause" B14a2@stx)) B14d2@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B14d0@t)))))))))))))))) (let ((B14d4@t B14ac@cls)) (let ((B14d6@ls/false (Bd79@syntax-dispatch B14d4@t '(#(scheme-id else) any . each-any)))) (if B14d6@ls/false (apply (lambda (B14d8@e B14d9@e*) (Be59@syntax-violation '#f '"incorrect position of keyword else" B14a2@stx)) B14d6@ls/false) (let ((B14dc@t B14d4@t)) (let ((B14de@ls/false (Bd79@syntax-dispatch B14dc@t '(any #(scheme-id =>) any)))) (if B14de@ls/false (apply (lambda (B14e0@e B14e1@p) (list 'let (list (list 't B14e0@e)) (list 'if 't (cons B14e1@p '(t)) (B14b0@f (car B14ad@cls*) (cdr B14ad@cls*))))) B14de@ls/false) (let ((B14e4@t B14dc@t)) (let ((B14e6@ls/false (Bd79@syntax-dispatch B14e4@t '(any)))) (if B14e6@ls/false (apply (lambda (B14e8@e) (list 'or B14e8@e (B14b0@f (car B14ad@cls*) (cdr B14ad@cls*)))) B14e6@ls/false) (let ((B14ea@t B14e4@t)) (let ((B14ec@ls/false (Bd79@syntax-dispatch B14ea@t '(any . each-any)))) (if B14ec@ls/false (apply (lambda (B14ee@e B14ef@e*) (list 'if B14ee@e (cons 'begin B14ef@e*) (B14b0@f (car B14ad@cls*) (cdr B14ad@cls*)))) B14ec@ls/false) (let ((B14f2@t B14ea@t)) (let ((B14f4@ls/false (Bd79@syntax-dispatch B14f2@t '_))) (if B14f4@ls/false (apply (lambda () (Be59@syntax-violation '#f '"invalid last clause" B14a2@stx)) B14f4@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B14f2@t)))))))))))))))))))) B14a6@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B14a4@t)))))) (set! B2841@Bd5d@cond-macro Bd5d@cond-macro) (set! Bd5f@do-include (lambda (B14f6@stx B14f7@id B14f8@filename) (let ((B14fc@filename (Bb86@stx->datum B14f8@filename))) (begin (if (not (and (string? B14fc@filename) (Bb72@id? B14f7@id))) (Be59@syntax-violation '#f '"invalid syntax" B14f6@stx) (void)) (cons (Bd2f@bless 'begin) (with-input-from-file B14fc@filename (lambda () (let B1500@f ((B14fe@ls '())) (let ((B1502@x (B6b4@B584@read-annotated))) (if (eof-object? B1502@x) (reverse B14fe@ls) (B1500@f (cons (Bb52@datum->stx B14f7@id B1502@x) B14fe@ls)))))))))))) (set! B2842@Bd5f@do-include Bd5f@do-include) (set! Bd61@include-macro (lambda (B1504@e) (let ((B1506@t B1504@e)) (let ((B1508@ls/false (Bd79@syntax-dispatch B1506@t '(any any)))) (if B1508@ls/false (apply (lambda (B150a@id B150b@filename) (Bd5f@do-include B1504@e B150a@id B150b@filename)) B1508@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1506@t)))))) (set! B2843@Bd61@include-macro Bd61@include-macro) (set! Bd63@include-into-macro (lambda (B150e@e) (let ((B1510@t B150e@e)) (let ((B1512@ls/false (Bd79@syntax-dispatch B1510@t '(_ any any)))) (if B1512@ls/false (apply (lambda (B1514@id B1515@filename) (Bd5f@do-include B150e@e B1514@id B1515@filename)) B1512@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1510@t)))))) (set! B2844@Bd63@include-into-macro Bd63@include-into-macro) (set! Bd65@syntax-rules-macro (lambda (B1518@e) (let ((B151a@t B1518@e)) (let ((B151c@ls/false (Bd79@syntax-dispatch B151a@t '(_ each-any . #(each (any any)))))) (if B151c@ls/false (apply (lambda (B151e@lits B151f@pat* B1520@tmp*) (begin (Bd7f@verify-literals B151e@lits B1518@e) (Bd2f@bless (list 'lambda '(x) (cons 'syntax-case (cons 'x (cons B151e@lits (map (lambda (B1524@pat B1525@tmp) (let ((B1528@t B1524@pat)) (let ((B152a@ls/false (Bd79@syntax-dispatch B1528@t '(_ . any)))) (if B152a@ls/false (apply (lambda (B152c@rest) (list (cons 'g B152c@rest) (list 'syntax B1525@tmp))) B152a@ls/false) (let ((B152e@t B1528@t)) (let ((B1530@ls/false (Bd79@syntax-dispatch B152e@t '_))) (if B1530@ls/false (apply (lambda () (Be59@syntax-violation '#f '"invalid syntax-rules pattern" B1518@e B1524@pat)) B1530@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B152e@t)))))))) B151f@pat* B1520@tmp*)))))))) B151c@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B151a@t)))))) (set! B2845@Bd65@syntax-rules-macro Bd65@syntax-rules-macro) (set! Bd67@quasiquote-macro (letrec* ((B1533@datum (lambda (B1634@x) (list (Bd01@scheme-stx 'quote) (Bb5a@mkstx B1634@x '() '() '())))) (B154f@quasicons* (lambda (B162c@x B162d@y) (let B1632@f ((B1630@x B162c@x)) (if (null? B1630@x) B162d@y (B1551@quasicons (car B1630@x) (B1632@f (cdr B1630@x))))))) (B1551@quasicons (lambda (B1606@x B1607@y) (let ((B160a@t B1607@y)) (let ((B160c@ls/false (Bd79@syntax-dispatch B160a@t '(#(scheme-id quote) any)))) (if B160c@ls/false (apply (lambda (B160e@dy) (let ((B1610@t B1606@x)) (let ((B1612@ls/false (Bd79@syntax-dispatch B1610@t '(#(scheme-id quote) any)))) (if B1612@ls/false (apply (lambda (B1614@dx) (list (Bd01@scheme-stx 'quote) (cons B1614@dx B160e@dy))) B1612@ls/false) (let ((B1616@t B1610@t)) (let ((B1618@ls/false (Bd79@syntax-dispatch B1616@t '_))) (if B1618@ls/false (apply (lambda () (let ((B161a@t B160e@dy)) (let ((B161c@ls/false (Bd79@syntax-dispatch B161a@t '()))) (if B161c@ls/false (apply (lambda () (list (Bd01@scheme-stx 'list) B1606@x)) B161c@ls/false) (let ((B161e@t B161a@t)) (let ((B1620@ls/false (Bd79@syntax-dispatch B161e@t '_))) (if B1620@ls/false (apply (lambda () (list (Bd01@scheme-stx 'cons) B1606@x B1607@y)) B1620@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B161e@t)))))))) B1618@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1616@t)))))))) B160c@ls/false) (let ((B1622@t B160a@t)) (let ((B1624@ls/false (Bd79@syntax-dispatch B1622@t '(#(scheme-id list) . each-any)))) (if B1624@ls/false (apply (lambda (B1626@stuff) (cons* (Bd01@scheme-stx 'list) B1606@x B1626@stuff)) B1624@ls/false) (let ((B1628@t B1622@t)) (let ((B162a@ls/false (Bd79@syntax-dispatch B1628@t '_))) (if B162a@ls/false (apply (lambda () (list (Bd01@scheme-stx 'cons) B1606@x B1607@y)) B162a@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1628@t)))))))))))) (B1553@quasiappend (lambda (B15ec@x B15ed@y) (let ((B15f0@ls (let B15f4@f ((B15f2@x B15ec@x)) (if (null? B15f2@x) (let ((B15f6@t B15ed@y)) (let ((B15f8@ls/false (Bd79@syntax-dispatch B15f6@t '(#(scheme-id quote) ())))) (if B15f8@ls/false (apply (lambda () '()) B15f8@ls/false) (let ((B15fa@t B15f6@t)) (let ((B15fc@ls/false (Bd79@syntax-dispatch B15fa@t '_))) (if B15fc@ls/false (apply (lambda () (list B15ed@y)) B15fc@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B15fa@t))))))) (let ((B15fe@t (car B15f2@x))) (let ((B1600@ls/false (Bd79@syntax-dispatch B15fe@t '(#(scheme-id quote) ())))) (if B1600@ls/false (apply (lambda () (B15f4@f (cdr B15f2@x))) B1600@ls/false) (let ((B1602@t B15fe@t)) (let ((B1604@ls/false (Bd79@syntax-dispatch B1602@t '_))) (if B1604@ls/false (apply (lambda () (cons (car B15f2@x) (B15f4@f (cdr B15f2@x)))) B1604@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1602@t))))))))))) (if (null? B15f0@ls) (list (Bd01@scheme-stx 'quote) '()) (if (null? (cdr B15f0@ls)) (car B15f0@ls) (cons* (Bd01@scheme-stx 'append) B15f0@ls)))))) (B1555@quasivector (lambda (B15ba@x) (let ((B15bc@pat-x B15ba@x)) (let ((B15be@t B15bc@pat-x)) (let ((B15c0@ls/false (Bd79@syntax-dispatch B15be@t '(#(scheme-id quote) each-any)))) (if B15c0@ls/false (apply (lambda (B15c2@x*) (list (Bd01@scheme-stx 'quote) (list->vector B15c2@x*))) B15c0@ls/false) (let ((B15c4@t B15be@t)) (let ((B15c6@ls/false (Bd79@syntax-dispatch B15c4@t '_))) (if B15c6@ls/false (apply (lambda () (let B15ce@f ((B15c8@x B15ba@x) (B15c9@k (lambda (B15cc@ls) (cons* (Bd01@scheme-stx 'vector) B15cc@ls)))) (let ((B15d0@t B15c8@x)) (let ((B15d2@ls/false (Bd79@syntax-dispatch B15d0@t '(#(scheme-id quote) each-any)))) (if B15d2@ls/false (apply (lambda (B15d4@x*) (B15c9@k (map (lambda (B15d6@x) (list (Bd01@scheme-stx 'quote) B15d6@x)) B15d4@x*))) B15d2@ls/false) (let ((B15d8@t B15d0@t)) (let ((B15da@ls/false (Bd79@syntax-dispatch B15d8@t '(#(scheme-id list) . each-any)))) (if B15da@ls/false (apply (lambda (B15dc@x*) (B15c9@k B15dc@x*)) B15da@ls/false) (let ((B15de@t B15d8@t)) (let ((B15e0@ls/false (Bd79@syntax-dispatch B15de@t '(#(scheme-id cons) any any)))) (if B15e0@ls/false (apply (lambda (B15e2@x B15e3@y) (B15ce@f B15e3@y (lambda (B15e6@ls) (B15c9@k (cons B15e2@x B15e6@ls))))) B15e0@ls/false) (let ((B15e8@t B15de@t)) (let ((B15ea@ls/false (Bd79@syntax-dispatch B15e8@t '_))) (if B15ea@ls/false (apply (lambda () (list (Bd01@scheme-stx 'list->vector) B15bc@pat-x)) B15ea@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B15e8@t))))))))))))))) B15c6@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B15c4@t)))))))))) (B1557@vquasi (lambda (B1598@p B1599@lev) (let ((B159c@t B1598@p)) (let ((B159e@ls/false (Bd79@syntax-dispatch B159c@t '(any . any)))) (if B159e@ls/false (apply (lambda (B15a0@p B15a1@q) (let ((B15a4@t B15a0@p)) (let ((B15a6@ls/false (Bd79@syntax-dispatch B15a4@t '(#(scheme-id unquote) . each-any)))) (if B15a6@ls/false (apply (lambda (B15a8@p) (if (= B1599@lev '0) (B154f@quasicons* B15a8@p (B1557@vquasi B15a1@q B1599@lev)) (B1551@quasicons (B1551@quasicons (B1533@datum 'unquote) (B1559@quasi B15a8@p (- B1599@lev '1))) (B1557@vquasi B15a1@q B1599@lev)))) B15a6@ls/false) (let ((B15aa@t B15a4@t)) (let ((B15ac@ls/false (Bd79@syntax-dispatch B15aa@t '(#(scheme-id unquote-splicing) . each-any)))) (if B15ac@ls/false (apply (lambda (B15ae@p) (if (= B1599@lev '0) (B1553@quasiappend B15ae@p (B1557@vquasi B15a1@q B1599@lev)) (B1551@quasicons (B1551@quasicons (B1533@datum 'unquote-splicing) (B1559@quasi B15ae@p (- B1599@lev '1))) (B1557@vquasi B15a1@q B1599@lev)))) B15ac@ls/false) (let ((B15b0@t B15aa@t)) (let ((B15b2@ls/false (Bd79@syntax-dispatch B15b0@t 'any))) (if B15b2@ls/false (apply (lambda (B15b4@p) (B1551@quasicons (B1559@quasi B15b4@p B1599@lev) (B1557@vquasi B15a1@q B1599@lev))) B15b2@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B15b0@t))))))))))) B159e@ls/false) (let ((B15b6@t B159c@t)) (let ((B15b8@ls/false (Bd79@syntax-dispatch B15b6@t '()))) (if B15b8@ls/false (apply (lambda () (list (Bd01@scheme-stx 'quote) '())) B15b8@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B15b6@t))))))))) (B1559@quasi (lambda (B1562@p B1563@lev) (let ((B1566@t B1562@p)) (let ((B1568@ls/false (Bd79@syntax-dispatch B1566@t '(#(scheme-id unquote) any)))) (if B1568@ls/false (apply (lambda (B156a@p) (if (= B1563@lev '0) B156a@p (B1551@quasicons (B1533@datum 'unquote) (B1559@quasi (list B156a@p) (- B1563@lev '1))))) B1568@ls/false) (let ((B156c@t B1566@t)) (let ((B156e@ls/false (Bd79@syntax-dispatch B156c@t '((#(scheme-id unquote) . each-any) . any)))) (if B156e@ls/false (apply (lambda (B1570@p B1571@q) (if (= B1563@lev '0) (B154f@quasicons* B1570@p (B1559@quasi B1571@q B1563@lev)) (B1551@quasicons (B1551@quasicons (B1533@datum 'unquote) (B1559@quasi B1570@p (- B1563@lev '1))) (B1559@quasi B1571@q B1563@lev)))) B156e@ls/false) (let ((B1574@t B156c@t)) (let ((B1576@ls/false (Bd79@syntax-dispatch B1574@t '((#(scheme-id unquote-splicing) . each-any) . any)))) (if B1576@ls/false (apply (lambda (B1578@p B1579@q) (if (= B1563@lev '0) (B1553@quasiappend B1578@p (B1559@quasi B1579@q B1563@lev)) (B1551@quasicons (B1551@quasicons (B1533@datum 'unquote-splicing) (B1559@quasi B1578@p (- B1563@lev '1))) (B1559@quasi B1579@q B1563@lev)))) B1576@ls/false) (let ((B157c@t B1574@t)) (let ((B157e@ls/false (Bd79@syntax-dispatch B157c@t '(#(scheme-id quasiquote) any)))) (if B157e@ls/false (apply (lambda (B1580@p) (B1551@quasicons (B1533@datum 'quasiquote) (B1559@quasi (list B1580@p) (+ B1563@lev '1)))) B157e@ls/false) (let ((B1582@t B157c@t)) (let ((B1584@ls/false (Bd79@syntax-dispatch B1582@t '(any . any)))) (if B1584@ls/false (apply (lambda (B1586@p B1587@q) (B1551@quasicons (B1559@quasi B1586@p B1563@lev) (B1559@quasi B1587@q B1563@lev))) B1584@ls/false) (let ((B158a@t B1582@t)) (let ((B158c@ls/false (Bd79@syntax-dispatch B158a@t '#(vector each-any)))) (if (and B158c@ls/false (apply (lambda (B158e@x) (not (Bb3e@stx? B158e@x))) B158c@ls/false)) (apply (lambda (B1590@x) (B1555@quasivector (B1557@vquasi B1590@x B1563@lev))) B158c@ls/false) (let ((B1592@t B158a@t)) (let ((B1594@ls/false (Bd79@syntax-dispatch B1592@t 'any))) (if B1594@ls/false (apply (lambda (B1596@p) (list (Bd01@scheme-stx 'quote) B1596@p)) B1594@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1592@t))))))))))))))))))))))))) (lambda (B155a@x) (let ((B155c@t B155a@x)) (let ((B155e@ls/false (Bd79@syntax-dispatch B155c@t '(_ any)))) (if B155e@ls/false (apply (lambda (B1560@e) (B1559@quasi B1560@e '0)) B155e@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B155c@t))))))) (set! B2846@Bd67@quasiquote-macro Bd67@quasiquote-macro) (set! Bd69@quasisyntax-macro (letrec* ((B1637@quasi (lambda (B1652@p B1653@lev) (let ((B1656@t B1652@p)) (let ((B1658@ls/false (Bd79@syntax-dispatch B1656@t '(#(scheme-id unsyntax) any)))) (if B1658@ls/false (apply (lambda (B165a@p) (if (= B1653@lev '0) (let ((B165c@g (gensym))) (values (list B165c@g) (list B165a@p) B165c@g)) (call-with-values (lambda () (B1637@quasi B165a@p (- B1653@lev '1))) (lambda (B1664@B165f B1665@B1661 B1666@B1663) (let ((B166a@p B1666@B1663) (B166b@rhs* B1665@B1661) (B166c@lhs* B1664@B165f)) (values B166c@lhs* B166b@rhs* (list 'unsyntax B166a@p))))))) B1658@ls/false) (let ((B1670@t B1656@t)) (let ((B1672@ls/false (Bd79@syntax-dispatch B1670@t '#(scheme-id unsyntax)))) (if (and B1672@ls/false (apply (lambda () (= B1653@lev '0)) B1672@ls/false)) (apply (lambda () (Be59@syntax-violation '#f '"incorrect use of unsyntax" B1652@p)) B1672@ls/false) (let ((B1674@t B1670@t)) (let ((B1676@ls/false (Bd79@syntax-dispatch B1674@t '((#(scheme-id unsyntax) . each-any) . any)))) (if B1676@ls/false (apply (lambda (B1678@p* B1679@q) (call-with-values (lambda () (B1637@quasi B1679@q B1653@lev)) (lambda (B1682@B167d B1683@B167f B1684@B1681) (let ((B1688@q B1684@B1681) (B1689@rhs* B1683@B167f) (B168a@lhs* B1682@B167d)) (if (= B1653@lev '0) (let ((B168e@g* (map (lambda (B1690@x) (gensym)) B1678@p*))) (values (append B168e@g* B168a@lhs*) (append B1678@p* B1689@rhs*) (append B168e@g* B1688@q))) (call-with-values (lambda () (B1637@quasi B1678@p* (- B1653@lev '1))) (lambda (B1698@B1693 B1699@B1695 B169a@B1697) (let ((B169e@p* B169a@B1697) (B169f@rhs2* B1699@B1695) (B16a0@lhs2* B1698@B1693)) (values (append B16a0@lhs2* B168a@lhs*) (append B169f@rhs2* B1689@rhs*) (cons (cons 'unsyntax B169e@p*) B1688@q)))))))))) B1676@ls/false) (let ((B16a4@t B1674@t)) (let ((B16a6@ls/false (Bd79@syntax-dispatch B16a4@t '((#(scheme-id unsyntax-splicing) . each-any) . any)))) (if B16a6@ls/false (apply (lambda (B16a8@p* B16a9@q) (call-with-values (lambda () (B1637@quasi B16a9@q B1653@lev)) (lambda (B16b2@B16ad B16b3@B16af B16b4@B16b1) (let ((B16b8@q B16b4@B16b1) (B16b9@rhs* B16b3@B16af) (B16ba@lhs* B16b2@B16ad)) (if (= B1653@lev '0) (let ((B16be@g* (map (lambda (B16c0@x) (gensym)) B16a8@p*))) (values (append (map (lambda (B16c2@g) (cons B16c2@g '(...))) B16be@g*) B16ba@lhs*) (append B16a8@p* B16b9@rhs*) (append (apply append (map (lambda (B16c4@g) (cons B16c4@g '(...))) B16be@g*)) B16b8@q))) (call-with-values (lambda () (B1637@quasi B16a8@p* (- B1653@lev '1))) (lambda (B16cc@B16c7 B16cd@B16c9 B16ce@B16cb) (let ((B16d2@p* B16ce@B16cb) (B16d3@rhs2* B16cd@B16c9) (B16d4@lhs2* B16cc@B16c7)) (values (append B16d4@lhs2* B16ba@lhs*) (append B16d3@rhs2* B16b9@rhs*) (cons (cons 'unsyntax-splicing B16d2@p*) B16b8@q)))))))))) B16a6@ls/false) (let ((B16d8@t B16a4@t)) (let ((B16da@ls/false (Bd79@syntax-dispatch B16d8@t '#(scheme-id unsyntax-splicing)))) (if (and B16da@ls/false (apply (lambda () (= B1653@lev '0)) B16da@ls/false)) (apply (lambda () (Be59@syntax-violation '#f '"incorrect use of unsyntax-splicing" B1652@p)) B16da@ls/false) (let ((B16dc@t B16d8@t)) (let ((B16de@ls/false (Bd79@syntax-dispatch B16dc@t '(#(scheme-id quasisyntax) any)))) (if B16de@ls/false (apply (lambda (B16e0@p) (call-with-values (lambda () (B1637@quasi B16e0@p (+ B1653@lev '1))) (lambda (B16e8@B16e3 B16e9@B16e5 B16ea@B16e7) (let ((B16ee@p B16ea@B16e7) (B16ef@rhs* B16e9@B16e5) (B16f0@lhs* B16e8@B16e3)) (values B16f0@lhs* B16ef@rhs* (list 'quasisyntax B16ee@p)))))) B16de@ls/false) (let ((B16f4@t B16dc@t)) (let ((B16f6@ls/false (Bd79@syntax-dispatch B16f4@t '(any . any)))) (if B16f6@ls/false (apply (lambda (B16f8@p B16f9@q) (call-with-values (lambda () (B1637@quasi B16f8@p B1653@lev)) (lambda (B1708@B16fd B1709@B16ff B170a@B1701) (call-with-values (lambda () (B1637@quasi B16f9@q B1653@lev)) (lambda (B170e@B1703 B170f@B1705 B1710@B1707) (let ((B1714@q B1710@B1707) (B1715@rhs2* B170f@B1705) (B1716@lhs2* B170e@B1703) (B1717@p B170a@B1701) (B1718@rhs* B1709@B16ff) (B1719@lhs* B1708@B16fd)) (values (append B1716@lhs2* B1719@lhs*) (append B1715@rhs2* B1718@rhs*) (cons B1717@p B1714@q)))))))) B16f6@ls/false) (let ((B1720@t B16f4@t)) (let ((B1722@ls/false (Bd79@syntax-dispatch B1720@t '#(vector each-any)))) (if B1722@ls/false (apply (lambda (B1724@x*) (call-with-values (lambda () (B1637@quasi B1724@x* B1653@lev)) (lambda (B172c@B1727 B172d@B1729 B172e@B172b) (let ((B1732@x* B172e@B172b) (B1733@rhs* B172d@B1729) (B1734@lhs* B172c@B1727)) (values B1734@lhs* B1733@rhs* (list->vector B1732@x*)))))) B1722@ls/false) (let ((B1738@t B1720@t)) (let ((B173a@ls/false (Bd79@syntax-dispatch B1738@t '_))) (if B173a@ls/false (apply (lambda () (values '() '() B1652@p)) B173a@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1738@t))))))))))))))))))))))))))))))) (lambda (B1638@x) (let ((B163a@t B1638@x)) (let ((B163c@ls/false (Bd79@syntax-dispatch B163a@t '(_ any)))) (if B163c@ls/false (apply (lambda (B163e@e) (call-with-values (lambda () (B1637@quasi B163e@e '0)) (lambda (B1646@B1641 B1647@B1643 B1648@B1645) (let ((B164c@v B1648@B1645) (B164d@rhs* B1647@B1643) (B164e@lhs* B1646@B1641)) (Bd2f@bless (list 'syntax-case (cons 'list B164d@rhs*) '() (list B164e@lhs* (list 'syntax B164c@v)))))))) B163c@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B163a@t))))))) (set! B2847@Bd69@quasisyntax-macro Bd69@quasisyntax-macro) (set! Bd6b@define-struct-macro (lambda (B173c@stx) (Be59@syntax-violation '#f '"define-struct not supported" B173c@stx))) (set! B2848@Bd6b@define-struct-macro Bd6b@define-struct-macro) (set! Bd6d@define-record-type-macro (lambda (B173e@x) (letrec* ((B1741@id (lambda (B1934@ctxt . B1936@str*) (Be5d@datum->syntax B1934@ctxt (string->symbol (apply string-append (map (lambda (B1938@x) (if (symbol? B1938@x) (symbol->string B1938@x) (if (string? B1938@x) B1938@x (assertion-violation 'define-record-type '"BUG")))) B1936@str*)))))) (B1743@get-record-name (lambda (B1922@spec) (let ((B1924@t B1922@spec)) (let ((B1926@ls/false (Bd79@syntax-dispatch B1924@t '(any any any)))) (if B1926@ls/false (apply (lambda (B1928@foo B1929@make-foo B192a@foo?) B1928@foo) B1926@ls/false) (let ((B192e@t B1924@t)) (let ((B1930@ls/false (Bd79@syntax-dispatch B192e@t 'any))) (if B1930@ls/false (apply (lambda (B1932@foo) B1932@foo) B1930@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B192e@t))))))))) (B1745@get-record-constructor-name (lambda (B190e@spec) (let ((B1910@t B190e@spec)) (let ((B1912@ls/false (Bd79@syntax-dispatch B1910@t '(any any any)))) (if B1912@ls/false (apply (lambda (B1914@foo B1915@make-foo B1916@foo?) B1915@make-foo) B1912@ls/false) (let ((B191a@t B1910@t)) (let ((B191c@ls/false (Bd79@syntax-dispatch B191a@t 'any))) (if (and B191c@ls/false (apply (lambda (B191e@foo) (Bb72@id? B191e@foo)) B191c@ls/false)) (apply (lambda (B1920@foo) (B1741@id B1920@foo '"make-" (Bb86@stx->datum B1920@foo))) B191c@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B191a@t))))))))) (B1747@get-record-predicate-name (lambda (B18fa@spec) (let ((B18fc@t B18fa@spec)) (let ((B18fe@ls/false (Bd79@syntax-dispatch B18fc@t '(any any any)))) (if B18fe@ls/false (apply (lambda (B1900@foo B1901@make-foo B1902@foo?) B1902@foo?) B18fe@ls/false) (let ((B1906@t B18fc@t)) (let ((B1908@ls/false (Bd79@syntax-dispatch B1906@t 'any))) (if (and B1908@ls/false (apply (lambda (B190a@foo) (Bb72@id? B190a@foo)) B1908@ls/false)) (apply (lambda (B190c@foo) (B1741@id B190c@foo (Bb86@stx->datum B190c@foo) '"?")) B1908@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1906@t))))))))) (B1749@get-clause (lambda (B18e8@id B18e9@ls) (let ((B18ec@t B18e9@ls)) (let ((B18ee@ls/false (Bd79@syntax-dispatch B18ec@t '()))) (if B18ee@ls/false (apply (lambda () '#f) B18ee@ls/false) (let ((B18f0@t B18ec@t)) (let ((B18f2@ls/false (Bd79@syntax-dispatch B18f0@t '((any . any) . any)))) (if B18f2@ls/false (apply (lambda (B18f4@x B18f5@rest B18f6@ls) (if (Bb78@free-id=? (Bd2f@bless B18e8@id) B18f4@x) (cons B18f4@x B18f5@rest) (B1749@get-clause B18e8@id B18f6@ls))) B18f2@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B18f0@t))))))))) (B174b@foo-rtd-code (lambda (B1896@name B1897@clause* B1898@parent-rtd-code) (letrec* ((B189d@convert-field-spec* (lambda (B18ce@ls) (list->vector (map (lambda (B18d0@x) (let ((B18d2@t B18d0@x)) (let ((B18d4@ls/false (Bd79@syntax-dispatch B18d2@t '(#(scheme-id mutable) any . any)))) (if B18d4@ls/false (apply (lambda (B18d6@name B18d7@rest) (list 'mutable B18d6@name)) B18d4@ls/false) (let ((B18da@t B18d2@t)) (let ((B18dc@ls/false (Bd79@syntax-dispatch B18da@t '(#(scheme-id immutable) any . any)))) (if B18dc@ls/false (apply (lambda (B18de@name B18df@rest) (list 'immutable B18de@name)) B18dc@ls/false) (let ((B18e2@t B18da@t)) (let ((B18e4@ls/false (Bd79@syntax-dispatch B18e2@t 'any))) (if B18e4@ls/false (apply (lambda (B18e6@name) (list 'immutable B18e6@name)) B18e4@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B18e2@t))))))))))) B18ce@ls))))) (let ((B189e@uid-code (let ((B18a6@t (B1749@get-clause 'nongenerative B1897@clause*))) (let ((B18a8@ls/false (Bd79@syntax-dispatch B18a6@t '(_)))) (if B18a8@ls/false (apply (lambda () (list 'quote (gensym))) B18a8@ls/false) (let ((B18aa@t B18a6@t)) (let ((B18ac@ls/false (Bd79@syntax-dispatch B18aa@t '(_ any)))) (if B18ac@ls/false (apply (lambda (B18ae@uid) (list 'quote B18ae@uid)) B18ac@ls/false) (let ((B18b0@t B18aa@t)) (let ((B18b2@ls/false (Bd79@syntax-dispatch B18b0@t '_))) (if B18b2@ls/false (apply (lambda () '#f) B18b2@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B18b0@t))))))))))) (B189f@sealed? (let ((B18b4@t (B1749@get-clause 'sealed B1897@clause*))) (let ((B18b6@ls/false (Bd79@syntax-dispatch B18b4@t '(_ #(atom #t))))) (if B18b6@ls/false (apply (lambda () '#t) B18b6@ls/false) (let ((B18b8@t B18b4@t)) (let ((B18ba@ls/false (Bd79@syntax-dispatch B18b8@t '_))) (if B18ba@ls/false (apply (lambda () '#f) B18ba@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B18b8@t)))))))) (B18a0@opaque? (let ((B18bc@t (B1749@get-clause 'opaque B1897@clause*))) (let ((B18be@ls/false (Bd79@syntax-dispatch B18bc@t '(_ #(atom #t))))) (if B18be@ls/false (apply (lambda () '#t) B18be@ls/false) (let ((B18c0@t B18bc@t)) (let ((B18c2@ls/false (Bd79@syntax-dispatch B18c0@t '_))) (if B18c2@ls/false (apply (lambda () '#f) B18c2@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B18c0@t)))))))) (B18a1@fields (let ((B18c4@t (B1749@get-clause 'fields B1897@clause*))) (let ((B18c6@ls/false (Bd79@syntax-dispatch B18c4@t '(_ . each-any)))) (if B18c6@ls/false (apply (lambda (B18c8@field-spec*) (list 'quote (B189d@convert-field-spec* B18c8@field-spec*))) B18c6@ls/false) (let ((B18ca@t B18c4@t)) (let ((B18cc@ls/false (Bd79@syntax-dispatch B18ca@t '_))) (if B18cc@ls/false (apply (lambda () ''#()) B18cc@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B18ca@t))))))))) (Bd2f@bless (list 'make-record-type-descriptor (list 'quote B1896@name) B1898@parent-rtd-code B189e@uid-code B189f@sealed? B18a0@opaque? B18a1@fields)))))) (B174d@parent-rtd-code (lambda (B187e@clause*) (let ((B1880@t (B1749@get-clause 'parent B187e@clause*))) (let ((B1882@ls/false (Bd79@syntax-dispatch B1880@t '(_ any)))) (if B1882@ls/false (apply (lambda (B1884@name) (list 'record-type-descriptor B1884@name)) B1882@ls/false) (let ((B1886@t B1880@t)) (let ((B1888@ls/false (Bd79@syntax-dispatch B1886@t '#(atom #f)))) (if B1888@ls/false (apply (lambda () (let ((B188a@t (B1749@get-clause 'parent-rtd B187e@clause*))) (let ((B188c@ls/false (Bd79@syntax-dispatch B188a@t '(_ any any)))) (if B188c@ls/false (apply (lambda (B188e@rtd B188f@rcd) B188e@rtd) B188c@ls/false) (let ((B1892@t B188a@t)) (let ((B1894@ls/false (Bd79@syntax-dispatch B1892@t '#(atom #f)))) (if B1894@ls/false (apply (lambda () '#f) B1894@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1892@t)))))))) B1888@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1886@t))))))))) (B174f@parent-rcd-code (lambda (B1866@clause*) (let ((B1868@t (B1749@get-clause 'parent B1866@clause*))) (let ((B186a@ls/false (Bd79@syntax-dispatch B1868@t '(_ any)))) (if B186a@ls/false (apply (lambda (B186c@name) (list 'record-constructor-descriptor B186c@name)) B186a@ls/false) (let ((B186e@t B1868@t)) (let ((B1870@ls/false (Bd79@syntax-dispatch B186e@t '#(atom #f)))) (if B1870@ls/false (apply (lambda () (let ((B1872@t (B1749@get-clause 'parent-rtd B1866@clause*))) (let ((B1874@ls/false (Bd79@syntax-dispatch B1872@t '(_ any any)))) (if B1874@ls/false (apply (lambda (B1876@rtd B1877@rcd) B1877@rcd) B1874@ls/false) (let ((B187a@t B1872@t)) (let ((B187c@ls/false (Bd79@syntax-dispatch B187a@t '#(atom #f)))) (if B187c@ls/false (apply (lambda () '#f) B187c@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B187a@t)))))))) B1870@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B186e@t))))))))) (B1751@foo-rcd-code (lambda (B185e@clause* B185f@foo-rtd B1860@protocol B1861@parent-rcd-code) (list 'make-record-constructor-descriptor B185f@foo-rtd B1861@parent-rcd-code B1860@protocol))) (B1753@get-protocol-code (lambda (B1852@clause*) (let ((B1854@t (B1749@get-clause 'protocol B1852@clause*))) (let ((B1856@ls/false (Bd79@syntax-dispatch B1854@t '(_ any)))) (if B1856@ls/false (apply (lambda (B1858@expr) B1858@expr) B1856@ls/false) (let ((B185a@t B1854@t)) (let ((B185c@ls/false (Bd79@syntax-dispatch B185a@t '_))) (if B185c@ls/false (apply (lambda () '#f) B185c@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B185a@t))))))))) (B1755@get-fields (lambda (B1840@clause*) (let ((B1842@t B1840@clause*)) (let ((B1844@ls/false (Bd79@syntax-dispatch B1842@t '()))) (if B1844@ls/false (apply (lambda () '()) B1844@ls/false) (let ((B1846@t B1842@t)) (let ((B1848@ls/false (Bd79@syntax-dispatch B1846@t '((#(scheme-id fields) . each-any) . _)))) (if B1848@ls/false (apply (lambda (B184a@f*) B184a@f*) B1848@ls/false) (let ((B184c@t B1846@t)) (let ((B184e@ls/false (Bd79@syntax-dispatch B184c@t '(_ . any)))) (if B184e@ls/false (apply (lambda (B1850@rest) (B1755@get-fields B1850@rest)) B184e@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B184c@t)))))))))))) (B1757@get-mutator-indices (lambda (B1828@fields) (let B182e@f ((B182a@fields B1828@fields) (B182b@i '0)) (let ((B1830@t B182a@fields)) (let ((B1832@ls/false (Bd79@syntax-dispatch B1830@t '()))) (if B1832@ls/false (apply (lambda () '()) B1832@ls/false) (let ((B1834@t B1830@t)) (let ((B1836@ls/false (Bd79@syntax-dispatch B1834@t '((#(scheme-id mutable) . _) . any)))) (if B1836@ls/false (apply (lambda (B1838@rest) (cons B182b@i (B182e@f B1838@rest (+ B182b@i '1)))) B1836@ls/false) (let ((B183a@t B1834@t)) (let ((B183c@ls/false (Bd79@syntax-dispatch B183a@t '(_ . any)))) (if B183c@ls/false (apply (lambda (B183e@rest) (B182e@f B183e@rest (+ B182b@i '1))) B183c@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B183a@t))))))))))))) (B1759@get-mutators (lambda (B17fe@foo B17ff@fields) (letrec* ((B1803@gen-name (lambda (B1826@x) (Be5d@datum->syntax B17fe@foo (string->symbol (string-append (symbol->string (Be5f@syntax->datum B17fe@foo)) '"-" (symbol->string (Be5f@syntax->datum B1826@x)) '"-set!")))))) (let B1806@f ((B1804@fields B17ff@fields)) (let ((B1808@t B1804@fields)) (let ((B180a@ls/false (Bd79@syntax-dispatch B1808@t '()))) (if B180a@ls/false (apply (lambda () '()) B180a@ls/false) (let ((B180c@t B1808@t)) (let ((B180e@ls/false (Bd79@syntax-dispatch B180c@t '((#(scheme-id mutable) any any any) . any)))) (if B180e@ls/false (apply (lambda (B1810@name B1811@accessor B1812@mutator B1813@rest) (cons B1812@mutator (B1806@f B1813@rest))) B180e@ls/false) (let ((B1818@t B180c@t)) (let ((B181a@ls/false (Bd79@syntax-dispatch B1818@t '((#(scheme-id mutable) any) . any)))) (if B181a@ls/false (apply (lambda (B181c@name B181d@rest) (cons (B1803@gen-name B181c@name) (B1806@f B181d@rest))) B181a@ls/false) (let ((B1820@t B1818@t)) (let ((B1822@ls/false (Bd79@syntax-dispatch B1820@t '(_ . any)))) (if B1822@ls/false (apply (lambda (B1824@rest) (B1806@f B1824@rest)) B1822@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1820@t))))))))))))))))) (B175b@get-accessors (lambda (B17ba@foo B17bb@fields) (letrec* ((B17bf@gen-name (lambda (B17fc@x) (Be5d@datum->syntax B17ba@foo (string->symbol (string-append (symbol->string (Be5f@syntax->datum B17ba@foo)) '"-" (symbol->string (Be5f@syntax->datum B17fc@x)))))))) (map (lambda (B17c0@field) (let ((B17c2@t B17c0@field)) (let ((B17c4@ls/false (Bd79@syntax-dispatch B17c2@t '(#(scheme-id mutable) any any any)))) (if (and B17c4@ls/false (apply (lambda (B17c6@name B17c7@accessor B17c8@mutator) (Bb72@id? B17c7@accessor)) B17c4@ls/false)) (apply (lambda (B17cc@name B17cd@accessor B17ce@mutator) B17cd@accessor) B17c4@ls/false) (let ((B17d2@t B17c2@t)) (let ((B17d4@ls/false (Bd79@syntax-dispatch B17d2@t '(#(scheme-id immutable) any any)))) (if (and B17d4@ls/false (apply (lambda (B17d6@name B17d7@accessor) (Bb72@id? B17d7@accessor)) B17d4@ls/false)) (apply (lambda (B17da@name B17db@accessor) B17db@accessor) B17d4@ls/false) (let ((B17de@t B17d2@t)) (let ((B17e0@ls/false (Bd79@syntax-dispatch B17de@t '(#(scheme-id mutable) any)))) (if (and B17e0@ls/false (apply (lambda (B17e2@name) (Bb72@id? B17e2@name)) B17e0@ls/false)) (apply (lambda (B17e4@name) (B17bf@gen-name B17e4@name)) B17e0@ls/false) (let ((B17e6@t B17de@t)) (let ((B17e8@ls/false (Bd79@syntax-dispatch B17e6@t '(#(scheme-id immutable) any)))) (if (and B17e8@ls/false (apply (lambda (B17ea@name) (Bb72@id? B17ea@name)) B17e8@ls/false)) (apply (lambda (B17ec@name) (B17bf@gen-name B17ec@name)) B17e8@ls/false) (let ((B17ee@t B17e6@t)) (let ((B17f0@ls/false (Bd79@syntax-dispatch B17ee@t 'any))) (if (and B17f0@ls/false (apply (lambda (B17f2@name) (Bb72@id? B17f2@name)) B17f0@ls/false)) (apply (lambda (B17f4@name) (B17bf@gen-name B17f4@name)) B17f0@ls/false) (let ((B17f6@t B17ee@t)) (let ((B17f8@ls/false (Bd79@syntax-dispatch B17f6@t 'any))) (if B17f8@ls/false (apply (lambda (B17fa@others) (Be59@syntax-violation '#f '"invalid field spec" B17c0@field)) B17f8@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B17f6@t)))))))))))))))))))) B17bb@fields)))) (B175d@enumerate (lambda (B17b2@ls) (let B17b8@f ((B17b4@ls B17b2@ls) (B17b5@i '0)) (if (null? B17b4@ls) '() (cons B17b5@i (B17b8@f (cdr B17b4@ls) (+ B17b5@i '1))))))) (B175f@do-define-record (lambda (B178a@namespec B178b@clause*) (let ((B178e@foo (B1743@get-record-name B178a@namespec))) (let ((B1790@foo-rtd (gensym))) (let ((B1792@foo-rcd (gensym))) (let ((B1794@protocol (gensym))) (let ((B1796@make-foo (B1745@get-record-constructor-name B178a@namespec))) (let ((B1798@fields (B1755@get-fields B178b@clause*))) (let ((B179a@idx* (B175d@enumerate B1798@fields))) (let ((B179c@foo-x* (B175b@get-accessors B178e@foo B1798@fields))) (let ((B179e@set-foo-x!* (B1759@get-mutators B178e@foo B1798@fields))) (let ((B17a0@set-foo-idx* (B1757@get-mutator-indices B1798@fields))) (let ((B17a2@foo? (B1747@get-record-predicate-name B178a@namespec))) (let ((B17a4@foo-rtd-code (B174b@foo-rtd-code B178e@foo B178b@clause* (B174d@parent-rtd-code B178b@clause*)))) (let ((B17a6@foo-rcd-code (B1751@foo-rcd-code B178b@clause* B1790@foo-rtd B1794@protocol (B174f@parent-rcd-code B178b@clause*)))) (let ((B17a8@protocol-code (B1753@get-protocol-code B178b@clause*))) (Bd2f@bless (cons 'begin (cons (list 'define B1790@foo-rtd B17a4@foo-rtd-code) (cons (list 'define B1794@protocol B17a8@protocol-code) (cons (list 'define B1792@foo-rcd B17a6@foo-rcd-code) (cons (list 'define-syntax B178e@foo (list 'list ''$rtd (list 'syntax B1790@foo-rtd) (list 'syntax B1792@foo-rcd))) (cons (list 'define B17a2@foo? (list 'record-predicate B1790@foo-rtd)) (cons (list 'define B1796@make-foo (list 'record-constructor B1792@foo-rcd)) (append (map (lambda (B17aa@foo-x B17ab@idx) (list 'define B17aa@foo-x (list 'record-accessor B1790@foo-rtd B17ab@idx))) B179c@foo-x* B179a@idx*) (map (lambda (B17ae@set-foo-x! B17af@idx) (list 'define B17ae@set-foo-x! (list 'record-mutator B1790@foo-rtd B17af@idx))) B179e@set-foo-x!* B17a0@set-foo-idx*)))))))))))))))))))))))))) (B1761@verify-clauses (lambda (B176a@x B176b@cls*) (letrec* ((B176f@valid-kwds (map Bd2f@bless '(fields parent parent-rtd protocol sealed opaque nongenerative))) (B1771@free-id-member? (lambda (B1786@x B1787@ls) (and (pair? B1787@ls) (or (Bb78@free-id=? B1786@x (car B1787@ls)) (B1771@free-id-member? B1786@x (cdr B1787@ls))))))) (let B1776@f ((B1772@cls* B176b@cls*) (B1773@seen* '())) (if (not (null? B1772@cls*)) (let ((B1778@t (car B1772@cls*))) (let ((B177a@ls/false (Bd79@syntax-dispatch B1778@t '(any . any)))) (if B177a@ls/false (apply (lambda (B177c@kwd B177d@rest) (if (or (not (Bb72@id? B177c@kwd)) (not (B1771@free-id-member? B177c@kwd B176f@valid-kwds))) (Be59@syntax-violation '#f '"not a valid define-record-type keyword" B177c@kwd) (if (Bb7e@bound-id-member? B177c@kwd B1773@seen*) (Be59@syntax-violation '#f '"duplicate use of keyword " B176a@x B177c@kwd) (B1776@f (cdr B1772@cls*) (cons B177c@kwd B1773@seen*))))) B177a@ls/false) (let ((B1780@t B1778@t)) (let ((B1782@ls/false (Bd79@syntax-dispatch B1780@t 'any))) (if B1782@ls/false (apply (lambda (B1784@cls) (Be59@syntax-violation '#f '"malformed define-record-type clause" B1784@cls)) B1782@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1780@t))))))) (void))))))) (let ((B1762@t B173e@x)) (let ((B1764@ls/false (Bd79@syntax-dispatch B1762@t '(_ any . each-any)))) (if B1764@ls/false (apply (lambda (B1766@namespec B1767@clause*) (begin (B1761@verify-clauses B173e@x B1767@clause*) (B175f@do-define-record B1766@namespec B1767@clause*))) B1764@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1762@t))))))) (set! B2849@Bd6d@define-record-type-macro Bd6d@define-record-type-macro) (set! Bd6f@define-condition-type-macro (lambda (B193a@x) (letrec* ((B193d@mkname (lambda (B196a@name B196b@suffix) (Be5d@datum->syntax B196a@name (string->symbol (string-append (symbol->string (Be5f@syntax->datum B196a@name)) B196b@suffix)))))) (let ((B193e@t B193a@x)) (let ((B1940@ls/false (Bd79@syntax-dispatch B193e@t '(any any any any any . #(each (any any)))))) (if (and B1940@ls/false (apply (lambda (B1942@ctxt B1943@name B1944@super B1945@constructor B1946@predicate B1947@field* B1948@accessor*) (and (Bb72@id? B1943@name) (Bb72@id? B1944@super) (Bb72@id? B1945@constructor) (Bb72@id? B1946@predicate) (for-all Bb72@id? B1947@field*) (for-all Bb72@id? B1948@accessor*))) B1940@ls/false)) (apply (lambda (B1950@ctxt B1951@name B1952@super B1953@constructor B1954@predicate B1955@field* B1956@accessor*) (let ((B195e@aux-accessor* (map (lambda (B1960@x) (gensym)) B1956@accessor*))) (Bd2f@bless (cons 'begin (cons (cons 'define-record-type (cons (list B1951@name B1953@constructor (gensym)) (cons (list 'parent B1952@super) (cons (cons 'fields (map (lambda (B1962@field B1963@aux) (list 'immutable B1962@field B1963@aux)) B1955@field* B195e@aux-accessor*)) '((nongenerative) (sealed #f) (opaque #f)))))) (cons (list 'define B1954@predicate (list 'condition-predicate (list 'record-type-descriptor B1951@name))) (map (lambda (B1966@accessor B1967@aux) (list 'define B1966@accessor (list 'condition-accessor (list 'record-type-descriptor B1951@name) B1967@aux))) B1956@accessor* B195e@aux-accessor*))))))) B1940@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B193e@t))))))) (set! B284a@Bd6f@define-condition-type-macro Bd6f@define-condition-type-macro) (set! Bd71@incorrect-usage-macro (lambda (B196e@e) (Be59@syntax-violation '#f '"incorrect usage of auxiliary keyword" B196e@e))) (set! B284b@Bd71@incorrect-usage-macro Bd71@incorrect-usage-macro) (set! Bd73@parameterize-macro (lambda (B1970@e) (let ((B1972@t B1970@e)) (let ((B1974@ls/false (Bd79@syntax-dispatch B1972@t '(_ () any . each-any)))) (if B1974@ls/false (apply (lambda (B1976@b B1977@b*) (Bd2f@bless (cons 'let (cons '() (cons B1976@b B1977@b*))))) B1974@ls/false) (let ((B197a@t B1972@t)) (let ((B197c@ls/false (Bd79@syntax-dispatch B197a@t '(_ #(each (any any)) any . each-any)))) (if B197c@ls/false (apply (lambda (B197e@olhs* B197f@orhs* B1980@b B1981@b*) (let ((B1986@lhs* (Be47@generate-temporaries B197e@olhs*)) (B1987@rhs* (Be47@generate-temporaries B197f@orhs*))) (Bd2f@bless (cons (list 'lambda (append B1986@lhs* B1987@rhs*) (list 'let (list (list 'swap (cons 'lambda (cons '() (map (lambda (B198a@lhs B198b@rhs) (list 'let (list (list 't (list B198a@lhs))) (list B198a@lhs B198b@rhs) (cons 'set! (cons B198b@rhs '(t))))) B1986@lhs* B1987@rhs*))))) (cons 'dynamic-wind (cons 'swap (cons (cons 'lambda (cons '() (cons B1980@b B1981@b*))) '(swap)))))) (append B197e@olhs* B197f@orhs*))))) B197c@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B197a@t))))))))) (set! B284c@Bd73@parameterize-macro Bd73@parameterize-macro) (set! Bd75@foreign-call-transformer (lambda (B198e@e B198f@r B1990@mr) (let ((B1994@t B198e@e)) (let ((B1996@ls/false (Bd79@syntax-dispatch B1994@t '(_ any . each-any)))) (if B1996@ls/false (apply (lambda (B1998@name B1999@arg*) (cons 'foreign-call (cons (Bd9b@chi-expr B1998@name B198f@r B1990@mr) (Bd97@chi-expr* B1999@arg* B198f@r B1990@mr)))) B1996@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1994@t)))))) (set! B284d@Bd75@foreign-call-transformer Bd75@foreign-call-transformer) (set! Bd77@convert-pattern (lambda (B199c@pattern B199d@keys) (letrec* ((B19a1@cvt* (lambda (B1a40@p* B1a41@n B1a42@ids) (if (null? B1a40@p*) (values '() B1a42@ids) (call-with-values (lambda () (B19a1@cvt* (cdr B1a40@p*) B1a41@n B1a42@ids)) (lambda (B1a4a@B1a47 B1a4b@B1a49) (let ((B1a4e@ids B1a4b@B1a49) (B1a4f@y B1a4a@B1a47)) (call-with-values (lambda () (B19a3@cvt (car B1a40@p*) B1a41@n B1a4e@ids)) (lambda (B1a56@B1a53 B1a57@B1a55) (let ((B1a5a@ids B1a57@B1a55) (B1a5b@x B1a56@B1a53)) (values (cons B1a5b@x B1a4f@y) B1a5a@ids)))))))))) (B19a3@cvt (lambda (B19a4@p B19a5@n B19a6@ids) (let ((B19aa@t B19a4@p)) (let ((B19ac@ls/false (Bd79@syntax-dispatch B19aa@t 'any))) (if (and B19ac@ls/false (apply (lambda (B19ae@id) (Bb72@id? B19ae@id)) B19ac@ls/false)) (apply (lambda (B19b0@id) (if (Bb7e@bound-id-member? B19a4@p B199d@keys) (values (vector 'free-id B19a4@p) B19a6@ids) (if (Bb78@free-id=? B19a4@p (Bd01@scheme-stx '_)) (values '_ B19a6@ids) (values 'any (cons (cons B19a4@p B19a5@n) B19a6@ids))))) B19ac@ls/false) (let ((B19b2@t B19aa@t)) (let ((B19b4@ls/false (Bd79@syntax-dispatch B19b2@t '(any any)))) (if (and B19b4@ls/false (apply (lambda (B19b6@p B19b7@dots) (Bd7b@ellipsis? B19b7@dots)) B19b4@ls/false)) (apply (lambda (B19ba@p B19bb@dots) (call-with-values (lambda () (B19a3@cvt B19ba@p (+ B19a5@n '1) B19a6@ids)) (lambda (B19c2@B19bf B19c3@B19c1) (let ((B19c6@ids B19c3@B19c1) (B19c7@p B19c2@B19bf)) (values (if (eq? B19c7@p 'any) 'each-any (vector 'each B19c7@p)) B19c6@ids))))) B19b4@ls/false) (let ((B19ca@t B19b2@t)) (let ((B19cc@ls/false (Bd79@syntax-dispatch B19ca@t '(any any . #(each+ any () any))))) (if (and B19cc@ls/false (apply (lambda (B19ce@x B19cf@dots B19d0@ys B19d1@z) (Bd7b@ellipsis? B19cf@dots)) B19cc@ls/false)) (apply (lambda (B19d6@x B19d7@dots B19d8@ys B19d9@z) (call-with-values (lambda () (B19a3@cvt B19d9@z B19a5@n B19a6@ids)) (lambda (B19e2@B19df B19e3@B19e1) (let ((B19e6@ids B19e3@B19e1) (B19e7@z B19e2@B19df)) (call-with-values (lambda () (B19a1@cvt* B19d8@ys B19a5@n B19e6@ids)) (lambda (B19ee@B19eb B19ef@B19ed) (let ((B19f2@ids B19ef@B19ed) (B19f3@ys B19ee@B19eb)) (call-with-values (lambda () (B19a3@cvt B19d6@x (+ B19a5@n '1) B19f2@ids)) (lambda (B19fa@B19f7 B19fb@B19f9) (let ((B19fe@ids B19fb@B19f9) (B19ff@x B19fa@B19f7)) (values (vector 'each+ B19ff@x (reverse B19f3@ys) B19e7@z) B19fe@ids))))))))))) B19cc@ls/false) (let ((B1a02@t B19ca@t)) (let ((B1a04@ls/false (Bd79@syntax-dispatch B1a02@t '(any . any)))) (if B1a04@ls/false (apply (lambda (B1a06@x B1a07@y) (call-with-values (lambda () (B19a3@cvt B1a07@y B19a5@n B19a6@ids)) (lambda (B1a0e@B1a0b B1a0f@B1a0d) (let ((B1a12@ids B1a0f@B1a0d) (B1a13@y B1a0e@B1a0b)) (call-with-values (lambda () (B19a3@cvt B1a06@x B19a5@n B1a12@ids)) (lambda (B1a1a@B1a17 B1a1b@B1a19) (let ((B1a1e@ids B1a1b@B1a19) (B1a1f@x B1a1a@B1a17)) (values (cons B1a1f@x B1a13@y) B1a1e@ids)))))))) B1a04@ls/false) (let ((B1a22@t B1a02@t)) (let ((B1a24@ls/false (Bd79@syntax-dispatch B1a22@t '()))) (if B1a24@ls/false (apply (lambda () (values '() B19a6@ids)) B1a24@ls/false) (let ((B1a26@t B1a22@t)) (let ((B1a28@ls/false (Bd79@syntax-dispatch B1a26@t '#(vector each-any)))) (if (and B1a28@ls/false (apply (lambda (B1a2a@p) (not (Bb3e@stx? B1a2a@p))) B1a28@ls/false)) (apply (lambda (B1a2c@p) (call-with-values (lambda () (B19a3@cvt B1a2c@p B19a5@n B19a6@ids)) (lambda (B1a32@B1a2f B1a33@B1a31) (let ((B1a36@ids B1a33@B1a31) (B1a37@p B1a32@B1a2f)) (values (vector 'vector B1a37@p) B1a36@ids))))) B1a28@ls/false) (let ((B1a3a@t B1a26@t)) (let ((B1a3c@ls/false (Bd79@syntax-dispatch B1a3a@t 'any))) (if B1a3c@ls/false (apply (lambda (B1a3e@datum) (values (vector 'atom (Bb86@stx->datum B1a3e@datum)) B19a6@ids)) B1a3c@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1a3a@t))))))))))))))))))))))))) (B19a3@cvt B199c@pattern '0 '())))) (set! B284e@Bd77@convert-pattern Bd77@convert-pattern) (set! Bd79@syntax-dispatch (letrec* ((B1a5f@stx^ (lambda (B1b3a@e B1b3b@m* B1b3c@s* B1b3d@ae*) (if (and (null? B1b3b@m*) (null? B1b3c@s*) (null? B1b3d@ae*)) B1b3a@e (Bb5a@mkstx B1b3a@e B1b3b@m* B1b3c@s* B1b3d@ae*)))) (B1a61@match-each (lambda (B1b1a@e B1b1b@p B1b1c@m* B1b1d@s* B1b1e@ae*) (if (pair? B1b1a@e) (let ((B1b24@first (B1a6d@match (car B1b1a@e) B1b1b@p B1b1c@m* B1b1d@s* B1b1e@ae* '()))) (and B1b24@first (let ((B1b26@rest (B1a61@match-each (cdr B1b1a@e) B1b1b@p B1b1c@m* B1b1d@s* B1b1e@ae*))) (and B1b26@rest (cons B1b24@first B1b26@rest))))) (if (null? B1b1a@e) '() (if (Bb3e@stx? B1b1a@e) (and (not (Baf8@top-marked? B1b1c@m*)) (call-with-values (lambda () (join-wraps B1b1c@m* B1b1d@s* B1b1e@ae* B1b1a@e)) (lambda (B1b2e@B1b29 B1b2f@B1b2b B1b30@B1b2d) (let ((B1b34@ae* B1b30@B1b2d) (B1b35@s* B1b2f@B1b2b) (B1b36@m* B1b2e@B1b29)) (B1a61@match-each (Bb40@stx-expr B1b1a@e) B1b1b@p B1b36@m* B1b35@s* B1b34@ae*))))) (if (B6b6@B588@annotation? B1b1a@e) (B1a61@match-each (B6b8@B58c@annotation-expression B1b1a@e) B1b1b@p B1b1c@m* B1b1d@s* B1b1e@ae*) '#f)))))) (B1a63@match-each+ (lambda (B1ada@e B1adb@x-pat B1adc@y-pat B1add@z-pat B1ade@m* B1adf@s* B1ae0@ae* B1ae1@r) (let B1af2@f ((B1aea@e B1ada@e) (B1aeb@m* B1ade@m*) (B1aec@s* B1adf@s*) (B1aed@ae* B1ae0@ae*)) (if (pair? B1aea@e) (call-with-values (lambda () (B1af2@f (cdr B1aea@e) B1aeb@m* B1aec@s* B1aed@ae*)) (lambda (B1afa@B1af5 B1afb@B1af7 B1afc@B1af9) (let ((B1b00@r B1afc@B1af9) (B1b01@y-pat B1afb@B1af7) (B1b02@xr* B1afa@B1af5)) (if B1b00@r (if (null? B1b01@y-pat) (let ((B1b06@xr (B1a6d@match (car B1aea@e) B1adb@x-pat B1aeb@m* B1aec@s* B1aed@ae* '()))) (if B1b06@xr (values (cons B1b06@xr B1b02@xr*) B1b01@y-pat B1b00@r) (values '#f '#f '#f))) (values '() (cdr B1b01@y-pat) (B1a6d@match (car B1aea@e) (car B1b01@y-pat) B1aeb@m* B1aec@s* B1aed@ae* B1b00@r))) (values '#f '#f '#f))))) (if (Bb3e@stx? B1aea@e) (if (Baf8@top-marked? B1aeb@m*) (values '() B1adc@y-pat (B1a6d@match B1aea@e B1add@z-pat B1aeb@m* B1aec@s* B1aed@ae* B1ae1@r)) (call-with-values (lambda () (join-wraps B1aeb@m* B1aec@s* B1aed@ae* B1aea@e)) (lambda (B1b0e@B1b09 B1b0f@B1b0b B1b10@B1b0d) (let ((B1b14@ae* B1b10@B1b0d) (B1b15@s* B1b0f@B1b0b) (B1b16@m* B1b0e@B1b09)) (B1af2@f (Bb40@stx-expr B1aea@e) B1b16@m* B1b15@s* B1b14@ae*))))) (if (B6b6@B588@annotation? B1aea@e) (B1af2@f (B6b8@B58c@annotation-expression B1aea@e) B1aeb@m* B1aec@s* B1aed@ae*) (values '() B1adc@y-pat (B1a6d@match B1aea@e B1add@z-pat B1aeb@m* B1aec@s* B1aed@ae* B1ae1@r)))))))) (B1a65@match-each-any (lambda (B1abe@e B1abf@m* B1ac0@s* B1ac1@ae*) (if (pair? B1abe@e) (let ((B1ac6@l (B1a65@match-each-any (cdr B1abe@e) B1abf@m* B1ac0@s* B1ac1@ae*))) (and B1ac6@l (cons (B1a5f@stx^ (car B1abe@e) B1abf@m* B1ac0@s* B1ac1@ae*) B1ac6@l))) (if (null? B1abe@e) '() (if (Bb3e@stx? B1abe@e) (and (not (Baf8@top-marked? B1abf@m*)) (call-with-values (lambda () (join-wraps B1abf@m* B1ac0@s* B1ac1@ae* B1abe@e)) (lambda (B1ace@B1ac9 B1acf@B1acb B1ad0@B1acd) (let ((B1ad4@ae* B1ad0@B1acd) (B1ad5@s* B1acf@B1acb) (B1ad6@m* B1ace@B1ac9)) (B1a65@match-each-any (Bb40@stx-expr B1abe@e) B1ad6@m* B1ad5@s* B1ad4@ae*))))) (if (B6b6@B588@annotation? B1abe@e) (B1a65@match-each-any (B6b8@B58c@annotation-expression B1abe@e) B1abf@m* B1ac0@s* B1ac1@ae*) '#f)))))) (B1a67@match-empty (lambda (B1ab8@p B1ab9@r) (if (null? B1ab8@p) B1ab9@r (if (eq? B1ab8@p '_) B1ab9@r (if (eq? B1ab8@p 'any) (cons '() B1ab9@r) (if (pair? B1ab8@p) (B1a67@match-empty (car B1ab8@p) (B1a67@match-empty (cdr B1ab8@p) B1ab9@r)) (if (eq? B1ab8@p 'each-any) (cons '() B1ab9@r) (let ((B1abc@t (vector-ref B1ab8@p '0))) (if (memv B1abc@t '(each)) (B1a67@match-empty (vector-ref B1ab8@p '1) B1ab9@r) (if (memv B1abc@t '(each+)) (B1a67@match-empty (vector-ref B1ab8@p '1) (B1a67@match-empty (reverse (vector-ref B1ab8@p '2)) (B1a67@match-empty (vector-ref B1ab8@p '3) B1ab9@r))) (if (memv B1abc@t '(free-id atom)) B1ab9@r (if (memv B1abc@t '(scheme-id atom)) B1ab9@r (if (memv B1abc@t '(vector)) (B1a67@match-empty (vector-ref B1ab8@p '1) B1ab9@r) (assertion-violation 'syntax-dispatch '"invalid pattern" B1ab8@p)))))))))))))) (B1a69@combine (lambda (B1ab4@r* B1ab5@r) (if (null? (car B1ab4@r*)) B1ab5@r (cons (map car B1ab4@r*) (B1a69@combine (map cdr B1ab4@r*) B1ab5@r))))) (B1a6b@match* (lambda (B1a90@e B1a91@p B1a92@m* B1a93@s* B1a94@ae* B1a95@r) (if (null? B1a91@p) (and (null? B1a90@e) B1a95@r) (if (pair? B1a91@p) (and (pair? B1a90@e) (B1a6d@match (car B1a90@e) (car B1a91@p) B1a92@m* B1a93@s* B1a94@ae* (B1a6d@match (cdr B1a90@e) (cdr B1a91@p) B1a92@m* B1a93@s* B1a94@ae* B1a95@r))) (if (eq? B1a91@p 'each-any) (let ((B1a9c@l (B1a65@match-each-any B1a90@e B1a92@m* B1a93@s* B1a94@ae*))) (and B1a9c@l (cons B1a9c@l B1a95@r))) (let ((B1a9e@t (vector-ref B1a91@p '0))) (if (memv B1a9e@t '(each)) (if (null? B1a90@e) (B1a67@match-empty (vector-ref B1a91@p '1) B1a95@r) (let ((B1aa0@r* (B1a61@match-each B1a90@e (vector-ref B1a91@p '1) B1a92@m* B1a93@s* B1a94@ae*))) (and B1aa0@r* (B1a69@combine B1aa0@r* B1a95@r)))) (if (memv B1a9e@t '(free-id)) (and (symbol? B1a90@e) (Baf8@top-marked? B1a92@m*) (Bb78@free-id=? (B1a5f@stx^ B1a90@e B1a92@m* B1a93@s* B1a94@ae*) (vector-ref B1a91@p '1)) B1a95@r) (if (memv B1a9e@t '(scheme-id)) (and (symbol? B1a90@e) (Baf8@top-marked? B1a92@m*) (Bb78@free-id=? (B1a5f@stx^ B1a90@e B1a92@m* B1a93@s* B1a94@ae*) (Bd01@scheme-stx (vector-ref B1a91@p '1))) B1a95@r) (if (memv B1a9e@t '(each+)) (call-with-values (lambda () (B1a63@match-each+ B1a90@e (vector-ref B1a91@p '1) (vector-ref B1a91@p '2) (vector-ref B1a91@p '3) B1a92@m* B1a93@s* B1a94@ae* B1a95@r)) (lambda (B1aa8@B1aa3 B1aa9@B1aa5 B1aaa@B1aa7) (let ((B1aae@r B1aaa@B1aa7) (B1aaf@y-pat B1aa9@B1aa5) (B1ab0@xr* B1aa8@B1aa3)) (and B1aae@r (null? B1aaf@y-pat) (if (null? B1ab0@xr*) (B1a67@match-empty (vector-ref B1a91@p '1) B1aae@r) (B1a69@combine B1ab0@xr* B1aae@r)))))) (if (memv B1a9e@t '(atom)) (and (fast-equal? (vector-ref B1a91@p '1) (Bb84@strip B1a90@e B1a92@m*)) B1a95@r) (if (memv B1a9e@t '(vector)) (and (vector? B1a90@e) (B1a6d@match (vector->list B1a90@e) (vector-ref B1a91@p '1) B1a92@m* B1a93@s* B1a94@ae* B1a95@r)) (assertion-violation 'syntax-dispatch '"invalid pattern" B1a91@p))))))))))))) (B1a6d@match (lambda (B1a72@e B1a73@p B1a74@m* B1a75@s* B1a76@ae* B1a77@r) (if (not B1a77@r) '#f (if (eq? B1a73@p '_) B1a77@r (if (eq? B1a73@p 'any) (cons (B1a5f@stx^ B1a72@e B1a74@m* B1a75@s* B1a76@ae*) B1a77@r) (if (Bb3e@stx? B1a72@e) (and (not (Baf8@top-marked? B1a74@m*)) (call-with-values (lambda () (join-wraps B1a74@m* B1a75@s* B1a76@ae* B1a72@e)) (lambda (B1a84@B1a7f B1a85@B1a81 B1a86@B1a83) (let ((B1a8a@ae* B1a86@B1a83) (B1a8b@s* B1a85@B1a81) (B1a8c@m* B1a84@B1a7f)) (B1a6d@match (Bb40@stx-expr B1a72@e) B1a73@p B1a8c@m* B1a8b@s* B1a8a@ae* B1a77@r))))) (if (B6b6@B588@annotation? B1a72@e) (B1a6d@match (B6b8@B58c@annotation-expression B1a72@e) B1a73@p B1a74@m* B1a75@s* B1a76@ae* B1a77@r) (B1a6b@match* B1a72@e B1a73@p B1a74@m* B1a75@s* B1a76@ae* B1a77@r))))))))) (lambda (B1a6e@e B1a6f@p) (B1a6d@match B1a6e@e B1a6f@p '() '() '() '())))) (set! B284f@Bd79@syntax-dispatch Bd79@syntax-dispatch) (set! Bd7b@ellipsis? (lambda (B1b42@x) (and (Bb72@id? B1b42@x) (Bb78@free-id=? B1b42@x (Bd01@scheme-stx '...))))) (set! B2850@Bd7b@ellipsis? Bd7b@ellipsis?) (set! Bd7d@underscore? (lambda (B1b44@x) (and (Bb72@id? B1b44@x) (Bb78@free-id=? B1b44@x (Bd01@scheme-stx '_))))) (set! B2851@Bd7d@underscore? Bd7d@underscore?) (set! Bd7f@verify-literals (lambda (B1b46@lits B1b47@expr) (for-each (lambda (B1b4a@x) (if (or (not (Bb72@id? B1b4a@x)) (Bd7b@ellipsis? B1b4a@x) (Bd7d@underscore? B1b4a@x)) (Be59@syntax-violation '#f '"invalid literal" B1b47@expr B1b4a@x) (void))) B1b46@lits))) (set! B2852@Bd7f@verify-literals Bd7f@verify-literals) (set! Bd81@syntax-case-transformer (letrec* ((B1b4d@build-dispatch-call (lambda (B1bbe@pvars B1bbf@expr B1bc0@y B1bc1@r B1bc2@mr) (let ((B1bc8@ids (map car B1bbe@pvars)) (B1bc9@levels (map cdr B1bbe@pvars))) (let ((B1bcc@labels (map Bafe@gen-label B1bc8@ids)) (B1bcd@new-vars (map Bafa@gen-lexical B1bc8@ids))) (let ((B1bd0@body (Bd9b@chi-expr (Bb5e@add-subst (Bb32@make-full-rib B1bc8@ids B1bcc@labels) B1bbf@expr) (append (map (lambda (B1bd2@label B1bd3@var B1bd4@level) (cons B1bd2@label (Bb8c@make-binding 'syntax (cons B1bd3@var B1bd4@level)))) B1bcc@labels B1bcd@new-vars (map cdr B1bbe@pvars)) B1bc1@r) B1bc2@mr))) (list '(primitive apply) (Bad5@Ba07@build-lambda '#f B1bcd@new-vars B1bd0@body) B1bc0@y)))))) (B1b4f@invalid-ids-error (lambda (B1bb2@id* B1bb3@e B1bb4@class) (let B1bbc@find ((B1bb8@id* B1bb2@id*) (B1bb9@ok* '())) (if (null? B1bb8@id*) (Be59@syntax-violation '#f '"invalid syntax" B1bb3@e) (if (Bb72@id? (car B1bb8@id*)) (if (Bb7e@bound-id-member? (car B1bb8@id*) B1bb9@ok*) (Be55@syntax-error (car B1bb8@id*) '"duplicate " B1bb4@class) (B1bbc@find (cdr B1bb8@id*) (cons (car B1bb8@id*) B1bb9@ok*))) (Be55@syntax-error (car B1bb8@id*) '"invalid " B1bb4@class)))))) (B1b51@gen-clause (lambda (B1b8a@x B1b8b@keys B1b8c@clauses B1b8d@r B1b8e@mr B1b8f@pat B1b90@fender B1b91@expr) (call-with-values (lambda () (Bd77@convert-pattern B1b8f@pat B1b8b@keys)) (lambda (B1b9e@B1b9b B1b9f@B1b9d) (let ((B1ba2@pvars B1b9f@B1b9d) (B1ba3@p B1b9e@B1b9b)) (if (not (Bb7c@distinct-bound-ids? (map car B1ba2@pvars))) (B1b4f@invalid-ids-error (map car B1ba2@pvars) B1b8f@pat '"pattern variable") (if (not (for-all (lambda (B1ba6@x) (not (Bd7b@ellipsis? (car B1ba6@x)))) B1ba2@pvars)) (Be59@syntax-violation '#f '"misplaced ellipsis in syntax-case pattern" B1b8f@pat) (let ((B1ba8@y (Bafa@gen-lexical 'tmp))) (let ((B1baa@test (if (eq? B1b90@fender '#t) B1ba8@y (let ((B1bac@call (B1b4d@build-dispatch-call B1ba2@pvars B1b90@fender B1ba8@y B1b8d@r B1b8e@mr))) (list 'if B1ba8@y B1bac@call (list 'quote '#f)))))) (let ((B1bae@conseq (B1b4d@build-dispatch-call B1ba2@pvars B1b91@expr B1ba8@y B1b8d@r B1b8e@mr))) (let ((B1bb0@altern (B1b53@gen-syntax-case B1b8a@x B1b8b@keys B1b8c@clauses B1b8d@r B1b8e@mr))) (list (Bad5@Ba07@build-lambda '#f (list B1ba8@y) (list 'if B1baa@test B1bae@conseq B1bb0@altern)) (list '(primitive syntax-dispatch) B1b8a@x (list 'quote B1ba3@p)))))))))))))) (B1b53@gen-syntax-case (lambda (B1b68@x B1b69@keys B1b6a@clauses B1b6b@r B1b6c@mr) (if (null? B1b6a@clauses) (list '(primitive syntax-error) B1b68@x) (let ((B1b72@t (car B1b6a@clauses))) (let ((B1b74@ls/false (Bd79@syntax-dispatch B1b72@t '(any any)))) (if B1b74@ls/false (apply (lambda (B1b76@pat B1b77@expr) (if (and (Bb72@id? B1b76@pat) (not (Bb7e@bound-id-member? B1b76@pat B1b69@keys)) (not (Bd7b@ellipsis? B1b76@pat))) (if (Bb78@free-id=? B1b76@pat (Bd01@scheme-stx '_)) (Bd9b@chi-expr B1b77@expr B1b6b@r B1b6c@mr) (let ((B1b7a@lab (Bafe@gen-label B1b76@pat)) (B1b7b@lex (Bafa@gen-lexical B1b76@pat))) (let ((B1b7e@body (Bd9b@chi-expr (Bb5e@add-subst (Bb32@make-full-rib (list B1b76@pat) (list B1b7a@lab)) B1b77@expr) (cons (cons B1b7a@lab (Bb8c@make-binding 'syntax (cons B1b7b@lex '0))) B1b6b@r) B1b6c@mr))) (list (Bad5@Ba07@build-lambda '#f (list B1b7b@lex) B1b7e@body) B1b68@x)))) (B1b51@gen-clause B1b68@x B1b69@keys (cdr B1b6a@clauses) B1b6b@r B1b6c@mr B1b76@pat '#t B1b77@expr))) B1b74@ls/false) (let ((B1b80@t B1b72@t)) (let ((B1b82@ls/false (Bd79@syntax-dispatch B1b80@t '(any any any)))) (if B1b82@ls/false (apply (lambda (B1b84@pat B1b85@fender B1b86@expr) (B1b51@gen-clause B1b68@x B1b69@keys (cdr B1b6a@clauses) B1b6b@r B1b6c@mr B1b84@pat B1b85@fender B1b86@expr)) B1b82@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1b80@t))))))))))) (lambda (B1b54@e B1b55@r B1b56@mr) (let ((B1b5a@t B1b54@e)) (let ((B1b5c@ls/false (Bd79@syntax-dispatch B1b5a@t '(_ any each-any . each-any)))) (if B1b5c@ls/false (apply (lambda (B1b5e@expr B1b5f@keys B1b60@clauses) (begin (Bd7f@verify-literals B1b5f@keys B1b54@e) (let ((B1b64@x (Bafa@gen-lexical 'tmp))) (let ((B1b66@body (B1b53@gen-syntax-case B1b64@x B1b5f@keys B1b60@clauses B1b55@r B1b56@mr))) (list (Bad5@Ba07@build-lambda '#f (list B1b64@x) B1b66@body) (Bd9b@chi-expr B1b5e@expr B1b55@r B1b56@mr)))))) B1b5c@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1b5a@t))))))) (set! B2853@Bd81@syntax-case-transformer Bd81@syntax-case-transformer) (set! Bd83@ellipsis-map (lambda (B1bd8@proc B1bd9@ls . B1bdc@ls*) (letrec* ((B1bdf@who '...)) (begin (if (not (list? B1bd9@ls)) (assertion-violation B1bdf@who '"not a list" B1bd9@ls) (void)) (if (not (null? B1bdc@ls*)) (let ((B1be0@n (length B1bd9@ls))) (for-each (lambda (B1be2@x) (begin (if (not (list? B1be2@x)) (assertion-violation B1bdf@who '"not a list" B1be2@x) (void)) (if (not (= (length B1be2@x) B1be0@n)) (assertion-violation B1bdf@who '"length mismatch" B1bd9@ls B1be2@x) (void)))) B1bdc@ls*)) (void)) (apply map B1bd8@proc B1bd9@ls B1bdc@ls*))))) (set! B2854@Bd83@ellipsis-map Bd83@ellipsis-map) (set! Bd85@syntax-transformer (letrec* ((B1be5@gen-syntax (lambda (B1c5c@src B1c5d@e B1c5e@r B1c5f@maps B1c60@ellipsis? B1c61@vec?) (let ((B1c68@t B1c5d@e)) (let ((B1c6a@ls/false (Bd79@syntax-dispatch B1c68@t 'any))) (if (and B1c6a@ls/false (apply (lambda (B1c6c@dots) (B1c60@ellipsis? B1c6c@dots)) B1c6a@ls/false)) (apply (lambda (B1c6e@dots) (Be59@syntax-violation '#f '"misplaced ellipsis in syntax form" B1c5c@src)) B1c6a@ls/false) (let ((B1c70@t B1c68@t)) (let ((B1c72@ls/false (Bd79@syntax-dispatch B1c70@t 'any))) (if (and B1c72@ls/false (apply (lambda (B1c74@id) (Bb72@id? B1c74@id)) B1c72@ls/false)) (apply (lambda (B1c76@id) (let ((B1c78@label (Bb88@id->label B1c5d@e))) (let ((B1c7a@b (Bb8a@label->binding B1c78@label B1c5e@r))) (if (eq? (Bb8e@binding-type B1c7a@b) 'syntax) (call-with-values (lambda () (let ((B1c80@var.lev (Bb90@binding-value B1c7a@b))) (B1be7@gen-ref B1c5c@src (car B1c80@var.lev) (cdr B1c80@var.lev) B1c5f@maps))) (lambda (B1c82@B1c7d B1c83@B1c7f) (let ((B1c86@maps B1c83@B1c7f) (B1c87@var B1c82@B1c7d)) (values (list 'ref B1c87@var) B1c86@maps)))) (values (list 'quote B1c5d@e) B1c5f@maps))))) B1c72@ls/false) (let ((B1c8a@t B1c70@t)) (let ((B1c8c@ls/false (Bd79@syntax-dispatch B1c8a@t '(any any)))) (if (and B1c8c@ls/false (apply (lambda (B1c8e@dots B1c8f@e) (B1c60@ellipsis? B1c8e@dots)) B1c8c@ls/false)) (apply (lambda (B1c92@dots B1c93@e) (if B1c61@vec? (Be59@syntax-violation '#f '"misplaced ellipsis in syntax form" B1c5c@src) (B1be5@gen-syntax B1c5c@src B1c93@e B1c5e@r B1c5f@maps (lambda (B1c96@x) '#f) '#f))) B1c8c@ls/false) (let ((B1c98@t B1c8a@t)) (let ((B1c9a@ls/false (Bd79@syntax-dispatch B1c98@t '(any any . any)))) (if (and B1c9a@ls/false (apply (lambda (B1c9c@x B1c9d@dots B1c9e@y) (B1c60@ellipsis? B1c9d@dots)) B1c9a@ls/false)) (apply (lambda (B1ca2@x B1ca3@dots B1ca4@y) (let B1cba@f ((B1ca8@y B1ca4@y) (B1ca9@k (lambda (B1cac@maps) (call-with-values (lambda () (B1be5@gen-syntax B1c5c@src B1ca2@x B1c5e@r (cons '() B1cac@maps) B1c60@ellipsis? '#f)) (lambda (B1cb2@B1caf B1cb3@B1cb1) (let ((B1cb6@maps B1cb3@B1cb1) (B1cb7@x B1cb2@B1caf)) (if (null? (car B1cb6@maps)) (Be59@syntax-violation '#f '"extra ellipsis in syntax form" B1c5c@src) (values (B1bed@gen-map B1cb7@x (car B1cb6@maps)) (cdr B1cb6@maps))))))))) (let ((B1cbc@t B1ca8@y)) (let ((B1cbe@ls/false (Bd79@syntax-dispatch B1cbc@t '()))) (if B1cbe@ls/false (apply (lambda () (B1ca9@k B1c5f@maps)) B1cbe@ls/false) (let ((B1cc0@t B1cbc@t)) (let ((B1cc2@ls/false (Bd79@syntax-dispatch B1cc0@t '(any . any)))) (if (and B1cc2@ls/false (apply (lambda (B1cc4@dots B1cc5@y) (B1c60@ellipsis? B1cc4@dots)) B1cc2@ls/false)) (apply (lambda (B1cc8@dots B1cc9@y) (B1cba@f B1cc9@y (lambda (B1ccc@maps) (call-with-values (lambda () (B1ca9@k (cons '() B1ccc@maps))) (lambda (B1cd2@B1ccf B1cd3@B1cd1) (let ((B1cd6@maps B1cd3@B1cd1) (B1cd7@x B1cd2@B1ccf)) (if (null? (car B1cd6@maps)) (Be59@syntax-violation '#f '"extra ellipsis in syntax form" B1c5c@src) (values (B1beb@gen-mappend B1cd7@x (car B1cd6@maps)) (cdr B1cd6@maps))))))))) B1cc2@ls/false) (let ((B1cda@t B1cc0@t)) (let ((B1cdc@ls/false (Bd79@syntax-dispatch B1cda@t '_))) (if B1cdc@ls/false (apply (lambda () (call-with-values (lambda () (B1be5@gen-syntax B1c5c@src B1ca8@y B1c5e@r B1c5f@maps B1c60@ellipsis? B1c61@vec?)) (lambda (B1ce2@B1cdf B1ce3@B1ce1) (let ((B1ce6@maps B1ce3@B1ce1) (B1ce7@y B1ce2@B1cdf)) (call-with-values (lambda () (B1ca9@k B1ce6@maps)) (lambda (B1cee@B1ceb B1cef@B1ced) (let ((B1cf2@maps B1cef@B1ced) (B1cf3@x B1cee@B1ceb)) (values (B1be9@gen-append B1cf3@x B1ce7@y) B1cf2@maps)))))))) B1cdc@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1cda@t)))))))))))) B1c9a@ls/false) (let ((B1cf6@t B1c98@t)) (let ((B1cf8@ls/false (Bd79@syntax-dispatch B1cf6@t '(any . any)))) (if B1cf8@ls/false (apply (lambda (B1cfa@x B1cfb@y) (call-with-values (lambda () (B1be5@gen-syntax B1c5c@src B1cfa@x B1c5e@r B1c5f@maps B1c60@ellipsis? '#f)) (lambda (B1d02@B1cff B1d03@B1d01) (let ((B1d06@maps B1d03@B1d01) (B1d07@xnew B1d02@B1cff)) (call-with-values (lambda () (B1be5@gen-syntax B1c5c@src B1cfb@y B1c5e@r B1d06@maps B1c60@ellipsis? B1c61@vec?)) (lambda (B1d0e@B1d0b B1d0f@B1d0d) (let ((B1d12@maps B1d0f@B1d0d) (B1d13@ynew B1d0e@B1d0b)) (values (B1bef@gen-cons B1c5d@e B1cfa@x B1cfb@y B1d07@xnew B1d13@ynew) B1d12@maps)))))))) B1cf8@ls/false) (let ((B1d16@t B1cf6@t)) (let ((B1d18@ls/false (Bd79@syntax-dispatch B1d16@t '#(vector each-any)))) (if B1d18@ls/false (apply (lambda (B1d1a@ls) (call-with-values (lambda () (B1be5@gen-syntax B1c5c@src B1d1a@ls B1c5e@r B1c5f@maps B1c60@ellipsis? '#t)) (lambda (B1d20@B1d1d B1d21@B1d1f) (let ((B1d24@maps B1d21@B1d1f) (B1d25@lsnew B1d20@B1d1d)) (values (B1bf1@gen-vector B1c5d@e B1d1a@ls B1d25@lsnew) B1d24@maps))))) B1d18@ls/false) (let ((B1d28@t B1d16@t)) (let ((B1d2a@ls/false (Bd79@syntax-dispatch B1d28@t '_))) (if B1d2a@ls/false (apply (lambda () (values (list 'quote B1c5d@e) B1c5f@maps)) B1d2a@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1d28@t)))))))))))))))))))))))) (B1be7@gen-ref (lambda (B1c42@src B1c43@var B1c44@level B1c45@maps) (if (= B1c44@level '0) (values B1c43@var B1c45@maps) (if (null? B1c45@maps) (Be59@syntax-violation '#f '"missing ellipsis in syntax form" B1c42@src) (call-with-values (lambda () (B1be7@gen-ref B1c42@src B1c43@var (- B1c44@level '1) (cdr B1c45@maps))) (lambda (B1c4e@B1c4b B1c4f@B1c4d) (let ((B1c52@outer-maps B1c4f@B1c4d) (B1c53@outer-var B1c4e@B1c4b)) (let ((B1c56@t (assq B1c53@outer-var (car B1c45@maps)))) (if B1c56@t ((lambda (B1c58@b) (values (cdr B1c58@b) B1c45@maps)) B1c56@t) (let ((B1c5a@inner-var (Bafa@gen-lexical 'tmp))) (values B1c5a@inner-var (cons (cons (cons B1c53@outer-var B1c5a@inner-var) (car B1c45@maps)) B1c52@outer-maps)))))))))))) (B1be9@gen-append (lambda (B1c3e@x B1c3f@y) (if (fast-equal? B1c3f@y ''()) B1c3e@x (list 'append B1c3e@x B1c3f@y)))) (B1beb@gen-mappend (lambda (B1c3a@e B1c3b@map-env) (list 'apply '(primitive append) (B1bed@gen-map B1c3a@e B1c3b@map-env)))) (B1bed@gen-map (lambda (B1c28@e B1c29@map-env) (let ((B1c2c@formals (map cdr B1c29@map-env)) (B1c2d@actuals (map (lambda (B1c30@x) (list 'ref (car B1c30@x))) B1c29@map-env))) (if (eq? (car B1c28@e) 'ref) (car B1c2d@actuals) (if (for-all (lambda (B1c32@x) (and (eq? (car B1c32@x) 'ref) (memq (cadr B1c32@x) B1c2c@formals))) (cdr B1c28@e)) (let ((B1c34@args (map (let ((B1c36@r (map cons B1c2c@formals B1c2d@actuals))) (lambda (B1c38@x) (cdr (assq (cadr B1c38@x) B1c36@r)))) (cdr B1c28@e)))) (cons 'map (cons (list 'primitive (car B1c28@e)) B1c34@args))) (cons* 'map (list 'lambda B1c2c@formals B1c28@e) B1c2d@actuals)))))) (B1bef@gen-cons (lambda (B1c18@e B1c19@x B1c1a@y B1c1b@xnew B1c1c@ynew) (let ((B1c22@t (car B1c1c@ynew))) (if (memv B1c22@t '(quote)) (if (eq? (car B1c1b@xnew) 'quote) (let ((B1c24@xnew (cadr B1c1b@xnew)) (B1c25@ynew (cadr B1c1c@ynew))) (if (and (eq? B1c24@xnew B1c19@x) (eq? B1c25@ynew B1c1a@y)) (list 'quote B1c18@e) (list 'quote (cons B1c24@xnew B1c25@ynew)))) (if (null? (cadr B1c1c@ynew)) (list 'list B1c1b@xnew) (list 'cons B1c1b@xnew B1c1c@ynew))) (if (memv B1c22@t '(list)) (cons 'list (cons B1c1b@xnew (cdr B1c1c@ynew))) (list 'cons B1c1b@xnew B1c1c@ynew)))))) (B1bf1@gen-vector (lambda (B1c12@e B1c13@ls B1c14@lsnew) (if (eq? (car B1c14@lsnew) 'quote) (if (eq? (cadr B1c14@lsnew) B1c13@ls) (list 'quote B1c12@e) (list 'quote (list->vector (cadr B1c14@lsnew)))) (if (eq? (car B1c14@lsnew) 'list) (cons 'vector (cdr B1c14@lsnew)) (list 'list->vector B1c14@lsnew))))) (B1bf3@regen (lambda (B1c0c@x) (let ((B1c0e@t (car B1c0c@x))) (if (memv B1c0e@t '(ref)) (cadr B1c0c@x) (if (memv B1c0e@t '(primitive)) (list 'primitive (cadr B1c0c@x)) (if (memv B1c0e@t '(quote)) (list 'quote (cadr B1c0c@x)) (if (memv B1c0e@t '(lambda)) (Bad5@Ba07@build-lambda '#f (cadr B1c0c@x) (B1bf3@regen (caddr B1c0c@x))) (if (memv B1c0e@t '(map)) (let ((B1c10@ls (map B1bf3@regen (cdr B1c0c@x)))) (cons '(primitive ellipsis-map) B1c10@ls)) (cons (list 'primitive (car B1c0c@x)) (map B1bf3@regen (cdr B1c0c@x)))))))))))) (lambda (B1bf4@e B1bf5@r B1bf6@mr) (let ((B1bfa@t B1bf4@e)) (let ((B1bfc@ls/false (Bd79@syntax-dispatch B1bfa@t '(_ any)))) (if B1bfc@ls/false (apply (lambda (B1bfe@x) (call-with-values (lambda () (B1be5@gen-syntax B1bf4@e B1bfe@x B1bf5@r '() Bd7b@ellipsis? '#f)) (lambda (B1c04@B1c01 B1c05@B1c03) (let ((B1c08@maps B1c05@B1c03) (B1c09@e B1c04@B1c01)) (B1bf3@regen B1c09@e))))) B1bfc@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1bfa@t))))))) (set! B2855@Bd85@syntax-transformer Bd85@syntax-transformer) (set! Bd87@core-macro-transformer (lambda (B1d2c@name) (let ((B1d2e@t B1d2c@name)) (if (memv B1d2e@t '(quote)) Bd29@quote-transformer (if (memv B1d2e@t '(lambda)) Bd2d@lambda-transformer (if (memv B1d2e@t '(case-lambda)) Bd2b@case-lambda-transformer (if (memv B1d2e@t '(letrec)) Bd11@letrec-transformer (if (memv B1d2e@t '(letrec*)) Bd13@letrec*-transformer (if (memv B1d2e@t '(let)) Bd0f@let-transformer (if (memv B1d2e@t '(if)) Bd21@if-transformer (if (memv B1d2e@t '(and)) Bd23@and-transformer (if (memv B1d2e@t '(or)) Bd25@or-transformer (if (memv B1d2e@t '(foreign-call)) Bd75@foreign-call-transformer (if (memv B1d2e@t '(syntax-case)) Bd81@syntax-case-transformer (if (memv B1d2e@t '(syntax)) Bd85@syntax-transformer (if (memv B1d2e@t '(type-descriptor)) Bd17@type-descriptor-transformer (if (memv B1d2e@t '(record-type-descriptor)) Bd19@record-type-descriptor-transformer (if (memv B1d2e@t '(record-constructor-descriptor)) Bd1b@record-constructor-descriptor-transformer (if (memv B1d2e@t '(fluid-let-syntax)) Bd15@fluid-let-syntax-transformer (assertion-violation 'macro-transformer '"BUG: cannot find transformer" B1d2c@name)))))))))))))))))))) (set! B2856@Bd87@core-macro-transformer Bd87@core-macro-transformer) (set! Bd89@symbol-macro (lambda (B1d30@x B1d31@set) (let ((B1d34@t B1d30@x)) (let ((B1d36@ls/false (Bd79@syntax-dispatch B1d34@t '(_ any)))) (if (and B1d36@ls/false (apply (lambda (B1d38@name) (and (Bb72@id? B1d38@name) (memq (Bb74@id->sym B1d38@name) B1d31@set))) B1d36@ls/false)) (apply (lambda (B1d3a@name) (Bd2f@bless (list 'quote B1d3a@name))) B1d36@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1d34@t)))))) (set! B2857@Bd89@symbol-macro Bd89@symbol-macro) (set! Bd8b@macro-transformer (lambda (B1d3c@x) (if (procedure? B1d3c@x) B1d3c@x (if (symbol? B1d3c@x) (let ((B1d3e@t B1d3c@x)) (if (memv B1d3e@t '(define-record-type)) Bd6d@define-record-type-macro (if (memv B1d3e@t '(define-struct)) Bd6b@define-struct-macro (if (memv B1d3e@t '(include)) Bd61@include-macro (if (memv B1d3e@t '(cond)) Bd5d@cond-macro (if (memv B1d3e@t '(let)) Bd35@let-macro (if (memv B1d3e@t '(do)) Bd55@do-macro (if (memv B1d3e@t '(or)) Bd59@or-macro (if (memv B1d3e@t '(and)) Bd5b@and-macro (if (memv B1d3e@t '(let*)) Bd57@let*-macro (if (memv B1d3e@t '(let-values)) Bd37@let-values-macro (if (memv B1d3e@t '(let*-values)) Bd39@let*-values-macro (if (memv B1d3e@t '(syntax-rules)) Bd65@syntax-rules-macro (if (memv B1d3e@t '(quasiquote)) Bd67@quasiquote-macro (if (memv B1d3e@t '(quasisyntax)) Bd69@quasisyntax-macro (if (memv B1d3e@t '(with-syntax)) Bd31@with-syntax-macro (if (memv B1d3e@t '(when)) Bd1d@when-macro (if (memv B1d3e@t '(unless)) Bd1f@unless-macro (if (memv B1d3e@t '(case)) Bd27@case-macro (if (memv B1d3e@t '(identifier-syntax)) Bd53@identifier-syntax-macro (if (memv B1d3e@t '(time)) Bd4b@time-macro (if (memv B1d3e@t '(delay)) Bd4d@delay-macro (if (memv B1d3e@t '(assert)) Bd4f@assert-macro (if (memv B1d3e@t '(endianness)) Bd51@endianness-macro (if (memv B1d3e@t '(guard)) Bd47@guard-macro (if (memv B1d3e@t '(define-enumeration)) Bd49@define-enumeration-macro (if (memv B1d3e@t '(trace-lambda)) Bd3b@trace-lambda-macro (if (memv B1d3e@t '(trace-define)) Bd3d@trace-define-macro (if (memv B1d3e@t '(trace-define-syntax)) Bd3f@trace-define-syntax-macro (if (memv B1d3e@t '(trace-let-syntax)) Bd43@trace-let-syntax-macro (if (memv B1d3e@t '(trace-letrec-syntax)) Bd45@trace-letrec-syntax-macro (if (memv B1d3e@t '(define-condition-type)) Bd6f@define-condition-type-macro (if (memv B1d3e@t '(parameterize)) Bd73@parameterize-macro (if (memv B1d3e@t '(include-into)) Bd63@include-into-macro (if (memv B1d3e@t '(eol-style)) (lambda (B1d40@x) (Bd89@symbol-macro B1d40@x '(none lf cr crlf nel crnel ls))) (if (memv B1d3e@t '(error-handling-mode)) (lambda (B1d42@x) (Bd89@symbol-macro B1d42@x '(ignore raise replace))) (if (memv B1d3e@t '(buffer-mode)) (lambda (B1d44@x) (Bd89@symbol-macro B1d44@x '(none line block))) (if (memv B1d3e@t '(file-options)) Baed@file-options-macro (if (memv B1d3e@t '(... => _ else unquote unquote-splicing unsyntax unsyntax-splicing fields mutable immutable parent protocol sealed opaque nongenerative parent-rtd)) Bd71@incorrect-usage-macro (error 'macro-transformer '"BUG: invalid macro" B1d3c@x)))))))))))))))))))))))))))))))))))))))) (error 'core-macro-transformer '"BUG: invalid macro" B1d3c@x))))) (set! B2858@Bd8b@macro-transformer Bd8b@macro-transformer) (set! Bd8d@local-macro-transformer (lambda (B1d46@x) (car B1d46@x))) (set! B2859@Bd8d@local-macro-transformer Bd8d@local-macro-transformer) (set! Bd8f@do-macro-call (lambda (B1d48@transformer B1d49@expr) (let ((B1d4c@out (B1d48@transformer (Bb5c@add-mark Bb56@anti-mark B1d49@expr '#f)))) (begin (let B1d50@f ((B1d4e@x B1d4c@out)) (if (not (Bb3e@stx? B1d4e@x)) (if (pair? B1d4e@x) (begin (B1d50@f (car B1d4e@x)) (B1d50@f (cdr B1d4e@x))) (if (vector? B1d4e@x) (vector-for-each B1d50@f B1d4e@x) (if (symbol? B1d4e@x) (Be59@syntax-violation '#f '"raw symbol encountered in output of macro" B1d49@expr B1d4e@x) (void)))) (void))) (Bb5c@add-mark (Bb54@gen-mark) B1d4c@out B1d49@expr))))) (set! B285a@Bd8f@do-macro-call Bd8f@do-macro-call) (set! Bd91@chi-macro (lambda (B1d52@p B1d53@e) (Bd8f@do-macro-call (Bd8b@macro-transformer B1d52@p) B1d53@e))) (set! B285b@Bd91@chi-macro Bd91@chi-macro) (set! Bd93@chi-local-macro (lambda (B1d56@p B1d57@e) (Bd8f@do-macro-call (Bd8d@local-macro-transformer B1d56@p) B1d57@e))) (set! B285c@Bd93@chi-local-macro Bd93@chi-local-macro) (set! Bd95@chi-global-macro (lambda (B1d5a@p B1d5b@e) (let ((B1d5e@lib (car B1d5a@p)) (B1d5f@loc (cdr B1d5a@p))) (begin (B98f@B7de@visit-library B1d5e@lib) (let ((B1d62@x (symbol-value B1d5f@loc))) (let ((B1d64@transformer (if (procedure? B1d62@x) B1d62@x (assertion-violation 'chi-global-macro '"BUG: not a procedure" B1d62@x)))) (Bd8f@do-macro-call B1d64@transformer B1d5b@e))))))) (set! B285d@Bd95@chi-global-macro Bd95@chi-global-macro) (set! Bd97@chi-expr* (lambda (B1d66@e* B1d67@r B1d68@mr) (if (null? B1d66@e*) '() (let ((B1d6c@e (Bd9b@chi-expr (car B1d66@e*) B1d67@r B1d68@mr))) (cons B1d6c@e (Bd97@chi-expr* (cdr B1d66@e*) B1d67@r B1d68@mr)))))) (set! B285e@Bd97@chi-expr* Bd97@chi-expr*) (set! Bd99@chi-application (lambda (B1d6e@e B1d6f@r B1d70@mr) (let ((B1d74@t B1d6e@e)) (let ((B1d76@ls/false (Bd79@syntax-dispatch B1d74@t '(any . each-any)))) (if B1d76@ls/false (apply (lambda (B1d78@rator B1d79@rands) (let ((B1d7c@rator (Bd9b@chi-expr B1d78@rator B1d6f@r B1d70@mr))) (cons B1d7c@rator (Bd97@chi-expr* B1d79@rands B1d6f@r B1d70@mr)))) B1d76@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1d74@t)))))) (set! B285f@Bd99@chi-application Bd99@chi-application) (set! Bd9b@chi-expr (lambda (B1d7e@e B1d7f@r B1d80@mr) (call-with-values (lambda () (Bb94@syntax-type B1d7e@e B1d7f@r)) (lambda (B1d8a@B1d85 B1d8b@B1d87 B1d8c@B1d89) (let ((B1d90@kwd B1d8c@B1d89) (B1d91@value B1d8b@B1d87) (B1d92@type B1d8a@B1d85)) (let ((B1d96@t B1d92@type)) (if (memv B1d96@t '(core-macro)) (let ((B1d98@transformer (Bd87@core-macro-transformer B1d91@value))) (B1d98@transformer B1d7e@e B1d7f@r B1d80@mr)) (if (memv B1d96@t '(global)) (let ((B1d9a@lib (car B1d91@value))) (let ((B1d9c@loc (cdr B1d91@value))) (begin ((Bde1@inv-collector) B1d9a@lib) B1d9c@loc))) (if (memv B1d96@t '(core-prim)) (let ((B1d9e@name B1d91@value)) (list 'primitive B1d9e@name)) (if (memv B1d96@t '(call)) (Bd99@chi-application B1d7e@e B1d7f@r B1d80@mr) (if (memv B1d96@t '(lexical)) (let ((B1da0@lex (Bd03@lexical-var B1d91@value))) B1da0@lex) (if (memv B1d96@t '(global-macro global-macro!)) (Bd9b@chi-expr (Bd95@chi-global-macro B1d91@value B1d7e@e) B1d7f@r B1d80@mr) (if (memv B1d96@t '(local-macro local-macro!)) (Bd9b@chi-expr (Bd93@chi-local-macro B1d91@value B1d7e@e) B1d7f@r B1d80@mr) (if (memv B1d96@t '(macro macro!)) (Bd9b@chi-expr (Bd91@chi-macro B1d91@value B1d7e@e) B1d7f@r B1d80@mr) (if (memv B1d96@t '(constant)) (let ((B1da2@datum B1d91@value)) (list 'quote B1da2@datum)) (if (memv B1d96@t '(set!)) (Bd9d@chi-set! B1d7e@e B1d7f@r B1d80@mr) (if (memv B1d96@t '(begin)) (let ((B1da4@t B1d7e@e)) (let ((B1da6@ls/false (Bd79@syntax-dispatch B1da4@t '(_ any . each-any)))) (if B1da6@ls/false (apply (lambda (B1da8@x B1da9@x*) (Bad7@Ba37@build-sequence '#f (Bd97@chi-expr* (cons B1da8@x B1da9@x*) B1d7f@r B1d80@mr))) B1da6@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1da4@t)))) (if (memv B1d96@t '(let-syntax letrec-syntax)) (let ((B1dac@t B1d7e@e)) (let ((B1dae@ls/false (Bd79@syntax-dispatch B1dac@t '(_ #(each (any any)) any . each-any)))) (if (and B1dae@ls/false (apply (lambda (B1db0@xlhs* B1db1@xrhs* B1db2@xbody B1db3@xbody*) (if (not (Bb7a@valid-bound-ids? B1db0@xlhs*)) (Be59@syntax-violation '#f '"invalid identifiers" B1d7e@e) (void))) B1dae@ls/false)) (apply (lambda (B1db8@xlhs* B1db9@xrhs* B1dba@xbody B1dbb@xbody*) (let ((B1dc0@xlab* (map Bafe@gen-label B1db8@xlhs*))) (let ((B1dc2@xrib (Bb32@make-full-rib B1db8@xlhs* B1dc0@xlab*))) (let ((B1dc4@xb* (map (lambda (B1dc6@x) (Bbaa@make-eval-transformer (Bdd3@expand-transformer (if (eq? B1d92@type 'let-syntax) B1dc6@x (Bb5e@add-subst B1dc2@xrib B1dc6@x)) B1d80@mr))) B1db9@xrhs*))) (Bad7@Ba37@build-sequence '#f (Bd97@chi-expr* (map (lambda (B1dc8@x) (Bb5e@add-subst B1dc2@xrib B1dc8@x)) (cons B1dba@xbody B1dbb@xbody*)) (append (map cons B1dc0@xlab* B1dc4@xb*) B1d7f@r) (append (map cons B1dc0@xlab* B1dc4@xb*) B1d80@mr))))))) B1dae@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1dac@t)))) (if (memv B1d96@t '(displaced-lexical)) (Be59@syntax-violation '#f '"identifier out of context" B1d7e@e) (if (memv B1d96@t '(syntax)) (Be59@syntax-violation '#f '"reference to pattern variable outside a syntax form" B1d7e@e) (if (memv B1d96@t '(define define-syntax module import library)) (Be59@syntax-violation '#f (string-append (let ((B1dca@t B1d92@type)) (if (memv B1dca@t '(define)) '"a definition" (if (memv B1dca@t '(define-syntax)) '"a define-syntax" (if (memv B1dca@t '(module)) '"a module definition" (if (memv B1dca@t '(library)) '"a library definition" (if (memv B1dca@t '(import)) '"an import declaration" (if (memv B1dca@t '(export)) '"an export declaration" '"a non-expression"))))))) '" was found where an expression was expected") B1d7e@e) (if (memv B1d96@t '(mutable)) (Be59@syntax-violation '#f '"attempt to reference an unexportable variable" B1d7e@e) (Be59@syntax-violation '#f '"invalid expression" B1d7e@e))))))))))))))))))))))) (set! B2860@Bd9b@chi-expr Bd9b@chi-expr) (set! Bd9d@chi-set! (lambda (B1dcc@e B1dcd@r B1dce@mr) (let ((B1dd2@t B1dcc@e)) (let ((B1dd4@ls/false (Bd79@syntax-dispatch B1dd2@t '(_ any any)))) (if (and B1dd4@ls/false (apply (lambda (B1dd6@x B1dd7@v) (Bb72@id? B1dd6@x)) B1dd4@ls/false)) (apply (lambda (B1dda@x B1ddb@v) (call-with-values (lambda () (Bb94@syntax-type B1dda@x B1dcd@r)) (lambda (B1de4@B1ddf B1de5@B1de1 B1de6@B1de3) (let ((B1dea@kwd B1de6@B1de3) (B1deb@value B1de5@B1de1) (B1dec@type B1de4@B1ddf)) (let ((B1df0@t B1dec@type)) (if (memv B1df0@t '(lexical)) (begin (Bd07@set-lexical-mutable! B1deb@value '#t) (list 'set! (Bd03@lexical-var B1deb@value) (Bd9b@chi-expr B1ddb@v B1dcd@r B1dce@mr))) (if (memv B1df0@t '(core-prim)) (Be59@syntax-violation '#f '"cannot modify imported core primitive" B1dcc@e) (if (memv B1df0@t '(global)) (Be59@syntax-violation '#f '"attempt to modify imported binding" B1dcc@e) (if (memv B1df0@t '(global-macro!)) (Bd9b@chi-expr (Bd95@chi-global-macro B1deb@value B1dcc@e) B1dcd@r B1dce@mr) (if (memv B1df0@t '(local-macro!)) (Bd9b@chi-expr (Bd93@chi-local-macro B1deb@value B1dcc@e) B1dcd@r B1dce@mr) (if (memv B1df0@t '(mutable)) (Be59@syntax-violation '#f '"attempt to assign to an unexportable variable" B1dcc@e) (Be59@syntax-violation '#f '"invalid syntax" B1dcc@e)))))))))))) B1dd4@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1dd2@t)))))) (set! B2861@Bd9d@chi-set! Bd9d@chi-set!) (set! Bd9f@verify-formals (lambda (B1df2@fmls B1df3@stx) (let ((B1df6@t B1df2@fmls)) (let ((B1df8@ls/false (Bd79@syntax-dispatch B1df6@t 'each-any))) (if B1df8@ls/false (apply (lambda (B1dfa@x*) (if (not (Bb7a@valid-bound-ids? B1dfa@x*)) (Bd33@invalid-fmls-error B1df3@stx B1df2@fmls) (void))) B1df8@ls/false) (let ((B1dfc@t B1df6@t)) (let ((B1dfe@ls/false (Bd79@syntax-dispatch B1dfc@t '#(each+ any () any)))) (if B1dfe@ls/false (apply (lambda (B1e00@x* B1e01@x) (if (not (Bb7a@valid-bound-ids? (cons B1e01@x B1e00@x*))) (Bd33@invalid-fmls-error B1df3@stx B1df2@fmls) (void))) B1dfe@ls/false) (let ((B1e04@t B1dfc@t)) (let ((B1e06@ls/false (Bd79@syntax-dispatch B1e04@t '_))) (if B1e06@ls/false (apply (lambda () (Be59@syntax-violation '#f '"invalid syntax" B1df3@stx)) B1e06@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1e04@t)))))))))))) (set! B2862@Bd9f@verify-formals Bd9f@verify-formals) (set! Bda1@chi-lambda-clause (lambda (B1e08@stx B1e09@fmls B1e0a@body* B1e0b@r B1e0c@mr) (let ((B1e12@t B1e09@fmls)) (let ((B1e14@ls/false (Bd79@syntax-dispatch B1e12@t 'each-any))) (if B1e14@ls/false (apply (lambda (B1e16@x*) (begin (Bd9f@verify-formals B1e09@fmls B1e08@stx) (let ((B1e18@lex* (map Bafa@gen-lexical B1e16@x*)) (B1e19@lab* (map Bafe@gen-label B1e16@x*))) (values B1e18@lex* (Bdb1@chi-internal (Bb5e@add-subst (Bb32@make-full-rib B1e16@x* B1e19@lab*) B1e0a@body*) (Bd0b@add-lexicals B1e19@lab* B1e18@lex* B1e0b@r) B1e0c@mr))))) B1e14@ls/false) (let ((B1e1c@t B1e12@t)) (let ((B1e1e@ls/false (Bd79@syntax-dispatch B1e1c@t '#(each+ any () any)))) (if B1e1e@ls/false (apply (lambda (B1e20@x* B1e21@x) (begin (Bd9f@verify-formals B1e09@fmls B1e08@stx) (let ((B1e24@lex* (map Bafa@gen-lexical B1e20@x*)) (B1e25@lab* (map Bafe@gen-label B1e20@x*)) (B1e26@lex (Bafa@gen-lexical B1e21@x)) (B1e27@lab (Bafe@gen-label B1e21@x))) (values (append B1e24@lex* B1e26@lex) (Bdb1@chi-internal (Bb5e@add-subst (Bb32@make-full-rib (cons B1e21@x B1e20@x*) (cons B1e27@lab B1e25@lab*)) B1e0a@body*) (Bd0b@add-lexicals (cons B1e27@lab B1e25@lab*) (cons B1e26@lex B1e24@lex*) B1e0b@r) B1e0c@mr))))) B1e1e@ls/false) (let ((B1e2c@t B1e1c@t)) (let ((B1e2e@ls/false (Bd79@syntax-dispatch B1e2c@t '_))) (if B1e2e@ls/false (apply (lambda () (Be59@syntax-violation '#f '"invalid syntax" B1e09@fmls)) B1e2e@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1e2c@t)))))))))))) (set! B2863@Bda1@chi-lambda-clause Bda1@chi-lambda-clause) (set! Bda3@chi-lambda-clause* (lambda (B1e30@stx B1e31@fmls* B1e32@body** B1e33@r B1e34@mr) (if (null? B1e31@fmls*) (values '() '()) (call-with-values (lambda () (Bda1@chi-lambda-clause B1e30@stx (car B1e31@fmls*) (car B1e32@body**) B1e33@r B1e34@mr)) (lambda (B1e3e@B1e3b B1e3f@B1e3d) (let ((B1e42@b B1e3f@B1e3d) (B1e43@a B1e3e@B1e3b)) (call-with-values (lambda () (Bda3@chi-lambda-clause* B1e30@stx (cdr B1e31@fmls*) (cdr B1e32@body**) B1e33@r B1e34@mr)) (lambda (B1e4a@B1e47 B1e4b@B1e49) (let ((B1e4e@b* B1e4b@B1e49) (B1e4f@a* B1e4a@B1e47)) (values (cons B1e43@a B1e4f@a*) (cons B1e42@b B1e4e@b*))))))))))) (set! B2864@Bda3@chi-lambda-clause* Bda3@chi-lambda-clause*) (set! Bda5@chi-defun (lambda (B1e52@x B1e53@r B1e54@mr) (let ((B1e58@fmls (car B1e52@x)) (B1e59@body* (cdr B1e52@x))) (call-with-values (lambda () (Bda1@chi-lambda-clause B1e58@fmls B1e58@fmls B1e59@body* B1e53@r B1e54@mr)) (lambda (B1e60@B1e5d B1e61@B1e5f) (let ((B1e64@body B1e61@B1e5f) (B1e65@fmls B1e60@B1e5d)) (Bad5@Ba07@build-lambda '#f B1e65@fmls B1e64@body))))))) (set! B2865@Bda5@chi-defun Bda5@chi-defun) (set! Bda7@chi-rhs (lambda (B1e68@rhs B1e69@r B1e6a@mr) (let ((B1e6e@t (car B1e68@rhs))) (if (memv B1e6e@t '(defun)) (Bda5@chi-defun (cdr B1e68@rhs) B1e69@r B1e6a@mr) (if (memv B1e6e@t '(expr)) (let ((B1e70@expr (cdr B1e68@rhs))) (Bd9b@chi-expr B1e70@expr B1e69@r B1e6a@mr)) (if (memv B1e6e@t '(top-expr)) (let ((B1e72@expr (cdr B1e68@rhs))) (Bad7@Ba37@build-sequence '#f (list (Bd9b@chi-expr B1e72@expr B1e69@r B1e6a@mr) (Bad8@Ba39@build-void)))) (assertion-violation 'chi-rhs '"BUG: invalid rhs" B1e68@rhs))))))) (set! B2866@Bda7@chi-rhs Bda7@chi-rhs) (set! Bda9@expand-interaction-rhs*/init* (lambda (B1e74@lhs* B1e75@rhs* B1e76@init* B1e77@r B1e78@mr) (let B1e82@f ((B1e7e@lhs* B1e74@lhs*) (B1e7f@rhs* B1e75@rhs*)) (if (null? B1e7e@lhs*) (map (lambda (B1e84@x) (Bd9b@chi-expr B1e84@x B1e77@r B1e78@mr)) B1e76@init*) (let ((B1e86@lhs (car B1e7e@lhs*)) (B1e87@rhs (car B1e7f@rhs*))) (let ((B1e8a@t (car B1e87@rhs))) (if (memv B1e8a@t '(defun)) (let ((B1e8c@rhs (Bda5@chi-defun (cdr B1e87@rhs) B1e77@r B1e78@mr))) (cons (list 'set! B1e86@lhs B1e8c@rhs) (B1e82@f (cdr B1e7e@lhs*) (cdr B1e7f@rhs*)))) (if (memv B1e8a@t '(expr)) (let ((B1e8e@rhs (Bd9b@chi-expr (cdr B1e87@rhs) B1e77@r B1e78@mr))) (cons (list 'set! B1e86@lhs B1e8e@rhs) (B1e82@f (cdr B1e7e@lhs*) (cdr B1e7f@rhs*)))) (if (memv B1e8a@t '(top-expr)) (let ((B1e90@e (Bd9b@chi-expr (cdr B1e87@rhs) B1e77@r B1e78@mr))) (cons B1e90@e (B1e82@f (cdr B1e7e@lhs*) (cdr B1e7f@rhs*)))) (error 'expand-interaction '"invallid" B1e87@rhs)))))))))) (set! B2867@Bda9@expand-interaction-rhs*/init* Bda9@expand-interaction-rhs*/init*) (set! Bdab@chi-rhs* (lambda (B1e92@rhs* B1e93@r B1e94@mr) (let B1e9a@f ((B1e98@ls B1e92@rhs*)) (if (null? B1e98@ls) '() (let ((B1e9c@a (Bda7@chi-rhs (car B1e98@ls) B1e93@r B1e94@mr))) (cons B1e9c@a (B1e9a@f (cdr B1e98@ls)))))))) (set! B2868@Bdab@chi-rhs* Bdab@chi-rhs*) (set! Bdad@find-bound=? (lambda (B1e9e@x B1e9f@lhs* B1ea0@rhs*) (if (null? B1e9f@lhs*) '#f (if (Bb76@bound-id=? B1e9e@x (car B1e9f@lhs*)) (car B1ea0@rhs*) (Bdad@find-bound=? B1e9e@x (cdr B1e9f@lhs*) (cdr B1ea0@rhs*)))))) (set! B2869@Bdad@find-bound=? Bdad@find-bound=?) (set! Bdaf@find-dups (lambda (B1ea4@ls) (let B1eaa@f ((B1ea6@ls B1ea4@ls) (B1ea7@dups '())) (if (null? B1ea6@ls) B1ea7@dups (let ((B1eac@t (Bdad@find-bound=? (car B1ea6@ls) (cdr B1ea6@ls) (cdr B1ea6@ls)))) (if B1eac@t ((lambda (B1eae@x) (B1eaa@f (cdr B1ea6@ls) (cons (list (car B1ea6@ls) B1eae@x) B1ea7@dups))) B1eac@t) (B1eaa@f (cdr B1ea6@ls) B1ea7@dups))))))) (set! B286a@Bdaf@find-dups Bdaf@find-dups) (set! Bdb1@chi-internal (lambda (B1eb0@e* B1eb1@r B1eb2@mr) (let ((B1eb6@rib (Bb26@make-empty-rib))) (call-with-values (lambda () (Bdd1@chi-body* (map (lambda (B1ec8@x) (Bb5e@add-subst B1eb6@rib B1ec8@x)) (Bb70@syntax->list B1eb0@e*)) B1eb1@r B1eb2@mr '() '() '() '() '() B1eb6@rib '#f)) (lambda (B1eca@B1eb9 B1ecb@B1ebb B1ecc@B1ebd B1ecd@B1ebf B1ece@B1ec1 B1ecf@B1ec3 B1ed0@B1ec5 B1ed1@B1ec7) (let ((B1eda@_exp* B1ed1@B1ec7) (B1edb@kwd* B1ed0@B1ec5) (B1edc@mod** B1ecf@B1ec3) (B1edd@rhs* B1ece@B1ec1) (B1ede@lex* B1ecd@B1ebf) (B1edf@mr B1ecc@B1ebd) (B1ee0@r B1ecb@B1ebb) (B1ee1@e* B1eca@B1eb9)) (begin (if (null? B1ee1@e*) (Be59@syntax-violation '#f '"no expression in body" B1ee1@e*) (void)) (let ((B1eea@init* (Bd97@chi-expr* (append (apply append (reverse B1edc@mod**)) B1ee1@e*) B1ee0@r B1edf@mr))) (let ((B1eec@rhs* (Bdab@chi-rhs* B1edd@rhs* B1ee0@r B1edf@mr))) (Badc@Ba41@build-letrec* '#f (reverse B1ede@lex*) (reverse B1eec@rhs*) (Bad7@Ba37@build-sequence '#f B1eea@init*))))))))))) (set! B286b@Bdb1@chi-internal Bdb1@chi-internal) (set! Bdb3@parse-module (lambda (B1eee@e) (let ((B1ef0@t B1eee@e)) (let ((B1ef2@ls/false (Bd79@syntax-dispatch B1ef0@t '(_ each-any . each-any)))) (if B1ef2@ls/false (apply (lambda (B1ef4@export* B1ef5@b*) (begin (if (not (for-all Bb72@id? B1ef4@export*)) (Be59@syntax-violation '#f '"module exports must be identifiers" B1eee@e) (void)) (values '#f (list->vector B1ef4@export*) B1ef5@b*))) B1ef2@ls/false) (let ((B1ef8@t B1ef0@t)) (let ((B1efa@ls/false (Bd79@syntax-dispatch B1ef8@t '(_ any each-any . each-any)))) (if B1efa@ls/false (apply (lambda (B1efc@name B1efd@export* B1efe@b*) (begin (if (not (Bb72@id? B1efc@name)) (Be59@syntax-violation '#f '"module name must be an identifier" B1eee@e) (void)) (if (not (for-all Bb72@id? B1efd@export*)) (Be59@syntax-violation '#f '"module exports must be identifiers" B1eee@e) (void)) (values B1efc@name (list->vector B1efd@export*) B1efe@b*))) B1efa@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1ef8@t))))))))) (set! B286c@Bdb3@parse-module Bdb3@parse-module) (set! Bdbd@module-interface? (lambda (B1f02@x) (and (simple-struct? B1f02@x) (eq? (simple-struct-name B1f02@x) 'module-interface)))) (set! B286d@Bdbd@module-interface? Bdbd@module-interface?) (set! Bdbf@module-interface-first-mark (lambda (B1f04@x) (simple-struct-ref B1f04@x '0))) (set! B286e@Bdbf@module-interface-first-mark Bdbf@module-interface-first-mark) (set! Bdc1@set-module-interface-first-mark! (lambda (B1f06@x B1f07@val) (simple-struct-set! B1f06@x '0 B1f07@val))) (set! B286f@Bdc1@set-module-interface-first-mark! Bdc1@set-module-interface-first-mark!) (set! Bdc3@module-interface-exp-id-vec (lambda (B1f0a@x) (simple-struct-ref B1f0a@x '1))) (set! B2870@Bdc3@module-interface-exp-id-vec Bdc3@module-interface-exp-id-vec) (set! Bdc5@set-module-interface-exp-id-vec! (lambda (B1f0c@x B1f0d@val) (simple-struct-set! B1f0c@x '1 B1f0d@val))) (set! B2871@Bdc5@set-module-interface-exp-id-vec! Bdc5@set-module-interface-exp-id-vec!) (set! Bdc7@module-interface-exp-lab-vec (lambda (B1f10@x) (simple-struct-ref B1f10@x '2))) (set! B2872@Bdc7@module-interface-exp-lab-vec Bdc7@module-interface-exp-lab-vec) (set! Bdc9@set-module-interface-exp-lab-vec! (lambda (B1f12@x B1f13@val) (simple-struct-set! B1f12@x '2 B1f13@val))) (set! B2873@Bdc9@set-module-interface-exp-lab-vec! Bdc9@set-module-interface-exp-lab-vec!) (set! Bdcb@dummy '3) (set! B2874@Bdcb@dummy Bdcb@dummy) (set! Bdcd@module-interface-exp-id* (lambda (B1f16@iface B1f17@id) (letrec* ((B1f1b@diff-marks (lambda (B1f22@ls B1f23@x) (begin (if (null? B1f22@ls) (error 'diff-marks '"BUG: should not happen") (void)) (let ((B1f26@a (car B1f22@ls))) (if (eq? B1f26@a B1f23@x) '() (cons B1f26@a (B1f1b@diff-marks (cdr B1f22@ls) B1f23@x)))))))) (let ((B1f1c@diff (B1f1b@diff-marks (Bb44@stx-mark* B1f17@id) (Bdbf@module-interface-first-mark B1f16@iface))) (B1f1d@id-vec (Bdc3@module-interface-exp-id-vec B1f16@iface))) (if (null? B1f1c@diff) B1f1d@id-vec (vector-map (lambda (B1f20@x) (make-simple-struct 'stx '5 (list (Bb40@stx-expr B1f20@x) (append B1f1c@diff (Bb44@stx-mark* B1f20@x)) '() '()))) B1f1d@id-vec)))))) (set! B2875@Bdcd@module-interface-exp-id* Bdcd@module-interface-exp-id*) (set! Bdcf@chi-internal-module (lambda (B1f28@e B1f29@r B1f2a@mr B1f2b@lex* B1f2c@rhs* B1f2d@mod** B1f2e@kwd*) (call-with-values (lambda () (Bdb3@parse-module B1f28@e)) (lambda (B1f3c@B1f37 B1f3d@B1f39 B1f3e@B1f3b) (let ((B1f42@e* B1f3e@B1f3b) (B1f43@exp-id* B1f3d@B1f39) (B1f44@name B1f3c@B1f37)) (let ((B1f48@rib (Bb26@make-empty-rib))) (let ((B1f4a@e* (map (lambda (B1f4c@x) (Bb5e@add-subst B1f48@rib B1f4c@x)) (Bb70@syntax->list B1f42@e*)))) (call-with-values (lambda () (Bdd1@chi-body* B1f4a@e* B1f29@r B1f2a@mr B1f2b@lex* B1f2c@rhs* B1f2d@mod** B1f2e@kwd* '() B1f48@rib '#f)) (lambda (B1f5e@B1f4f B1f5f@B1f51 B1f60@B1f53 B1f61@B1f55 B1f62@B1f57 B1f63@B1f59 B1f64@B1f5b B1f65@B1f5d) (let ((B1f6e@_exp* B1f65@B1f5d) (B1f6f@kwd* B1f64@B1f5b) (B1f70@mod** B1f63@B1f59) (B1f71@rhs* B1f62@B1f57) (B1f72@lex* B1f61@B1f55) (B1f73@mr B1f60@B1f53) (B1f74@r B1f5f@B1f51) (B1f75@e* B1f5e@B1f4f)) (let ((B1f7e@exp-lab* (vector-map (lambda (B1f82@x) (or (Bb88@id->label (make-simple-struct 'stx '5 (list (Bb74@id->sym B1f82@x) (Bb44@stx-mark* B1f82@x) (list B1f48@rib) '()))) (Be59@syntax-violation '#f '"cannot find module export" B1f82@x))) B1f43@exp-id*)) (B1f7f@mod** (cons B1f75@e* B1f70@mod**))) (if (not B1f44@name) (values B1f72@lex* B1f71@rhs* B1f43@exp-id* B1f7e@exp-lab* B1f74@r B1f73@mr B1f7f@mod** B1f6f@kwd*) (let ((B1f84@lab (Bafe@gen-label 'module)) (B1f85@iface (make-simple-struct 'module-interface '4 (list (car (Bb44@stx-mark* B1f44@name)) (vector-map (lambda (B1f88@x) (make-simple-struct 'stx '5 (list (Bb40@stx-expr B1f88@x) (Bb44@stx-mark* B1f88@x) '() '()))) B1f43@exp-id*) B1f7e@exp-lab*)))) (values B1f72@lex* B1f71@rhs* (vector B1f44@name) (vector B1f84@lab) (cons (cons B1f84@lab (cons '$module B1f85@iface)) B1f74@r) (cons (cons B1f84@lab (cons '$module B1f85@iface)) B1f73@mr) B1f7f@mod** B1f6f@kwd*)))))))))))))) (set! B2876@Bdcf@chi-internal-module Bdcf@chi-internal-module) (set! Bdd1@chi-body* (lambda (B1f8a@e* B1f8b@r B1f8c@mr B1f8d@lex* B1f8e@rhs* B1f8f@mod** B1f90@kwd* B1f91@exp* B1f92@rib B1f93@top?) (if (null? B1f8a@e*) (values B1f8a@e* B1f8b@r B1f8c@mr B1f8d@lex* B1f8e@rhs* B1f8f@mod** B1f90@kwd* B1f91@exp*) (let ((B1f9e@e (car B1f8a@e*))) (call-with-values (lambda () (Bb94@syntax-type B1f9e@e B1f8b@r)) (lambda (B1fa6@B1fa1 B1fa7@B1fa3 B1fa8@B1fa5) (let ((B1fac@kwd B1fa8@B1fa5) (B1fad@value B1fa7@B1fa3) (B1fae@type B1fa6@B1fa1)) (let ((B1fb2@kwd* (if (Bb72@id? B1fac@kwd) (cons B1fac@kwd B1f90@kwd*) B1f90@kwd*))) (let ((B1fb4@t B1fae@type)) (if (memv B1fb4@t '(define)) (call-with-values (lambda () (Bcfb@parse-define B1f9e@e)) (lambda (B1fba@B1fb7 B1fbb@B1fb9) (let ((B1fbe@rhs B1fbb@B1fb9) (B1fbf@id B1fba@B1fb7)) (begin (if (Bb7e@bound-id-member? B1fbf@id B1fb2@kwd*) (Be59@syntax-violation '#f '"cannot redefine keyword" B1f9e@e) (void)) (call-with-values (lambda () (Bb02@gen-define-label+loc B1fbf@id B1f92@rib)) (lambda (B1fc6@B1fc3 B1fc7@B1fc5) (let ((B1fca@lex B1fc7@B1fc5) (B1fcb@lab B1fc6@B1fc3)) (begin (Bb28@extend-rib! B1f92@rib B1fbf@id B1fcb@lab) (Bdd1@chi-body* (cdr B1f8a@e*) (Bd09@add-lexical B1fcb@lab B1fca@lex B1f8b@r) B1f8c@mr (cons B1fca@lex B1f8d@lex*) (cons B1fbe@rhs B1f8e@rhs*) B1f8f@mod** B1fb2@kwd* B1f91@exp* B1f92@rib B1f93@top?))))))))) (if (memv B1fb4@t '(define-syntax)) (call-with-values (lambda () (Bcfd@parse-define-syntax B1f9e@e)) (lambda (B1fd2@B1fcf B1fd3@B1fd1) (let ((B1fd6@rhs B1fd3@B1fd1) (B1fd7@id B1fd2@B1fcf)) (begin (if (Bb7e@bound-id-member? B1fd7@id B1fb2@kwd*) (Be59@syntax-violation '#f '"cannot redefine keyword" B1f9e@e) (void)) (let ((B1fda@lab (Bb04@gen-define-label B1fd7@id B1f92@rib)) (B1fdb@expanded-rhs (Bdd3@expand-transformer B1fd6@rhs B1f8c@mr))) (begin (Bb28@extend-rib! B1f92@rib B1fd7@id B1fda@lab) (let ((B1fde@b (Bbaa@make-eval-transformer B1fdb@expanded-rhs))) (Bdd1@chi-body* (cdr B1f8a@e*) (cons (cons B1fda@lab B1fde@b) B1f8b@r) (cons (cons B1fda@lab B1fde@b) B1f8c@mr) B1f8d@lex* B1f8e@rhs* B1f8f@mod** B1fb2@kwd* B1f91@exp* B1f92@rib B1f93@top?)))))))) (if (memv B1fb4@t '(let-syntax letrec-syntax)) (let ((B1fe0@t B1f9e@e)) (let ((B1fe2@ls/false (Bd79@syntax-dispatch B1fe0@t '(_ #(each (any any)) . each-any)))) (if (and B1fe2@ls/false (apply (lambda (B1fe4@xlhs* B1fe5@xrhs* B1fe6@xbody*) (if (not (Bb7a@valid-bound-ids? B1fe4@xlhs*)) (Be59@syntax-violation '#f '"invalid identifiers" B1f9e@e) (void))) B1fe2@ls/false)) (apply (lambda (B1fea@xlhs* B1feb@xrhs* B1fec@xbody*) (let ((B1ff0@xlab* (map Bafe@gen-label B1fea@xlhs*))) (let ((B1ff2@xrib (Bb32@make-full-rib B1fea@xlhs* B1ff0@xlab*))) (let ((B1ff4@xb* (map (lambda (B1ff6@x) (Bbaa@make-eval-transformer (Bdd3@expand-transformer (if (eq? B1fae@type 'let-syntax) B1ff6@x (Bb5e@add-subst B1ff2@xrib B1ff6@x)) B1f8c@mr))) B1feb@xrhs*))) (Bdd1@chi-body* (append (map (lambda (B1ff8@x) (Bb5e@add-subst B1ff2@xrib B1ff8@x)) B1fec@xbody*) (cdr B1f8a@e*)) (append (map cons B1ff0@xlab* B1ff4@xb*) B1f8b@r) (append (map cons B1ff0@xlab* B1ff4@xb*) B1f8c@mr) B1f8d@lex* B1f8e@rhs* B1f8f@mod** B1fb2@kwd* B1f91@exp* B1f92@rib B1f93@top?))))) B1fe2@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1fe0@t)))) (if (memv B1fb4@t '(begin)) (let ((B1ffa@t B1f9e@e)) (let ((B1ffc@ls/false (Bd79@syntax-dispatch B1ffa@t '(_ . each-any)))) (if B1ffc@ls/false (apply (lambda (B1ffe@x*) (Bdd1@chi-body* (append B1ffe@x* (cdr B1f8a@e*)) B1f8b@r B1f8c@mr B1f8d@lex* B1f8e@rhs* B1f8f@mod** B1fb2@kwd* B1f91@exp* B1f92@rib B1f93@top?)) B1ffc@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B1ffa@t)))) (if (memv B1fb4@t '(global-macro global-macro!)) (Bdd1@chi-body* (cons (Bb5e@add-subst B1f92@rib (Bd95@chi-global-macro B1fad@value B1f9e@e)) (cdr B1f8a@e*)) B1f8b@r B1f8c@mr B1f8d@lex* B1f8e@rhs* B1f8f@mod** B1fb2@kwd* B1f91@exp* B1f92@rib B1f93@top?) (if (memv B1fb4@t '(local-macro local-macro!)) (Bdd1@chi-body* (cons (Bb5e@add-subst B1f92@rib (Bd93@chi-local-macro B1fad@value B1f9e@e)) (cdr B1f8a@e*)) B1f8b@r B1f8c@mr B1f8d@lex* B1f8e@rhs* B1f8f@mod** B1fb2@kwd* B1f91@exp* B1f92@rib B1f93@top?) (if (memv B1fb4@t '(macro macro!)) (Bdd1@chi-body* (cons (Bb5e@add-subst B1f92@rib (Bd91@chi-macro B1fad@value B1f9e@e)) (cdr B1f8a@e*)) B1f8b@r B1f8c@mr B1f8d@lex* B1f8e@rhs* B1f8f@mod** B1fb2@kwd* B1f91@exp* B1f92@rib B1f93@top?) (if (memv B1fb4@t '(module)) (call-with-values (lambda () (Bdcf@chi-internal-module B1f9e@e B1f8b@r B1f8c@mr B1f8d@lex* B1f8e@rhs* B1f8f@mod** B1fb2@kwd*)) (lambda (B2010@B2001 B2011@B2003 B2012@B2005 B2013@B2007 B2014@B2009 B2015@B200b B2016@B200d B2017@B200f) (let ((B2020@kwd* B2017@B200f) (B2021@mod** B2016@B200d) (B2022@mr B2015@B200b) (B2023@r B2014@B2009) (B2024@m-exp-lab* B2013@B2007) (B2025@m-exp-id* B2012@B2005) (B2026@rhs* B2011@B2003) (B2027@lex* B2010@B2001)) (begin (vector-for-each (lambda (B2030@id B2031@lab) (Bb28@extend-rib! B1f92@rib B2030@id B2031@lab)) B2025@m-exp-id* B2024@m-exp-lab*) (Bdd1@chi-body* (cdr B1f8a@e*) B2023@r B2022@mr B2027@lex* B2026@rhs* B2021@mod** B2020@kwd* B1f91@exp* B1f92@rib B1f93@top?))))) (if (memv B1fb4@t '(library)) (begin (Be3b@library-expander (Bb86@stx->datum B1f9e@e)) (Bdd1@chi-body* (cdr B1f8a@e*) B1f8b@r B1f8c@mr B1f8d@lex* B1f8e@rhs* B1f8f@mod** B1fb2@kwd* B1f91@exp* B1f92@rib B1f93@top?)) (if (memv B1fb4@t '(export)) (let ((B2034@t B1f9e@e)) (let ((B2036@ls/false (Bd79@syntax-dispatch B2034@t '(_ . each-any)))) (if B2036@ls/false (apply (lambda (B2038@exp-decl*) (Bdd1@chi-body* (cdr B1f8a@e*) B1f8b@r B1f8c@mr B1f8d@lex* B1f8e@rhs* B1f8f@mod** B1fb2@kwd* (append B2038@exp-decl* B1f91@exp*) B1f92@rib B1f93@top?)) B2036@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B2034@t)))) (if (memv B1fb4@t '(import)) (letrec* ((B203b@module-import? (lambda (B208e@e) (let ((B2090@t B208e@e)) (let ((B2092@ls/false (Bd79@syntax-dispatch B2090@t '(_ any)))) (if (and B2092@ls/false (apply (lambda (B2094@id) (Bb72@id? B2094@id)) B2092@ls/false)) (apply (lambda (B2096@id) '#t) B2092@ls/false) (let ((B2098@t B2090@t)) (let ((B209a@ls/false (Bd79@syntax-dispatch B2098@t '(_ . each-any)))) (if B209a@ls/false (apply (lambda (B209c@imp*) '#f) B209a@ls/false) (let ((B209e@t B2098@t)) (let ((B20a0@ls/false (Bd79@syntax-dispatch B209e@t '_))) (if B20a0@ls/false (apply (lambda () (Be59@syntax-violation '#f '"malformed import form" B208e@e)) B20a0@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B209e@t)))))))))))) (B203d@module-import (lambda (B206c@e B206d@r) (let ((B2070@t B206c@e)) (let ((B2072@ls/false (Bd79@syntax-dispatch B2070@t '(_ any)))) (if (and B2072@ls/false (apply (lambda (B2074@id) (Bb72@id? B2074@id)) B2072@ls/false)) (apply (lambda (B2076@id) (call-with-values (lambda () (Bb94@syntax-type B2076@id B206d@r)) (lambda (B207e@B2079 B207f@B207b B2080@B207d) (let ((B2084@kwd B2080@B207d) (B2085@value B207f@B207b) (B2086@type B207e@B2079)) (let ((B208a@t B2086@type)) (if (memv B208a@t '($module)) (let ((B208c@iface B2085@value)) (values (Bdcd@module-interface-exp-id* B208c@iface B2076@id) (Bdc7@module-interface-exp-lab-vec B208c@iface))) (Be59@syntax-violation '#f '"invalid import" B206c@e))))))) B2072@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B2070@t)))))) (B203f@library-import (lambda (B2050@e) (let ((B2052@t B2050@e)) (let ((B2054@ls/false (Bd79@syntax-dispatch B2052@t '(any . each-any)))) (if B2054@ls/false (apply (lambda (B2056@ctxt B2057@imp*) (call-with-values (lambda () (Bddb@parse-import-spec* (Be5f@syntax->datum B2057@imp*))) (lambda (B205e@B205b B205f@B205d) (let ((B2062@subst-labels B205f@B205d) (B2063@subst-names B205e@B205b)) (values (vector-map (lambda (B2066@name) (Bb52@datum->stx B2056@ctxt B2066@name)) B2063@subst-names) B2062@subst-labels))))) B2054@ls/false) (let ((B2068@t B2052@t)) (let ((B206a@ls/false (Bd79@syntax-dispatch B2068@t '_))) (if B206a@ls/false (apply (lambda () (Be59@syntax-violation '#f '"invalid import form" B2050@e)) B206a@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B2068@t)))))))))) (begin (call-with-values (lambda () (if (B203b@module-import? B1f9e@e) (B203d@module-import B1f9e@e B1f8b@r) (B203f@library-import B1f9e@e))) (lambda (B2044@B2041 B2045@B2043) (let ((B2048@lab* B2045@B2043) (B2049@id* B2044@B2041)) (vector-for-each (lambda (B204c@id B204d@lab) (Bb28@extend-rib! B1f92@rib B204c@id B204d@lab)) B2049@id* B2048@lab*)))) (Bdd1@chi-body* (cdr B1f8a@e*) B1f8b@r B1f8c@mr B1f8d@lex* B1f8e@rhs* B1f8f@mod** B1fb2@kwd* B1f91@exp* B1f92@rib B1f93@top?))) (if B1f93@top? (Bdd1@chi-body* (cdr B1f8a@e*) B1f8b@r B1f8c@mr (cons (Bafa@gen-lexical 'dummy) B1f8d@lex*) (cons (cons 'top-expr B1f9e@e) B1f8e@rhs*) B1f8f@mod** B1fb2@kwd* B1f91@exp* B1f92@rib B1f93@top?) (values B1f8a@e* B1f8b@r B1f8c@mr B1f8d@lex* B1f8e@rhs* B1f8f@mod** B1fb2@kwd* B1f91@exp*)))))))))))))))))))))) (set! B2877@Bdd1@chi-body* Bdd1@chi-body*) (set! Bdd3@expand-transformer (lambda (B20a2@expr B20a3@r) (let ((B20a6@rtc (Bddf@make-collector))) (let ((B20a8@expanded-rhs (let ((B20b2@B20ab Bde1@inv-collector) (B20b3@B20ad Bde3@vis-collector) (B20b4@B20af B20a6@rtc) (B20b5@B20b1 (lambda (B20ba@x) (values)))) (let ((B20bc@swap (lambda () (begin (let ((B20be@t (B20b2@B20ab))) (begin (B20b2@B20ab B20b4@B20af) (set! B20b4@B20af B20be@t))) (let ((B20c0@t (B20b3@B20ad))) (begin (B20b3@B20ad B20b5@B20b1) (set! B20b5@B20b1 B20c0@t))))))) (dynamic-wind B20bc@swap (lambda () (Bd9b@chi-expr B20a2@expr B20a3@r B20a3@r)) B20bc@swap))))) (begin (for-each (let ((B20c2@mark-visit (Bde3@vis-collector))) (lambda (B20c4@x) (begin (B98e@B7dc@invoke-library B20c4@x) (B20c2@mark-visit B20c4@x)))) (B20a6@rtc)) B20a8@expanded-rhs))))) (set! B2878@Bdd3@expand-transformer Bdd3@expand-transformer) (set! Bdd5@parse-exports (lambda (B20c6@exp*) (let B20ce@f ((B20c8@exp* B20c6@exp*) (B20c9@int* '()) (B20ca@ext* '())) (if (null? B20c8@exp*) (begin (if (not (Bb7a@valid-bound-ids? B20ca@ext*)) (Be59@syntax-violation 'export '"invalid exports" (Bdaf@find-dups B20ca@ext*)) (void)) (values (map Be5f@syntax->datum B20ca@ext*) B20c9@int*)) (let ((B20d0@t (car B20c8@exp*))) (let ((B20d2@ls/false (Bd79@syntax-dispatch B20d0@t '(any . #(each (any any)))))) (if B20d2@ls/false (apply (lambda (B20d4@rename B20d5@i* B20d6@e*) (begin (if (not (and (eq? (Be5f@syntax->datum B20d4@rename) 'rename) (for-all Bb72@id? B20d5@i*) (for-all Bb72@id? B20d6@e*))) (Be59@syntax-violation 'export '"invalid export specifier" (car B20c8@exp*)) (void)) (B20ce@f (cdr B20c8@exp*) (append B20d5@i* B20c9@int*) (append B20d6@e* B20ca@ext*)))) B20d2@ls/false) (let ((B20da@t B20d0@t)) (let ((B20dc@ls/false (Bd79@syntax-dispatch B20da@t 'any))) (if B20dc@ls/false (apply (lambda (B20de@ie) (begin (if (not (Bb72@id? B20de@ie)) (Be59@syntax-violation 'export '"invalid export" B20de@ie) (void)) (B20ce@f (cdr B20c8@exp*) (cons B20de@ie B20c9@int*) (cons B20de@ie B20ca@ext*)))) B20dc@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B20da@t))))))))))) (set! B2879@Bdd5@parse-exports Bdd5@parse-exports) (set! Bdd7@parse-library-name (lambda (B20e0@spec) (letrec* ((B20e3@parse (lambda (B20f0@x) (let ((B20f2@t B20f0@x)) (let ((B20f4@ls/false (Bd79@syntax-dispatch B20f2@t '(each-any)))) (if (and B20f4@ls/false (apply (lambda (B20f6@v*) (for-all (lambda (B20f8@x) (let ((B20fa@x (Be5f@syntax->datum B20f8@x))) (and (integer? B20fa@x) (exact? B20fa@x)))) B20f6@v*)) B20f4@ls/false)) (apply (lambda (B20fc@v*) (values '() (map Be5f@syntax->datum B20fc@v*))) B20f4@ls/false) (let ((B20fe@t B20f2@t)) (let ((B2100@ls/false (Bd79@syntax-dispatch B20fe@t '(any . any)))) (if (and B2100@ls/false (apply (lambda (B2102@x B2103@rest) (symbol? (Be5f@syntax->datum B2102@x))) B2100@ls/false)) (apply (lambda (B2106@x B2107@rest) (call-with-values (lambda () (B20e3@parse B2107@rest)) (lambda (B210e@B210b B210f@B210d) (let ((B2112@v* B210f@B210d) (B2113@x* B210e@B210b)) (values (cons (Be5f@syntax->datum B2106@x) B2113@x*) B2112@v*))))) B2100@ls/false) (let ((B2116@t B20fe@t)) (let ((B2118@ls/false (Bd79@syntax-dispatch B2116@t '()))) (if B2118@ls/false (apply (lambda () (values '() '())) B2118@ls/false) (let ((B211a@t B2116@t)) (let ((B211c@ls/false (Bd79@syntax-dispatch B211a@t '_))) (if B211c@ls/false (apply (lambda () (Be59@syntax-violation '#f '"invalid library name" B20e0@spec)) B211c@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B211a@t)))))))))))))))) (call-with-values (lambda () (B20e3@parse B20e0@spec)) (lambda (B20e8@B20e5 B20e9@B20e7) (let ((B20ec@ver* B20e9@B20e7) (B20ed@name* B20e8@B20e5)) (begin (if (null? B20ed@name*) (Be59@syntax-violation '#f '"empty library name" B20e0@spec) (void)) (values B20ed@name* B20ec@ver*)))))))) (set! B287a@Bdd7@parse-library-name Bdd7@parse-library-name) (set! Bdd9@parse-library (lambda (B211e@e) (let ((B2120@t B211e@e)) (let ((B2122@ls/false (Bd79@syntax-dispatch B2120@t '(any each-any (any . each-any) (any . each-any) . each-any)))) (if (and B2122@ls/false (apply (lambda (B2124@library B2125@name* B2126@export B2127@exp* B2128@import B2129@imp* B212a@b*) (and (eq? (Be5f@syntax->datum B2126@export) 'export) (eq? (Be5f@syntax->datum B2128@import) 'import) (eq? (Be5f@syntax->datum B2124@library) 'library))) B2122@ls/false)) (apply (lambda (B2132@library B2133@name* B2134@export B2135@exp* B2136@import B2137@imp* B2138@b*) (values B2133@name* B2135@exp* B2137@imp* B2138@b*)) B2122@ls/false) (let ((B2140@t B2120@t)) (let ((B2142@ls/false (Bd79@syntax-dispatch B2140@t '_))) (if B2142@ls/false (apply (lambda () (Be59@syntax-violation '#f '"malformed library" B211e@e)) B2142@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B2140@t))))))))) (set! B287b@Bdd9@parse-library Bdd9@parse-library) (set! Bddb@parse-import-spec* (letrec* ((B2145@idsyn? (lambda (B234e@x) (symbol? (Be5f@syntax->datum B234e@x)))) (B2147@dup-error (lambda (B234c@name) (Be59@syntax-violation 'import '"two imports with different bindings" B234c@name))) (B2149@merge-substs (lambda (B233a@s B233b@subst) (letrec* ((B233f@insert-to-subst (lambda (B2340@a B2341@subst) (let ((B2344@name (car B2340@a)) (B2345@label (cdr B2340@a))) (let ((B2348@t (assq B2344@name B2341@subst))) (if B2348@t ((lambda (B234a@x) (if (eq? (cdr B234a@x) B2345@label) B2341@subst (B2147@dup-error B2344@name))) B2348@t) (cons B2340@a B2341@subst))))))) (if (null? B233a@s) B233b@subst (B233f@insert-to-subst (car B233a@s) (B2149@merge-substs (cdr B233a@s) B233b@subst)))))) (B214b@exclude* (lambda (B230a@sym* B230b@subst) (letrec* ((B230f@exclude (lambda (B2328@sym B2329@subst) (if (null? B2329@subst) (Be59@syntax-violation 'import '"cannot rename unbound identifier" B2328@sym) (if (eq? B2328@sym (caar B2329@subst)) (values (cdar B2329@subst) (cdr B2329@subst)) (let ((B232c@a (car B2329@subst))) (call-with-values (lambda () (B230f@exclude B2328@sym (cdr B2329@subst))) (lambda (B2332@B232f B2333@B2331) (let ((B2336@subst B2333@B2331) (B2337@old B2332@B232f)) (values B2337@old (cons B232c@a B2336@subst))))))))))) (if (null? B230a@sym*) (values '() B230b@subst) (call-with-values (lambda () (B230f@exclude (car B230a@sym*) B230b@subst)) (lambda (B2314@B2311 B2315@B2313) (let ((B2318@subst B2315@B2313) (B2319@old B2314@B2311)) (call-with-values (lambda () (B214b@exclude* (cdr B230a@sym*) B2318@subst)) (lambda (B2320@B231d B2321@B231f) (let ((B2324@subst B2321@B231f) (B2325@old* B2320@B231d)) (values (cons B2319@old B2325@old*) B2324@subst))))))))))) (B214d@find* (lambda (B2302@sym* B2303@subst) (map (lambda (B2306@x) (let ((B2308@t (assq B2306@x B2303@subst))) (if B2308@t (cdr B2308@t) (Be59@syntax-violation 'import '"cannot find identifier" B2306@x)))) B2302@sym*))) (B214f@rem* (lambda (B22fa@sym* B22fb@subst) (let B2300@f ((B22fe@subst B22fb@subst)) (if (null? B22fe@subst) '() (if (memq (caar B22fe@subst) B22fa@sym*) (B2300@f (cdr B22fe@subst)) (cons (car B22fe@subst) (B2300@f (cdr B22fe@subst)))))))) (B2151@remove-dups (lambda (B22f8@ls) (if (null? B22f8@ls) '() (if (memq (car B22f8@ls) (cdr B22f8@ls)) (B2151@remove-dups (cdr B22f8@ls)) (cons (car B22f8@ls) (B2151@remove-dups (cdr B22f8@ls))))))) (B2153@parse-library-name (lambda (B2210@spec) (letrec* ((B2213@subversion? (lambda (B22f4@x) (let ((B22f6@x (Be5f@syntax->datum B22f4@x))) (and (integer? B22f6@x) (exact? B22f6@x) (>= B22f6@x '0))))) (B2215@subversion-pred (lambda (B2294@x*) (let ((B2296@t B2294@x*)) (let ((B2298@ls/false (Bd79@syntax-dispatch B2296@t 'any))) (if (and B2298@ls/false (apply (lambda (B229a@n) (B2213@subversion? B229a@n)) B2298@ls/false)) (apply (lambda (B229c@n) (lambda (B229e@x) (= B229e@x (Be5f@syntax->datum B229c@n)))) B2298@ls/false) (let ((B22a0@t B2296@t)) (let ((B22a2@ls/false (Bd79@syntax-dispatch B22a0@t '(any . each-any)))) (if (and B22a2@ls/false (apply (lambda (B22a4@p? B22a5@sub*) (eq? (Be5f@syntax->datum B22a4@p?) 'and)) B22a2@ls/false)) (apply (lambda (B22a8@p? B22a9@sub*) (let ((B22ac@p* (map B2215@subversion-pred B22a9@sub*))) (lambda (B22ae@x) (for-all (lambda (B22b0@p) (B22b0@p B22ae@x)) B22ac@p*)))) B22a2@ls/false) (let ((B22b2@t B22a0@t)) (let ((B22b4@ls/false (Bd79@syntax-dispatch B22b2@t '(any . each-any)))) (if (and B22b4@ls/false (apply (lambda (B22b6@p? B22b7@sub*) (eq? (Be5f@syntax->datum B22b6@p?) 'or)) B22b4@ls/false)) (apply (lambda (B22ba@p? B22bb@sub*) (let ((B22be@p* (map B2215@subversion-pred B22bb@sub*))) (lambda (B22c0@x) (exists (lambda (B22c2@p) (B22c2@p B22c0@x)) B22be@p*)))) B22b4@ls/false) (let ((B22c4@t B22b2@t)) (let ((B22c6@ls/false (Bd79@syntax-dispatch B22c4@t '(any any)))) (if (and B22c6@ls/false (apply (lambda (B22c8@p? B22c9@sub) (eq? (Be5f@syntax->datum B22c8@p?) 'not)) B22c6@ls/false)) (apply (lambda (B22cc@p? B22cd@sub) (let ((B22d0@p (B2215@subversion-pred B22cd@sub))) (lambda (B22d2@x) (not (B22d0@p B22d2@x))))) B22c6@ls/false) (let ((B22d4@t B22c4@t)) (let ((B22d6@ls/false (Bd79@syntax-dispatch B22d4@t '(any any)))) (if (and B22d6@ls/false (apply (lambda (B22d8@p? B22d9@n) (and (eq? (Be5f@syntax->datum B22d8@p?) '<=) (B2213@subversion? B22d9@n))) B22d6@ls/false)) (apply (lambda (B22dc@p? B22dd@n) (lambda (B22e0@x) (<= B22e0@x (Be5f@syntax->datum B22dd@n)))) B22d6@ls/false) (let ((B22e2@t B22d4@t)) (let ((B22e4@ls/false (Bd79@syntax-dispatch B22e2@t '(any any)))) (if (and B22e4@ls/false (apply (lambda (B22e6@p? B22e7@n) (and (eq? (Be5f@syntax->datum B22e6@p?) '>=) (B2213@subversion? B22e7@n))) B22e4@ls/false)) (apply (lambda (B22ea@p? B22eb@n) (lambda (B22ee@x) (>= B22ee@x (Be5f@syntax->datum B22eb@n)))) B22e4@ls/false) (let ((B22f0@t B22e2@t)) (let ((B22f2@ls/false (Bd79@syntax-dispatch B22f0@t '_))) (if B22f2@ls/false (apply (lambda () (Be59@syntax-violation 'import '"invalid sub-version spec" B2210@spec B2294@x*)) B22f2@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B22f0@t)))))))))))))))))))))))) (B2217@version-pred (lambda (B2244@x*) (let ((B2246@t B2244@x*)) (let ((B2248@ls/false (Bd79@syntax-dispatch B2246@t '()))) (if B2248@ls/false (apply (lambda () (lambda (B224a@x) '#t)) B2248@ls/false) (let ((B224c@t B2246@t)) (let ((B224e@ls/false (Bd79@syntax-dispatch B224c@t '(any . each-any)))) (if (and B224e@ls/false (apply (lambda (B2250@c B2251@ver*) (eq? (Be5f@syntax->datum B2250@c) 'and)) B224e@ls/false)) (apply (lambda (B2254@c B2255@ver*) (let ((B2258@p* (map B2217@version-pred B2255@ver*))) (lambda (B225a@x) (for-all (lambda (B225c@p) (B225c@p B225a@x)) B2258@p*)))) B224e@ls/false) (let ((B225e@t B224c@t)) (let ((B2260@ls/false (Bd79@syntax-dispatch B225e@t '(any . each-any)))) (if (and B2260@ls/false (apply (lambda (B2262@c B2263@ver*) (eq? (Be5f@syntax->datum B2262@c) 'or)) B2260@ls/false)) (apply (lambda (B2266@c B2267@ver*) (let ((B226a@p* (map B2217@version-pred B2267@ver*))) (lambda (B226c@x) (exists (lambda (B226e@p) (B226e@p B226c@x)) B226a@p*)))) B2260@ls/false) (let ((B2270@t B225e@t)) (let ((B2272@ls/false (Bd79@syntax-dispatch B2270@t '(any any)))) (if (and B2272@ls/false (apply (lambda (B2274@c B2275@ver) (eq? (Be5f@syntax->datum B2274@c) 'not)) B2272@ls/false)) (apply (lambda (B2278@c B2279@ver) (let ((B227c@p (B2217@version-pred B2279@ver))) (lambda (B227e@x) (not (B227c@p B227e@x))))) B2272@ls/false) (let ((B2280@t B2270@t)) (let ((B2282@ls/false (Bd79@syntax-dispatch B2280@t 'each-any))) (if B2282@ls/false (apply (lambda (B2284@sub*) (let ((B2286@p* (map B2215@subversion-pred B2284@sub*))) (lambda (B2288@x) (let B228e@f ((B228a@p* B2286@p*) (B228b@x B2288@x)) (if (null? B228a@p*) '#t (if (null? B228b@x) '#f (and ((car B228a@p*) (car B228b@x)) (B228e@f (cdr B228a@p*) (cdr B228b@x))))))))) B2282@ls/false) (let ((B2290@t B2280@t)) (let ((B2292@ls/false (Bd79@syntax-dispatch B2290@t '_))) (if B2292@ls/false (apply (lambda () (Be59@syntax-violation 'import '"invalid version spec" B2210@spec B2244@x*)) B2292@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B2290@t)))))))))))))))))))))) (let B221a@f ((B2218@x B2210@spec)) (let ((B221c@t B2218@x)) (let ((B221e@ls/false (Bd79@syntax-dispatch B221c@t '(each-any)))) (if B221e@ls/false (apply (lambda (B2220@version-spec*) (values '() (B2217@version-pred B2220@version-spec*))) B221e@ls/false) (let ((B2222@t B221c@t)) (let ((B2224@ls/false (Bd79@syntax-dispatch B2222@t '(any . any)))) (if (and B2224@ls/false (apply (lambda (B2226@x B2227@x*) (B2145@idsyn? B2226@x)) B2224@ls/false)) (apply (lambda (B222a@x B222b@x*) (call-with-values (lambda () (B221a@f B222b@x*)) (lambda (B2232@B222f B2233@B2231) (let ((B2236@pred B2233@B2231) (B2237@name B2232@B222f)) (values (cons (Be5f@syntax->datum B222a@x) B2237@name) B2236@pred))))) B2224@ls/false) (let ((B223a@t B2222@t)) (let ((B223c@ls/false (Bd79@syntax-dispatch B223a@t '()))) (if B223c@ls/false (apply (lambda () (values '() (lambda (B223e@x) '#t))) B223c@ls/false) (let ((B2240@t B223a@t)) (let ((B2242@ls/false (Bd79@syntax-dispatch B2240@t '_))) (if B2242@ls/false (apply (lambda () (Be59@syntax-violation '#f '"invalid import spec" B2210@spec)) B2242@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B2240@t))))))))))))))))) (B2155@import-library (lambda (B2200@spec*) (call-with-values (lambda () (B2153@parse-library-name B2200@spec*)) (lambda (B2206@B2203 B2207@B2205) (let ((B220a@pred B2207@B2205) (B220b@name B2206@B2203)) (begin (if (null? B220b@name) (Be59@syntax-violation 'import '"empty library name" B2200@spec*) (void)) (let ((B220e@lib (B987@B7ce@find-library-by-name B220b@name))) (begin (if (not B220e@lib) (Be59@syntax-violation 'import '"cannot find library with required name" B220b@name) (void)) (if (not (B220a@pred (B961@B782@library-version B220e@lib))) (Be59@syntax-violation 'import '"library does not satisfy version specification" B2200@spec* B220e@lib) (void)) ((Bde5@imp-collector) B220e@lib) (B969@B792@library-subst B220e@lib))))))))) (B2157@get-import (lambda (B2172@spec) (let ((B2174@t B2172@spec)) (let ((B2176@ls/false (Bd79@syntax-dispatch B2174@t '(any . each-any)))) (if (and B2176@ls/false (apply (lambda (B2178@x B2179@x*) (not (memq (Be5f@syntax->datum B2178@x) '(for rename except only prefix library)))) B2176@ls/false)) (apply (lambda (B217c@x B217d@x*) (B2155@import-library (cons B217c@x B217d@x*))) B2176@ls/false) (let ((B2180@t B2174@t)) (let ((B2182@ls/false (Bd79@syntax-dispatch B2180@t '(any any . #(each (any any)))))) (if (and B2182@ls/false (apply (lambda (B2184@rename B2185@isp B2186@old* B2187@new*) (and (eq? (Be5f@syntax->datum B2184@rename) 'rename) (for-all B2145@idsyn? B2186@old*) (for-all B2145@idsyn? B2187@new*))) B2182@ls/false)) (apply (lambda (B218c@rename B218d@isp B218e@old* B218f@new*) (let ((B2194@subst (B2157@get-import B218d@isp)) (B2195@old* (map Be5f@syntax->datum B218e@old*)) (B2196@new* (map Be5f@syntax->datum B218f@new*))) (let ((B219a@old-label* (B214d@find* B2195@old* B2194@subst))) (let ((B219c@subst (B214f@rem* B2195@old* B2194@subst))) (B2149@merge-substs (map cons B2196@new* B219a@old-label*) B219c@subst))))) B2182@ls/false) (let ((B219e@t B2180@t)) (let ((B21a0@ls/false (Bd79@syntax-dispatch B219e@t '(any any . each-any)))) (if (and B21a0@ls/false (apply (lambda (B21a2@except B21a3@isp B21a4@sym*) (and (eq? (Be5f@syntax->datum B21a2@except) 'except) (for-all B2145@idsyn? B21a4@sym*))) B21a0@ls/false)) (apply (lambda (B21a8@except B21a9@isp B21aa@sym*) (let ((B21ae@subst (B2157@get-import B21a9@isp))) (B214f@rem* (map Be5f@syntax->datum B21aa@sym*) B21ae@subst))) B21a0@ls/false) (let ((B21b0@t B219e@t)) (let ((B21b2@ls/false (Bd79@syntax-dispatch B21b0@t '(any any . each-any)))) (if (and B21b2@ls/false (apply (lambda (B21b4@only B21b5@isp B21b6@sym*) (and (eq? (Be5f@syntax->datum B21b4@only) 'only) (for-all B2145@idsyn? B21b6@sym*))) B21b2@ls/false)) (apply (lambda (B21ba@only B21bb@isp B21bc@sym*) (let ((B21c0@subst (B2157@get-import B21bb@isp)) (B21c1@sym* (map Be5f@syntax->datum B21bc@sym*))) (let ((B21c4@sym* (B2151@remove-dups B21c1@sym*))) (let ((B21c6@lab* (B214d@find* B21c4@sym* B21c0@subst))) (map cons B21c4@sym* B21c6@lab*))))) B21b2@ls/false) (let ((B21c8@t B21b0@t)) (let ((B21ca@ls/false (Bd79@syntax-dispatch B21c8@t '(any any any)))) (if (and B21ca@ls/false (apply (lambda (B21cc@prefix B21cd@isp B21ce@p) (and (eq? (Be5f@syntax->datum B21cc@prefix) 'prefix) (B2145@idsyn? B21ce@p))) B21ca@ls/false)) (apply (lambda (B21d2@prefix B21d3@isp B21d4@p) (let ((B21d8@subst (B2157@get-import B21d3@isp)) (B21d9@prefix (symbol->string (Be5f@syntax->datum B21d4@p)))) (map (lambda (B21dc@x) (cons (string->symbol (string-append B21d9@prefix (symbol->string (car B21dc@x)))) (cdr B21dc@x))) B21d8@subst))) B21ca@ls/false) (let ((B21de@t B21c8@t)) (let ((B21e0@ls/false (Bd79@syntax-dispatch B21de@t '(any each-any)))) (if (and B21e0@ls/false (apply (lambda (B21e2@library B21e3@spec*) (eq? (Be5f@syntax->datum B21e2@library) 'library)) B21e0@ls/false)) (apply (lambda (B21e6@library B21e7@spec*) (B2155@import-library B21e7@spec*)) B21e0@ls/false) (let ((B21ea@t B21de@t)) (let ((B21ec@ls/false (Bd79@syntax-dispatch B21ea@t '(any any . any)))) (if (and B21ec@ls/false (apply (lambda (B21ee@for B21ef@isp B21f0@rest) (eq? (Be5f@syntax->datum B21ee@for) 'for)) B21ec@ls/false)) (apply (lambda (B21f4@for B21f5@isp B21f6@rest) (B2157@get-import B21f5@isp)) B21ec@ls/false) (let ((B21fa@t B21ea@t)) (let ((B21fc@ls/false (Bd79@syntax-dispatch B21fa@t 'any))) (if B21fc@ls/false (apply (lambda (B21fe@spec) (Be59@syntax-violation 'import '"invalid import spec" B21fe@spec)) B21fc@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B21fa@t))))))))))))))))))))))))))) (B2159@add-imports! (lambda (B2162@imp B2163@h) (let ((B2166@subst (B2157@get-import B2162@imp))) (for-each (lambda (B2168@x) (let ((B216a@name (car B2168@x)) (B216b@label (cdr B2168@x))) (let ((B216e@t (hashtable-ref B2163@h B216a@name '#f))) (if B216e@t ((lambda (B2170@l) (if (not (eq? B2170@l B216b@label)) (B2147@dup-error B216a@name) (void))) B216e@t) (hashtable-set! B2163@h B216a@name B216b@label))))) B2166@subst))))) (lambda (B215a@imp*) (let B2160@f ((B215c@imp* B215a@imp*) (B215d@h (make-eq-hashtable))) (if (null? B215c@imp*) (hashtable-entries B215d@h) (begin (B2159@add-imports! (car B215c@imp*) B215d@h) (B2160@f (cdr B215c@imp*) B215d@h))))))) (set! B287c@Bddb@parse-import-spec* Bddb@parse-import-spec*) (set! Bddd@make-top-rib (lambda (B2350@names B2351@labels) (let ((B2354@rib (Bb26@make-empty-rib))) (begin (vector-for-each (lambda (B2356@name B2357@label) (begin (if (not (symbol? B2356@name)) (error 'make-top-rib '"BUG: not a symbol" B2356@name) (void)) (Bb2a@extend-rib/nc! B2354@rib (make-simple-struct 'stx '5 (list B2356@name Baf6@top-mark* '() '())) B2357@label))) B2350@names B2351@labels) B2354@rib)))) (set! B287d@Bddd@make-top-rib Bddd@make-top-rib) (set! Bddf@make-collector (lambda () (let ((B235a@ls '())) (lambda B235e (let ((B235f (length B235e))) (if (= B235f '0) (apply (lambda () B235a@ls) B235e) (if (= B235f '1) (apply (lambda (B235c@x) (set! B235a@ls (Baef@set-cons B235c@x B235a@ls))) B235e) (error 'apply '"invalid arg count")))))))) (set! B287e@Bddf@make-collector Bddf@make-collector) (set! Bde1@inv-collector (B6c2@B5a0@make-parameter (lambda B2360@args (assertion-violation 'inv-collector '"BUG: not initialized")) (lambda (B2362@x) (begin (if (not (procedure? B2362@x)) (assertion-violation 'inv-collector '"BUG: not a procedure" B2362@x) (void)) B2362@x)))) (set! B287f@Bde1@inv-collector Bde1@inv-collector) (set! Bde3@vis-collector (B6c2@B5a0@make-parameter (lambda B2364@args (assertion-violation 'vis-collector '"BUG: not initialized")) (lambda (B2366@x) (begin (if (not (procedure? B2366@x)) (assertion-violation 'vis-collector '"BUG: not a procedure" B2366@x) (void)) B2366@x)))) (set! B2880@Bde3@vis-collector Bde3@vis-collector) (set! Bde5@imp-collector (B6c2@B5a0@make-parameter (lambda B2368@args (assertion-violation 'imp-collector '"BUG: not initialized")) (lambda (B236a@x) (begin (if (not (procedure? B236a@x)) (assertion-violation 'imp-collector '"BUG: not a procedure" B236a@x) (void)) B236a@x)))) (set! B2881@Bde5@imp-collector Bde5@imp-collector) (set! Bde7@chi-library-internal (lambda (B236c@e* B236d@rib B236e@top?) (call-with-values (lambda () (Bdd1@chi-body* B236c@e* '() '() '() '() '() '() '() B236d@rib B236e@top?)) (lambda (B2382@B2373 B2383@B2375 B2384@B2377 B2385@B2379 B2386@B237b B2387@B237d B2388@B237f B2389@B2381) (let ((B2392@exp* B2389@B2381) (B2393@_kwd* B2388@B237f) (B2394@mod** B2387@B237d) (B2395@rhs* B2386@B237b) (B2396@lex* B2385@B2379) (B2397@mr B2384@B2377) (B2398@r B2383@B2375) (B2399@e* B2382@B2373)) (values (append (apply append (reverse B2394@mod**)) B2399@e*) B2398@r B2397@mr (reverse B2396@lex*) (reverse B2395@rhs*) B2392@exp*)))))) (set! B2882@Bde7@chi-library-internal Bde7@chi-library-internal) (set! Bde9@chi-interaction-expr (lambda (B23a2@e B23a3@rib B23a4@r) (call-with-values (lambda () (Bdd1@chi-body* (list B23a2@e) B23a4@r B23a4@r '() '() '() '() '() B23a3@rib '#t)) (lambda (B23b8@B23a9 B23b9@B23ab B23ba@B23ad B23bb@B23af B23bc@B23b1 B23bd@B23b3 B23be@B23b5 B23bf@B23b7) (let ((B23c8@_exp* B23bf@B23b7) (B23c9@_kwd* B23be@B23b5) (B23ca@mod** B23bd@B23b3) (B23cb@rhs* B23bc@B23b1) (B23cc@lex* B23bb@B23af) (B23cd@mr B23ba@B23ad) (B23ce@r B23b9@B23ab) (B23cf@e* B23b8@B23a9)) (let ((B23d8@e* (Bda9@expand-interaction-rhs*/init* (reverse B23cc@lex*) (reverse B23cb@rhs*) (append (apply append (reverse B23ca@mod**)) B23cf@e*) B23ce@r B23cd@mr))) (let ((B23da@e (if (null? B23d8@e*) (Bad8@Ba39@build-void) (if (null? (cdr B23d8@e*)) (car B23d8@e*) (Bad7@Ba37@build-sequence '#f B23d8@e*))))) (values B23da@e B23ce@r)))))))) (set! B2883@Bde9@chi-interaction-expr Bde9@chi-interaction-expr) (set! Bdeb@library-body-expander (lambda (B23dc@name B23dd@main-exp* B23de@imp* B23df@b* B23e0@top?) (letrec* ((B23e7@itc (Bddf@make-collector))) (let ((B23f0@B23e9 Bde5@imp-collector) (B23f1@B23eb Be69@top-level-context) (B23f2@B23ed B23e7@itc) (B23f3@B23ef '#f)) (let ((B23f8@swap (lambda () (begin (let ((B23fa@t (B23f0@B23e9))) (begin (B23f0@B23e9 B23f2@B23ed) (set! B23f2@B23ed B23fa@t))) (let ((B23fc@t (B23f1@B23eb))) (begin (B23f1@B23eb B23f3@B23ef) (set! B23f3@B23ef B23fc@t))))))) (dynamic-wind B23f8@swap (lambda () (call-with-values (lambda () (Bddb@parse-import-spec* B23de@imp*)) (lambda (B2402@B23ff B2403@B2401) (let ((B2406@subst-labels B2403@B2401) (B2407@subst-names B2402@B23ff)) (let ((B240a@rib (Bddd@make-top-rib B2407@subst-names B2406@subst-labels))) (letrec* ((B240d@wrap (lambda (B2488@x) (make-simple-struct 'stx '5 (list B2488@x Baf6@top-mark* (list B240a@rib) '()))))) (let ((B240e@b* (map B240d@wrap B23df@b*)) (B240f@main-exp* (map B240d@wrap B23dd@main-exp*)) (B2410@rtc (Bddf@make-collector)) (B2411@vtc (Bddf@make-collector))) (let ((B241e@B2417 Bde1@inv-collector) (B241f@B2419 Bde3@vis-collector) (B2420@B241b B2410@rtc) (B2421@B241d B2411@vtc)) (let ((B2426@swap (lambda () (begin (let ((B2428@t (B241e@B2417))) (begin (B241e@B2417 B2420@B241b) (set! B2420@B241b B2428@t))) (let ((B242a@t (B241f@B2419))) (begin (B241f@B2419 B2421@B241d) (set! B2421@B241d B242a@t))))))) (dynamic-wind B2426@swap (lambda () (call-with-values (lambda () (Bde7@chi-library-internal B240e@b* B240a@rib B23e0@top?)) (lambda (B2438@B242d B2439@B242f B243a@B2431 B243b@B2433 B243c@B2435 B243d@B2437) (let ((B2444@internal-exp* B243d@B2437) (B2445@rhs* B243c@B2435) (B2446@lex* B243b@B2433) (B2447@mr B243a@B2431) (B2448@r B2439@B242f) (B2449@init* B2438@B242d)) (call-with-values (lambda () (Bdd5@parse-exports (append B240f@main-exp* B2444@internal-exp*))) (lambda (B2454@B2451 B2455@B2453) (let ((B2458@exp-id* B2455@B2453) (B2459@exp-name* B2454@B2451)) (begin (Bb2e@seal-rib! B240a@rib) (let ((B245c@init* (Bd97@chi-expr* B2449@init* B2448@r B2447@mr))) (let ((B245e@rhs* (Bdab@chi-rhs* B2445@rhs* B2448@r B2447@mr))) (begin (Bb30@unseal-rib! B240a@rib) (let ((B2460@loc* (map Bafc@gen-global B2446@lex*)) (B2461@export-subst (Be43@make-export-subst B2459@exp-name* B2458@exp-id*))) (letrec* ((B2465@errstr '"attempt to export mutated variable")) (call-with-values (lambda () (Be45@make-export-env/macros B2446@lex* B2460@loc* B2448@r)) (lambda (B246c@B2467 B246d@B2469 B246e@B246b) (let ((B2472@macro* B246e@B246b) (B2473@global* B246d@B2469) (B2474@export-env B246c@B2467)) (begin (for-each (lambda (B2478@s) (let ((B247a@name (car B2478@s)) (B247b@label (cdr B2478@s))) (let ((B247e@p (assq B247b@label B2474@export-env))) (if B247e@p (let ((B2480@b (cdr B247e@p))) (let ((B2482@type (car B2480@b))) (if (eq? B2482@type 'mutable) (Be59@syntax-violation 'export B2465@errstr B247a@name) (void)))) (void))))) B2461@export-subst) (let ((B2484@invoke-body (Badd@Ba43@build-library-letrec* '#f B23dc@name B2446@lex* B2460@loc* B245e@rhs* (if (null? B245c@init*) (Bad8@Ba39@build-void) (Bad7@Ba37@build-sequence '#f B245c@init*)))) (B2485@invoke-definitions (map Bad4@B996@build-global-define (map cdr B2473@global*)))) (values (B23e7@itc) (B2410@rtc) (B2411@vtc) (Bad7@Ba37@build-sequence '#f (append B2485@invoke-definitions (list B2484@invoke-body))) B2472@macro* B2461@export-subst B2474@export-env))))))))))))))))))) B2426@swap)))))))))) B23f8@swap)))))) (set! B2884@Bdeb@library-body-expander Bdeb@library-body-expander) (set! Bded@core-library-expander (lambda (B248a@e B248b@verify-name) (call-with-values (lambda () (Bdd9@parse-library B248a@e)) (lambda (B2496@B248f B2497@B2491 B2498@B2493 B2499@B2495) (let ((B249e@b* B2499@B2495) (B249f@imp* B2498@B2493) (B24a0@exp* B2497@B2491) (B24a1@name* B2496@B248f)) (call-with-values (lambda () (Bdd7@parse-library-name B24a1@name*)) (lambda (B24aa@B24a7 B24ab@B24a9) (let ((B24ae@ver B24ab@B24a9) (B24af@name B24aa@B24a7)) (begin (B248b@verify-name B24af@name) (call-with-values (lambda () (Bdeb@library-body-expander B24af@name B24a0@exp* B249f@imp* B249e@b* '#f)) (lambda (B24c0@B24b3 B24c1@B24b5 B24c2@B24b7 B24c3@B24b9 B24c4@B24bb B24c5@B24bd B24c6@B24bf) (let ((B24ce@export-env B24c6@B24bf) (B24cf@export-subst B24c5@B24bd) (B24d0@visit-code B24c4@B24bb) (B24d1@invoke-code B24c3@B24b9) (B24d2@visit-req* B24c2@B24b7) (B24d3@invoke-req* B24c1@B24b5) (B24d4@imp* B24c0@B24b3)) (values B24af@name B24ae@ver B24d4@imp* B24d3@invoke-req* B24d2@visit-req* B24d1@invoke-code B24d0@visit-code B24cf@export-subst B24ce@export-env))))))))))))) (set! B2885@Bded@core-library-expander Bded@core-library-expander) (set! Bdef@parse-top-level-program (lambda (B24dc@e*) (let ((B24de@t B24dc@e*)) (let ((B24e0@ls/false (Bd79@syntax-dispatch B24de@t '((any . each-any) . each-any)))) (if (and B24e0@ls/false (apply (lambda (B24e2@import B24e3@imp* B24e4@b*) (eq? (Be5f@syntax->datum B24e2@import) 'import)) B24e0@ls/false)) (apply (lambda (B24e8@import B24e9@imp* B24ea@b*) (values B24e9@imp* B24ea@b*)) B24e0@ls/false) (let ((B24ee@t B24de@t)) (let ((B24f0@ls/false (Bd79@syntax-dispatch B24ee@t '((any . any) . any)))) (if (and B24f0@ls/false (apply (lambda (B24f2@import B24f3@x B24f4@y) (eq? (Be5f@syntax->datum B24f2@import) 'import)) B24f0@ls/false)) (apply (lambda (B24f8@import B24f9@x B24fa@y) (Be59@syntax-violation 'expander '"invalid syntax of top-level program" (Bb6c@syntax-car B24dc@e*))) B24f0@ls/false) (let ((B24fe@t B24ee@t)) (let ((B2500@ls/false (Bd79@syntax-dispatch B24fe@t '_))) (if B2500@ls/false (apply (lambda () (assertion-violation 'expander '"top-level program is missing an (import ---) clause")) B2500@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B24fe@t)))))))))))) (set! B2886@Bdef@parse-top-level-program Bdef@parse-top-level-program) (set! Bdf1@top-level-expander (lambda (B2502@e*) (call-with-values (lambda () (Bdef@parse-top-level-program B2502@e*)) (lambda (B2508@B2505 B2509@B2507) (let ((B250c@b* B2509@B2507) (B250d@imp* B2508@B2505)) (call-with-values (lambda () (Bdeb@library-body-expander '() '() B250d@imp* B250c@b* '#t)) (lambda (B251e@B2511 B251f@B2513 B2520@B2515 B2521@B2517 B2522@B2519 B2523@B251b B2524@B251d) (let ((B252c@export-env B2524@B251d) (B252d@export-subst B2523@B251b) (B252e@visit-code B2522@B2519) (B252f@invoke-code B2521@B2517) (B2530@visit-req* B2520@B2515) (B2531@invoke-req* B251f@B2513) (B2532@imp* B251e@B2511)) (values B2531@invoke-req* B252f@invoke-code))))))))) (set! B2887@Bdf1@top-level-expander Bdf1@top-level-expander) (set! Bdf3@rp (B6bf@B59a@make-record-printer 'env (lambda (B253a@x B253b@p B253c@wr) (display '"#<environment>" B253b@p)))) (set! B2888@Bdf3@rp Bdf3@rp) (set! Bdfd@env? (lambda (B2540@x) (and (simple-struct? B2540@x) (eq? (simple-struct-name B2540@x) 'env)))) (set! B2889@Bdfd@env? Bdfd@env?) (set! Bdff@env-names (lambda (B2542@x) (simple-struct-ref B2542@x '0))) (set! B288a@Bdff@env-names Bdff@env-names) (set! Be01@set-env-names! (lambda (B2544@x B2545@val) (simple-struct-set! B2544@x '0 B2545@val))) (set! B288b@Be01@set-env-names! Be01@set-env-names!) (set! Be03@env-labels (lambda (B2548@x) (simple-struct-ref B2548@x '1))) (set! B288c@Be03@env-labels Be03@env-labels) (set! Be05@set-env-labels! (lambda (B254a@x B254b@val) (simple-struct-set! B254a@x '1 B254b@val))) (set! B288d@Be05@set-env-labels! Be05@set-env-labels!) (set! Be07@env-itc (lambda (B254e@x) (simple-struct-ref B254e@x '2))) (set! B288e@Be07@env-itc Be07@env-itc) (set! Be09@set-env-itc! (lambda (B2550@x B2551@val) (simple-struct-set! B2550@x '2 B2551@val))) (set! B288f@Be09@set-env-itc! Be09@set-env-itc!) (set! Be0b@dummy '3) (set! B2890@Be0b@dummy Be0b@dummy) (set! Be0d@rp (B6bf@B59a@make-record-printer 'interaction-env (lambda (B2554@x B2555@p B2556@wr) (display '"#<environment>" B2555@p)))) (set! B2891@Be0d@rp Be0d@rp) (set! Be17@interaction-env? (lambda (B255a@x) (and (simple-struct? B255a@x) (eq? (simple-struct-name B255a@x) 'interaction-env)))) (set! B2892@Be17@interaction-env? Be17@interaction-env?) (set! Be19@interaction-env-rib (lambda (B255c@x) (simple-struct-ref B255c@x '0))) (set! B2893@Be19@interaction-env-rib Be19@interaction-env-rib) (set! Be1b@set-interaction-env-rib! (lambda (B255e@x B255f@val) (simple-struct-set! B255e@x '0 B255f@val))) (set! B2894@Be1b@set-interaction-env-rib! Be1b@set-interaction-env-rib!) (set! Be1d@interaction-env-r (lambda (B2562@x) (simple-struct-ref B2562@x '1))) (set! B2895@Be1d@interaction-env-r Be1d@interaction-env-r) (set! Be1f@set-interaction-env-r! (lambda (B2564@x B2565@val) (simple-struct-set! B2564@x '1 B2565@val))) (set! B2896@Be1f@set-interaction-env-r! Be1f@set-interaction-env-r!) (set! Be21@interaction-env-locs (lambda (B2568@x) (simple-struct-ref B2568@x '2))) (set! B2897@Be21@interaction-env-locs Be21@interaction-env-locs) (set! Be23@set-interaction-env-locs! (lambda (B256a@x B256b@val) (simple-struct-set! B256a@x '2 B256b@val))) (set! B2898@Be23@set-interaction-env-locs! Be23@set-interaction-env-locs!) (set! Be25@dummy '3) (set! B2899@Be25@dummy Be25@dummy) (set! Be27@interaction-environment-symbols (lambda () (Be2f@environment-symbols (Be67@interaction-environment)))) (set! B289a@Be27@interaction-environment-symbols Be27@interaction-environment-symbols) (set! Be29@environment-bindings (lambda (B256e@e) (vector->list (vector-map (lambda (B2570@name B2571@label) (Be2b@parse-binding (cons B2570@name (B98d@B7da@imported-label->binding B2571@label)))) (Bdff@env-names B256e@e) (Be03@env-labels B256e@e))))) (set! B289b@Be29@environment-bindings Be29@environment-bindings) (set! Be2b@parse-binding (lambda (B2574@b) (cons (car B2574@b) (let ((B2576@t (cadr B2574@b))) (if (memv B2576@t '(core-prim global)) 'procedure (if (memv B2576@t '(core-macro macro global-macro)) 'syntax (if (memv B2576@t '($core-rtd)) 'record (if (eq? (car B2574@b) (cadr B2574@b)) 'syntax 'unknown)))))))) (set! B289c@Be2b@parse-binding Be2b@parse-binding) (set! Be2d@environment? (lambda (B2578@x) (or (Bdfd@env? B2578@x) (Be17@interaction-env? B2578@x)))) (set! B289d@Be2d@environment? Be2d@environment?) (set! Be2f@environment-symbols (lambda (B257a@x) (if (Bdfd@env? B257a@x) (vector->list (Bdff@env-names B257a@x)) (if (Be17@interaction-env? B257a@x) (map values (Bb10@rib-sym* (Be19@interaction-env-rib B257a@x))) (assertion-violation 'environment-symbols '"not an environment" B257a@x))))) (set! B289e@Be2f@environment-symbols Be2f@environment-symbols) (set! Be31@environment (lambda B257c@imp* (let ((B257e@itc (Bddf@make-collector))) (let ((B2584@B2581 Bde5@imp-collector) (B2585@B2583 B257e@itc)) (let ((B2588@swap (lambda () (let ((B258a@t (B2584@B2581))) (begin (B2584@B2581 B2585@B2583) (set! B2585@B2583 B258a@t)))))) (dynamic-wind B2588@swap (lambda () (call-with-values (lambda () (Bddb@parse-import-spec* B257c@imp*)) (lambda (B2590@B258d B2591@B258f) (let ((B2594@subst-labels B2591@B258f) (B2595@subst-names B2590@B258d)) (make-simple-struct 'env '4 (list B2595@subst-names B2594@subst-labels B257e@itc)))))) B2588@swap)))))) (set! B289f@Be31@environment Be31@environment) (set! Be33@null-environment (lambda (B2598@n) (begin (if (not (eqv? B2598@n '5)) (assertion-violation 'null-environment '"not 5" B2598@n) (void)) (Be31@environment '(psyntax null-environment-5))))) (set! B28a0@Be33@null-environment Be33@null-environment) (set! Be35@scheme-report-environment (lambda (B259a@n) (begin (if (not (eqv? B259a@n '5)) (assertion-violation 'scheme-report-environment '"not 5" B259a@n) (void)) (Be31@environment '(psyntax scheme-report-environment-5))))) (set! B28a1@Be35@scheme-report-environment Be35@scheme-report-environment) (set! Be37@expand (lambda (B259c@x B259d@env) (if (Bdfd@env? B259d@env) (let ((B25a0@rib (Bddd@make-top-rib (Bdff@env-names B259d@env) (Be03@env-labels B259d@env)))) (let ((B25a2@x (make-simple-struct 'stx '5 (list B259c@x Baf6@top-mark* (list B25a0@rib) '()))) (B25a3@itc (Be07@env-itc B259d@env)) (B25a4@rtc (Bddf@make-collector)) (B25a5@vtc (Bddf@make-collector))) (let ((B25aa@x (let ((B25bc@B25ad Be69@top-level-context) (B25bd@B25af Bde1@inv-collector) (B25be@B25b1 Bde3@vis-collector) (B25bf@B25b3 Bde5@imp-collector) (B25c0@B25b5 '#f) (B25c1@B25b7 B25a4@rtc) (B25c2@B25b9 B25a5@vtc) (B25c3@B25bb B25a3@itc)) (let ((B25cc@swap (lambda () (begin (let ((B25ce@t (B25bc@B25ad))) (begin (B25bc@B25ad B25c0@B25b5) (set! B25c0@B25b5 B25ce@t))) (let ((B25d0@t (B25bd@B25af))) (begin (B25bd@B25af B25c1@B25b7) (set! B25c1@B25b7 B25d0@t))) (let ((B25d2@t (B25be@B25b1))) (begin (B25be@B25b1 B25c2@B25b9) (set! B25c2@B25b9 B25d2@t))) (let ((B25d4@t (B25bf@B25b3))) (begin (B25bf@B25b3 B25c3@B25bb) (set! B25c3@B25bb B25d4@t))))))) (dynamic-wind B25cc@swap (lambda () (Bd9b@chi-expr B25a2@x '() '())) B25cc@swap))))) (begin (Bb2e@seal-rib! B25a0@rib) (values B25aa@x (B25a4@rtc)))))) (if (Be17@interaction-env? B259d@env) (let ((B25d6@rib (Be19@interaction-env-rib B259d@env)) (B25d7@r (Be1d@interaction-env-r B259d@env)) (B25d8@rtc (Bddf@make-collector))) (let ((B25dc@x (make-simple-struct 'stx '5 (list B259c@x Baf6@top-mark* (list B25d6@rib) '())))) (call-with-values (lambda () (let ((B25f2@B25e3 Be69@top-level-context) (B25f3@B25e5 Bde1@inv-collector) (B25f4@B25e7 Bde3@vis-collector) (B25f5@B25e9 Bde5@imp-collector) (B25f6@B25eb B259d@env) (B25f7@B25ed B25d8@rtc) (B25f8@B25ef (Bddf@make-collector)) (B25f9@B25f1 (Bddf@make-collector))) (let ((B2602@swap (lambda () (begin (let ((B2604@t (B25f2@B25e3))) (begin (B25f2@B25e3 B25f6@B25eb) (set! B25f6@B25eb B2604@t))) (let ((B2606@t (B25f3@B25e5))) (begin (B25f3@B25e5 B25f7@B25ed) (set! B25f7@B25ed B2606@t))) (let ((B2608@t (B25f4@B25e7))) (begin (B25f4@B25e7 B25f8@B25ef) (set! B25f8@B25ef B2608@t))) (let ((B260a@t (B25f5@B25e9))) (begin (B25f5@B25e9 B25f9@B25f1) (set! B25f9@B25f1 B260a@t))))))) (dynamic-wind B2602@swap (lambda () (Bde9@chi-interaction-expr B25dc@x B25d6@rib B25d7@r)) B2602@swap)))) (lambda (B260c@B25df B260d@B25e1) (let ((B2610@r^ B260d@B25e1) (B2611@e B260c@B25df)) (begin (Be1f@set-interaction-env-r! B259d@env B2610@r^) (values B2611@e (B25d8@rtc)))))))) (assertion-violation 'expand '"not an environment" B259d@env))))) (set! B28a2@Be37@expand Be37@expand) (set! Be39@eval (lambda (B2614@x B2615@env) (begin (if (not (Be2d@environment? B2615@env)) (error 'eval '"not an environment" B2615@env) (void)) (call-with-values (lambda () (Be37@expand B2614@x B2615@env)) (lambda (B261c@B2619 B261d@B261b) (let ((B2620@invoke-req* B261d@B261b) (B2621@x B261c@B2619)) (begin (for-each B98e@B7dc@invoke-library B2620@invoke-req*) (eval-core (B718@B6d0@expanded->core B2621@x))))))))) (set! B28a3@Be39@eval Be39@eval) (set! Be3b@library-expander (lambda B2692 (let ((B2693 (length B2692))) (if (= B2693 '3) (apply (lambda (B2624@x B2625@filename B2626@verify-name) (letrec* ((B262b@build-visit-code (lambda (B2680@macro*) (if (null? B2680@macro*) (Bad8@Ba39@build-void) (Bad7@Ba37@build-sequence '#f (map (lambda (B2682@x) (let ((B2684@loc (car B2682@x)) (B2685@src (cddr B2682@x))) (list 'set! B2684@loc B2685@src))) B2680@macro*))))) (B262d@visit! (lambda (B2678@macro*) (for-each (lambda (B267a@x) (let ((B267c@loc (car B267a@x)) (B267d@proc (cadr B267a@x))) (set-symbol-value! B267c@loc B267d@proc))) B2678@macro*)))) (call-with-values (lambda () (Bded@core-library-expander B2624@x B2626@verify-name)) (lambda (B2640@B262f B2641@B2631 B2642@B2633 B2643@B2635 B2644@B2637 B2645@B2639 B2646@B263b B2647@B263d B2648@B263f) (let ((B2652@export-env B2648@B263f) (B2653@export-subst B2647@B263d) (B2654@macro* B2646@B263b) (B2655@invoke-code B2645@B2639) (B2656@vis* B2644@B2637) (B2657@inv* B2643@B2635) (B2658@imp* B2642@B2633) (B2659@ver B2641@B2631) (B265a@name B2640@B262f)) (let ((B2664@id (gensym)) (B2665@name B265a@name) (B2666@ver B2659@ver) (B2667@imp* (map B992@B7e4@library-spec B2658@imp*)) (B2668@vis* (map B992@B7e4@library-spec B2656@vis*)) (B2669@inv* (map B992@B7e4@library-spec B2657@inv*)) (B266a@visit-proc (lambda () (B262d@visit! B2654@macro*))) (B266b@invoke-proc (lambda () (eval-core (B718@B6d0@expanded->core B2655@invoke-code)))) (B266c@visit-code (B262b@build-visit-code B2654@macro*)) (B266d@invoke-code B2655@invoke-code)) (begin (B98c@B7d8@install-library B2664@id B2665@name B2666@ver B2667@imp* B2668@vis* B2669@inv* B2653@export-subst B2652@export-env B266a@visit-proc B266b@invoke-proc B266c@visit-code B266d@invoke-code '#t B2625@filename) (values B2664@id B2665@name B2666@ver B2667@imp* B2668@vis* B2669@inv* B266d@invoke-code B266c@visit-code B2653@export-subst B2652@export-env)))))))) B2692) (if (= B2693 '2) (apply (lambda (B2688@x B2689@filename) (Be3b@library-expander B2688@x B2689@filename (lambda (B268c@x) (values)))) B2692) (if (= B2693 '1) (apply (lambda (B268e@x) (Be3b@library-expander B268e@x '#f (lambda (B2690@x) (values)))) B2692) (error 'apply '"invalid arg count"))))))) (set! B28a4@Be3b@library-expander Be3b@library-expander) (set! Be3d@boot-library-expand (lambda (B2694@x) (call-with-values (lambda () (Be3b@library-expander B2694@x)) (lambda (B26aa@B2697 B26ab@B2699 B26ac@B269b B26ad@B269d B26ae@B269f B26af@B26a1 B26b0@B26a3 B26b1@B26a5 B26b2@B26a7 B26b3@B26a9) (let ((B26be@export-env B26b3@B26a9) (B26bf@export-subst B26b2@B26a7) (B26c0@visit-code B26b1@B26a5) (B26c1@invoke-code B26b0@B26a3) (B26c2@inv* B26af@B26a1) (B26c3@vis* B26ae@B269f) (B26c4@imp* B26ad@B269d) (B26c5@ver B26ac@B269b) (B26c6@name B26ab@B2699) (B26c7@id B26aa@B2697)) (values B26c6@name B26c1@invoke-code B26bf@export-subst B26be@export-env)))))) (set! B28a5@Be3d@boot-library-expand Be3d@boot-library-expand) (set! Be3f@rev-map-append (lambda (B26d2@f B26d3@ls B26d4@ac) (if (null? B26d3@ls) B26d4@ac (Be3f@rev-map-append B26d2@f (cdr B26d3@ls) (cons (B26d2@f (car B26d3@ls)) B26d4@ac))))) (set! B28a6@Be3f@rev-map-append Be3f@rev-map-append) (set! Be41@build-exports (lambda (B26d8@lex*+loc* B26d9@init*) (Bad7@Ba37@build-sequence '#f (cons (Bad8@Ba39@build-void) (Be3f@rev-map-append (lambda (B26dc@x) (list 'set! (cdr B26dc@x) (car B26dc@x))) B26d8@lex*+loc* B26d9@init*))))) (set! B28a7@Be41@build-exports Be41@build-exports) (set! Be43@make-export-subst (lambda (B26de@name* B26df@id*) (map (lambda (B26e2@name B26e3@id) (let ((B26e6@label (Bb88@id->label B26e3@id))) (begin (if (not B26e6@label) (Be59@syntax-violation '#f '"cannot export unbound identifier" B26e3@id) (void)) (cons B26e2@name B26e6@label)))) B26de@name* B26df@id*))) (set! B28a8@Be43@make-export-subst Be43@make-export-subst) (set! Be45@make-export-env/macros (lambda (B26e8@lex* B26e9@loc* B26ea@r) (letrec* ((B26ef@lookup (lambda (B270c@x) (let B2714@f ((B270e@x B270c@x) (B270f@lex* B26e8@lex*) (B2710@loc* B26e9@loc*)) (if (pair? B270f@lex*) (if (eq? B270e@x (car B270f@lex*)) (car B2710@loc*) (B2714@f B270e@x (cdr B270f@lex*) (cdr B2710@loc*))) (assertion-violation 'lookup-make-export '"BUG")))))) (let B26f8@f ((B26f0@r B26ea@r) (B26f1@env '()) (B26f2@global* '()) (B26f3@macro* '())) (if (null? B26f0@r) (values B26f1@env B26f2@global* B26f3@macro*) (let ((B26fa@x (car B26f0@r))) (let ((B26fc@label (car B26fa@x)) (B26fd@b (cdr B26fa@x))) (let ((B2700@t (Bb8e@binding-type B26fd@b))) (if (memv B2700@t '(lexical)) (let ((B2702@v (Bb90@binding-value B26fd@b))) (let ((B2704@loc (B26ef@lookup (Bd03@lexical-var B2702@v))) (B2705@type (if (Bd05@lexical-mutable? B2702@v) 'mutable 'global))) (B26f8@f (cdr B26f0@r) (cons (cons* B26fc@label B2705@type B2704@loc) B26f1@env) (cons (cons (Bd03@lexical-var B2702@v) B2704@loc) B26f2@global*) B26f3@macro*))) (if (memv B2700@t '(local-macro)) (let ((B2708@loc (gensym))) (B26f8@f (cdr B26f0@r) (cons (cons* B26fc@label 'global-macro B2708@loc) B26f1@env) B26f2@global* (cons (cons B2708@loc (Bb90@binding-value B26fd@b)) B26f3@macro*))) (if (memv B2700@t '(local-macro!)) (let ((B270a@loc (gensym))) (B26f8@f (cdr B26f0@r) (cons (cons* B26fc@label 'global-macro! B270a@loc) B26f1@env) B26f2@global* (cons (cons B270a@loc (Bb90@binding-value B26fd@b)) B26f3@macro*))) (if (memv B2700@t '($rtd $module)) (B26f8@f (cdr B26f0@r) (cons B26fa@x B26f1@env) B26f2@global* B26f3@macro*) (assertion-violation 'expander '"BUG: do not know how to export" (Bb8e@binding-type B26fd@b) (Bb90@binding-value B26fd@b)))))))))))))) (set! B28a9@Be45@make-export-env/macros Be45@make-export-env/macros) (set! Be47@generate-temporaries (lambda (B2716@ls) (let ((B2718@t B2716@ls)) (let ((B271a@ls/false (Bd79@syntax-dispatch B2718@t 'each-any))) (if B271a@ls/false (apply (lambda (B271c@ls) (map (lambda (B271e@x) (make-simple-struct 'stx '5 (list (let ((B2720@x (Be5f@syntax->datum B271e@x))) (if (or (symbol? B2720@x) (string? B2720@x)) (gensym B2720@x) (gensym 't))) Baf6@top-mark* '() '()))) B271c@ls)) B271a@ls/false) (let ((B2722@t B2718@t)) (let ((B2724@ls/false (Bd79@syntax-dispatch B2722@t '_))) (if B2724@ls/false (apply (lambda () (assertion-violation 'generate-temporaries '"not a list")) B2724@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B2722@t))))))))) (set! B28aa@Be47@generate-temporaries Be47@generate-temporaries) (set! Be49@free-identifier=? (lambda (B2726@x B2727@y) (if (Bb72@id? B2726@x) (if (Bb72@id? B2727@y) (Bb78@free-id=? B2726@x B2727@y) (assertion-violation 'free-identifier=? '"not an identifier" B2727@y)) (assertion-violation 'free-identifier=? '"not an identifier" B2726@x)))) (set! B28ab@Be49@free-identifier=? Be49@free-identifier=?) (set! Be4b@bound-identifier=? (lambda (B272a@x B272b@y) (if (Bb72@id? B272a@x) (if (Bb72@id? B272b@y) (Bb76@bound-id=? B272a@x B272b@y) (assertion-violation 'bound-identifier=? '"not an identifier" B272b@y)) (assertion-violation 'bound-identifier=? '"not an identifier" B272a@x)))) (set! B28ac@Be4b@bound-identifier=? Be4b@bound-identifier=?) (set! Be4d@make-source-condition (lambda (B272e@x) (letrec* ((B2738@B2733 (make-record-type-descriptor '&source-information &condition-rtd 'B2736 '#f '#f '#((immutable file-name) (immutable line)))) (B273a@B2735 '#f) (B273c@B2734 (make-record-constructor-descriptor B2738@B2733 &condition-rcd B273a@B2735)) (B273f@B2732 (record-predicate B2738@B2733)) (B2741@make-source-condition (record-constructor B273c@B2734)) (B2743@B2730 (record-accessor B2738@B2733 '0)) (B2745@B2731 (record-accessor B2738@B2733 '1)) (B2747@source-condition? (condition-predicate B2738@B2733)) (B2749@source-filename (condition-accessor B2738@B2733 B2743@B2730)) (B274b@source-character (condition-accessor B2738@B2733 B2745@B2731))) (if (and (pair? B272e@x) (pair? (cdr B272e@x))) (B2741@make-source-condition (car B272e@x) (cadr B272e@x)) (condition))))) (set! B28ad@Be4d@make-source-condition Be4d@make-source-condition) (set! Be4f@extract-position-condition (lambda (B274c@x) (Be4d@make-source-condition (Be51@expression-position B274c@x)))) (set! B28ae@Be4f@extract-position-condition Be4f@extract-position-condition) (set! Be51@expression-position (lambda (B274e@x) (and (Bb3e@stx? B274e@x) (let ((B2750@x (Bb40@stx-expr B274e@x))) (and (B6b6@B588@annotation? B2750@x) (B6b7@B58a@annotation-source B2750@x)))))) (set! B28af@Be51@expression-position Be51@expression-position) (set! Be53@assertion-error (lambda (B2752@expr B2753@pos) (raise (condition (make-assertion-violation) (make-who-condition 'assert) (make-message-condition '"assertion failed") (make-irritants-condition (list B2752@expr)) (Be4d@make-source-condition B2753@pos))))) (set! B28b0@Be53@assertion-error Be53@assertion-error) (set! Be55@syntax-error (lambda (B2756@x . B2758@args) (begin (if (not (for-all string? B2758@args)) (assertion-violation 'syntax-error '"invalid argument" B2758@args) (void)) (raise (condition (make-message-condition (if (null? B2758@args) '"invalid syntax" (apply string-append B2758@args))) (make-syntax-violation (Be5f@syntax->datum B2756@x) '#f) (Be4f@extract-position-condition B2756@x)))))) (set! B28b1@Be55@syntax-error Be55@syntax-error) (set! Be57@syntax-violation* (lambda (B275a@who B275b@msg B275c@form B275d@condition-object) (begin (if (not (string? B275b@msg)) (assertion-violation 'syntax-violation '"message is not a string" B275b@msg) (void)) (let ((B2762@who (if (or (string? B275a@who) (symbol? B275a@who)) B275a@who (if (not B275a@who) (let ((B2764@t B275c@form)) (let ((B2766@ls/false (Bd79@syntax-dispatch B2764@t 'any))) (if (and B2766@ls/false (apply (lambda (B2768@id) (Bb72@id? B2768@id)) B2766@ls/false)) (apply (lambda (B276a@id) (Be5f@syntax->datum B276a@id)) B2766@ls/false) (let ((B276c@t B2764@t)) (let ((B276e@ls/false (Bd79@syntax-dispatch B276c@t '(any . any)))) (if (and B276e@ls/false (apply (lambda (B2770@id B2771@rest) (Bb72@id? B2770@id)) B276e@ls/false)) (apply (lambda (B2774@id B2775@rest) (Be5f@syntax->datum B2774@id)) B276e@ls/false) (let ((B2778@t B276c@t)) (let ((B277a@ls/false (Bd79@syntax-dispatch B2778@t '_))) (if B277a@ls/false (apply (lambda () '#f) B277a@ls/false) (Be59@syntax-violation '#f '"invalid syntax" B2778@t)))))))))) (assertion-violation 'syntax-violation '"invalid who argument" B275a@who))))) (raise (condition (if B2762@who (make-who-condition B2762@who) (condition)) (make-message-condition B275b@msg) B275d@condition-object (Be4f@extract-position-condition B275c@form))))))) (set! B28b2@Be57@syntax-violation* Be57@syntax-violation*) (set! Be59@syntax-violation (lambda B278a (let ((B278b (length B278a))) (if (= B278b '3) (apply (lambda (B277c@who B277d@msg B277e@form) (Be59@syntax-violation B277c@who B277d@msg B277e@form '#f)) B278a) (if (= B278b '4) (apply (lambda (B2782@who B2783@msg B2784@form B2785@subform) (Be57@syntax-violation* B2782@who B2783@msg B2784@form (make-syntax-violation (Be5f@syntax->datum B2784@form) (Be5f@syntax->datum B2785@subform)))) B278a) (error 'apply '"invalid arg count")))))) (set! B28b3@Be59@syntax-violation Be59@syntax-violation) (set! Be5b@identifier? (lambda (B278c@x) (Bb72@id? B278c@x))) (set! B28b4@Be5b@identifier? Be5b@identifier?) (set! Be5d@datum->syntax (lambda (B278e@id B278f@datum) (if (Bb72@id? B278e@id) (Bb52@datum->stx B278e@id B278f@datum) (assertion-violation 'datum->syntax '"not an identifier" B278e@id)))) (set! B28b5@Be5d@datum->syntax Be5d@datum->syntax) (set! Be5f@syntax->datum (lambda (B2792@x) (Bb86@stx->datum B2792@x))) (set! B28b6@Be5f@syntax->datum Be5f@syntax->datum) (set! Be61@ungensym-all (lambda (B2794@code) (if (pair? B2794@code) (cons (Be61@ungensym-all (car B2794@code)) (Be61@ungensym-all (cdr B2794@code))) (if (symbol? B2794@code) (ungensym B2794@code) B2794@code)))) (set! B28b7@Be61@ungensym-all Be61@ungensym-all) (set! Be63@compile-r6rs-top-level (lambda (B2796@x*) (call-with-values (lambda () (Bdf1@top-level-expander B2796@x*)) (lambda (B279c@B2799 B279d@B279b) (let ((B27a0@invoke-code B279d@B279b) (B27a1@lib* B279c@B2799)) (lambda () (begin (for-each B98e@B7dc@invoke-library B27a1@lib*) (let ((B27a4@expanded (B718@B6d0@expanded->core B27a0@invoke-code))) (begin (if (symbol-value 'debug-expand) (format '#t '"psyntax expanded=~a\n" (Be61@ungensym-all B27a4@expanded)) (void)) (eval-core B27a4@expanded)))))))))) (set! B28b8@Be63@compile-r6rs-top-level Be63@compile-r6rs-top-level) (set! Be65@pre-compile-r6rs-top-level (lambda (B27a6@x*) (call-with-values (lambda () (Bdf1@top-level-expander B27a6@x*)) (lambda (B27ac@B27a9 B27ad@B27ab) (let ((B27b0@invoke-code B27ad@B27ab) (B27b1@lib* B27ac@B27a9)) (begin (for-each B98e@B7dc@invoke-library B27b1@lib*) (B6c0@B59c@compile-core (B718@B6d0@expanded->core B27b0@invoke-code)))))))) (set! B28b9@Be65@pre-compile-r6rs-top-level Be65@pre-compile-r6rs-top-level) (set! Be67@interaction-environment (let ((B27b4@the-env '#f)) (lambda () (or B27b4@the-env (let ((B27b6@lib (B987@B7ce@find-library-by-name '(mosh interaction))) (B27b7@rib (Bb26@make-empty-rib))) (begin (let ((B27ba@subst (B969@B792@library-subst B27b6@lib))) (begin (Bb12@set-rib-sym*! B27b7@rib (map car B27ba@subst)) (Bb16@set-rib-mark**! B27b7@rib (map (lambda (B27bc@x) Baf6@top-mark*) B27ba@subst)) (Bb1a@set-rib-label*! B27b7@rib (map cdr B27ba@subst)))) (let ((B27be@env (make-simple-struct 'interaction-env '4 (list B27b7@rib '() '())))) (begin (set! B27b4@the-env B27be@env) B27be@env)))))))) (set! B28ba@Be67@interaction-environment Be67@interaction-environment) (set! Be69@top-level-context (B6c2@B5a0@make-parameter '#f)) (set! B28bb@Be69@top-level-context Be69@top-level-context) (B984@B7c8@current-library-expander Be3b@library-expander))
(begin (begin (B715@B6ca@current-primitive-locations (lambda (B2e0b@x) (let ((B2e0d@t (assq B2e0b@x '((syntax-error . B28b1@Be55@syntax-error) (syntax-dispatch . B284f@Bd79@syntax-dispatch) (load . B2a3b@B28e2@load) (interaction-environment . B28ba@Be67@interaction-environment) (library-path . B97c@B7b8@library-path) (mosh-cache-dir . B6c3@B5a2@mosh-cache-dir) (make-parameter . B6c2@B5a0@make-parameter) (make-variable-transformer . B280c@Bba4@make-variable-transformer) (identifier? . B28b4@Be5b@identifier?) (generate-temporaries . B28aa@Be47@generate-temporaries) (free-identifier=? . B28ab@Be49@free-identifier=?) (syntax->datum . B28b6@Be5f@syntax->datum) (datum->syntax . B28b5@Be5d@datum->syntax) (bound-identifier=? . B28ac@Be4b@bound-identifier=?) (scheme-report-environment . B28a1@Be35@scheme-report-environment) (null-environment . B28a0@Be33@null-environment) (command-line . B2a38@B28dc@command-line) (eval . B28a3@Be39@eval) (environment . B289f@Be31@environment) (syntax-violation . B28b3@Be59@syntax-violation) (assertion-error . B28b0@Be53@assertion-error))))) (if B2e0d@t (cdr B2e0d@t) '#f)))) (B98c@B7d8@install-library 'B2de8 '(mosh interaction) '() '() '() '() '((regexp? . B2da8) (alist->eq-hash-table . B2da4) (format . B2da1) (string-split . B2d95) (call-process . B2d8f) (set-current-directory! . B2d8b) (expand-path . B2d8a) (current-directory . B2d89) (%spawn . B2d88) (%waitpid . B2d87) (simple-struct-name . B2d86) (simple-struct-set! . B2d85) (simple-struct-ref . B2d84) (make-simple-struct . B2d83) (simple-struct? . B2d82) (pointer-ref-c-int64 . B2d81) (pointer-ref-c-int32 . B2d80) (pointer-ref-c-int16 . B2d7f) (pointer-ref-c-int8 . B2d7e) (pointer-ref-c-uint64 . B2d7d) (pointer-ref-c-uint32 . B2d7c) (pointer-ref-c-uint16 . B2d7b) (pointer-ref-c-uint8 . B2d7a) (pointer-set-c-uint64! . B2d79) (pointer-set-c-uint32! . B2d78) (pointer-set-c-uint16! . B2d77) (pointer-set-c-uint8! . B2d76) (pointer-set-c-int64! . B2d75) (pointer-set-c-int32! . B2d74) (pointer-set-c-int16! . B2d73) (pointer-set-c-int8! . B2d72) (pointer-set-c-pointer! . B2d71) (pointer-set-c-double! . B2d70) (pointer-set-c-float! . B2d6f) (pointer-set-c-long-long! . B2d6e) (pointer-set-c-long! . B2d6d) (pointer-set-c-int! . B2d6c) (pointer-set-c-short! . B2d6b) (pointer-set-c-char! . B2d6a) (pointer-ref-c-pointer . B2d69) (pointer-ref-c-double . B2d68) (pointer-ref-c-float . B2d67) (pointer-ref-c-unsigned-long-long . B2d66) (pointer-ref-c-signed-long-long . B2d65) (pointer-ref-c-unsigned-long . B2d64) (pointer-ref-c-signed-long . B2d63) (pointer-ref-c-unsigned-int . B2d62) (pointer-ref-c-signed-int . B2d61) (pointer-ref-c-unsigned-short . B2d60) (pointer-ref-c-signed-short . B2d5f) (pointer-ref-c-unsigned-char . B2d5e) (pointer-ref-c-signed-char . B2d5d) (pointer->integer . B2d5c) (integer->pointer . B2d5b) (pointer? . B2d5a) (shared-errno . B2d59) (%ffi-supported? . B2d54) (%ffi-pointer->string . B2d53) (%ffi-call . B2d52) (%ffi-lookup . B2d51) (%ffi-open . B2d50) (null-terminated-utf8->string . B2d4f) (null-terminated-bytevector->string . B2d4e) (%exec . B2d4d) (%fork . B2d4c) (%pipe . B2d4b) (p . B2d4a) (whereis . B2d2e) (register . B2d2d) (vm-join! . B2d2c) (vm-set-value! . B2d2b) (vm? . B2d2a) (main-vm? . B2d29) (vm-eval . B2d28) (vm-self . B2d27) (vm-start! . B2d26) (make-vm . B2d25) (mutex-try-lock! . B2d24) (mutex-unlock! . B2d23) (mutex-lock! . B2d22) (mutex? . B2d21) (make-mutex . B2d20) (condition-variable-notify-all! . B2d1f) (condition-variable-notify! . B2d1e) (condition-variable-wait! . B2d1d) (make-condition-variable . B2d1c) (write/ss . B2d1b) (string-upcase . B2d03) (string-titlecase . B2d02) (string-normalize-nfkd . B2d01) (string-normalize-nfkc . B2d00) (string-normalize-nfd . B2cff) (string-normalize-nfc . B2cfe) (string-foldcase . B2cfd) (string-downcase . B2cfc) (string-ci>? . B2cfb) (string-ci>=? . B2cfa) (string-ci=? . B2cf9) (string-ci<? . B2cf8) (string-ci<=? . B2cf7) (char-whitespace? . B2cf6) (char-upper-case? . B2cf5) (char-title-case? . B2cf4) (char-numeric? . B2cf3) (char-lower-case? . B2cf2) (char-general-category . B2cf1) (char-upcase . B2cf0) (char-titlecase . B2cef) (char-foldcase . B2cee) (char-downcase . B2ced) (char-ci>? . B2cec) (char-ci>=? . B2ceb) (char-ci=? . B2cea) (char-ci<? . B2ce9) (char-ci<=? . B2ce8) (char-alphabetic? . B2ce7) (make-variable-transformer . Bba3) (identifier? . Be5a) (generate-temporaries . Be46) (free-identifier=? . Be48) (syntax->datum . Be5e) (datum->syntax . Be5c) (bound-identifier=? . Be4a) (record-type-descriptor? . B2ce6) (record-predicate . B2ce5) (record-mutator . B2ce4) (record-constructor . B2ce3) (record-accessor . B2ce2) (make-record-type-descriptor . B2ce1) (make-record-constructor-descriptor . B2ce0) (record? . B2cdf) (record-type-uid . B2cde) (record-type-sealed? . B2cdd) (record-type-parent . B2cdc) (record-type-opaque? . B2cdb) (record-type-name . B2cda) (record-type-generative? . B2cd9) (record-type-field-names . B2cd8) (record-rtd . B2cd7) (record-field-mutable? . B2cd6) (delete-file . B2cd5) (file-exists? . B2cd4) (vector-sort! . B2cd3) (vector-sort . B2cd2) (list-sort . B2cd1) (symbol-hash . B2cd0) (string-ci-hash . B2ccf) (string-hash . B2cce) (equal-hash . B2ccd) (hashtable-equivalence-function . B2ccc) (make-hashtable . B2ccb) (hashtable-hash-function . B2cca) (make-eqv-hashtable . B2cc9) (make-eq-hashtable . B2cc8) (hashtable? . B2cc7) (hashtable-update! . B2cc6) (hashtable-size . B2cc5) (hashtable-set! . B2cc4) (hashtable-ref . B2cc3) (hashtable-mutable? . B2cc2) (hashtable-keys . B2cc1) (hashtable-entries . B2cc0) (hashtable-delete! . B2cbf) (hashtable-copy . B2cbe) (hashtable-contains? . B2cbd) (hashtable-clear! . B2cbc) (call-with-output-file . B2cbb) (call-with-input-file . B2cba) (write-char . B2cb9) (write . B2cb8) (with-output-to-file . B2cb7) (with-input-from-file . B2cb6) (read-char . B2cb5) (read . B2cb4) (peek-char . B2cb3) (open-output-file . B2cb2) (open-input-file . B2cb1) (newline . B2cb0) (display . B2caf) (close-output-port . B2cae) (close-input-port . B2cad) (eof-object? . B2cac) (eof-object . B2cab) (current-error-port . B2caa) (current-output-port . B2ca9) (current-input-port . B2ca8) (output-port? . B2ca7) (input-port? . B2ca6) (utf-8-codec . B2ca5) (utf-16-codec . B2ca4) (transcoder-error-handling-mode . B2ca3) (transcoder-eol-style . B2ca2) (transcoder-codec . B2ca1) (transcoded-port . B2ca0) (textual-port? . B2c9f) (string->bytevector . B2c9e) (standard-output-port . B2c9d) (standard-input-port . B2c9c) (standard-error-port . B2c9b) (set-port-position! . B2c9a) (put-u8 . B2c99) (put-string . B2c98) (put-datum . B2c97) (put-char . B2c96) (put-bytevector . B2c95) (port? . B2c94) (port-transcoder . B2c93) (port-position . B2c92) (port-has-set-port-position!? . B2c91) (port-has-port-position? . B2c90) (port-eof? . B2c8f) (output-port-buffer-mode . B2c8e) (open-string-output-port . B2c8d) (open-string-input-port . B2c8c) (open-file-output-port . B2c8b) (open-file-input/output-port . B2c8a) (open-file-input-port . B2c89) (open-bytevector-output-port . B2c88) (open-bytevector-input-port . B2c87) (native-transcoder . B2c86) (native-eol-style . B2c85) (make-transcoder . B2c84) (latin-1-codec . B2c83) (make-i/o-write-error . B2c82) (make-i/o-read-error . B2c81) (make-i/o-port-error . B2c80) (make-i/o-invalid-position-error . B2c7f) (make-i/o-filename-error . B2c7e) (make-i/o-file-protection-error . B2c7d) (make-i/o-file-is-read-only-error . B2c7c) (make-i/o-file-does-not-exist-error . B2c7b) (make-i/o-file-already-exists-error . B2c7a) (make-i/o-error . B2c79) (make-i/o-encoding-error . B2c78) (make-i/o-decoding-error . B2c77) (make-custom-textual-output-port . B2c76) (make-custom-textual-input/output-port . B2c75) (make-custom-textual-input-port . B2c74) (make-custom-binary-output-port . B2c73) (make-custom-binary-input/output-port . B2c72) (make-custom-binary-input-port . B2c71) (make-bytevector . B2c70) (lookahead-u8 . B2c6f) (lookahead-char . B2c6e) (i/o-write-error? . B2c6d) (i/o-read-error? . B2c6c) (i/o-port-error? . B2c6b) (i/o-invalid-position-error? . B2c6a) (i/o-filename-error? . B2c69) (i/o-file-protection-error? . B2c68) (i/o-file-is-read-only-error? . B2c67) (i/o-file-does-not-exist-error? . B2c66) (i/o-file-already-exists-error? . B2c65) (i/o-error? . B2c64) (i/o-error-position . B2c63) (i/o-error-port . B2c62) (i/o-error-filename . B2c61) (i/o-encoding-error? . B2c60) (i/o-encoding-error-char . B2c5f) (i/o-decoding-error? . B2c5e) (get-u8 . B2c5d) (get-string-n! . B2c5c) (get-string-n . B2c5b) (get-string-all . B2c5a) (get-line . B2c59) (get-datum . B2c58) (get-char . B2c57) (get-bytevector-some . B2c56) (get-bytevector-n! . B2c55) (get-bytevector-n . B2c54) (get-bytevector-all . B2c53) (flush-output-port . B2c52) (close-port . B2c51) (exit . B2c49) (command-line . B28db) (string-fill! . B2c48) (string-set! . B2c47) (set-cdr! . B2c46) (set-car! . B2c45) (remove . B2c44) (remv . B2c43) (remp . B2c42) (remq . B2c41) (partition . B2c40) (memv . B2c3f) (memq . B2c3e) (memp . B2c3d) (member . B2c3c) (exists . B2c3b) (for-all . B2c3a) (fold-right . B2c39) (fold-left . B2c38) (find . B2c37) (filter . B2c36) (cons* . B2c35) (assv . B2c34) (assq . B2c33) (assp . B2c32) (assoc . B2c31) (call-with-string-output-port . B2c30) (call-with-port . B2c2f) (call-with-bytevector-output-port . B2c2e) (bytevector->string . B2c2d) (buffer-mode? . B2c2c) (binary-port? . B2c2b) (with-exception-handler . B2c2a) (raise-continuable . B2c29) (raise . B2c28) (eval . Be38) (environment . Be30) (make-enumeration . B2c27) (enum-set=? . B2c26) (enum-set-universe . B2c25) (enum-set-union . B2c24) (enum-set-subset? . B2c23) (enum-set-projection . B2c22) (enum-set-member? . B2c21) (enum-set-intersection . B2c20) (enum-set-indexer . B2c1f) (enum-set-difference . B2c1e) (enum-set-constructor . B2c1d) (enum-set-complement . B2c1c) (enum-set->list . B2c1b) (who-condition? . B2c1a) (warning? . B2c19) (violation? . B2c18) (undefined-violation? . B2c17) (syntax-violation? . B2c16) (syntax-violation-subform . B2c15) (syntax-violation-form . B2c14) (syntax-violation . Be58) (simple-conditions . B2c13) (serious-condition? . B2c12) (non-continuable-violation? . B2c11) (message-condition? . B2c10) (make-who-condition . B2c0f) (make-warning . B2c0e) (make-violation . B2c0d) (make-undefined-violation . B2c0c) (make-syntax-violation . B2c0b) (make-serious-condition . B2c0a) (make-non-continuable-violation . B2c09) (make-message-condition . B2c08) (make-lexical-violation . B2c07) (make-irritants-condition . B2c06) (make-implementation-restriction-violation . B2c05) (make-error . B2c04) (make-assertion-violation . B2c03) (lexical-violation? . B2c02) (irritants-condition? . B2c01) (implementation-restriction-violation? . B2c00) (error? . B2bff) (condition-who . B2bfe) (condition-predicate . B2bfd) (condition-message . B2bfc) (condition-irritants . B2bfb) (condition-accessor . B2bfa) (condition . B2bf9) (assertion-violation? . B2bf8) (condition? . B2bf7) (utf32->string . B2bf6) (utf16->string . B2bf5) (utf8->string . B2bf4) (uint-list->bytevector . B2bf3) (u8-list->bytevector . B2bf2) (string->utf8 . B2bf1) (string->utf32 . B2bf0) (string->utf16 . B2bef) (sint-list->bytevector . B2bee) (native-endianness . B2bed) (bytevector? . B2bec) (bytevector=? . B2beb) (bytevector-uint-set! . B2bea) (bytevector-uint-ref . B2be9) (bytevector-u8-set! . B2be8) (bytevector-u8-ref . B2be7) (bytevector-u64-set! . B2be6) (bytevector-u64-ref . B2be5) (bytevector-u64-native-set! . B2be4) (bytevector-u64-native-ref . B2be3) (bytevector-u32-set! . B2be2) (bytevector-u32-ref . B2be1) (bytevector-u32-native-set! . B2be0) (bytevector-u32-native-ref . B2bdf) (bytevector-u16-set! . B2bde) (bytevector-u16-ref . B2bdd) (bytevector-u16-native-set! . B2bdc) (bytevector-u16-native-ref . B2bdb) (bytevector-sint-set! . B2bda) (bytevector-sint-ref . B2bd9) (bytevector-s8-set! . B2bd8) (bytevector-s8-ref . B2bd7) (bytevector-s64-set! . B2bd6) (bytevector-s64-ref . B2bd5) (bytevector-s64-native-set! . B2bd4) (bytevector-s64-native-ref . B2bd3) (bytevector-s32-set! . B2bd2) (bytevector-s32-ref . B2bd1) (bytevector-s32-native-set! . B2bd0) (bytevector-s32-native-ref . B2bcf) (bytevector-s16-set! . B2bce) (bytevector-s16-ref . B2bcd) (bytevector-s16-native-set! . B2bcc) (bytevector-s16-native-ref . B2bcb) (bytevector-length . B2bca) (bytevector-ieee-single-ref . B2bc9) (bytevector-ieee-single-set! . B2bc8) (bytevector-ieee-single-native-set! . B2bc7) (bytevector-ieee-single-native-ref . B2bc6) (bytevector-ieee-double-set! . B2bc5) (bytevector-ieee-double-ref . B2bc4) (bytevector-ieee-double-native-set! . B2bc3) (bytevector-ieee-double-native-ref . B2bc2) (bytevector-fill! . B2bc1) (bytevector-copy! . B2bc0) (bytevector-copy . B2bbf) (bytevector->uint-list . B2bbe) (bytevector->u8-list . B2bbd) (bytevector->sint-list . B2bbc) (no-nans-violation? . B2bbb) (no-infinities-violation? . B2bba) (make-no-nans-violation . B2bb9) (make-no-infinities-violation . B2bb8) (real->flonum . B2bb7) (flzero? . B2bb6) (fltruncate . B2bb5) (fltan . B2bb4) (flsqrt . B2bb3) (flsin . B2bb2) (flround . B2bb1) (flpositive? . B2bb0) (flonum? . B2baf) (flodd? . B2bae) (flnumerator . B2bad) (flnegative? . B2bac) (flnan? . B2bab) (flmod0 . B2baa) (flmod . B2ba9) (flmin . B2ba8) (flmax . B2ba7) (fllog . B2ba6) (flinteger? . B2ba5) (flinfinite? . B2ba4) (flfloor . B2ba3) (flfinite? . B2ba2) (flexpt . B2ba1) (flexp . B2ba0) (fleven? . B2b9f) (fldiv0-and-mod0 . B2b9e) (fldiv0 . B2b9d) (fldiv-and-mod . B2b9c) (fldiv . B2b9b) (fldenominator . B2b9a) (flcos . B2b99) (flceiling . B2b98) (flatan . B2b97) (flasin . B2b96) (flacos . B2b95) (flabs . B2b94) (fl>? . B2b93) (fl>=? . B2b92) (fl=? . B2b91) (fl<? . B2b90) (fl<=? . B2b8f) (fl/ . B2b8e) (fl- . B2b8d) (fl+ . B2b8c) (fl* . B2b8b) (fixnum->flonum . B2b8a) (fxzero? . B2b89) (fxxor . B2b88) (fxrotate-bit-field . B2b87) (fxreverse-bit-field . B2b86) (fxpositive? . B2b85) (fxodd? . B2b84) (fxnot . B2b83) (fxnegative? . B2b82) (fxmod0 . B2b81) (fxmod . B2b80) (fxmin . B2b7f) (fxmax . B2b7e) (fxlength . B2b7d) (fxior . B2b7c) (fxif . B2b7b) (fxfirst-bit-set . B2b7a) (fxeven? . B2b79) (fxdiv0-and-mod0 . B2b78) (fxdiv0 . B2b77) (fxdiv-and-mod . B2b76) (fxdiv . B2b75) (fxcopy-bit-field . B2b74) (fxcopy-bit . B2b73) (fxbit-set? . B2b72) (fxbit-field . B2b71) (fxbit-count . B2b70) (fxarithmetic-shift-right . B2b6f) (fxarithmetic-shift-left . B2b6e) (fxarithmetic-shift . B2b6d) (fxand . B2b6c) (fx>? . B2b6b) (fx>=? . B2b6a) (fx=? . B2b69) (fx<? . B2b68) (fx<=? . B2b67) (fx-/carry . B2b66) (fx- . B2b65) (fx+/carry . B2b64) (fx+ . B2b63) (fx*/carry . B2b62) (fx* . B2b61) (greatest-fixnum . B2b60) (least-fixnum . B2b5f) (fixnum-width . B2b5e) (fixnum? . B2b5d) (bitwise-rotate-bit-field . B2b5c) (bitwise-reverse-bit-field . B2b5b) (bitwise-length . B2b5a) (bitwise-if . B2b59) (bitwise-first-bit-set . B2b58) (bitwise-copy-bit-field . B2b57) (bitwise-copy-bit . B2b56) (bitwise-bit-set? . B2b55) (bitwise-bit-field . B2b54) (bitwise-bit-count . B2b53) (bitwise-xor . B2b52) (bitwise-ior . B2b51) (bitwise-and . B2b50) (bitwise-not . B2b4f) (bitwise-arithmetic-shift-right . B2b4e) (bitwise-arithmetic-shift-left . B2b4d) (bitwise-arithmetic-shift . B2b4c) (zero? . B2b4b) (vector? . B2b4a) (vector-set! . B2b49) (vector-ref . B2b48) (vector-map . B2b47) (vector-length . B2b46) (vector-for-each . B2b45) (vector-fill! . B2b44) (vector->list . B2b43) (vector . B2b42) (values . B2b41) (truncate . B2b40) (tan . B2b3f) (symbol? . B2b3e) (symbol=? . B2b3d) (symbol->string . B2b3c) (substring . B2b3b) (string? . B2b3a) (string>? . B2b39) (string>=? . B2b38) (string=? . B2b37) (string<? . B2b36) (string<=? . B2b35) (string-ref . B2b34) (string-length . B2b33) (string-for-each . B2b32) (string-copy . B2b31) (string-append . B2b30) (string->symbol . B2b2f) (string->number . B2b2e) (string->list . B2b2d) (string . B2b2c) (sqrt . B2b2b) (sin . B2b2a) (round . B2b29) (reverse . B2b28) (real? . B2b27) (real-valued? . B2b26) (real-part . B2b25) (rationalize . B2b24) (rational? . B2b23) (rational-valued? . B2b22) (procedure? . B2b21) (positive? . B2b20) (pair? . B2b1f) (odd? . B2b1e) (numerator . B2b1d) (number? . B2b1c) (number->string . B2b1b) (null? . B2b1a) (not . B2b19) (negative? . B2b18) (nan? . B2b17) (min . B2b16) (max . B2b15) (map . B2b14) (make-vector . B2b13) (make-string . B2b12) (make-rectangular . B2b11) (make-polar . B2b10) (magnitude . B2b0f) (log . B2b0e) (list? . B2b0d) (list-tail . B2b0c) (list-ref . B2b0b) (list->vector . B2b0a) (list->string . B2b09) (list . B2b08) (length . B2b07) (lcm . B2b06) (integer? . B2b05) (integer-valued? . B2b04) (integer->char . B2b03) (infinite? . B2b02) (inexact? . B2b01) (inexact . B2b00) (imag-part . B2aff) (gcd . B2afe) (for-each . B2afd) (floor . B2afc) (finite? . B2afb) (expt . B2afa) (exp . B2af9) (exact? . B2af8) (exact-integer-sqrt . B2af7) (exact . B2af6) (even? . B2af5) (error . B2af4) (eqv? . B2af3) (equal? . B2af2) (eq? . B2af1) (dynamic-wind . B2af0) (div0-and-mod0 . B2aef) (mod0 . B2aee) (div0 . B2aed) (div-and-mod . B2aec) (mod . B2aeb) (div . B2aea) (denominator . B2ae9) (cos . B2ae8) (cons . B2ae7) (complex? . B2ae6) (char? . B2ae5) (char>? . B2ae4) (char>=? . B2ae3) (char=? . B2ae2) (char<? . B2ae1) (char<=? . B2ae0) (char->integer . B2adf) (ceiling . B2ade) (call-with-values . B2add) (call/cc . B2adc) (call-with-current-continuation . B2adb) (cddddr . B2ada) (cdddar . B2ad9) (cddadr . B2ad8) (cddaar . B2ad7) (cdaddr . B2ad6) (cdadar . B2ad5) (cdaadr . B2ad4) (cdaaar . B2ad3) (cadddr . B2ad2) (caddar . B2ad1) (cadadr . B2ad0) (cadaar . B2acf) (caaddr . B2ace) (caadar . B2acd) (caaadr . B2acc) (caaaar . B2acb) (cdddr . B2aca) (cddar . B2ac9) (cdadr . B2ac8) (cdaar . B2ac7) (caddr . B2ac6) (cadar . B2ac5) (caadr . B2ac4) (caaar . B2ac3) (cddr . B2ac2) (cdar . B2ac1) (cadr . B2ac0) (caar . B2abf) (cdr . B2abe) (car . B2abd) (boolean? . B2abc) (boolean=? . B2abb) (atan . B2aba) (assertion-violation . B2ab9) (asin . B2ab8) (apply . B2ab7) (append . B2ab6) (angle . B2ab5) (acos . B2ab4) (abs . B2ab3) (/ . B2ab2) (* . B2ab1) (- . B2ab0) (+ . B2aaf) (>= . B2aae) (> . B2aad) (= . B2aac) (<= . B2aab) (< . B2aaa) (library . B2aa9) (&no-nans . B2aa8) (&no-infinities . B2aa7) (&i/o-encoding . B2aa6) (&i/o-decoding . B2aa5) (&i/o-port . B2aa4) (&i/o-file-does-not-exist . B2aa3) (&i/o-file-already-exists . B2aa2) (&i/o-file-is-read-only . B2aa1) (&i/o-file-protection . B2aa0) (&i/o-filename . B2a9f) (&i/o-invalid-position . B2a9e) (&i/o-write . B2a9d) (&i/o-read . B2a9c) (&i/o . B2a9b) (&undefined . B2a9a) (&syntax . B2a99) (&lexical . B2a98) (&implementation-restriction . B2a97) (&non-continuable . B2a96) (&who . B2a95) (&irritants . B2a94) (&assertion . B2a93) (&violation . B2a92) (&error . B2a91) (&serious . B2a90) (&warning . B2a8f) (&message . B2a8e) (&condition . B2a8d) (define-condition-type . B2a8c) (define-enumeration . B2a8b) (define-record-type . B2a8a) (parent-rtd . B2a89) (nongenerative . B2a88) (opaque . B2a87) (sealed . B2a86) (protocol . B2a85) (parent . B2a84) (immutable . B2a83) (mutable . B2a82) (fields . B2a81) (error-handling-mode . B2a80) (file-options . B2a7f) (buffer-mode . B2a7e) (eol-style . B2a7d) (guard . B2a7c) (unsyntax-splicing . B2a79) (unsyntax . B2a78) (unquote-splicing . B2a77) (unquote . B2a76) (_ . B2a75) (else . B2a74) (=> . B2a73) (... . B2a72) (assert . B2a71) (endianness . B2a70) (time . B2a6e) (do . B2a6d) (cond . B2a6c) (let* . B2a6b) (let*-values . B2a6a) (let-values . B2a69) (identifier-syntax . B2a68) (with-syntax . B2a67) (quasisyntax . B2a66) (quasiquote . B2a65) (syntax-rules . B2a64) (include . B2a63) (record-constructor-descriptor . B2a61) (record-type-descriptor . B2a60) (case . B2a5f) (unless . B2a5d) (when . B2a5c) (or . B2a5b) (and . B2a5a) (if . B2a59) (let . B2a58) (letrec* . B2a57) (letrec . B2a56) (case-lambda . B2a54) (lambda . B2a53) (syntax . B2a52) (syntax-case . B2a51) (quote . B2a50) (letrec-syntax . B2a4e) (let-syntax . B2a4d) (set! . B2a4c) (import . B2a4b) (begin . B2a4a) (define-syntax . B2a48) (define . B2a47)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2de9 '(psyntax null-environment-5) '() '() '() '() '((make-promise . B2c4a) (unquote-splicing . B2a77) (unquote . B2a76) (_ . B2a75) (else . B2a74) (=> . B2a73) (... . B2a72) (delay . B2a6f) (do . B2a6d) (cond . B2a6c) (let* . B2a6b) (quasiquote . B2a65) (syntax-rules . B2a64) (case . B2a5f) (or . B2a5b) (and . B2a5a) (if . B2a59) (let . B2a58) (letrec . B2a56) (lambda . B2a53) (quote . B2a50) (letrec-syntax . B2a4e) (let-syntax . B2a4d) (set! . B2a4c) (begin . B2a4a) (define-syntax . B2a48) (define . B2a47)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2dea '(psyntax scheme-report-environment-5) '() '() '() '() '((string-ci>? . B2cfb) (string-ci>=? . B2cfa) (string-ci=? . B2cf9) (string-ci<? . B2cf8) (string-ci<=? . B2cf7) (char-whitespace? . B2cf6) (char-upper-case? . B2cf5) (char-numeric? . B2cf3) (char-lower-case? . B2cf2) (char-upcase . B2cf0) (char-downcase . B2ced) (char-ci>? . B2cec) (char-ci>=? . B2ceb) (char-ci=? . B2cea) (char-ci<? . B2ce9) (char-ci<=? . B2ce8) (char-alphabetic? . B2ce7) (call-with-output-file . B2cbb) (call-with-input-file . B2cba) (write-char . B2cb9) (write . B2cb8) (with-output-to-file . B2cb7) (with-input-from-file . B2cb6) (read-char . B2cb5) (read . B2cb4) (peek-char . B2cb3) (open-output-file . B2cb2) (open-input-file . B2cb1) (newline . B2cb0) (display . B2caf) (close-output-port . B2cae) (close-input-port . B2cad) (eof-object . B2cab) (current-output-port . B2ca9) (current-input-port . B2ca8) (output-port? . B2ca7) (input-port? . B2ca6) (scheme-report-environment . Be34) (quotient . B2c50) (null-environment . Be32) (remainder . B2c4f) (modulo . B2c4e) (inexact->exact . B2c4d) (force . B2c4c) (exact->inexact . B2c4b) (make-promise . B2c4a) (string-fill! . B2c48) (string-set! . B2c47) (set-cdr! . B2c46) (set-car! . B2c45) (memv . B2c3f) (memq . B2c3e) (member . B2c3c) (assv . B2c34) (assq . B2c33) (assoc . B2c31) (eval . Be38) (zero? . B2b4b) (vector? . B2b4a) (vector-set! . B2b49) (vector-ref . B2b48) (vector-length . B2b46) (vector-fill! . B2b44) (vector->list . B2b43) (vector . B2b42) (values . B2b41) (truncate . B2b40) (tan . B2b3f) (symbol? . B2b3e) (symbol->string . B2b3c) (substring . B2b3b) (string? . B2b3a) (string>? . B2b39) (string>=? . B2b38) (string=? . B2b37) (string<? . B2b36) (string<=? . B2b35) (string-ref . B2b34) (string-length . B2b33) (string-copy . B2b31) (string-append . B2b30) (string->symbol . B2b2f) (string->number . B2b2e) (string->list . B2b2d) (string . B2b2c) (sqrt . B2b2b) (sin . B2b2a) (round . B2b29) (reverse . B2b28) (real? . B2b27) (real-part . B2b25) (rationalize . B2b24) (rational? . B2b23) (procedure? . B2b21) (positive? . B2b20) (pair? . B2b1f) (odd? . B2b1e) (numerator . B2b1d) (number? . B2b1c) (number->string . B2b1b) (not . B2b19) (negative? . B2b18) (min . B2b16) (max . B2b15) (map . B2b14) (make-vector . B2b13) (make-string . B2b12) (make-rectangular . B2b11) (make-polar . B2b10) (magnitude . B2b0f) (log . B2b0e) (list? . B2b0d) (list-tail . B2b0c) (list-ref . B2b0b) (list->vector . B2b0a) (list->string . B2b09) (list . B2b08) (length . B2b07) (lcm . B2b06) (integer? . B2b05) (integer->char . B2b03) (inexact? . B2b01) (imag-part . B2aff) (gcd . B2afe) (for-each . B2afd) (floor . B2afc) (expt . B2afa) (exp . B2af9) (exact? . B2af8) (even? . B2af5) (eqv? . B2af3) (equal? . B2af2) (eq? . B2af1) (dynamic-wind . B2af0) (denominator . B2ae9) (cos . B2ae8) (cons . B2ae7) (complex? . B2ae6) (char? . B2ae5) (char>? . B2ae4) (char>=? . B2ae3) (char=? . B2ae2) (char<? . B2ae1) (char<=? . B2ae0) (char->integer . B2adf) (ceiling . B2ade) (call-with-values . B2add) (call-with-current-continuation . B2adb) (cddddr . B2ada) (cdddar . B2ad9) (cddadr . B2ad8) (cddaar . B2ad7) (cdaddr . B2ad6) (cdadar . B2ad5) (cdaadr . B2ad4) (cdaaar . B2ad3) (cadddr . B2ad2) (caddar . B2ad1) (cadadr . B2ad0) (cadaar . B2acf) (caaddr . B2ace) (caadar . B2acd) (caaadr . B2acc) (caaaar . B2acb) (cdddr . B2aca) (cddar . B2ac9) (cdadr . B2ac8) (cdaar . B2ac7) (caddr . B2ac6) (cadar . B2ac5) (caadr . B2ac4) (caaar . B2ac3) (cddr . B2ac2) (cdar . B2ac1) (cadr . B2ac0) (caar . B2abf) (cdr . B2abe) (car . B2abd) (boolean? . B2abc) (atan . B2aba) (asin . B2ab8) (apply . B2ab7) (append . B2ab6) (angle . B2ab5) (acos . B2ab4) (abs . B2ab3) (/ . B2ab2) (* . B2ab1) (- . B2ab0) (+ . B2aaf) (>= . B2aae) (> . B2aad) (= . B2aac) (<= . B2aab) (< . B2aaa) (unquote-splicing . B2a77) (unquote . B2a76) (else . B2a74) (=> . B2a73) (... . B2a72) (delay . B2a6f) (do . B2a6d) (cond . B2a6c) (let* . B2a6b) (quasiquote . B2a65) (syntax-rules . B2a64) (case . B2a5f) (or . B2a5b) (and . B2a5a) (if . B2a59) (let . B2a58) (letrec . B2a56) (lambda . B2a53) (quote . B2a50) (letrec-syntax . B2a4e) (let-syntax . B2a4d) (set! . B2a4c) (begin . B2a4a) (define-syntax . B2a48) (define . B2a47)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2deb '(psyntax modules) '() '() '() '() '((module . B2a49)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2dec '(chez parameters) '() '() '() '() '() '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2ded '(rnrs) '(6) '() '() '() '((regexp? . B2da8) (string-upcase . B2d03) (string-titlecase . B2d02) (string-normalize-nfkd . B2d01) (string-normalize-nfkc . B2d00) (string-normalize-nfd . B2cff) (string-normalize-nfc . B2cfe) (string-foldcase . B2cfd) (string-downcase . B2cfc) (string-ci>? . B2cfb) (string-ci>=? . B2cfa) (string-ci=? . B2cf9) (string-ci<? . B2cf8) (string-ci<=? . B2cf7) (char-whitespace? . B2cf6) (char-upper-case? . B2cf5) (char-title-case? . B2cf4) (char-numeric? . B2cf3) (char-lower-case? . B2cf2) (char-general-category . B2cf1) (char-upcase . B2cf0) (char-titlecase . B2cef) (char-foldcase . B2cee) (char-downcase . B2ced) (char-ci>? . B2cec) (char-ci>=? . B2ceb) (char-ci=? . B2cea) (char-ci<? . B2ce9) (char-ci<=? . B2ce8) (char-alphabetic? . B2ce7) (make-variable-transformer . Bba3) (identifier? . Be5a) (generate-temporaries . Be46) (free-identifier=? . Be48) (syntax->datum . Be5e) (datum->syntax . Be5c) (bound-identifier=? . Be4a) (record-type-descriptor? . B2ce6) (record-predicate . B2ce5) (record-mutator . B2ce4) (record-constructor . B2ce3) (record-accessor . B2ce2) (make-record-type-descriptor . B2ce1) (make-record-constructor-descriptor . B2ce0) (record? . B2cdf) (record-type-uid . B2cde) (record-type-sealed? . B2cdd) (record-type-parent . B2cdc) (record-type-opaque? . B2cdb) (record-type-name . B2cda) (record-type-generative? . B2cd9) (record-type-field-names . B2cd8) (record-rtd . B2cd7) (record-field-mutable? . B2cd6) (delete-file . B2cd5) (file-exists? . B2cd4) (vector-sort! . B2cd3) (vector-sort . B2cd2) (list-sort . B2cd1) (symbol-hash . B2cd0) (string-ci-hash . B2ccf) (string-hash . B2cce) (equal-hash . B2ccd) (hashtable-equivalence-function . B2ccc) (make-hashtable . B2ccb) (hashtable-hash-function . B2cca) (make-eqv-hashtable . B2cc9) (make-eq-hashtable . B2cc8) (hashtable? . B2cc7) (hashtable-update! . B2cc6) (hashtable-size . B2cc5) (hashtable-set! . B2cc4) (hashtable-ref . B2cc3) (hashtable-mutable? . B2cc2) (hashtable-keys . B2cc1) (hashtable-entries . B2cc0) (hashtable-delete! . B2cbf) (hashtable-copy . B2cbe) (hashtable-contains? . B2cbd) (hashtable-clear! . B2cbc) (call-with-output-file . B2cbb) (call-with-input-file . B2cba) (write-char . B2cb9) (write . B2cb8) (with-output-to-file . B2cb7) (with-input-from-file . B2cb6) (read-char . B2cb5) (read . B2cb4) (peek-char . B2cb3) (open-output-file . B2cb2) (open-input-file . B2cb1) (newline . B2cb0) (display . B2caf) (close-output-port . B2cae) (close-input-port . B2cad) (eof-object? . B2cac) (eof-object . B2cab) (current-error-port . B2caa) (current-output-port . B2ca9) (current-input-port . B2ca8) (output-port? . B2ca7) (input-port? . B2ca6) (utf-8-codec . B2ca5) (utf-16-codec . B2ca4) (transcoder-error-handling-mode . B2ca3) (transcoder-eol-style . B2ca2) (transcoder-codec . B2ca1) (transcoded-port . B2ca0) (textual-port? . B2c9f) (string->bytevector . B2c9e) (standard-output-port . B2c9d) (standard-input-port . B2c9c) (standard-error-port . B2c9b) (set-port-position! . B2c9a) (put-u8 . B2c99) (put-string . B2c98) (put-datum . B2c97) (put-char . B2c96) (put-bytevector . B2c95) (port? . B2c94) (port-transcoder . B2c93) (port-position . B2c92) (port-has-set-port-position!? . B2c91) (port-has-port-position? . B2c90) (port-eof? . B2c8f) (output-port-buffer-mode . B2c8e) (open-string-output-port . B2c8d) (open-string-input-port . B2c8c) (open-file-output-port . B2c8b) (open-file-input/output-port . B2c8a) (open-file-input-port . B2c89) (open-bytevector-output-port . B2c88) (open-bytevector-input-port . B2c87) (native-transcoder . B2c86) (native-eol-style . B2c85) (make-transcoder . B2c84) (latin-1-codec . B2c83) (make-i/o-write-error . B2c82) (make-i/o-read-error . B2c81) (make-i/o-port-error . B2c80) (make-i/o-invalid-position-error . B2c7f) (make-i/o-filename-error . B2c7e) (make-i/o-file-protection-error . B2c7d) (make-i/o-file-is-read-only-error . B2c7c) (make-i/o-file-does-not-exist-error . B2c7b) (make-i/o-file-already-exists-error . B2c7a) (make-i/o-error . B2c79) (make-i/o-encoding-error . B2c78) (make-i/o-decoding-error . B2c77) (make-custom-textual-output-port . B2c76) (make-custom-textual-input/output-port . B2c75) (make-custom-textual-input-port . B2c74) (make-custom-binary-output-port . B2c73) (make-custom-binary-input/output-port . B2c72) (make-custom-binary-input-port . B2c71) (make-bytevector . B2c70) (lookahead-u8 . B2c6f) (lookahead-char . B2c6e) (i/o-write-error? . B2c6d) (i/o-read-error? . B2c6c) (i/o-port-error? . B2c6b) (i/o-invalid-position-error? . B2c6a) (i/o-filename-error? . B2c69) (i/o-file-protection-error? . B2c68) (i/o-file-is-read-only-error? . B2c67) (i/o-file-does-not-exist-error? . B2c66) (i/o-file-already-exists-error? . B2c65) (i/o-error? . B2c64) (i/o-error-position . B2c63) (i/o-error-port . B2c62) (i/o-error-filename . B2c61) (i/o-encoding-error? . B2c60) (i/o-encoding-error-char . B2c5f) (i/o-decoding-error? . B2c5e) (get-u8 . B2c5d) (get-string-n! . B2c5c) (get-string-n . B2c5b) (get-string-all . B2c5a) (get-line . B2c59) (get-datum . B2c58) (get-char . B2c57) (get-bytevector-some . B2c56) (get-bytevector-n! . B2c55) (get-bytevector-n . B2c54) (get-bytevector-all . B2c53) (flush-output-port . B2c52) (close-port . B2c51) (exit . B2c49) (command-line . B28db) (remove . B2c44) (remv . B2c43) (remp . B2c42) (remq . B2c41) (partition . B2c40) (memv . B2c3f) (memq . B2c3e) (memp . B2c3d) (member . B2c3c) (exists . B2c3b) (for-all . B2c3a) (fold-right . B2c39) (fold-left . B2c38) (find . B2c37) (filter . B2c36) (cons* . B2c35) (assv . B2c34) (assq . B2c33) (assp . B2c32) (assoc . B2c31) (call-with-string-output-port . B2c30) (call-with-port . B2c2f) (call-with-bytevector-output-port . B2c2e) (bytevector->string . B2c2d) (buffer-mode? . B2c2c) (binary-port? . B2c2b) (with-exception-handler . B2c2a) (raise-continuable . B2c29) (raise . B2c28) (make-enumeration . B2c27) (enum-set=? . B2c26) (enum-set-universe . B2c25) (enum-set-union . B2c24) (enum-set-subset? . B2c23) (enum-set-projection . B2c22) (enum-set-member? . B2c21) (enum-set-intersection . B2c20) (enum-set-indexer . B2c1f) (enum-set-difference . B2c1e) (enum-set-constructor . B2c1d) (enum-set-complement . B2c1c) (enum-set->list . B2c1b) (who-condition? . B2c1a) (warning? . B2c19) (violation? . B2c18) (undefined-violation? . B2c17) (syntax-violation? . B2c16) (syntax-violation-subform . B2c15) (syntax-violation-form . B2c14) (syntax-violation . Be58) (simple-conditions . B2c13) (serious-condition? . B2c12) (non-continuable-violation? . B2c11) (message-condition? . B2c10) (make-who-condition . B2c0f) (make-warning . B2c0e) (make-violation . B2c0d) (make-undefined-violation . B2c0c) (make-syntax-violation . B2c0b) (make-serious-condition . B2c0a) (make-non-continuable-violation . B2c09) (make-message-condition . B2c08) (make-lexical-violation . B2c07) (make-irritants-condition . B2c06) (make-implementation-restriction-violation . B2c05) (make-error . B2c04) (make-assertion-violation . B2c03) (lexical-violation? . B2c02) (irritants-condition? . B2c01) (implementation-restriction-violation? . B2c00) (error? . B2bff) (condition-who . B2bfe) (condition-predicate . B2bfd) (condition-message . B2bfc) (condition-irritants . B2bfb) (condition-accessor . B2bfa) (condition . B2bf9) (assertion-violation? . B2bf8) (condition? . B2bf7) (utf32->string . B2bf6) (utf16->string . B2bf5) (utf8->string . B2bf4) (uint-list->bytevector . B2bf3) (u8-list->bytevector . B2bf2) (string->utf8 . B2bf1) (string->utf32 . B2bf0) (string->utf16 . B2bef) (sint-list->bytevector . B2bee) (native-endianness . B2bed) (bytevector? . B2bec) (bytevector=? . B2beb) (bytevector-uint-set! . B2bea) (bytevector-uint-ref . B2be9) (bytevector-u8-set! . B2be8) (bytevector-u8-ref . B2be7) (bytevector-u64-set! . B2be6) (bytevector-u64-ref . B2be5) (bytevector-u64-native-set! . B2be4) (bytevector-u64-native-ref . B2be3) (bytevector-u32-set! . B2be2) (bytevector-u32-ref . B2be1) (bytevector-u32-native-set! . B2be0) (bytevector-u32-native-ref . B2bdf) (bytevector-u16-set! . B2bde) (bytevector-u16-ref . B2bdd) (bytevector-u16-native-set! . B2bdc) (bytevector-u16-native-ref . B2bdb) (bytevector-sint-set! . B2bda) (bytevector-sint-ref . B2bd9) (bytevector-s8-set! . B2bd8) (bytevector-s8-ref . B2bd7) (bytevector-s64-set! . B2bd6) (bytevector-s64-ref . B2bd5) (bytevector-s64-native-set! . B2bd4) (bytevector-s64-native-ref . B2bd3) (bytevector-s32-set! . B2bd2) (bytevector-s32-ref . B2bd1) (bytevector-s32-native-set! . B2bd0) (bytevector-s32-native-ref . B2bcf) (bytevector-s16-set! . B2bce) (bytevector-s16-ref . B2bcd) (bytevector-s16-native-set! . B2bcc) (bytevector-s16-native-ref . B2bcb) (bytevector-length . B2bca) (bytevector-ieee-single-ref . B2bc9) (bytevector-ieee-single-set! . B2bc8) (bytevector-ieee-single-native-set! . B2bc7) (bytevector-ieee-single-native-ref . B2bc6) (bytevector-ieee-double-set! . B2bc5) (bytevector-ieee-double-ref . B2bc4) (bytevector-ieee-double-native-set! . B2bc3) (bytevector-ieee-double-native-ref . B2bc2) (bytevector-fill! . B2bc1) (bytevector-copy! . B2bc0) (bytevector-copy . B2bbf) (bytevector->uint-list . B2bbe) (bytevector->u8-list . B2bbd) (bytevector->sint-list . B2bbc) (no-nans-violation? . B2bbb) (no-infinities-violation? . B2bba) (make-no-nans-violation . B2bb9) (make-no-infinities-violation . B2bb8) (real->flonum . B2bb7) (flzero? . B2bb6) (fltruncate . B2bb5) (fltan . B2bb4) (flsqrt . B2bb3) (flsin . B2bb2) (flround . B2bb1) (flpositive? . B2bb0) (flonum? . B2baf) (flodd? . B2bae) (flnumerator . B2bad) (flnegative? . B2bac) (flnan? . B2bab) (flmod0 . B2baa) (flmod . B2ba9) (flmin . B2ba8) (flmax . B2ba7) (fllog . B2ba6) (flinteger? . B2ba5) (flinfinite? . B2ba4) (flfloor . B2ba3) (flfinite? . B2ba2) (flexpt . B2ba1) (flexp . B2ba0) (fleven? . B2b9f) (fldiv0-and-mod0 . B2b9e) (fldiv0 . B2b9d) (fldiv-and-mod . B2b9c) (fldiv . B2b9b) (fldenominator . B2b9a) (flcos . B2b99) (flceiling . B2b98) (flatan . B2b97) (flasin . B2b96) (flacos . B2b95) (flabs . B2b94) (fl>? . B2b93) (fl>=? . B2b92) (fl=? . B2b91) (fl<? . B2b90) (fl<=? . B2b8f) (fl/ . B2b8e) (fl- . B2b8d) (fl+ . B2b8c) (fl* . B2b8b) (fixnum->flonum . B2b8a) (fxzero? . B2b89) (fxxor . B2b88) (fxrotate-bit-field . B2b87) (fxreverse-bit-field . B2b86) (fxpositive? . B2b85) (fxodd? . B2b84) (fxnot . B2b83) (fxnegative? . B2b82) (fxmod0 . B2b81) (fxmod . B2b80) (fxmin . B2b7f) (fxmax . B2b7e) (fxlength . B2b7d) (fxior . B2b7c) (fxif . B2b7b) (fxfirst-bit-set . B2b7a) (fxeven? . B2b79) (fxdiv0-and-mod0 . B2b78) (fxdiv0 . B2b77) (fxdiv-and-mod . B2b76) (fxdiv . B2b75) (fxcopy-bit-field . B2b74) (fxcopy-bit . B2b73) (fxbit-set? . B2b72) (fxbit-field . B2b71) (fxbit-count . B2b70) (fxarithmetic-shift-right . B2b6f) (fxarithmetic-shift-left . B2b6e) (fxarithmetic-shift . B2b6d) (fxand . B2b6c) (fx>? . B2b6b) (fx>=? . B2b6a) (fx=? . B2b69) (fx<? . B2b68) (fx<=? . B2b67) (fx-/carry . B2b66) (fx- . B2b65) (fx+/carry . B2b64) (fx+ . B2b63) (fx*/carry . B2b62) (fx* . B2b61) (greatest-fixnum . B2b60) (least-fixnum . B2b5f) (fixnum-width . B2b5e) (fixnum? . B2b5d) (bitwise-rotate-bit-field . B2b5c) (bitwise-reverse-bit-field . B2b5b) (bitwise-length . B2b5a) (bitwise-if . B2b59) (bitwise-first-bit-set . B2b58) (bitwise-copy-bit-field . B2b57) (bitwise-copy-bit . B2b56) (bitwise-bit-set? . B2b55) (bitwise-bit-field . B2b54) (bitwise-bit-count . B2b53) (bitwise-xor . B2b52) (bitwise-ior . B2b51) (bitwise-and . B2b50) (bitwise-not . B2b4f) (bitwise-arithmetic-shift-right . B2b4e) (bitwise-arithmetic-shift-left . B2b4d) (bitwise-arithmetic-shift . B2b4c) (zero? . B2b4b) (vector? . B2b4a) (vector-set! . B2b49) (vector-ref . B2b48) (vector-map . B2b47) (vector-length . B2b46) (vector-for-each . B2b45) (vector-fill! . B2b44) (vector->list . B2b43) (vector . B2b42) (values . B2b41) (truncate . B2b40) (tan . B2b3f) (symbol? . B2b3e) (symbol=? . B2b3d) (symbol->string . B2b3c) (substring . B2b3b) (string? . B2b3a) (string>? . B2b39) (string>=? . B2b38) (string=? . B2b37) (string<? . B2b36) (string<=? . B2b35) (string-ref . B2b34) (string-length . B2b33) (string-for-each . B2b32) (string-copy . B2b31) (string-append . B2b30) (string->symbol . B2b2f) (string->number . B2b2e) (string->list . B2b2d) (string . B2b2c) (sqrt . B2b2b) (sin . B2b2a) (round . B2b29) (reverse . B2b28) (real? . B2b27) (real-valued? . B2b26) (real-part . B2b25) (rationalize . B2b24) (rational? . B2b23) (rational-valued? . B2b22) (procedure? . B2b21) (positive? . B2b20) (pair? . B2b1f) (odd? . B2b1e) (numerator . B2b1d) (number? . B2b1c) (number->string . B2b1b) (null? . B2b1a) (not . B2b19) (negative? . B2b18) (nan? . B2b17) (min . B2b16) (max . B2b15) (map . B2b14) (make-vector . B2b13) (make-string . B2b12) (make-rectangular . B2b11) (make-polar . B2b10) (magnitude . B2b0f) (log . B2b0e) (list? . B2b0d) (list-tail . B2b0c) (list-ref . B2b0b) (list->vector . B2b0a) (list->string . B2b09) (list . B2b08) (length . B2b07) (lcm . B2b06) (integer? . B2b05) (integer-valued? . B2b04) (integer->char . B2b03) (infinite? . B2b02) (inexact? . B2b01) (inexact . B2b00) (imag-part . B2aff) (gcd . B2afe) (for-each . B2afd) (floor . B2afc) (finite? . B2afb) (expt . B2afa) (exp . B2af9) (exact? . B2af8) (exact-integer-sqrt . B2af7) (exact . B2af6) (even? . B2af5) (error . B2af4) (eqv? . B2af3) (equal? . B2af2) (eq? . B2af1) (dynamic-wind . B2af0) (div0-and-mod0 . B2aef) (mod0 . B2aee) (div0 . B2aed) (div-and-mod . B2aec) (mod . B2aeb) (div . B2aea) (denominator . B2ae9) (cos . B2ae8) (cons . B2ae7) (complex? . B2ae6) (char? . B2ae5) (char>? . B2ae4) (char>=? . B2ae3) (char=? . B2ae2) (char<? . B2ae1) (char<=? . B2ae0) (char->integer . B2adf) (ceiling . B2ade) (call-with-values . B2add) (call/cc . B2adc) (call-with-current-continuation . B2adb) (cddddr . B2ada) (cdddar . B2ad9) (cddadr . B2ad8) (cddaar . B2ad7) (cdaddr . B2ad6) (cdadar . B2ad5) (cdaadr . B2ad4) (cdaaar . B2ad3) (cadddr . B2ad2) (caddar . B2ad1) (cadadr . B2ad0) (cadaar . B2acf) (caaddr . B2ace) (caadar . B2acd) (caaadr . B2acc) (caaaar . B2acb) (cdddr . B2aca) (cddar . B2ac9) (cdadr . B2ac8) (cdaar . B2ac7) (caddr . B2ac6) (cadar . B2ac5) (caadr . B2ac4) (caaar . B2ac3) (cddr . B2ac2) (cdar . B2ac1) (cadr . B2ac0) (caar . B2abf) (cdr . B2abe) (car . B2abd) (boolean? . B2abc) (boolean=? . B2abb) (atan . B2aba) (assertion-violation . B2ab9) (asin . B2ab8) (apply . B2ab7) (append . B2ab6) (angle . B2ab5) (acos . B2ab4) (abs . B2ab3) (/ . B2ab2) (* . B2ab1) (- . B2ab0) (+ . B2aaf) (>= . B2aae) (> . B2aad) (= . B2aac) (<= . B2aab) (< . B2aaa) (&no-nans . B2aa8) (&no-infinities . B2aa7) (&i/o-encoding . B2aa6) (&i/o-decoding . B2aa5) (&i/o-port . B2aa4) (&i/o-file-does-not-exist . B2aa3) (&i/o-file-already-exists . B2aa2) (&i/o-file-is-read-only . B2aa1) (&i/o-file-protection . B2aa0) (&i/o-filename . B2a9f) (&i/o-invalid-position . B2a9e) (&i/o-write . B2a9d) (&i/o-read . B2a9c) (&i/o . B2a9b) (&undefined . B2a9a) (&syntax . B2a99) (&lexical . B2a98) (&implementation-restriction . B2a97) (&non-continuable . B2a96) (&who . B2a95) (&irritants . B2a94) (&assertion . B2a93) (&violation . B2a92) (&error . B2a91) (&serious . B2a90) (&warning . B2a8f) (&message . B2a8e) (&condition . B2a8d) (define-condition-type . B2a8c) (define-enumeration . B2a8b) (define-record-type . B2a8a) (parent-rtd . B2a89) (nongenerative . B2a88) (opaque . B2a87) (sealed . B2a86) (protocol . B2a85) (parent . B2a84) (immutable . B2a83) (mutable . B2a82) (fields . B2a81) (error-handling-mode . B2a80) (file-options . B2a7f) (buffer-mode . B2a7e) (eol-style . B2a7d) (guard . B2a7c) (unsyntax-splicing . B2a79) (unsyntax . B2a78) (unquote-splicing . B2a77) (unquote . B2a76) (_ . B2a75) (else . B2a74) (=> . B2a73) (... . B2a72) (assert . B2a71) (endianness . B2a70) (do . B2a6d) (cond . B2a6c) (let* . B2a6b) (let*-values . B2a6a) (let-values . B2a69) (identifier-syntax . B2a68) (with-syntax . B2a67) (quasisyntax . B2a66) (quasiquote . B2a65) (syntax-rules . B2a64) (record-constructor-descriptor . B2a61) (record-type-descriptor . B2a60) (case . B2a5f) (unless . B2a5d) (when . B2a5c) (or . B2a5b) (and . B2a5a) (if . B2a59) (let . B2a58) (letrec* . B2a57) (letrec . B2a56) (case-lambda . B2a54) (lambda . B2a53) (syntax . B2a52) (syntax-case . B2a51) (quote . B2a50) (letrec-syntax . B2a4e) (let-syntax . B2a4d) (set! . B2a4c) (begin . B2a4a) (define-syntax . B2a48) (define . B2a47)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2dee '(rnrs r5rs) '(6) '() '() '() '((scheme-report-environment . Be34) (quotient . B2c50) (null-environment . Be32) (remainder . B2c4f) (modulo . B2c4e) (inexact->exact . B2c4d) (force . B2c4c) (exact->inexact . B2c4b) (make-promise . B2c4a) (delay . B2a6f)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2def '(rnrs control) '(6) '() '() '() '((do . B2a6d) (unless . B2a5d) (when . B2a5c) (case-lambda . B2a54)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2df0 '(rnrs eval) '(6) '() '() '() '((eval . Be38) (environment . Be30)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2df1 '(rnrs mutable-pairs) '(6) '() '() '() '((set-cdr! . B2c46) (set-car! . B2c45)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2df2 '(rnrs mutable-strings) '(6) '() '() '() '((string-fill! . B2c48) (string-set! . B2c47)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2df3 '(rnrs programs) '(6) '() '() '() '((exit . B2c49) (command-line . B28db)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2df4 '(rnrs syntax-case) '(6) '() '() '() '((make-variable-transformer . Bba3) (identifier? . Be5a) (generate-temporaries . Be46) (free-identifier=? . Be48) (syntax->datum . Be5e) (datum->syntax . Be5c) (bound-identifier=? . Be4a) (syntax-violation . Be58) (unsyntax-splicing . B2a79) (unsyntax . B2a78) (_ . B2a75) (... . B2a72) (with-syntax . B2a67) (quasisyntax . B2a66) (syntax . B2a52) (syntax-case . B2a51)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2df5 '(rnrs files) '(6) '() '() '() '((delete-file . B2cd5) (file-exists? . B2cd4) (make-i/o-write-error . B2c82) (make-i/o-read-error . B2c81) (make-i/o-port-error . B2c80) (make-i/o-invalid-position-error . B2c7f) (make-i/o-filename-error . B2c7e) (make-i/o-file-protection-error . B2c7d) (make-i/o-file-is-read-only-error . B2c7c) (make-i/o-file-does-not-exist-error . B2c7b) (make-i/o-file-already-exists-error . B2c7a) (make-i/o-error . B2c79) (i/o-write-error? . B2c6d) (i/o-read-error? . B2c6c) (i/o-port-error? . B2c6b) (i/o-invalid-position-error? . B2c6a) (i/o-filename-error? . B2c69) (i/o-file-protection-error? . B2c68) (i/o-file-is-read-only-error? . B2c67) (i/o-file-does-not-exist-error? . B2c66) (i/o-file-already-exists-error? . B2c65) (i/o-error? . B2c64) (i/o-error-position . B2c63) (i/o-error-port . B2c62) (i/o-error-filename . B2c61) (&i/o-port . B2aa4) (&i/o-file-does-not-exist . B2aa3) (&i/o-file-already-exists . B2aa2) (&i/o-file-is-read-only . B2aa1) (&i/o-file-protection . B2aa0) (&i/o-filename . B2a9f) (&i/o-invalid-position . B2a9e) (&i/o-write . B2a9d) (&i/o-read . B2a9c) (&i/o . B2a9b)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2df6 '(rnrs sorting) '(6) '() '() '() '((vector-sort! . B2cd3) (vector-sort . B2cd2) (list-sort . B2cd1)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2df7 '(rnrs base) '(6) '() '() '() '((zero? . B2b4b) (vector? . B2b4a) (vector-set! . B2b49) (vector-ref . B2b48) (vector-map . B2b47) (vector-length . B2b46) (vector-for-each . B2b45) (vector-fill! . B2b44) (vector->list . B2b43) (vector . B2b42) (values . B2b41) (truncate . B2b40) (tan . B2b3f) (symbol? . B2b3e) (symbol=? . B2b3d) (symbol->string . B2b3c) (substring . B2b3b) (string? . B2b3a) (string>? . B2b39) (string>=? . B2b38) (string=? . B2b37) (string<? . B2b36) (string<=? . B2b35) (string-ref . B2b34) (string-length . B2b33) (string-for-each . B2b32) (string-copy . B2b31) (string-append . B2b30) (string->symbol . B2b2f) (string->number . B2b2e) (string->list . B2b2d) (string . B2b2c) (sqrt . B2b2b) (sin . B2b2a) (round . B2b29) (reverse . B2b28) (real? . B2b27) (real-valued? . B2b26) (real-part . B2b25) (rationalize . B2b24) (rational? . B2b23) (rational-valued? . B2b22) (procedure? . B2b21) (positive? . B2b20) (pair? . B2b1f) (odd? . B2b1e) (numerator . B2b1d) (number? . B2b1c) (number->string . B2b1b) (null? . B2b1a) (not . B2b19) (negative? . B2b18) (nan? . B2b17) (min . B2b16) (max . B2b15) (map . B2b14) (make-vector . B2b13) (make-string . B2b12) (make-rectangular . B2b11) (make-polar . B2b10) (magnitude . B2b0f) (log . B2b0e) (list? . B2b0d) (list-tail . B2b0c) (list-ref . B2b0b) (list->vector . B2b0a) (list->string . B2b09) (list . B2b08) (length . B2b07) (lcm . B2b06) (integer? . B2b05) (integer-valued? . B2b04) (integer->char . B2b03) (infinite? . B2b02) (inexact? . B2b01) (inexact . B2b00) (imag-part . B2aff) (gcd . B2afe) (for-each . B2afd) (floor . B2afc) (finite? . B2afb) (expt . B2afa) (exp . B2af9) (exact? . B2af8) (exact-integer-sqrt . B2af7) (exact . B2af6) (even? . B2af5) (error . B2af4) (eqv? . B2af3) (equal? . B2af2) (eq? . B2af1) (dynamic-wind . B2af0) (div0-and-mod0 . B2aef) (mod0 . B2aee) (div0 . B2aed) (div-and-mod . B2aec) (mod . B2aeb) (div . B2aea) (denominator . B2ae9) (cos . B2ae8) (cons . B2ae7) (complex? . B2ae6) (char? . B2ae5) (char>? . B2ae4) (char>=? . B2ae3) (char=? . B2ae2) (char<? . B2ae1) (char<=? . B2ae0) (char->integer . B2adf) (ceiling . B2ade) (call-with-values . B2add) (call/cc . B2adc) (call-with-current-continuation . B2adb) (cddddr . B2ada) (cdddar . B2ad9) (cddadr . B2ad8) (cddaar . B2ad7) (cdaddr . B2ad6) (cdadar . B2ad5) (cdaadr . B2ad4) (cdaaar . B2ad3) (cadddr . B2ad2) (caddar . B2ad1) (cadadr . B2ad0) (cadaar . B2acf) (caaddr . B2ace) (caadar . B2acd) (caaadr . B2acc) (caaaar . B2acb) (cdddr . B2aca) (cddar . B2ac9) (cdadr . B2ac8) (cdaar . B2ac7) (caddr . B2ac6) (cadar . B2ac5) (caadr . B2ac4) (caaar . B2ac3) (cddr . B2ac2) (cdar . B2ac1) (cadr . B2ac0) (caar . B2abf) (cdr . B2abe) (car . B2abd) (boolean? . B2abc) (boolean=? . B2abb) (atan . B2aba) (assertion-violation . B2ab9) (asin . B2ab8) (apply . B2ab7) (append . B2ab6) (angle . B2ab5) (acos . B2ab4) (abs . B2ab3) (/ . B2ab2) (* . B2ab1) (- . B2ab0) (+ . B2aaf) (>= . B2aae) (> . B2aad) (= . B2aac) (<= . B2aab) (< . B2aaa) (unquote-splicing . B2a77) (unquote . B2a76) (_ . B2a75) (else . B2a74) (=> . B2a73) (... . B2a72) (assert . B2a71) (cond . B2a6c) (let* . B2a6b) (let*-values . B2a6a) (let-values . B2a69) (identifier-syntax . B2a68) (quasiquote . B2a65) (syntax-rules . B2a64) (case . B2a5f) (or . B2a5b) (and . B2a5a) (if . B2a59) (let . B2a58) (letrec* . B2a57) (letrec . B2a56) (lambda . B2a53) (quote . B2a50) (letrec-syntax . B2a4e) (let-syntax . B2a4d) (set! . B2a4c) (begin . B2a4a) (define-syntax . B2a48) (define . B2a47)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2df8 '(rnrs lists) '(6) '() '() '() '((remove . B2c44) (remv . B2c43) (remp . B2c42) (remq . B2c41) (partition . B2c40) (memv . B2c3f) (memq . B2c3e) (memp . B2c3d) (member . B2c3c) (exists . B2c3b) (for-all . B2c3a) (fold-right . B2c39) (fold-left . B2c38) (find . B2c37) (filter . B2c36) (cons* . B2c35) (assv . B2c34) (assq . B2c33) (assp . B2c32) (assoc . B2c31)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2df9 '(rnrs io simple) '(6) '() '() '() '((call-with-output-file . B2cbb) (call-with-input-file . B2cba) (write-char . B2cb9) (write . B2cb8) (with-output-to-file . B2cb7) (with-input-from-file . B2cb6) (read-char . B2cb5) (read . B2cb4) (peek-char . B2cb3) (open-output-file . B2cb2) (open-input-file . B2cb1) (newline . B2cb0) (display . B2caf) (close-output-port . B2cae) (close-input-port . B2cad) (eof-object? . B2cac) (eof-object . B2cab) (current-error-port . B2caa) (current-output-port . B2ca9) (current-input-port . B2ca8) (output-port? . B2ca7) (input-port? . B2ca6) (make-i/o-write-error . B2c82) (make-i/o-read-error . B2c81) (make-i/o-port-error . B2c80) (make-i/o-invalid-position-error . B2c7f) (make-i/o-filename-error . B2c7e) (make-i/o-file-protection-error . B2c7d) (make-i/o-file-is-read-only-error . B2c7c) (make-i/o-file-does-not-exist-error . B2c7b) (make-i/o-file-already-exists-error . B2c7a) (make-i/o-error . B2c79) (i/o-write-error? . B2c6d) (i/o-read-error? . B2c6c) (i/o-port-error? . B2c6b) (i/o-invalid-position-error? . B2c6a) (i/o-filename-error? . B2c69) (i/o-file-protection-error? . B2c68) (i/o-file-is-read-only-error? . B2c67) (i/o-file-does-not-exist-error? . B2c66) (i/o-file-already-exists-error? . B2c65) (i/o-error? . B2c64) (i/o-error-position . B2c63) (i/o-error-port . B2c62) (i/o-error-filename . B2c61) (&i/o-port . B2aa4) (&i/o-file-does-not-exist . B2aa3) (&i/o-file-already-exists . B2aa2) (&i/o-file-is-read-only . B2aa1) (&i/o-file-protection . B2aa0) (&i/o-filename . B2a9f) (&i/o-invalid-position . B2a9e) (&i/o-write . B2a9d) (&i/o-read . B2a9c) (&i/o . B2a9b)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2dfa '(rnrs bytevectors) '(6) '() '() '() '((make-bytevector . B2c70) (utf32->string . B2bf6) (utf16->string . B2bf5) (utf8->string . B2bf4) (uint-list->bytevector . B2bf3) (u8-list->bytevector . B2bf2) (string->utf8 . B2bf1) (string->utf32 . B2bf0) (string->utf16 . B2bef) (sint-list->bytevector . B2bee) (native-endianness . B2bed) (bytevector? . B2bec) (bytevector=? . B2beb) (bytevector-uint-set! . B2bea) (bytevector-uint-ref . B2be9) (bytevector-u8-set! . B2be8) (bytevector-u8-ref . B2be7) (bytevector-u64-set! . B2be6) (bytevector-u64-ref . B2be5) (bytevector-u64-native-set! . B2be4) (bytevector-u64-native-ref . B2be3) (bytevector-u32-set! . B2be2) (bytevector-u32-ref . B2be1) (bytevector-u32-native-set! . B2be0) (bytevector-u32-native-ref . B2bdf) (bytevector-u16-set! . B2bde) (bytevector-u16-ref . B2bdd) (bytevector-u16-native-set! . B2bdc) (bytevector-u16-native-ref . B2bdb) (bytevector-sint-set! . B2bda) (bytevector-sint-ref . B2bd9) (bytevector-s8-set! . B2bd8) (bytevector-s8-ref . B2bd7) (bytevector-s64-set! . B2bd6) (bytevector-s64-ref . B2bd5) (bytevector-s64-native-set! . B2bd4) (bytevector-s64-native-ref . B2bd3) (bytevector-s32-set! . B2bd2) (bytevector-s32-ref . B2bd1) (bytevector-s32-native-set! . B2bd0) (bytevector-s32-native-ref . B2bcf) (bytevector-s16-set! . B2bce) (bytevector-s16-ref . B2bcd) (bytevector-s16-native-set! . B2bcc) (bytevector-s16-native-ref . B2bcb) (bytevector-length . B2bca) (bytevector-ieee-single-ref . B2bc9) (bytevector-ieee-single-set! . B2bc8) (bytevector-ieee-single-native-set! . B2bc7) (bytevector-ieee-single-native-ref . B2bc6) (bytevector-ieee-double-set! . B2bc5) (bytevector-ieee-double-ref . B2bc4) (bytevector-ieee-double-native-set! . B2bc3) (bytevector-ieee-double-native-ref . B2bc2) (bytevector-fill! . B2bc1) (bytevector-copy! . B2bc0) (bytevector-copy . B2bbf) (bytevector->uint-list . B2bbe) (bytevector->u8-list . B2bbd) (bytevector->sint-list . B2bbc) (endianness . B2a70)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2dfb '(rnrs unicode) '(6) '() '() '() '((string-upcase . B2d03) (string-titlecase . B2d02) (string-normalize-nfkd . B2d01) (string-normalize-nfkc . B2d00) (string-normalize-nfd . B2cff) (string-normalize-nfc . B2cfe) (string-foldcase . B2cfd) (string-downcase . B2cfc) (string-ci>? . B2cfb) (string-ci>=? . B2cfa) (string-ci=? . B2cf9) (string-ci<? . B2cf8) (string-ci<=? . B2cf7) (char-whitespace? . B2cf6) (char-upper-case? . B2cf5) (char-title-case? . B2cf4) (char-numeric? . B2cf3) (char-lower-case? . B2cf2) (char-general-category . B2cf1) (char-upcase . B2cf0) (char-titlecase . B2cef) (char-foldcase . B2cee) (char-downcase . B2ced) (char-ci>? . B2cec) (char-ci>=? . B2ceb) (char-ci=? . B2cea) (char-ci<? . B2ce9) (char-ci<=? . B2ce8) (char-alphabetic? . B2ce7)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2dfc '(rnrs exceptions) '(6) '() '() '() '((with-exception-handler . B2c2a) (raise-continuable . B2c29) (raise . B2c28) (guard . B2a7c) (else . B2a74) (=> . B2a73)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2dfd '(rnrs arithmetic bitwise) '(6) '() '() '() '((bitwise-rotate-bit-field . B2b5c) (bitwise-reverse-bit-field . B2b5b) (bitwise-length . B2b5a) (bitwise-if . B2b59) (bitwise-first-bit-set . B2b58) (bitwise-copy-bit-field . B2b57) (bitwise-copy-bit . B2b56) (bitwise-bit-set? . B2b55) (bitwise-bit-field . B2b54) (bitwise-bit-count . B2b53) (bitwise-xor . B2b52) (bitwise-ior . B2b51) (bitwise-and . B2b50) (bitwise-not . B2b4f) (bitwise-arithmetic-shift-right . B2b4e) (bitwise-arithmetic-shift-left . B2b4d) (bitwise-arithmetic-shift . B2b4c)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2dfe '(rnrs arithmetic fixnums) '(6) '() '() '() '((fxzero? . B2b89) (fxxor . B2b88) (fxrotate-bit-field . B2b87) (fxreverse-bit-field . B2b86) (fxpositive? . B2b85) (fxodd? . B2b84) (fxnot . B2b83) (fxnegative? . B2b82) (fxmod0 . B2b81) (fxmod . B2b80) (fxmin . B2b7f) (fxmax . B2b7e) (fxlength . B2b7d) (fxior . B2b7c) (fxif . B2b7b) (fxfirst-bit-set . B2b7a) (fxeven? . B2b79) (fxdiv0-and-mod0 . B2b78) (fxdiv0 . B2b77) (fxdiv-and-mod . B2b76) (fxdiv . B2b75) (fxcopy-bit-field . B2b74) (fxcopy-bit . B2b73) (fxbit-set? . B2b72) (fxbit-field . B2b71) (fxbit-count . B2b70) (fxarithmetic-shift-right . B2b6f) (fxarithmetic-shift-left . B2b6e) (fxarithmetic-shift . B2b6d) (fxand . B2b6c) (fx>? . B2b6b) (fx>=? . B2b6a) (fx=? . B2b69) (fx<? . B2b68) (fx<=? . B2b67) (fx-/carry . B2b66) (fx- . B2b65) (fx+/carry . B2b64) (fx+ . B2b63) (fx*/carry . B2b62) (fx* . B2b61) (greatest-fixnum . B2b60) (least-fixnum . B2b5f) (fixnum-width . B2b5e) (fixnum? . B2b5d)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2dff '(rnrs arithmetic flonums) '(6) '() '() '() '((no-nans-violation? . B2bbb) (no-infinities-violation? . B2bba) (make-no-nans-violation . B2bb9) (make-no-infinities-violation . B2bb8) (real->flonum . B2bb7) (flzero? . B2bb6) (fltruncate . B2bb5) (fltan . B2bb4) (flsqrt . B2bb3) (flsin . B2bb2) (flround . B2bb1) (flpositive? . B2bb0) (flonum? . B2baf) (flodd? . B2bae) (flnumerator . B2bad) (flnegative? . B2bac) (flnan? . B2bab) (flmod0 . B2baa) (flmod . B2ba9) (flmin . B2ba8) (flmax . B2ba7) (fllog . B2ba6) (flinteger? . B2ba5) (flinfinite? . B2ba4) (flfloor . B2ba3) (flfinite? . B2ba2) (flexpt . B2ba1) (flexp . B2ba0) (fleven? . B2b9f) (fldiv0-and-mod0 . B2b9e) (fldiv0 . B2b9d) (fldiv-and-mod . B2b9c) (fldiv . B2b9b) (fldenominator . B2b9a) (flcos . B2b99) (flceiling . B2b98) (flatan . B2b97) (flasin . B2b96) (flacos . B2b95) (flabs . B2b94) (fl>? . B2b93) (fl>=? . B2b92) (fl=? . B2b91) (fl<? . B2b90) (fl<=? . B2b8f) (fl/ . B2b8e) (fl- . B2b8d) (fl+ . B2b8c) (fl* . B2b8b) (fixnum->flonum . B2b8a) (&no-nans . B2aa8) (&no-infinities . B2aa7)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2e00 '(rnrs hashtables) '(6) '() '() '() '((symbol-hash . B2cd0) (string-ci-hash . B2ccf) (string-hash . B2cce) (equal-hash . B2ccd) (hashtable-equivalence-function . B2ccc) (make-hashtable . B2ccb) (hashtable-hash-function . B2cca) (make-eqv-hashtable . B2cc9) (make-eq-hashtable . B2cc8) (hashtable? . B2cc7) (hashtable-update! . B2cc6) (hashtable-size . B2cc5) (hashtable-set! . B2cc4) (hashtable-ref . B2cc3) (hashtable-mutable? . B2cc2) (hashtable-keys . B2cc1) (hashtable-entries . B2cc0) (hashtable-delete! . B2cbf) (hashtable-copy . B2cbe) (hashtable-contains? . B2cbd) (hashtable-clear! . B2cbc)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2e01 '(rnrs io ports) '(6) '() '() '() '((eof-object? . B2cac) (eof-object . B2cab) (current-error-port . B2caa) (current-output-port . B2ca9) (current-input-port . B2ca8) (output-port? . B2ca7) (input-port? . B2ca6) (utf-8-codec . B2ca5) (utf-16-codec . B2ca4) (transcoder-error-handling-mode . B2ca3) (transcoder-eol-style . B2ca2) (transcoder-codec . B2ca1) (transcoded-port . B2ca0) (textual-port? . B2c9f) (string->bytevector . B2c9e) (standard-output-port . B2c9d) (standard-input-port . B2c9c) (standard-error-port . B2c9b) (set-port-position! . B2c9a) (put-u8 . B2c99) (put-string . B2c98) (put-datum . B2c97) (put-char . B2c96) (put-bytevector . B2c95) (port? . B2c94) (port-transcoder . B2c93) (port-position . B2c92) (port-has-set-port-position!? . B2c91) (port-has-port-position? . B2c90) (port-eof? . B2c8f) (output-port-buffer-mode . B2c8e) (open-string-output-port . B2c8d) (open-string-input-port . B2c8c) (open-file-output-port . B2c8b) (open-file-input/output-port . B2c8a) (open-file-input-port . B2c89) (open-bytevector-output-port . B2c88) (open-bytevector-input-port . B2c87) (native-transcoder . B2c86) (native-eol-style . B2c85) (make-transcoder . B2c84) (latin-1-codec . B2c83) (make-i/o-write-error . B2c82) (make-i/o-read-error . B2c81) (make-i/o-port-error . B2c80) (make-i/o-invalid-position-error . B2c7f) (make-i/o-filename-error . B2c7e) (make-i/o-file-protection-error . B2c7d) (make-i/o-file-is-read-only-error . B2c7c) (make-i/o-file-does-not-exist-error . B2c7b) (make-i/o-file-already-exists-error . B2c7a) (make-i/o-error . B2c79) (make-i/o-encoding-error . B2c78) (make-i/o-decoding-error . B2c77) (make-custom-textual-output-port . B2c76) (make-custom-textual-input/output-port . B2c75) (make-custom-textual-input-port . B2c74) (make-custom-binary-output-port . B2c73) (make-custom-binary-input/output-port . B2c72) (make-custom-binary-input-port . B2c71) (lookahead-u8 . B2c6f) (lookahead-char . B2c6e) (i/o-write-error? . B2c6d) (i/o-read-error? . B2c6c) (i/o-port-error? . B2c6b) (i/o-invalid-position-error? . B2c6a) (i/o-filename-error? . B2c69) (i/o-file-protection-error? . B2c68) (i/o-file-is-read-only-error? . B2c67) (i/o-file-does-not-exist-error? . B2c66) (i/o-file-already-exists-error? . B2c65) (i/o-error? . B2c64) (i/o-error-position . B2c63) (i/o-error-port . B2c62) (i/o-error-filename . B2c61) (i/o-encoding-error? . B2c60) (i/o-encoding-error-char . B2c5f) (i/o-decoding-error? . B2c5e) (get-u8 . B2c5d) (get-string-n! . B2c5c) (get-string-n . B2c5b) (get-string-all . B2c5a) (get-line . B2c59) (get-datum . B2c58) (get-char . B2c57) (get-bytevector-some . B2c56) (get-bytevector-n! . B2c55) (get-bytevector-n . B2c54) (get-bytevector-all . B2c53) (flush-output-port . B2c52) (close-port . B2c51) (call-with-string-output-port . B2c30) (call-with-port . B2c2f) (call-with-bytevector-output-port . B2c2e) (bytevector->string . B2c2d) (buffer-mode? . B2c2c) (binary-port? . B2c2b) (&i/o-encoding . B2aa6) (&i/o-decoding . B2aa5) (&i/o-port . B2aa4) (&i/o-file-does-not-exist . B2aa3) (&i/o-file-already-exists . B2aa2) (&i/o-file-is-read-only . B2aa1) (&i/o-file-protection . B2aa0) (&i/o-filename . B2a9f) (&i/o-invalid-position . B2a9e) (&i/o-write . B2a9d) (&i/o-read . B2a9c) (&i/o . B2a9b) (error-handling-mode . B2a80) (file-options . B2a7f) (buffer-mode . B2a7e) (eol-style . B2a7d)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2e02 '(rnrs enums) '(6) '() '() '() '((make-enumeration . B2c27) (enum-set=? . B2c26) (enum-set-universe . B2c25) (enum-set-union . B2c24) (enum-set-subset? . B2c23) (enum-set-projection . B2c22) (enum-set-member? . B2c21) (enum-set-intersection . B2c20) (enum-set-indexer . B2c1f) (enum-set-difference . B2c1e) (enum-set-constructor . B2c1d) (enum-set-complement . B2c1c) (enum-set->list . B2c1b) (define-enumeration . B2a8b)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2e03 '(rnrs conditions) '(6) '() '() '() '((who-condition? . B2c1a) (warning? . B2c19) (violation? . B2c18) (undefined-violation? . B2c17) (syntax-violation? . B2c16) (syntax-violation-subform . B2c15) (syntax-violation-form . B2c14) (syntax-violation . Be58) (simple-conditions . B2c13) (serious-condition? . B2c12) (non-continuable-violation? . B2c11) (message-condition? . B2c10) (make-who-condition . B2c0f) (make-warning . B2c0e) (make-violation . B2c0d) (make-undefined-violation . B2c0c) (make-syntax-violation . B2c0b) (make-serious-condition . B2c0a) (make-non-continuable-violation . B2c09) (make-message-condition . B2c08) (make-lexical-violation . B2c07) (make-irritants-condition . B2c06) (make-implementation-restriction-violation . B2c05) (make-error . B2c04) (make-assertion-violation . B2c03) (lexical-violation? . B2c02) (irritants-condition? . B2c01) (implementation-restriction-violation? . B2c00) (error? . B2bff) (condition-who . B2bfe) (condition-predicate . B2bfd) (condition-message . B2bfc) (condition-irritants . B2bfb) (condition-accessor . B2bfa) (condition . B2bf9) (assertion-violation? . B2bf8) (condition? . B2bf7) (&undefined . B2a9a) (&syntax . B2a99) (&lexical . B2a98) (&implementation-restriction . B2a97) (&non-continuable . B2a96) (&who . B2a95) (&irritants . B2a94) (&assertion . B2a93) (&violation . B2a92) (&error . B2a91) (&serious . B2a90) (&warning . B2a8f) (&message . B2a8e) (&condition . B2a8d) (define-condition-type . B2a8c)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2e04 '(rnrs records inspection) '(6) '() '() '() '((record? . B2cdf) (record-type-uid . B2cde) (record-type-sealed? . B2cdd) (record-type-parent . B2cdc) (record-type-opaque? . B2cdb) (record-type-name . B2cda) (record-type-generative? . B2cd9) (record-type-field-names . B2cd8) (record-rtd . B2cd7) (record-field-mutable? . B2cd6)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2e05 '(rnrs records procedural) '(6) '() '() '() '((record-type-descriptor? . B2ce6) (record-predicate . B2ce5) (record-mutator . B2ce4) (record-constructor . B2ce3) (record-accessor . B2ce2) (make-record-type-descriptor . B2ce1) (make-record-constructor-descriptor . B2ce0)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2e06 '(rnrs records syntactic) '(6) '() '() '() '((define-record-type . B2a8a) (parent-rtd . B2a89) (nongenerative . B2a88) (opaque . B2a87) (sealed . B2a86) (protocol . B2a85) (parent . B2a84) (immutable . B2a83) (mutable . B2a82) (fields . B2a81) (record-constructor-descriptor . B2a61) (record-type-descriptor . B2a60)) '() values values '#f '#f '#t '#f) (B98c@B7d8@install-library 'B2e07 '(psyntax system $all) '() '() '() '() '((&no-nans-rcd . B2de7) (&no-nans-rtd . B2de6) (&no-infinities-rcd . B2de5) (&no-infinities-rtd . B2de4) (&i/o-encoding-rcd . B2de3) (&i/o-encoding-rtd . B2de2) (&i/o-decoding-rcd . B2de1) (&i/o-decoding-rtd . B2de0) (&i/o-port-rcd . B2ddf) (&i/o-port-rtd . B2dde) (&i/o-file-does-not-exist-rcd . B2ddd) (&i/o-file-does-not-exist-rtd . B2ddc) (&i/o-file-already-exists-rcd . B2ddb) (&i/o-file-already-exists-rtd . B2dda) (&i/o-file-is-read-only-rcd . B2dd9) (&i/o-file-is-read-only-rtd . B2dd8) (&i/o-file-protection-rcd . B2dd7) (&i/o-file-protection-rtd . B2dd6) (&i/o-filename-rcd . B2dd5) (&i/o-filename-rtd . B2dd4) (&i/o-invalid-position-rcd . B2dd3) (&i/o-invalid-position-rtd . B2dd2) (&i/o-write-rcd . B2dd1) (&i/o-write-rtd . B2dd0) (&i/o-read-rcd . B2dcf) (&i/o-read-rtd . B2dce) (&i/o-rcd . B2dcd) (&i/o-rtd . B2dcc) (&undefined-rcd . B2dcb) (&undefined-rtd . B2dca) (&syntax-rcd . B2dc9) (&syntax-rtd . B2dc8) (&lexical-rcd . B2dc7) (&lexical-rtd . B2dc6) (&implementation-restriction-rcd . B2dc5) (&implementation-restriction-rtd . B2dc4) (&non-continuable-rcd . B2dc3) (&non-continuable-rtd . B2dc2) (&who-rcd . B2dc1) (&who-rtd . B2dc0) (&irritants-rcd . B2dbf) (&irritants-rtd . B2dbe) (&assertion-rcd . B2dbd) (&assertion-rtd . B2dbc) (&violation-rcd . B2dbb) (&violation-rtd . B2dba) (&error-rcd . B2db9) (&error-rtd . B2db8) (&serious-rcd . B2db7) (&serious-rtd . B2db6) (&warning-rcd . B2db5) (&warning-rtd . B2db4) (&message-rcd . B2db3) (&message-rtd . B2db2) (&condition-rcd . B2db1) (&condition-rtd . B2db0) (syntax-error . Be54) (syntax-dispatch . Bd78) (pretty-print . B2daf) (eval-core . B2dae) (set-symbol-value! . B2dad) (symbol-value . B2dac) (gensym . B2dab) (void . B2daa) (load . B28e1) (interaction-environment . Be66) (char-ready? . B2da9) (regexp? . B2da8) (read-line . B2da7) (gensym-prefix-set! . B2da6) (ungensym . B2da5) (alist->eq-hash-table . B2da4) (assoc-ref . B2da3) (print . B2da2) (format . B2da1) (host-os . B2da0) (library-path . B7b7) (standard-library-path . B2d9f) (monapi-send . B2d9e) (file-newer? . B2d9d) (stat-mtime . B2d9c) (write-to-file . B2d9b) (file->list . B2d9a) (file->string . B2d99) (digit->integer . B2d98) (call-with-string-input-port . B2d97) (call-with-string-io . B2d96) (string-split . B2d95) (bytevector-for-each . B2d94) (string->regexp . B2d93) (rxmatch . B2d92) (regexp-replace-all . B2d91) (hashtable-for-each . B2d90) (mosh-cache-dir . B5a1) (call-process . B2d8f) (local-tz-offset . B2d8e) (microseconds . B2d8d) (directory-list . B2d8c) (set-current-directory! . B2d8b) (expand-path . B2d8a) (current-directory . B2d89) (%spawn . B2d88) (%waitpid . B2d87) (simple-struct-name . B2d86) (simple-struct-set! . B2d85) (simple-struct-ref . B2d84) (make-simple-struct . B2d83) (simple-struct? . B2d82) (pointer-ref-c-int64 . B2d81) (pointer-ref-c-int32 . B2d80) (pointer-ref-c-int16 . B2d7f) (pointer-ref-c-int8 . B2d7e) (pointer-ref-c-uint64 . B2d7d) (pointer-ref-c-uint32 . B2d7c) (pointer-ref-c-uint16 . B2d7b) (pointer-ref-c-uint8 . B2d7a) (pointer-set-c-uint64! . B2d79) (pointer-set-c-uint32! . B2d78) (pointer-set-c-uint16! . B2d77) (pointer-set-c-uint8! . B2d76) (pointer-set-c-int64! . B2d75) (pointer-set-c-int32! . B2d74) (pointer-set-c-int16! . B2d73) (pointer-set-c-int8! . B2d72) (pointer-set-c-pointer! . B2d71) (pointer-set-c-double! . B2d70) (pointer-set-c-float! . B2d6f) (pointer-set-c-long-long! . B2d6e) (pointer-set-c-long! . B2d6d) (pointer-set-c-int! . B2d6c) (pointer-set-c-short! . B2d6b) (pointer-set-c-char! . B2d6a) (pointer-ref-c-pointer . B2d69) (pointer-ref-c-double . B2d68) (pointer-ref-c-float . B2d67) (pointer-ref-c-unsigned-long-long . B2d66) (pointer-ref-c-signed-long-long . B2d65) (pointer-ref-c-unsigned-long . B2d64) (pointer-ref-c-signed-long . B2d63) (pointer-ref-c-unsigned-int . B2d62) (pointer-ref-c-signed-int . B2d61) (pointer-ref-c-unsigned-short . B2d60) (pointer-ref-c-signed-short . B2d5f) (pointer-ref-c-unsigned-char . B2d5e) (pointer-ref-c-signed-char . B2d5d) (pointer->integer . B2d5c) (integer->pointer . B2d5b) (pointer? . B2d5a) (shared-errno . B2d59) (%ffi-free-c-callback-trampoline . B2d58) (%ffi-make-c-callback-trampoline . B2d57) (%ffi-free . B2d56) (%ffi-malloc . B2d55) (%ffi-supported? . B2d54) (%ffi-pointer->string . B2d53) (%ffi-call . B2d52) (%ffi-lookup . B2d51) (%ffi-open . B2d50) (null-terminated-utf8->string . B2d4f) (null-terminated-bytevector->string . B2d4e) (%exec . B2d4d) (%fork . B2d4c) (%pipe . B2d4b) (p . B2d4a) (open-output-string . B2d49) (get-output-string . B2d48) (file-stat-ctime . B2d47) (file-stat-atime . B2d46) (file-stat-mtime . B2d45) (file-size-in-bytes . B2d44) (file-writable? . B2d43) (file-executable? . B2d42) (file-readable? . B2d41) (file-regular? . B2d40) (file-symbolic-link? . B2d3f) (file-directory? . B2d3e) (create-symbolic-link . B2d3d) (rename-file . B2d3c) (delete-directory . B2d3b) (create-directory . B2d3a) (create-mosh-cache-dir . B2d39) (get-environment-variables . B2d38) (current-exception-handler . B2d37) (get-environment-variable . B2d36) (join-wraps . B2d35) (id->real-label . B2d34) (same-marks? . B2d33) (same-marks*? . B2d32) (get-timeofday . B2d31) (get-command-line . B2d30) (sys-display . B2d2f) (whereis . B2d2e) (register . B2d2d) (vm-join! . B2d2c) (vm-set-value! . B2d2b) (vm? . B2d2a) (main-vm? . B2d29) (vm-eval . B2d28) (vm-self . B2d27) (vm-start! . B2d26) (make-vm . B2d25) (mutex-try-lock! . B2d24) (mutex-unlock! . B2d23) (mutex-lock! . B2d22) (mutex? . B2d21) (make-mutex . B2d20) (condition-variable-notify-all! . B2d1f) (condition-variable-notify! . B2d1e) (condition-variable-wait! . B2d1d) (make-condition-variable . B2d1c) (write/ss . B2d1b) (mosh-executable-path . B2d1a) (make-file-options . B2d19) (source-info . B2d18) (make-compiler-instruction . B2d17) (make-instruction . B2d16) (set-source-info! . B2d15) (bignum? . B2d14) (fast-equal? . B2d13) (fasl-read . B2d12) (fasl-write . B2d11) (time-usage . B2d10) (os-constant . B2d0f) (disasm . B2d0e) (make-parameter . B59f) (socket-port . B2d0d) (socket-shutdown . B2d0c) (socket-close . B2d0b) (socket-send . B2d0a) (socket-recv! . B2d09) (socket-recv . B2d08) (make-server-socket . B2d07) (make-client-socket . B2d06) (socket-accept . B2d05) (socket? . B2d04) (string-upcase . B2d03) (string-titlecase . B2d02) (string-normalize-nfkd . B2d01) (string-normalize-nfkc . B2d00) (string-normalize-nfd . B2cff) (string-normalize-nfc . B2cfe) (string-foldcase . B2cfd) (string-downcase . B2cfc) (string-ci>? . B2cfb) (string-ci>=? . B2cfa) (string-ci=? . B2cf9) (string-ci<? . B2cf8) (string-ci<=? . B2cf7) (char-whitespace? . B2cf6) (char-upper-case? . B2cf5) (char-title-case? . B2cf4) (char-numeric? . B2cf3) (char-lower-case? . B2cf2) (char-general-category . B2cf1) (char-upcase . B2cf0) (char-titlecase . B2cef) (char-foldcase . B2cee) (char-downcase . B2ced) (char-ci>? . B2cec) (char-ci>=? . B2ceb) (char-ci=? . B2cea) (char-ci<? . B2ce9) (char-ci<=? . B2ce8) (char-alphabetic? . B2ce7) (make-variable-transformer . Bba3) (identifier? . Be5a) (generate-temporaries . Be46) (free-identifier=? . Be48) (syntax->datum . Be5e) (datum->syntax . Be5c) (bound-identifier=? . Be4a) (record-type-descriptor? . B2ce6) (record-predicate . B2ce5) (record-mutator . B2ce4) (record-constructor . B2ce3) (record-accessor . B2ce2) (make-record-type-descriptor . B2ce1) (make-record-constructor-descriptor . B2ce0) (record? . B2cdf) (record-type-uid . B2cde) (record-type-sealed? . B2cdd) (record-type-parent . B2cdc) (record-type-opaque? . B2cdb) (record-type-name . B2cda) (record-type-generative? . B2cd9) (record-type-field-names . B2cd8) (record-rtd . B2cd7) (record-field-mutable? . B2cd6) (delete-file . B2cd5) (file-exists? . B2cd4) (vector-sort! . B2cd3) (vector-sort . B2cd2) (list-sort . B2cd1) (symbol-hash . B2cd0) (string-ci-hash . B2ccf) (string-hash . B2cce) (equal-hash . B2ccd) (hashtable-equivalence-function . B2ccc) (make-hashtable . B2ccb) (hashtable-hash-function . B2cca) (make-eqv-hashtable . B2cc9) (make-eq-hashtable . B2cc8) (hashtable? . B2cc7) (hashtable-update! . B2cc6) (hashtable-size . B2cc5) (hashtable-set! . B2cc4) (hashtable-ref . B2cc3) (hashtable-mutable? . B2cc2) (hashtable-keys . B2cc1) (hashtable-entries . B2cc0) (hashtable-delete! . B2cbf) (hashtable-copy . B2cbe) (hashtable-contains? . B2cbd) (hashtable-clear! . B2cbc) (call-with-output-file . B2cbb) (call-with-input-file . B2cba) (write-char . B2cb9) (write . B2cb8) (with-output-to-file . B2cb7) (with-input-from-file . B2cb6) (read-char . B2cb5) (read . B2cb4) (peek-char . B2cb3) (open-output-file . B2cb2) (open-input-file . B2cb1) (newline . B2cb0) (display . B2caf) (close-output-port . B2cae) (close-input-port . B2cad) (eof-object? . B2cac) (eof-object . B2cab) (current-error-port . B2caa) (current-output-port . B2ca9) (current-input-port . B2ca8) (output-port? . B2ca7) (input-port? . B2ca6) (utf-8-codec . B2ca5) (utf-16-codec . B2ca4) (transcoder-error-handling-mode . B2ca3) (transcoder-eol-style . B2ca2) (transcoder-codec . B2ca1) (transcoded-port . B2ca0) (textual-port? . B2c9f) (string->bytevector . B2c9e) (standard-output-port . B2c9d) (standard-input-port . B2c9c) (standard-error-port . B2c9b) (set-port-position! . B2c9a) (put-u8 . B2c99) (put-string . B2c98) (put-datum . B2c97) (put-char . B2c96) (put-bytevector . B2c95) (port? . B2c94) (port-transcoder . B2c93) (port-position . B2c92) (port-has-set-port-position!? . B2c91) (port-has-port-position? . B2c90) (port-eof? . B2c8f) (output-port-buffer-mode . B2c8e) (open-string-output-port . B2c8d) (open-string-input-port . B2c8c) (open-file-output-port . B2c8b) (open-file-input/output-port . B2c8a) (open-file-input-port . B2c89) (open-bytevector-output-port . B2c88) (open-bytevector-input-port . B2c87) (native-transcoder . B2c86) (native-eol-style . B2c85) (make-transcoder . B2c84) (latin-1-codec . B2c83) (make-i/o-write-error . B2c82) (make-i/o-read-error . B2c81) (make-i/o-port-error . B2c80) (make-i/o-invalid-position-error . B2c7f) (make-i/o-filename-error . B2c7e) (make-i/o-file-protection-error . B2c7d) (make-i/o-file-is-read-only-error . B2c7c) (make-i/o-file-does-not-exist-error . B2c7b) (make-i/o-file-already-exists-error . B2c7a) (make-i/o-error . B2c79) (make-i/o-encoding-error . B2c78) (make-i/o-decoding-error . B2c77) (make-custom-textual-output-port . B2c76) (make-custom-textual-input/output-port . B2c75) (make-custom-textual-input-port . B2c74) (make-custom-binary-output-port . B2c73) (make-custom-binary-input/output-port . B2c72) (make-custom-binary-input-port . B2c71) (make-bytevector . B2c70) (lookahead-u8 . B2c6f) (lookahead-char . B2c6e) (i/o-write-error? . B2c6d) (i/o-read-error? . B2c6c) (i/o-port-error? . B2c6b) (i/o-invalid-position-error? . B2c6a) (i/o-filename-error? . B2c69) (i/o-file-protection-error? . B2c68) (i/o-file-is-read-only-error? . B2c67) (i/o-file-does-not-exist-error? . B2c66) (i/o-file-already-exists-error? . B2c65) (i/o-error? . B2c64) (i/o-error-position . B2c63) (i/o-error-port . B2c62) (i/o-error-filename . B2c61) (i/o-encoding-error? . B2c60) (i/o-encoding-error-char . B2c5f) (i/o-decoding-error? . B2c5e) (get-u8 . B2c5d) (get-string-n! . B2c5c) (get-string-n . B2c5b) (get-string-all . B2c5a) (get-line . B2c59) (get-datum . B2c58) (get-char . B2c57) (get-bytevector-some . B2c56) (get-bytevector-n! . B2c55) (get-bytevector-n . B2c54) (get-bytevector-all . B2c53) (flush-output-port . B2c52) (close-port . B2c51) (scheme-report-environment . Be34) (quotient . B2c50) (null-environment . Be32) (remainder . B2c4f) (modulo . B2c4e) (inexact->exact . B2c4d) (force . B2c4c) (exact->inexact . B2c4b) (make-promise . B2c4a) (exit . B2c49) (command-line . B28db) (string-fill! . B2c48) (string-set! . B2c47) (set-cdr! . B2c46) (set-car! . B2c45) (remove . B2c44) (remv . B2c43) (remp . B2c42) (remq . B2c41) (partition . B2c40) (memv . B2c3f) (memq . B2c3e) (memp . B2c3d) (member . B2c3c) (exists . B2c3b) (for-all . B2c3a) (fold-right . B2c39) (fold-left . B2c38) (find . B2c37) (filter . B2c36) (cons* . B2c35) (assv . B2c34) (assq . B2c33) (assp . B2c32) (assoc . B2c31) (call-with-string-output-port . B2c30) (call-with-port . B2c2f) (call-with-bytevector-output-port . B2c2e) (bytevector->string . B2c2d) (buffer-mode? . B2c2c) (binary-port? . B2c2b) (with-exception-handler . B2c2a) (raise-continuable . B2c29) (raise . B2c28) (eval . Be38) (environment . Be30) (make-enumeration . B2c27) (enum-set=? . B2c26) (enum-set-universe . B2c25) (enum-set-union . B2c24) (enum-set-subset? . B2c23) (enum-set-projection . B2c22) (enum-set-member? . B2c21) (enum-set-intersection . B2c20) (enum-set-indexer . B2c1f) (enum-set-difference . B2c1e) (enum-set-constructor . B2c1d) (enum-set-complement . B2c1c) (enum-set->list . B2c1b) (who-condition? . B2c1a) (warning? . B2c19) (violation? . B2c18) (undefined-violation? . B2c17) (syntax-violation? . B2c16) (syntax-violation-subform . B2c15) (syntax-violation-form . B2c14) (syntax-violation . Be58) (simple-conditions . B2c13) (serious-condition? . B2c12) (non-continuable-violation? . B2c11) (message-condition? . B2c10) (make-who-condition . B2c0f) (make-warning . B2c0e) (make-violation . B2c0d) (make-undefined-violation . B2c0c) (make-syntax-violation . B2c0b) (make-serious-condition . B2c0a) (make-non-continuable-violation . B2c09) (make-message-condition . B2c08) (make-lexical-violation . B2c07) (make-irritants-condition . B2c06) (make-implementation-restriction-violation . B2c05) (make-error . B2c04) (make-assertion-violation . B2c03) (lexical-violation? . B2c02) (irritants-condition? . B2c01) (implementation-restriction-violation? . B2c00) (error? . B2bff) (condition-who . B2bfe) (condition-predicate . B2bfd) (condition-message . B2bfc) (condition-irritants . B2bfb) (condition-accessor . B2bfa) (condition . B2bf9) (assertion-violation? . B2bf8) (condition? . B2bf7) (utf32->string . B2bf6) (utf16->string . B2bf5) (utf8->string . B2bf4) (uint-list->bytevector . B2bf3) (u8-list->bytevector . B2bf2) (string->utf8 . B2bf1) (string->utf32 . B2bf0) (string->utf16 . B2bef) (sint-list->bytevector . B2bee) (native-endianness . B2bed) (bytevector? . B2bec) (bytevector=? . B2beb) (bytevector-uint-set! . B2bea) (bytevector-uint-ref . B2be9) (bytevector-u8-set! . B2be8) (bytevector-u8-ref . B2be7) (bytevector-u64-set! . B2be6) (bytevector-u64-ref . B2be5) (bytevector-u64-native-set! . B2be4) (bytevector-u64-native-ref . B2be3) (bytevector-u32-set! . B2be2) (bytevector-u32-ref . B2be1) (bytevector-u32-native-set! . B2be0) (bytevector-u32-native-ref . B2bdf) (bytevector-u16-set! . B2bde) (bytevector-u16-ref . B2bdd) (bytevector-u16-native-set! . B2bdc) (bytevector-u16-native-ref . B2bdb) (bytevector-sint-set! . B2bda) (bytevector-sint-ref . B2bd9) (bytevector-s8-set! . B2bd8) (bytevector-s8-ref . B2bd7) (bytevector-s64-set! . B2bd6) (bytevector-s64-ref . B2bd5) (bytevector-s64-native-set! . B2bd4) (bytevector-s64-native-ref . B2bd3) (bytevector-s32-set! . B2bd2) (bytevector-s32-ref . B2bd1) (bytevector-s32-native-set! . B2bd0) (bytevector-s32-native-ref . B2bcf) (bytevector-s16-set! . B2bce) (bytevector-s16-ref . B2bcd) (bytevector-s16-native-set! . B2bcc) (bytevector-s16-native-ref . B2bcb) (bytevector-length . B2bca) (bytevector-ieee-single-ref . B2bc9) (bytevector-ieee-single-set! . B2bc8) (bytevector-ieee-single-native-set! . B2bc7) (bytevector-ieee-single-native-ref . B2bc6) (bytevector-ieee-double-set! . B2bc5) (bytevector-ieee-double-ref . B2bc4) (bytevector-ieee-double-native-set! . B2bc3) (bytevector-ieee-double-native-ref . B2bc2) (bytevector-fill! . B2bc1) (bytevector-copy! . B2bc0) (bytevector-copy . B2bbf) (bytevector->uint-list . B2bbe) (bytevector->u8-list . B2bbd) (bytevector->sint-list . B2bbc) (no-nans-violation? . B2bbb) (no-infinities-violation? . B2bba) (make-no-nans-violation . B2bb9) (make-no-infinities-violation . B2bb8) (real->flonum . B2bb7) (flzero? . B2bb6) (fltruncate . B2bb5) (fltan . B2bb4) (flsqrt . B2bb3) (flsin . B2bb2) (flround . B2bb1) (flpositive? . B2bb0) (flonum? . B2baf) (flodd? . B2bae) (flnumerator . B2bad) (flnegative? . B2bac) (flnan? . B2bab) (flmod0 . B2baa) (flmod . B2ba9) (flmin . B2ba8) (flmax . B2ba7) (fllog . B2ba6) (flinteger? . B2ba5) (flinfinite? . B2ba4) (flfloor . B2ba3) (flfinite? . B2ba2) (flexpt . B2ba1) (flexp . B2ba0) (fleven? . B2b9f) (fldiv0-and-mod0 . B2b9e) (fldiv0 . B2b9d) (fldiv-and-mod . B2b9c) (fldiv . B2b9b) (fldenominator . B2b9a) (flcos . B2b99) (flceiling . B2b98) (flatan . B2b97) (flasin . B2b96) (flacos . B2b95) (flabs . B2b94) (fl>? . B2b93) (fl>=? . B2b92) (fl=? . B2b91) (fl<? . B2b90) (fl<=? . B2b8f) (fl/ . B2b8e) (fl- . B2b8d) (fl+ . B2b8c) (fl* . B2b8b) (fixnum->flonum . B2b8a) (fxzero? . B2b89) (fxxor . B2b88) (fxrotate-bit-field . B2b87) (fxreverse-bit-field . B2b86) (fxpositive? . B2b85) (fxodd? . B2b84) (fxnot . B2b83) (fxnegative? . B2b82) (fxmod0 . B2b81) (fxmod . B2b80) (fxmin . B2b7f) (fxmax . B2b7e) (fxlength . B2b7d) (fxior . B2b7c) (fxif . B2b7b) (fxfirst-bit-set . B2b7a) (fxeven? . B2b79) (fxdiv0-and-mod0 . B2b78) (fxdiv0 . B2b77) (fxdiv-and-mod . B2b76) (fxdiv . B2b75) (fxcopy-bit-field . B2b74) (fxcopy-bit . B2b73) (fxbit-set? . B2b72) (fxbit-field . B2b71) (fxbit-count . B2b70) (fxarithmetic-shift-right . B2b6f) (fxarithmetic-shift-left . B2b6e) (fxarithmetic-shift . B2b6d) (fxand . B2b6c) (fx>? . B2b6b) (fx>=? . B2b6a) (fx=? . B2b69) (fx<? . B2b68) (fx<=? . B2b67) (fx-/carry . B2b66) (fx- . B2b65) (fx+/carry . B2b64) (fx+ . B2b63) (fx*/carry . B2b62) (fx* . B2b61) (greatest-fixnum . B2b60) (least-fixnum . B2b5f) (fixnum-width . B2b5e) (fixnum? . B2b5d) (bitwise-rotate-bit-field . B2b5c) (bitwise-reverse-bit-field . B2b5b) (bitwise-length . B2b5a) (bitwise-if . B2b59) (bitwise-first-bit-set . B2b58) (bitwise-copy-bit-field . B2b57) (bitwise-copy-bit . B2b56) (bitwise-bit-set? . B2b55) (bitwise-bit-field . B2b54) (bitwise-bit-count . B2b53) (bitwise-xor . B2b52) (bitwise-ior . B2b51) (bitwise-and . B2b50) (bitwise-not . B2b4f) (bitwise-arithmetic-shift-right . B2b4e) (bitwise-arithmetic-shift-left . B2b4d) (bitwise-arithmetic-shift . B2b4c) (zero? . B2b4b) (vector? . B2b4a) (vector-set! . B2b49) (vector-ref . B2b48) (vector-map . B2b47) (vector-length . B2b46) (vector-for-each . B2b45) (vector-fill! . B2b44) (vector->list . B2b43) (vector . B2b42) (values . B2b41) (truncate . B2b40) (tan . B2b3f) (symbol? . B2b3e) (symbol=? . B2b3d) (symbol->string . B2b3c) (substring . B2b3b) (string? . B2b3a) (string>? . B2b39) (string>=? . B2b38) (string=? . B2b37) (string<? . B2b36) (string<=? . B2b35) (string-ref . B2b34) (string-length . B2b33) (string-for-each . B2b32) (string-copy . B2b31) (string-append . B2b30) (string->symbol . B2b2f) (string->number . B2b2e) (string->list . B2b2d) (string . B2b2c) (sqrt . B2b2b) (sin . B2b2a) (round . B2b29) (reverse . B2b28) (real? . B2b27) (real-valued? . B2b26) (real-part . B2b25) (rationalize . B2b24) (rational? . B2b23) (rational-valued? . B2b22) (procedure? . B2b21) (positive? . B2b20) (pair? . B2b1f) (odd? . B2b1e) (numerator . B2b1d) (number? . B2b1c) (number->string . B2b1b) (null? . B2b1a) (not . B2b19) (negative? . B2b18) (nan? . B2b17) (min . B2b16) (max . B2b15) (map . B2b14) (make-vector . B2b13) (make-string . B2b12) (make-rectangular . B2b11) (make-polar . B2b10) (magnitude . B2b0f) (log . B2b0e) (list? . B2b0d) (list-tail . B2b0c) (list-ref . B2b0b) (list->vector . B2b0a) (list->string . B2b09) (list . B2b08) (length . B2b07) (lcm . B2b06) (integer? . B2b05) (integer-valued? . B2b04) (integer->char . B2b03) (infinite? . B2b02) (inexact? . B2b01) (inexact . B2b00) (imag-part . B2aff) (gcd . B2afe) (for-each . B2afd) (floor . B2afc) (finite? . B2afb) (expt . B2afa) (exp . B2af9) (exact? . B2af8) (exact-integer-sqrt . B2af7) (exact . B2af6) (even? . B2af5) (error . B2af4) (eqv? . B2af3) (equal? . B2af2) (eq? . B2af1) (dynamic-wind . B2af0) (div0-and-mod0 . B2aef) (mod0 . B2aee) (div0 . B2aed) (div-and-mod . B2aec) (mod . B2aeb) (div . B2aea) (denominator . B2ae9) (cos . B2ae8) (cons . B2ae7) (complex? . B2ae6) (char? . B2ae5) (char>? . B2ae4) (char>=? . B2ae3) (char=? . B2ae2) (char<? . B2ae1) (char<=? . B2ae0) (char->integer . B2adf) (ceiling . B2ade) (call-with-values . B2add) (call/cc . B2adc) (call-with-current-continuation . B2adb) (cddddr . B2ada) (cdddar . B2ad9) (cddadr . B2ad8) (cddaar . B2ad7) (cdaddr . B2ad6) (cdadar . B2ad5) (cdaadr . B2ad4) (cdaaar . B2ad3) (cadddr . B2ad2) (caddar . B2ad1) (cadadr . B2ad0) (cadaar . B2acf) (caaddr . B2ace) (caadar . B2acd) (caaadr . B2acc) (caaaar . B2acb) (cdddr . B2aca) (cddar . B2ac9) (cdadr . B2ac8) (cdaar . B2ac7) (caddr . B2ac6) (cadar . B2ac5) (caadr . B2ac4) (caaar . B2ac3) (cddr . B2ac2) (cdar . B2ac1) (cadr . B2ac0) (caar . B2abf) (cdr . B2abe) (car . B2abd) (boolean? . B2abc) (boolean=? . B2abb) (atan . B2aba) (assertion-violation . B2ab9) (assertion-error . Be52) (asin . B2ab8) (apply . B2ab7) (append . B2ab6) (angle . B2ab5) (acos . B2ab4) (abs . B2ab3) (/ . B2ab2) (* . B2ab1) (- . B2ab0) (+ . B2aaf) (>= . B2aae) (> . B2aad) (= . B2aac) (<= . B2aab) (< . B2aaa) (library . B2aa9) (&no-nans . B2aa8) (&no-infinities . B2aa7) (&i/o-encoding . B2aa6) (&i/o-decoding . B2aa5) (&i/o-port . B2aa4) (&i/o-file-does-not-exist . B2aa3) (&i/o-file-already-exists . B2aa2) (&i/o-file-is-read-only . B2aa1) (&i/o-file-protection . B2aa0) (&i/o-filename . B2a9f) (&i/o-invalid-position . B2a9e) (&i/o-write . B2a9d) (&i/o-read . B2a9c) (&i/o . B2a9b) (&undefined . B2a9a) (&syntax . B2a99) (&lexical . B2a98) (&implementation-restriction . B2a97) (&non-continuable . B2a96) (&who . B2a95) (&irritants . B2a94) (&assertion . B2a93) (&violation . B2a92) (&error . B2a91) (&serious . B2a90) (&warning . B2a8f) (&message . B2a8e) (&condition . B2a8d) (define-condition-type . B2a8c) (define-enumeration . B2a8b) (define-record-type . B2a8a) (parent-rtd . B2a89) (nongenerative . B2a88) (opaque . B2a87) (sealed . B2a86) (protocol . B2a85) (parent . B2a84) (immutable . B2a83) (mutable . B2a82) (fields . B2a81) (error-handling-mode . B2a80) (file-options . B2a7f) (buffer-mode . B2a7e) (eol-style . B2a7d) (guard . B2a7c) (trace-define . B2a7b) (trace-lambda . B2a7a) (unsyntax-splicing . B2a79) (unsyntax . B2a78) (unquote-splicing . B2a77) (unquote . B2a76) (_ . B2a75) (else . B2a74) (=> . B2a73) (... . B2a72) (assert . B2a71) (endianness . B2a70) (delay . B2a6f) (time . B2a6e) (do . B2a6d) (cond . B2a6c) (let* . B2a6b) (let*-values . B2a6a) (let-values . B2a69) (identifier-syntax . B2a68) (with-syntax . B2a67) (quasisyntax . B2a66) (quasiquote . B2a65) (syntax-rules . B2a64) (include . B2a63) (define-struct . B2a62) (record-constructor-descriptor . B2a61) (record-type-descriptor . B2a60) (case . B2a5f) (parameterize . B2a5e) (unless . B2a5d) (when . B2a5c) (or . B2a5b) (and . B2a5a) (if . B2a59) (let . B2a58) (letrec* . B2a57) (letrec . B2a56) (type-descriptor . B2a55) (case-lambda . B2a54) (lambda . B2a53) (syntax . B2a52) (syntax-case . B2a51) (quote . B2a50) (foreign-call . B2a4f) (letrec-syntax . B2a4e) (let-syntax . B2a4d) (set! . B2a4c) (import . B2a4b) (begin . B2a4a) (module . B2a49) (define-syntax . B2a48) (define . B2a47)) '((B2de7 core-prim . &no-nans-rcd) (B2de6 core-prim . &no-nans-rtd) (B2de5 core-prim . &no-infinities-rcd) (B2de4 core-prim . &no-infinities-rtd) (B2de3 core-prim . &i/o-encoding-rcd) (B2de2 core-prim . &i/o-encoding-rtd) (B2de1 core-prim . &i/o-decoding-rcd) (B2de0 core-prim . &i/o-decoding-rtd) (B2ddf core-prim . &i/o-port-rcd) (B2dde core-prim . &i/o-port-rtd) (B2ddd core-prim . &i/o-file-does-not-exist-rcd) (B2ddc core-prim . &i/o-file-does-not-exist-rtd) (B2ddb core-prim . &i/o-file-already-exists-rcd) (B2dda core-prim . &i/o-file-already-exists-rtd) (B2dd9 core-prim . &i/o-file-is-read-only-rcd) (B2dd8 core-prim . &i/o-file-is-read-only-rtd) (B2dd7 core-prim . &i/o-file-protection-rcd) (B2dd6 core-prim . &i/o-file-protection-rtd) (B2dd5 core-prim . &i/o-filename-rcd) (B2dd4 core-prim . &i/o-filename-rtd) (B2dd3 core-prim . &i/o-invalid-position-rcd) (B2dd2 core-prim . &i/o-invalid-position-rtd) (B2dd1 core-prim . &i/o-write-rcd) (B2dd0 core-prim . &i/o-write-rtd) (B2dcf core-prim . &i/o-read-rcd) (B2dce core-prim . &i/o-read-rtd) (B2dcd core-prim . &i/o-rcd) (B2dcc core-prim . &i/o-rtd) (B2dcb core-prim . &undefined-rcd) (B2dca core-prim . &undefined-rtd) (B2dc9 core-prim . &syntax-rcd) (B2dc8 core-prim . &syntax-rtd) (B2dc7 core-prim . &lexical-rcd) (B2dc6 core-prim . &lexical-rtd) (B2dc5 core-prim . &implementation-restriction-rcd) (B2dc4 core-prim . &implementation-restriction-rtd) (B2dc3 core-prim . &non-continuable-rcd) (B2dc2 core-prim . &non-continuable-rtd) (B2dc1 core-prim . &who-rcd) (B2dc0 core-prim . &who-rtd) (B2dbf core-prim . &irritants-rcd) (B2dbe core-prim . &irritants-rtd) (B2dbd core-prim . &assertion-rcd) (B2dbc core-prim . &assertion-rtd) (B2dbb core-prim . &violation-rcd) (B2dba core-prim . &violation-rtd) (B2db9 core-prim . &error-rcd) (B2db8 core-prim . &error-rtd) (B2db7 core-prim . &serious-rcd) (B2db6 core-prim . &serious-rtd) (B2db5 core-prim . &warning-rcd) (B2db4 core-prim . &warning-rtd) (B2db3 core-prim . &message-rcd) (B2db2 core-prim . &message-rtd) (B2db1 core-prim . &condition-rcd) (B2db0 core-prim . &condition-rtd) (Be54 core-prim . syntax-error) (Bd78 core-prim . syntax-dispatch) (B2daf core-prim . pretty-print) (B2dae core-prim . eval-core) (B2dad core-prim . set-symbol-value!) (B2dac core-prim . symbol-value) (B2dab core-prim . gensym) (B2daa core-prim . void) (B28e1 core-prim . load) (Be66 core-prim . interaction-environment) (B2da9 core-prim . char-ready?) (B2da8 core-prim . regexp?) (B2da7 core-prim . read-line) (B2da6 core-prim . gensym-prefix-set!) (B2da5 core-prim . ungensym) (B2da4 core-prim . alist->eq-hash-table) (B2da3 core-prim . assoc-ref) (B2da2 core-prim . print) (B2da1 core-prim . format) (B2da0 core-prim . host-os) (B7b7 core-prim . library-path) (B2d9f core-prim . standard-library-path) (B2d9e core-prim . monapi-send) (B2d9d core-prim . file-newer?) (B2d9c core-prim . stat-mtime) (B2d9b core-prim . write-to-file) (B2d9a core-prim . file->list) (B2d99 core-prim . file->string) (B2d98 core-prim . digit->integer) (B2d97 core-prim . call-with-string-input-port) (B2d96 core-prim . call-with-string-io) (B2d95 core-prim . string-split) (B2d94 core-prim . bytevector-for-each) (B2d93 core-prim . string->regexp) (B2d92 core-prim . rxmatch) (B2d91 core-prim . regexp-replace-all) (B2d90 core-prim . hashtable-for-each) (B5a1 core-prim . mosh-cache-dir) (B2d8f core-prim . call-process) (B2d8e core-prim . local-tz-offset) (B2d8d core-prim . microseconds) (B2d8c core-prim . directory-list) (B2d8b core-prim . set-current-directory!) (B2d8a core-prim . expand-path) (B2d89 core-prim . current-directory) (B2d88 core-prim . %spawn) (B2d87 core-prim . %waitpid) (B2d86 core-prim . simple-struct-name) (B2d85 core-prim . simple-struct-set!) (B2d84 core-prim . simple-struct-ref) (B2d83 core-prim . make-simple-struct) (B2d82 core-prim . simple-struct?) (B2d81 core-prim . pointer-ref-c-int64) (B2d80 core-prim . pointer-ref-c-int32) (B2d7f core-prim . pointer-ref-c-int16) (B2d7e core-prim . pointer-ref-c-int8) (B2d7d core-prim . pointer-ref-c-uint64) (B2d7c core-prim . pointer-ref-c-uint32) (B2d7b core-prim . pointer-ref-c-uint16) (B2d7a core-prim . pointer-ref-c-uint8) (B2d79 core-prim . pointer-set-c-uint64!) (B2d78 core-prim . pointer-set-c-uint32!) (B2d77 core-prim . pointer-set-c-uint16!) (B2d76 core-prim . pointer-set-c-uint8!) (B2d75 core-prim . pointer-set-c-int64!) (B2d74 core-prim . pointer-set-c-int32!) (B2d73 core-prim . pointer-set-c-int16!) (B2d72 core-prim . pointer-set-c-int8!) (B2d71 core-prim . pointer-set-c-pointer!) (B2d70 core-prim . pointer-set-c-double!) (B2d6f core-prim . pointer-set-c-float!) (B2d6e core-prim . pointer-set-c-long-long!) (B2d6d core-prim . pointer-set-c-long!) (B2d6c core-prim . pointer-set-c-int!) (B2d6b core-prim . pointer-set-c-short!) (B2d6a core-prim . pointer-set-c-char!) (B2d69 core-prim . pointer-ref-c-pointer) (B2d68 core-prim . pointer-ref-c-double) (B2d67 core-prim . pointer-ref-c-float) (B2d66 core-prim . pointer-ref-c-unsigned-long-long) (B2d65 core-prim . pointer-ref-c-signed-long-long) (B2d64 core-prim . pointer-ref-c-unsigned-long) (B2d63 core-prim . pointer-ref-c-signed-long) (B2d62 core-prim . pointer-ref-c-unsigned-int) (B2d61 core-prim . pointer-ref-c-signed-int) (B2d60 core-prim . pointer-ref-c-unsigned-short) (B2d5f core-prim . pointer-ref-c-signed-short) (B2d5e core-prim . pointer-ref-c-unsigned-char) (B2d5d core-prim . pointer-ref-c-signed-char) (B2d5c core-prim . pointer->integer) (B2d5b core-prim . integer->pointer) (B2d5a core-prim . pointer?) (B2d59 core-prim . shared-errno) (B2d58 core-prim . %ffi-free-c-callback-trampoline) (B2d57 core-prim . %ffi-make-c-callback-trampoline) (B2d56 core-prim . %ffi-free) (B2d55 core-prim . %ffi-malloc) (B2d54 core-prim . %ffi-supported?) (B2d53 core-prim . %ffi-pointer->string) (B2d52 core-prim . %ffi-call) (B2d51 core-prim . %ffi-lookup) (B2d50 core-prim . %ffi-open) (B2d4f core-prim . null-terminated-utf8->string) (B2d4e core-prim . null-terminated-bytevector->string) (B2d4d core-prim . %exec) (B2d4c core-prim . %fork) (B2d4b core-prim . %pipe) (B2d4a core-prim . p) (B2d49 core-prim . open-output-string) (B2d48 core-prim . get-output-string) (B2d47 core-prim . file-stat-ctime) (B2d46 core-prim . file-stat-atime) (B2d45 core-prim . file-stat-mtime) (B2d44 core-prim . file-size-in-bytes) (B2d43 core-prim . file-writable?) (B2d42 core-prim . file-executable?) (B2d41 core-prim . file-readable?) (B2d40 core-prim . file-regular?) (B2d3f core-prim . file-symbolic-link?) (B2d3e core-prim . file-directory?) (B2d3d core-prim . create-symbolic-link) (B2d3c core-prim . rename-file) (B2d3b core-prim . delete-directory) (B2d3a core-prim . create-directory) (B2d39 core-prim . create-mosh-cache-dir) (B2d38 core-prim . get-environment-variables) (B2d37 core-prim . current-exception-handler) (B2d36 core-prim . get-environment-variable) (B2d35 core-prim . join-wraps) (B2d34 core-prim . id->real-label) (B2d33 core-prim . same-marks?) (B2d32 core-prim . same-marks*?) (B2d31 core-prim . get-timeofday) (B2d30 core-prim . get-command-line) (B2d2f core-prim . sys-display) (B2d2e core-prim . whereis) (B2d2d core-prim . register) (B2d2c core-prim . vm-join!) (B2d2b core-prim . vm-set-value!) (B2d2a core-prim . vm?) (B2d29 core-prim . main-vm?) (B2d28 core-prim . vm-eval) (B2d27 core-prim . vm-self) (B2d26 core-prim . vm-start!) (B2d25 core-prim . make-vm) (B2d24 core-prim . mutex-try-lock!) (B2d23 core-prim . mutex-unlock!) (B2d22 core-prim . mutex-lock!) (B2d21 core-prim . mutex?) (B2d20 core-prim . make-mutex) (B2d1f core-prim . condition-variable-notify-all!) (B2d1e core-prim . condition-variable-notify!) (B2d1d core-prim . condition-variable-wait!) (B2d1c core-prim . make-condition-variable) (B2d1b core-prim . write/ss) (B2d1a core-prim . mosh-executable-path) (B2d19 core-prim . make-file-options) (B2d18 core-prim . source-info) (B2d17 core-prim . make-compiler-instruction) (B2d16 core-prim . make-instruction) (B2d15 core-prim . set-source-info!) (B2d14 core-prim . bignum?) (B2d13 core-prim . fast-equal?) (B2d12 core-prim . fasl-read) (B2d11 core-prim . fasl-write) (B2d10 core-prim . time-usage) (B2d0f core-prim . os-constant) (B2d0e core-prim . disasm) (B59f core-prim . make-parameter) (B2d0d core-prim . socket-port) (B2d0c core-prim . socket-shutdown) (B2d0b core-prim . socket-close) (B2d0a core-prim . socket-send) (B2d09 core-prim . socket-recv!) (B2d08 core-prim . socket-recv) (B2d07 core-prim . make-server-socket) (B2d06 core-prim . make-client-socket) (B2d05 core-prim . socket-accept) (B2d04 core-prim . socket?) (B2d03 core-prim . string-upcase) (B2d02 core-prim . string-titlecase) (B2d01 core-prim . string-normalize-nfkd) (B2d00 core-prim . string-normalize-nfkc) (B2cff core-prim . string-normalize-nfd) (B2cfe core-prim . string-normalize-nfc) (B2cfd core-prim . string-foldcase) (B2cfc core-prim . string-downcase) (B2cfb core-prim . string-ci>?) (B2cfa core-prim . string-ci>=?) (B2cf9 core-prim . string-ci=?) (B2cf8 core-prim . string-ci<?) (B2cf7 core-prim . string-ci<=?) (B2cf6 core-prim . char-whitespace?) (B2cf5 core-prim . char-upper-case?) (B2cf4 core-prim . char-title-case?) (B2cf3 core-prim . char-numeric?) (B2cf2 core-prim . char-lower-case?) (B2cf1 core-prim . char-general-category) (B2cf0 core-prim . char-upcase) (B2cef core-prim . char-titlecase) (B2cee core-prim . char-foldcase) (B2ced core-prim . char-downcase) (B2cec core-prim . char-ci>?) (B2ceb core-prim . char-ci>=?) (B2cea core-prim . char-ci=?) (B2ce9 core-prim . char-ci<?) (B2ce8 core-prim . char-ci<=?) (B2ce7 core-prim . char-alphabetic?) (Bba3 core-prim . make-variable-transformer) (Be5a core-prim . identifier?) (Be46 core-prim . generate-temporaries) (Be48 core-prim . free-identifier=?) (Be5e core-prim . syntax->datum) (Be5c core-prim . datum->syntax) (Be4a core-prim . bound-identifier=?) (B2ce6 core-prim . record-type-descriptor?) (B2ce5 core-prim . record-predicate) (B2ce4 core-prim . record-mutator) (B2ce3 core-prim . record-constructor) (B2ce2 core-prim . record-accessor) (B2ce1 core-prim . make-record-type-descriptor) (B2ce0 core-prim . make-record-constructor-descriptor) (B2cdf core-prim . record?) (B2cde core-prim . record-type-uid) (B2cdd core-prim . record-type-sealed?) (B2cdc core-prim . record-type-parent) (B2cdb core-prim . record-type-opaque?) (B2cda core-prim . record-type-name) (B2cd9 core-prim . record-type-generative?) (B2cd8 core-prim . record-type-field-names) (B2cd7 core-prim . record-rtd) (B2cd6 core-prim . record-field-mutable?) (B2cd5 core-prim . delete-file) (B2cd4 core-prim . file-exists?) (B2cd3 core-prim . vector-sort!) (B2cd2 core-prim . vector-sort) (B2cd1 core-prim . list-sort) (B2cd0 core-prim . symbol-hash) (B2ccf core-prim . string-ci-hash) (B2cce core-prim . string-hash) (B2ccd core-prim . equal-hash) (B2ccc core-prim . hashtable-equivalence-function) (B2ccb core-prim . make-hashtable) (B2cca core-prim . hashtable-hash-function) (B2cc9 core-prim . make-eqv-hashtable) (B2cc8 core-prim . make-eq-hashtable) (B2cc7 core-prim . hashtable?) (B2cc6 core-prim . hashtable-update!) (B2cc5 core-prim . hashtable-size) (B2cc4 core-prim . hashtable-set!) (B2cc3 core-prim . hashtable-ref) (B2cc2 core-prim . hashtable-mutable?) (B2cc1 core-prim . hashtable-keys) (B2cc0 core-prim . hashtable-entries) (B2cbf core-prim . hashtable-delete!) (B2cbe core-prim . hashtable-copy) (B2cbd core-prim . hashtable-contains?) (B2cbc core-prim . hashtable-clear!) (B2cbb core-prim . call-with-output-file) (B2cba core-prim . call-with-input-file) (B2cb9 core-prim . write-char) (B2cb8 core-prim . write) (B2cb7 core-prim . with-output-to-file) (B2cb6 core-prim . with-input-from-file) (B2cb5 core-prim . read-char) (B2cb4 core-prim . read) (B2cb3 core-prim . peek-char) (B2cb2 core-prim . open-output-file) (B2cb1 core-prim . open-input-file) (B2cb0 core-prim . newline) (B2caf core-prim . display) (B2cae core-prim . close-output-port) (B2cad core-prim . close-input-port) (B2cac core-prim . eof-object?) (B2cab core-prim . eof-object) (B2caa core-prim . current-error-port) (B2ca9 core-prim . current-output-port) (B2ca8 core-prim . current-input-port) (B2ca7 core-prim . output-port?) (B2ca6 core-prim . input-port?) (B2ca5 core-prim . utf-8-codec) (B2ca4 core-prim . utf-16-codec) (B2ca3 core-prim . transcoder-error-handling-mode) (B2ca2 core-prim . transcoder-eol-style) (B2ca1 core-prim . transcoder-codec) (B2ca0 core-prim . transcoded-port) (B2c9f core-prim . textual-port?) (B2c9e core-prim . string->bytevector) (B2c9d core-prim . standard-output-port) (B2c9c core-prim . standard-input-port) (B2c9b core-prim . standard-error-port) (B2c9a core-prim . set-port-position!) (B2c99 core-prim . put-u8) (B2c98 core-prim . put-string) (B2c97 core-prim . put-datum) (B2c96 core-prim . put-char) (B2c95 core-prim . put-bytevector) (B2c94 core-prim . port?) (B2c93 core-prim . port-transcoder) (B2c92 core-prim . port-position) (B2c91 core-prim . port-has-set-port-position!?) (B2c90 core-prim . port-has-port-position?) (B2c8f core-prim . port-eof?) (B2c8e core-prim . output-port-buffer-mode) (B2c8d core-prim . open-string-output-port) (B2c8c core-prim . open-string-input-port) (B2c8b core-prim . open-file-output-port) (B2c8a core-prim . open-file-input/output-port) (B2c89 core-prim . open-file-input-port) (B2c88 core-prim . open-bytevector-output-port) (B2c87 core-prim . open-bytevector-input-port) (B2c86 core-prim . native-transcoder) (B2c85 core-prim . native-eol-style) (B2c84 core-prim . make-transcoder) (B2c83 core-prim . latin-1-codec) (B2c82 core-prim . make-i/o-write-error) (B2c81 core-prim . make-i/o-read-error) (B2c80 core-prim . make-i/o-port-error) (B2c7f core-prim . make-i/o-invalid-position-error) (B2c7e core-prim . make-i/o-filename-error) (B2c7d core-prim . make-i/o-file-protection-error) (B2c7c core-prim . make-i/o-file-is-read-only-error) (B2c7b core-prim . make-i/o-file-does-not-exist-error) (B2c7a core-prim . make-i/o-file-already-exists-error) (B2c79 core-prim . make-i/o-error) (B2c78 core-prim . make-i/o-encoding-error) (B2c77 core-prim . make-i/o-decoding-error) (B2c76 core-prim . make-custom-textual-output-port) (B2c75 core-prim . make-custom-textual-input/output-port) (B2c74 core-prim . make-custom-textual-input-port) (B2c73 core-prim . make-custom-binary-output-port) (B2c72 core-prim . make-custom-binary-input/output-port) (B2c71 core-prim . make-custom-binary-input-port) (B2c70 core-prim . make-bytevector) (B2c6f core-prim . lookahead-u8) (B2c6e core-prim . lookahead-char) (B2c6d core-prim . i/o-write-error?) (B2c6c core-prim . i/o-read-error?) (B2c6b core-prim . i/o-port-error?) (B2c6a core-prim . i/o-invalid-position-error?) (B2c69 core-prim . i/o-filename-error?) (B2c68 core-prim . i/o-file-protection-error?) (B2c67 core-prim . i/o-file-is-read-only-error?) (B2c66 core-prim . i/o-file-does-not-exist-error?) (B2c65 core-prim . i/o-file-already-exists-error?) (B2c64 core-prim . i/o-error?) (B2c63 core-prim . i/o-error-position) (B2c62 core-prim . i/o-error-port) (B2c61 core-prim . i/o-error-filename) (B2c60 core-prim . i/o-encoding-error?) (B2c5f core-prim . i/o-encoding-error-char) (B2c5e core-prim . i/o-decoding-error?) (B2c5d core-prim . get-u8) (B2c5c core-prim . get-string-n!) (B2c5b core-prim . get-string-n) (B2c5a core-prim . get-string-all) (B2c59 core-prim . get-line) (B2c58 core-prim . get-datum) (B2c57 core-prim . get-char) (B2c56 core-prim . get-bytevector-some) (B2c55 core-prim . get-bytevector-n!) (B2c54 core-prim . get-bytevector-n) (B2c53 core-prim . get-bytevector-all) (B2c52 core-prim . flush-output-port) (B2c51 core-prim . close-port) (Be34 core-prim . scheme-report-environment) (B2c50 core-prim . quotient) (Be32 core-prim . null-environment) (B2c4f core-prim . remainder) (B2c4e core-prim . modulo) (B2c4d core-prim . inexact->exact) (B2c4c core-prim . force) (B2c4b core-prim . exact->inexact) (B2c4a core-prim . make-promise) (B2c49 core-prim . exit) (B28db core-prim . command-line) (B2c48 core-prim . string-fill!) (B2c47 core-prim . string-set!) (B2c46 core-prim . set-cdr!) (B2c45 core-prim . set-car!) (B2c44 core-prim . remove) (B2c43 core-prim . remv) (B2c42 core-prim . remp) (B2c41 core-prim . remq) (B2c40 core-prim . partition) (B2c3f core-prim . memv) (B2c3e core-prim . memq) (B2c3d core-prim . memp) (B2c3c core-prim . member) (B2c3b core-prim . exists) (B2c3a core-prim . for-all) (B2c39 core-prim . fold-right) (B2c38 core-prim . fold-left) (B2c37 core-prim . find) (B2c36 core-prim . filter) (B2c35 core-prim . cons*) (B2c34 core-prim . assv) (B2c33 core-prim . assq) (B2c32 core-prim . assp) (B2c31 core-prim . assoc) (B2c30 core-prim . call-with-string-output-port) (B2c2f core-prim . call-with-port) (B2c2e core-prim . call-with-bytevector-output-port) (B2c2d core-prim . bytevector->string) (B2c2c core-prim . buffer-mode?) (B2c2b core-prim . binary-port?) (B2c2a core-prim . with-exception-handler) (B2c29 core-prim . raise-continuable) (B2c28 core-prim . raise) (Be38 core-prim . eval) (Be30 core-prim . environment) (B2c27 core-prim . make-enumeration) (B2c26 core-prim . enum-set=?) (B2c25 core-prim . enum-set-universe) (B2c24 core-prim . enum-set-union) (B2c23 core-prim . enum-set-subset?) (B2c22 core-prim . enum-set-projection) (B2c21 core-prim . enum-set-member?) (B2c20 core-prim . enum-set-intersection) (B2c1f core-prim . enum-set-indexer) (B2c1e core-prim . enum-set-difference) (B2c1d core-prim . enum-set-constructor) (B2c1c core-prim . enum-set-complement) (B2c1b core-prim . enum-set->list) (B2c1a core-prim . who-condition?) (B2c19 core-prim . warning?) (B2c18 core-prim . violation?) (B2c17 core-prim . undefined-violation?) (B2c16 core-prim . syntax-violation?) (B2c15 core-prim . syntax-violation-subform) (B2c14 core-prim . syntax-violation-form) (Be58 core-prim . syntax-violation) (B2c13 core-prim . simple-conditions) (B2c12 core-prim . serious-condition?) (B2c11 core-prim . non-continuable-violation?) (B2c10 core-prim . message-condition?) (B2c0f core-prim . make-who-condition) (B2c0e core-prim . make-warning) (B2c0d core-prim . make-violation) (B2c0c core-prim . make-undefined-violation) (B2c0b core-prim . make-syntax-violation) (B2c0a core-prim . make-serious-condition) (B2c09 core-prim . make-non-continuable-violation) (B2c08 core-prim . make-message-condition) (B2c07 core-prim . make-lexical-violation) (B2c06 core-prim . make-irritants-condition) (B2c05 core-prim . make-implementation-restriction-violation) (B2c04 core-prim . make-error) (B2c03 core-prim . make-assertion-violation) (B2c02 core-prim . lexical-violation?) (B2c01 core-prim . irritants-condition?) (B2c00 core-prim . implementation-restriction-violation?) (B2bff core-prim . error?) (B2bfe core-prim . condition-who) (B2bfd core-prim . condition-predicate) (B2bfc core-prim . condition-message) (B2bfb core-prim . condition-irritants) (B2bfa core-prim . condition-accessor) (B2bf9 core-prim . condition) (B2bf8 core-prim . assertion-violation?) (B2bf7 core-prim . condition?) (B2bf6 core-prim . utf32->string) (B2bf5 core-prim . utf16->string) (B2bf4 core-prim . utf8->string) (B2bf3 core-prim . uint-list->bytevector) (B2bf2 core-prim . u8-list->bytevector) (B2bf1 core-prim . string->utf8) (B2bf0 core-prim . string->utf32) (B2bef core-prim . string->utf16) (B2bee core-prim . sint-list->bytevector) (B2bed core-prim . native-endianness) (B2bec core-prim . bytevector?) (B2beb core-prim . bytevector=?) (B2bea core-prim . bytevector-uint-set!) (B2be9 core-prim . bytevector-uint-ref) (B2be8 core-prim . bytevector-u8-set!) (B2be7 core-prim . bytevector-u8-ref) (B2be6 core-prim . bytevector-u64-set!) (B2be5 core-prim . bytevector-u64-ref) (B2be4 core-prim . bytevector-u64-native-set!) (B2be3 core-prim . bytevector-u64-native-ref) (B2be2 core-prim . bytevector-u32-set!) (B2be1 core-prim . bytevector-u32-ref) (B2be0 core-prim . bytevector-u32-native-set!) (B2bdf core-prim . bytevector-u32-native-ref) (B2bde core-prim . bytevector-u16-set!) (B2bdd core-prim . bytevector-u16-ref) (B2bdc core-prim . bytevector-u16-native-set!) (B2bdb core-prim . bytevector-u16-native-ref) (B2bda core-prim . bytevector-sint-set!) (B2bd9 core-prim . bytevector-sint-ref) (B2bd8 core-prim . bytevector-s8-set!) (B2bd7 core-prim . bytevector-s8-ref) (B2bd6 core-prim . bytevector-s64-set!) (B2bd5 core-prim . bytevector-s64-ref) (B2bd4 core-prim . bytevector-s64-native-set!) (B2bd3 core-prim . bytevector-s64-native-ref) (B2bd2 core-prim . bytevector-s32-set!) (B2bd1 core-prim . bytevector-s32-ref) (B2bd0 core-prim . bytevector-s32-native-set!) (B2bcf core-prim . bytevector-s32-native-ref) (B2bce core-prim . bytevector-s16-set!) (B2bcd core-prim . bytevector-s16-ref) (B2bcc core-prim . bytevector-s16-native-set!) (B2bcb core-prim . bytevector-s16-native-ref) (B2bca core-prim . bytevector-length) (B2bc9 core-prim . bytevector-ieee-single-ref) (B2bc8 core-prim . bytevector-ieee-single-set!) (B2bc7 core-prim . bytevector-ieee-single-native-set!) (B2bc6 core-prim . bytevector-ieee-single-native-ref) (B2bc5 core-prim . bytevector-ieee-double-set!) (B2bc4 core-prim . bytevector-ieee-double-ref) (B2bc3 core-prim . bytevector-ieee-double-native-set!) (B2bc2 core-prim . bytevector-ieee-double-native-ref) (B2bc1 core-prim . bytevector-fill!) (B2bc0 core-prim . bytevector-copy!) (B2bbf core-prim . bytevector-copy) (B2bbe core-prim . bytevector->uint-list) (B2bbd core-prim . bytevector->u8-list) (B2bbc core-prim . bytevector->sint-list) (B2bbb core-prim . no-nans-violation?) (B2bba core-prim . no-infinities-violation?) (B2bb9 core-prim . make-no-nans-violation) (B2bb8 core-prim . make-no-infinities-violation) (B2bb7 core-prim . real->flonum) (B2bb6 core-prim . flzero?) (B2bb5 core-prim . fltruncate) (B2bb4 core-prim . fltan) (B2bb3 core-prim . flsqrt) (B2bb2 core-prim . flsin) (B2bb1 core-prim . flround) (B2bb0 core-prim . flpositive?) (B2baf core-prim . flonum?) (B2bae core-prim . flodd?) (B2bad core-prim . flnumerator) (B2bac core-prim . flnegative?) (B2bab core-prim . flnan?) (B2baa core-prim . flmod0) (B2ba9 core-prim . flmod) (B2ba8 core-prim . flmin) (B2ba7 core-prim . flmax) (B2ba6 core-prim . fllog) (B2ba5 core-prim . flinteger?) (B2ba4 core-prim . flinfinite?) (B2ba3 core-prim . flfloor) (B2ba2 core-prim . flfinite?) (B2ba1 core-prim . flexpt) (B2ba0 core-prim . flexp) (B2b9f core-prim . fleven?) (B2b9e core-prim . fldiv0-and-mod0) (B2b9d core-prim . fldiv0) (B2b9c core-prim . fldiv-and-mod) (B2b9b core-prim . fldiv) (B2b9a core-prim . fldenominator) (B2b99 core-prim . flcos) (B2b98 core-prim . flceiling) (B2b97 core-prim . flatan) (B2b96 core-prim . flasin) (B2b95 core-prim . flacos) (B2b94 core-prim . flabs) (B2b93 core-prim . fl>?) (B2b92 core-prim . fl>=?) (B2b91 core-prim . fl=?) (B2b90 core-prim . fl<?) (B2b8f core-prim . fl<=?) (B2b8e core-prim . fl/) (B2b8d core-prim . fl-) (B2b8c core-prim . fl+) (B2b8b core-prim . fl*) (B2b8a core-prim . fixnum->flonum) (B2b89 core-prim . fxzero?) (B2b88 core-prim . fxxor) (B2b87 core-prim . fxrotate-bit-field) (B2b86 core-prim . fxreverse-bit-field) (B2b85 core-prim . fxpositive?) (B2b84 core-prim . fxodd?) (B2b83 core-prim . fxnot) (B2b82 core-prim . fxnegative?) (B2b81 core-prim . fxmod0) (B2b80 core-prim . fxmod) (B2b7f core-prim . fxmin) (B2b7e core-prim . fxmax) (B2b7d core-prim . fxlength) (B2b7c core-prim . fxior) (B2b7b core-prim . fxif) (B2b7a core-prim . fxfirst-bit-set) (B2b79 core-prim . fxeven?) (B2b78 core-prim . fxdiv0-and-mod0) (B2b77 core-prim . fxdiv0) (B2b76 core-prim . fxdiv-and-mod) (B2b75 core-prim . fxdiv) (B2b74 core-prim . fxcopy-bit-field) (B2b73 core-prim . fxcopy-bit) (B2b72 core-prim . fxbit-set?) (B2b71 core-prim . fxbit-field) (B2b70 core-prim . fxbit-count) (B2b6f core-prim . fxarithmetic-shift-right) (B2b6e core-prim . fxarithmetic-shift-left) (B2b6d core-prim . fxarithmetic-shift) (B2b6c core-prim . fxand) (B2b6b core-prim . fx>?) (B2b6a core-prim . fx>=?) (B2b69 core-prim . fx=?) (B2b68 core-prim . fx<?) (B2b67 core-prim . fx<=?) (B2b66 core-prim . fx-/carry) (B2b65 core-prim . fx-) (B2b64 core-prim . fx+/carry) (B2b63 core-prim . fx+) (B2b62 core-prim . fx*/carry) (B2b61 core-prim . fx*) (B2b60 core-prim . greatest-fixnum) (B2b5f core-prim . least-fixnum) (B2b5e core-prim . fixnum-width) (B2b5d core-prim . fixnum?) (B2b5c core-prim . bitwise-rotate-bit-field) (B2b5b core-prim . bitwise-reverse-bit-field) (B2b5a core-prim . bitwise-length) (B2b59 core-prim . bitwise-if) (B2b58 core-prim . bitwise-first-bit-set) (B2b57 core-prim . bitwise-copy-bit-field) (B2b56 core-prim . bitwise-copy-bit) (B2b55 core-prim . bitwise-bit-set?) (B2b54 core-prim . bitwise-bit-field) (B2b53 core-prim . bitwise-bit-count) (B2b52 core-prim . bitwise-xor) (B2b51 core-prim . bitwise-ior) (B2b50 core-prim . bitwise-and) (B2b4f core-prim . bitwise-not) (B2b4e core-prim . bitwise-arithmetic-shift-right) (B2b4d core-prim . bitwise-arithmetic-shift-left) (B2b4c core-prim . bitwise-arithmetic-shift) (B2b4b core-prim . zero?) (B2b4a core-prim . vector?) (B2b49 core-prim . vector-set!) (B2b48 core-prim . vector-ref) (B2b47 core-prim . vector-map) (B2b46 core-prim . vector-length) (B2b45 core-prim . vector-for-each) (B2b44 core-prim . vector-fill!) (B2b43 core-prim . vector->list) (B2b42 core-prim . vector) (B2b41 core-prim . values) (B2b40 core-prim . truncate) (B2b3f core-prim . tan) (B2b3e core-prim . symbol?) (B2b3d core-prim . symbol=?) (B2b3c core-prim . symbol->string) (B2b3b core-prim . substring) (B2b3a core-prim . string?) (B2b39 core-prim . string>?) (B2b38 core-prim . string>=?) (B2b37 core-prim . string=?) (B2b36 core-prim . string<?) (B2b35 core-prim . string<=?) (B2b34 core-prim . string-ref) (B2b33 core-prim . string-length) (B2b32 core-prim . string-for-each) (B2b31 core-prim . string-copy) (B2b30 core-prim . string-append) (B2b2f core-prim . string->symbol) (B2b2e core-prim . string->number) (B2b2d core-prim . string->list) (B2b2c core-prim . string) (B2b2b core-prim . sqrt) (B2b2a core-prim . sin) (B2b29 core-prim . round) (B2b28 core-prim . reverse) (B2b27 core-prim . real?) (B2b26 core-prim . real-valued?) (B2b25 core-prim . real-part) (B2b24 core-prim . rationalize) (B2b23 core-prim . rational?) (B2b22 core-prim . rational-valued?) (B2b21 core-prim . procedure?) (B2b20 core-prim . positive?) (B2b1f core-prim . pair?) (B2b1e core-prim . odd?) (B2b1d core-prim . numerator) (B2b1c core-prim . number?) (B2b1b core-prim . number->string) (B2b1a core-prim . null?) (B2b19 core-prim . not) (B2b18 core-prim . negative?) (B2b17 core-prim . nan?) (B2b16 core-prim . min) (B2b15 core-prim . max) (B2b14 core-prim . map) (B2b13 core-prim . make-vector) (B2b12 core-prim . make-string) (B2b11 core-prim . make-rectangular) (B2b10 core-prim . make-polar) (B2b0f core-prim . magnitude) (B2b0e core-prim . log) (B2b0d core-prim . list?) (B2b0c core-prim . list-tail) (B2b0b core-prim . list-ref) (B2b0a core-prim . list->vector) (B2b09 core-prim . list->string) (B2b08 core-prim . list) (B2b07 core-prim . length) (B2b06 core-prim . lcm) (B2b05 core-prim . integer?) (B2b04 core-prim . integer-valued?) (B2b03 core-prim . integer->char) (B2b02 core-prim . infinite?) (B2b01 core-prim . inexact?) (B2b00 core-prim . inexact) (B2aff core-prim . imag-part) (B2afe core-prim . gcd) (B2afd core-prim . for-each) (B2afc core-prim . floor) (B2afb core-prim . finite?) (B2afa core-prim . expt) (B2af9 core-prim . exp) (B2af8 core-prim . exact?) (B2af7 core-prim . exact-integer-sqrt) (B2af6 core-prim . exact) (B2af5 core-prim . even?) (B2af4 core-prim . error) (B2af3 core-prim . eqv?) (B2af2 core-prim . equal?) (B2af1 core-prim . eq?) (B2af0 core-prim . dynamic-wind) (B2aef core-prim . div0-and-mod0) (B2aee core-prim . mod0) (B2aed core-prim . div0) (B2aec core-prim . div-and-mod) (B2aeb core-prim . mod) (B2aea core-prim . div) (B2ae9 core-prim . denominator) (B2ae8 core-prim . cos) (B2ae7 core-prim . cons) (B2ae6 core-prim . complex?) (B2ae5 core-prim . char?) (B2ae4 core-prim . char>?) (B2ae3 core-prim . char>=?) (B2ae2 core-prim . char=?) (B2ae1 core-prim . char<?) (B2ae0 core-prim . char<=?) (B2adf core-prim . char->integer) (B2ade core-prim . ceiling) (B2add core-prim . call-with-values) (B2adc core-prim . call/cc) (B2adb core-prim . call-with-current-continuation) (B2ada core-prim . cddddr) (B2ad9 core-prim . cdddar) (B2ad8 core-prim . cddadr) (B2ad7 core-prim . cddaar) (B2ad6 core-prim . cdaddr) (B2ad5 core-prim . cdadar) (B2ad4 core-prim . cdaadr) (B2ad3 core-prim . cdaaar) (B2ad2 core-prim . cadddr) (B2ad1 core-prim . caddar) (B2ad0 core-prim . cadadr) (B2acf core-prim . cadaar) (B2ace core-prim . caaddr) (B2acd core-prim . caadar) (B2acc core-prim . caaadr) (B2acb core-prim . caaaar) (B2aca core-prim . cdddr) (B2ac9 core-prim . cddar) (B2ac8 core-prim . cdadr) (B2ac7 core-prim . cdaar) (B2ac6 core-prim . caddr) (B2ac5 core-prim . cadar) (B2ac4 core-prim . caadr) (B2ac3 core-prim . caaar) (B2ac2 core-prim . cddr) (B2ac1 core-prim . cdar) (B2ac0 core-prim . cadr) (B2abf core-prim . caar) (B2abe core-prim . cdr) (B2abd core-prim . car) (B2abc core-prim . boolean?) (B2abb core-prim . boolean=?) (B2aba core-prim . atan) (B2ab9 core-prim . assertion-violation) (Be52 core-prim . assertion-error) (B2ab8 core-prim . asin) (B2ab7 core-prim . apply) (B2ab6 core-prim . append) (B2ab5 core-prim . angle) (B2ab4 core-prim . acos) (B2ab3 core-prim . abs) (B2ab2 core-prim . /) (B2ab1 core-prim . *) (B2ab0 core-prim . -) (B2aaf core-prim . +) (B2aae core-prim . >=) (B2aad core-prim . >) (B2aac core-prim . =) (B2aab core-prim . <=) (B2aaa core-prim . <) (B2aa9 core-prim . library) (B2aa8 $core-rtd &no-nans-rtd &no-nans-rcd) (B2aa7 $core-rtd &no-infinities-rtd &no-infinities-rcd) (B2aa6 $core-rtd &i/o-encoding-rtd &i/o-encoding-rcd) (B2aa5 $core-rtd &i/o-decoding-rtd &i/o-decoding-rcd) (B2aa4 $core-rtd &i/o-port-rtd &i/o-port-rcd) (B2aa3 $core-rtd &i/o-file-does-not-exist-rtd &i/o-file-does-not-exist-rcd) (B2aa2 $core-rtd &i/o-file-already-exists-rtd &i/o-file-already-exists-rcd) (B2aa1 $core-rtd &i/o-file-is-read-only-rtd &i/o-fie-is-read-only-rcd) (B2aa0 $core-rtd &i/o-file-protection-rtd &i/o-file-protection-rcd) (B2a9f $core-rtd &i/o-filename-rtd &i/o-filename-rcd) (B2a9e $core-rtd &i/o-invalid-position-rtd &i/o-invalid-position-rcd) (B2a9d $core-rtd &i/o-write-rtd &i/o-write-rcd) (B2a9c $core-rtd &i/o-read-rtd &i/o-read-rcd) (B2a9b $core-rtd &i/o-rtd &i/o-rcd) (B2a9a $core-rtd &undefined-rtd &undefined-rcd) (B2a99 $core-rtd &syntax-rtd &syntax-rcd) (B2a98 $core-rtd &lexical-rtd &lexical-rcd) (B2a97 $core-rtd &implementation-restriction-rtd &implementation-restriction-rcd) (B2a96 $core-rtd &non-continuable-rtd &non-continuable-rcd) (B2a95 $core-rtd &who-rtd &who-rcd) (B2a94 $core-rtd &irritants-rtd &irritants-rcd) (B2a93 $core-rtd &assertion-rtd &assertion-rcd) (B2a92 $core-rtd &violation-rtd &violation-rcd) (B2a91 $core-rtd &error-rtd &error-rcd) (B2a90 $core-rtd &serious-rtd &serious-rcd) (B2a8f $core-rtd &warning-rtd &warning-rcd) (B2a8e $core-rtd &message-rtd &message-rcd) (B2a8d $core-rtd &condition-rtd &condition-rcd) (B2a8c macro . define-condition-type) (B2a8b macro . define-enumeration) (B2a8a macro . define-record-type) (B2a89 macro . parent-rtd) (B2a88 macro . nongenerative) (B2a87 macro . opaque) (B2a86 macro . sealed) (B2a85 macro . protocol) (B2a84 macro . parent) (B2a83 macro . immutable) (B2a82 macro . mutable) (B2a81 macro . fields) (B2a80 macro . error-handling-mode) (B2a7f macro . file-options) (B2a7e macro . buffer-mode) (B2a7d macro . eol-style) (B2a7c macro . guard) (B2a7b macro . trace-define) (B2a7a macro . trace-lambda) (B2a79 macro . unsyntax-splicing) (B2a78 macro . unsyntax) (B2a77 macro . unquote-splicing) (B2a76 macro . unquote) (B2a75 macro . _) (B2a74 macro . else) (B2a73 macro . =>) (B2a72 macro . ...) (B2a71 macro . assert) (B2a70 macro . endianness) (B2a6f macro . delay) (B2a6e macro . time) (B2a6d macro . do) (B2a6c macro . cond) (B2a6b macro . let*) (B2a6a macro . let*-values) (B2a69 macro . let-values) (B2a68 macro . identifier-syntax) (B2a67 macro . with-syntax) (B2a66 macro . quasisyntax) (B2a65 macro . quasiquote) (B2a64 macro . syntax-rules) (B2a63 macro . include) (B2a62 macro . define-struct) (B2a61 core-macro . record-constructor-descriptor) (B2a60 core-macro . record-type-descriptor) (B2a5f macro . case) (B2a5e macro . parameterize) (B2a5d macro . unless) (B2a5c macro . when) (B2a5b core-macro . or) (B2a5a core-macro . and) (B2a59 core-macro . if) (B2a58 core-macro . let) (B2a57 core-macro . letrec*) (B2a56 core-macro . letrec) (B2a55 core-macro . type-descriptor) (B2a54 core-macro . case-lambda) (B2a53 core-macro . lambda) (B2a52 core-macro . syntax) (B2a51 core-macro . syntax-case) (B2a50 core-macro . quote) (B2a4f core-macro . foreign-call) (B2a4e letrec-syntax) (B2a4d let-syntax) (B2a4c set!) (B2a4b import) (B2a4a begin) (B2a49 module) (B2a48 define-syntax) (B2a47 define)) values values '#f '#f '#f '#f) (B98c@B7d8@install-library 'B2e08 '(psyntax system $bootstrap) '() '() '() '() '((pretty-print . B2daf) (eval-core . B2dae) (set-symbol-value! . B2dad) (symbol-value . B2dac) (gensym . B2dab) (void . B2daa)) '() values values '#f '#f '#f '#f) (B98c@B7d8@install-library 'B2e09 '(mosh) '() '() '() '() '((set-symbol-value! . B2dad) (symbol-value . B2dac) (regexp? . B2da8) (read-line . B2da7) (ungensym . B2da5) (alist->eq-hash-table . B2da4) (assoc-ref . B2da3) (print . B2da2) (format . B2da1) (host-os . B2da0) (library-path . B7b7) (standard-library-path . B2d9f) (monapi-send . B2d9e) (file-newer? . B2d9d) (stat-mtime . B2d9c) (digit->integer . B2d98) (call-with-string-input-port . B2d97) (call-with-string-io . B2d96) (string-split . B2d95) (bytevector-for-each . B2d94) (string->regexp . B2d93) (rxmatch . B2d92) (regexp-replace-all . B2d91) (hashtable-for-each . B2d90) (set-current-directory! . B2d8b) (expand-path . B2d8a) (current-directory . B2d89) (p . B2d4a) (get-timeofday . B2d31) (get-command-line . B2d30) (sys-display . B2d2f) (whereis . B2d2e) (register . B2d2d) (vm-join! . B2d2c) (vm-set-value! . B2d2b) (vm? . B2d2a) (main-vm? . B2d29) (vm-eval . B2d28) (vm-self . B2d27) (vm-start! . B2d26) (make-vm . B2d25) (mutex-try-lock! . B2d24) (mutex-unlock! . B2d23) (mutex-lock! . B2d22) (mutex? . B2d21) (make-mutex . B2d20) (condition-variable-notify-all! . B2d1f) (condition-variable-notify! . B2d1e) (condition-variable-wait! . B2d1d) (make-condition-variable . B2d1c) (write/ss . B2d1b) (mosh-executable-path . B2d1a) (make-file-options . B2d19) (source-info . B2d18) (make-compiler-instruction . B2d17) (make-instruction . B2d16) (set-source-info! . B2d15) (bignum? . B2d14) (fast-equal? . B2d13) (fasl-read . B2d12) (fasl-write . B2d11) (time-usage . B2d10) (os-constant . B2d0f) (time . B2a6e) (include . B2a63)) '() values values '#f '#f '#f '#f) (B98c@B7d8@install-library 'B2e0a '(system) '() '() '() '() '((gensym-prefix-set! . B2da6) (write-to-file . B2d9b) (file->list . B2d9a) (file->string . B2d99) (mosh-cache-dir . B5a1) (call-process . B2d8f) (local-tz-offset . B2d8e) (microseconds . B2d8d) (directory-list . B2d8c) (expand-path . B2d8a) (%spawn . B2d88) (%waitpid . B2d87) (simple-struct-name . B2d86) (simple-struct-set! . B2d85) (simple-struct-ref . B2d84) (make-simple-struct . B2d83) (simple-struct? . B2d82) (pointer-ref-c-int64 . B2d81) (pointer-ref-c-int32 . B2d80) (pointer-ref-c-int16 . B2d7f) (pointer-ref-c-int8 . B2d7e) (pointer-ref-c-uint64 . B2d7d) (pointer-ref-c-uint32 . B2d7c) (pointer-ref-c-uint16 . B2d7b) (pointer-ref-c-uint8 . B2d7a) (pointer-set-c-uint64! . B2d79) (pointer-set-c-uint32! . B2d78) (pointer-set-c-uint16! . B2d77) (pointer-set-c-uint8! . B2d76) (pointer-set-c-int64! . B2d75) (pointer-set-c-int32! . B2d74) (pointer-set-c-int16! . B2d73) (pointer-set-c-int8! . B2d72) (pointer-set-c-pointer! . B2d71) (pointer-set-c-double! . B2d70) (pointer-set-c-float! . B2d6f) (pointer-set-c-long-long! . B2d6e) (pointer-set-c-long! . B2d6d) (pointer-set-c-int! . B2d6c) (pointer-set-c-short! . B2d6b) (pointer-set-c-char! . B2d6a) (pointer-ref-c-pointer . B2d69) (pointer-ref-c-double . B2d68) (pointer-ref-c-float . B2d67) (pointer-ref-c-unsigned-long-long . B2d66) (pointer-ref-c-signed-long-long . B2d65) (pointer-ref-c-unsigned-long . B2d64) (pointer-ref-c-signed-long . B2d63) (pointer-ref-c-unsigned-int . B2d62) (pointer-ref-c-signed-int . B2d61) (pointer-ref-c-unsigned-short . B2d60) (pointer-ref-c-signed-short . B2d5f) (pointer-ref-c-unsigned-char . B2d5e) (pointer-ref-c-signed-char . B2d5d) (pointer->integer . B2d5c) (integer->pointer . B2d5b) (pointer? . B2d5a) (shared-errno . B2d59) (%ffi-free-c-callback-trampoline . B2d58) (%ffi-make-c-callback-trampoline . B2d57) (%ffi-free . B2d56) (%ffi-malloc . B2d55) (%ffi-supported? . B2d54) (%ffi-pointer->string . B2d53) (%ffi-call . B2d52) (%ffi-lookup . B2d51) (%ffi-open . B2d50) (null-terminated-utf8->string . B2d4f) (null-terminated-bytevector->string . B2d4e) (%exec . B2d4d) (%fork . B2d4c) (%pipe . B2d4b) (open-output-string . B2d49) (get-output-string . B2d48) (file-stat-ctime . B2d47) (file-stat-atime . B2d46) (file-stat-mtime . B2d45) (file-size-in-bytes . B2d44) (file-writable? . B2d43) (file-executable? . B2d42) (file-readable? . B2d41) (file-regular? . B2d40) (file-symbolic-link? . B2d3f) (file-directory? . B2d3e) (create-symbolic-link . B2d3d) (rename-file . B2d3c) (delete-directory . B2d3b) (create-directory . B2d3a) (create-mosh-cache-dir . B2d39) (get-environment-variables . B2d38) (current-exception-handler . B2d37) (get-environment-variable . B2d36) (join-wraps . B2d35) (id->real-label . B2d34) (same-marks? . B2d33) (same-marks*? . B2d32) (disasm . B2d0e) (make-parameter . B59f) (socket-port . B2d0d) (socket-shutdown . B2d0c) (socket-close . B2d0b) (socket-send . B2d0a) (socket-recv! . B2d09) (socket-recv . B2d08) (make-server-socket . B2d07) (make-client-socket . B2d06) (socket-accept . B2d05) (socket? . B2d04) (parameterize . B2a5e)) '() values values '#f '#f '#f '#f)))
(begin (set! B28c6@ref (unspecified)) (set! B28c8@x* (unspecified)) (set! B28ca@add-library-path! (unspecified)) (set! B28cc@parse-and-add-library-path (unspecified)) (set! B28ce@for-each-with-index (unspecified)) (set! B28d0@rpad (unspecified)) (set! B28d2@condition-printer (unspecified)) (set! B28d4@record->field-alist (unspecified)) (set! B28d6@map-with-index (unspecified)) (set! B28d8@repl (unspecified)) (set! B28da@trace-printer (unspecified)) (set! B28dc@command-line (unspecified)) (set! B28de@local-library-path (unspecified)) (set! B28e0@load/args (unspecified)) (set! B28e2@load (unspecified)) (set! B28e4@ironscheme-build (unspecified)) (set! B28e6@eval-top-level (unspecified)) (set! B28e8@compile-system-libraries (unspecified)) (set! B28ea@compile (unspecified)) (set! B28ec@compile->closure (unspecified)) (set! B28ee@pre-compile-r6rs-file (unspecified)) (set! B28f0@load-r6rs-top-level (unspecified)) (set! B28f2@load-r6rs-top-level-sexp (unspecified)) (set! B28f4@prefix-inc (unspecified)) (set! B28f6@prefix-inc! (unspecified)) (set! B28c6@ref (lambda (B2931@rtd B2932@i B2933@x) (let ((B2937@val ((record-accessor B2931@rtd B2932@i) B2933@x))) (if (symbol? B2937@val) (ungensym B2937@val) B2937@val)))) (set! B2a2d@B28c6@ref B28c6@ref) (set! B28c8@x* '()) (set! B2a2e@B28c8@x* B28c8@x*) (set! B28ca@add-library-path! (lambda (B2939@path) (B97c@B7b8@library-path (append (B97c@B7b8@library-path) (list B2939@path))))) (set! B2a2f@B28ca@add-library-path! B28ca@add-library-path!) (set! B28cc@parse-and-add-library-path (lambda (B293b@paths B293c@message) (letrec* ((B2940@separator (if (string=? (host-os) '"win32") '#\; '#\:))) (let ((B2941@t B293b@paths)) (if B2941@t ((lambda (B2943@paths) (for-each (lambda (B2945@path) (if (file-exists? B2945@path) (B28ca@add-library-path! (expand-path B2945@path)) (format (current-error-port) B293c@message B2945@path))) (string-split B2943@paths B2940@separator))) B2941@t) (void)))))) (set! B2a30@B28cc@parse-and-add-library-path B28cc@parse-and-add-library-path) (set! B28ce@for-each-with-index (lambda (B2947@proc B2948@lst) (letrec ((B294b@loop (lambda (B294d@i B294e@lst) (if (null? B294e@lst) (if '#f '#f (void)) (begin (B2947@proc B294d@i (car B294e@lst)) (B294b@loop (+ B294d@i '1) (cdr B294e@lst))))))) (B294b@loop '1 B2948@lst)))) (set! B2a31@B28ce@for-each-with-index B28ce@for-each-with-index) (set! B28d0@rpad (lambda (B2951@str B2952@pad B2953@n) (let ((B2957@rest (- B2953@n (string-length (format '"~a" B2951@str))))) (let B295d@loop ((B2959@rest B2957@rest) (B295a@ret (format '"~a" B2951@str))) (if (<= B2959@rest '0) B295a@ret (B295d@loop (- B2959@rest '1) (string-append B295a@ret B2952@pad))))))) (set! B2a32@B28d0@rpad B28d0@rpad) (set! B28d2@condition-printer (lambda (B295f@e B2960@port) (letrec* ((B2964@max-condition-len (apply max (map (lambda (B2975@c) (string-length (symbol->string (record-type-name (record-rtd B2975@c))))) (simple-conditions B295f@e))))) (begin (display '" Condition components:\n" B2960@port) (B28ce@for-each-with-index (lambda (B2965@i B2966@x) (let ((B2969@rtd (record-rtd B2966@x)) (B296a@fields-alist (B28d4@record->field-alist B2966@x))) (begin (format B2960@port '" ~d. ~a" B2965@i (B28d0@rpad (symbol->string (record-type-name B2969@rtd)) '" " B2964@max-condition-len)) (if (null? B296a@fields-alist) (newline B2960@port) (void)) (let B2971@loop ((B296d@first '#t) (B296e@fields-alist B296a@fields-alist)) (if (null? B296e@fields-alist) '() (let ((B2973@field (car B296e@fields-alist))) (begin (if (not B296d@first) (display (B28d0@rpad '"" '" " (+ '4 B2964@max-condition-len)) B2960@port) (void)) (display '"       " B2960@port) (display (car B2973@field) B2960@port) (display '": " B2960@port) (write (cdr B2973@field) B2960@port) (newline B2960@port) (B2971@loop '#f (cdr B296e@fields-alist))))))))) (simple-conditions B295f@e)))))) (set! B2a33@B28d2@condition-printer B28d2@condition-printer) (set! B28d4@record->field-alist (lambda (B2977@r) (letrec* ((B297a@ref (lambda (B2985@rtd B2986@i B2987@x) (let ((B298b@val ((record-accessor B2985@rtd B2986@i) B2987@x))) (if (symbol? B298b@val) (ungensym B298b@val) B298b@val))))) (let B297f@loop ((B297b@ret '()) (B297c@rtd (record-rtd B2977@r))) (if B297c@rtd (B297f@loop (append B297b@ret (B28d6@map-with-index (lambda (B2981@i B2982@field) (cons B2982@field (B297a@ref B297c@rtd B2981@i B2977@r))) (vector->list (record-type-field-names B297c@rtd)))) (record-type-parent B297c@rtd)) B297b@ret))))) (set! B2a34@B28d4@record->field-alist B28d4@record->field-alist) (set! B28d6@map-with-index (lambda (B298d@proc B298e@lst) (let B2997@loop ((B2991@i '0) (B2992@lst B298e@lst) (B2993@ret '())) (if (null? B2992@lst) (reverse B2993@ret) (B2997@loop (+ B2991@i '1) (cdr B2992@lst) (cons (B298d@proc B2991@i (car B2992@lst)) B2993@ret)))))) (set! B2a35@B28d6@map-with-index B28d6@map-with-index) (set! B28d8@repl (lambda B2999@x (letrec* ((B299c@rec (lambda () (begin (display '"mosh> ") ((call/cc (lambda (B299f@B299d) (lambda () (with-exception-handler (lambda (B29a1@e) ((call/cc (lambda (B29a3@B299e) (B299f@B299d (lambda () (if '#t (begin (display '"\nUnhandled exception:\n\n" (current-error-port)) (if (condition? B29a1@e) (B28d2@condition-printer B29a1@e (current-error-port)) (format (current-error-port) '"  Non-condition object:\n     ~a\n" B29a1@e))) (B29a3@B299e (lambda () (raise-continuable B29a1@e)))))))))) (lambda () (let B29a9@loop ((B29a5@line (get-line (current-input-port))) (B29a6@accum '"")) (letrec* ((B29ac@parentheses-ok? (lambda (B29b7@text) (let B29bf@loop ((B29b9@chars (string->list B29b7@text)) (B29ba@p0 '0) (B29bb@p1 '0)) (if (null? B29b9@chars) (= '0 B29ba@p0 B29bb@p1) (let ((B29c1@t (car B29b9@chars))) (if (memv B29c1@t '(#\()) (B29bf@loop (cdr B29b9@chars) (+ B29ba@p0 '1) B29bb@p1) (if (memv B29c1@t '(#\))) (B29bf@loop (cdr B29b9@chars) (- B29ba@p0 '1) B29bb@p1) (if (memv B29c1@t '(#\[)) (B29bf@loop (cdr B29b9@chars) B29ba@p0 (+ B29bb@p1 '1)) (if (memv B29c1@t '(#\])) (B29bf@loop (cdr B29b9@chars) B29ba@p0 (- B29bb@p1 '1)) (B29bf@loop (cdr B29b9@chars) B29ba@p0 B29bb@p1)))))))))) (B29ae@eval-string-print (lambda (B29b1@text) (if (not (or (string=? '"\n" B29b1@text) (= '0 (string-length B29b1@text)))) (call-with-values (lambda () (B28e6@eval-top-level (call-with-port (open-string-input-port B29b1@text) read))) (lambda B29b3@out* (for-each (lambda (B29b5@out) (begin (write B29b5@out) (newline))) B29b3@out*))) (void))))) (if (eof-object? B29a5@line) (begin (B29ae@eval-string-print B29a6@accum) (exit)) (let ((B29af@current (string-append B29a6@accum B29a5@line))) (if (B29ac@parentheses-ok? B29af@current) (B29ae@eval-string-print B29af@current) (B29a9@loop (get-line (current-input-port)) B29af@current)))))))))))) (newline) (B299c@rec))))) (B299c@rec)))) (set! B2a36@B28d8@repl B28d8@repl) (set! B28da@trace-printer (B6c2@B5a0@make-parameter write)) (set! B2a37@B28da@trace-printer B28da@trace-printer) (set! B28dc@command-line (B6c2@B5a0@make-parameter (get-command-line))) (set! B2a38@B28dc@command-line B28dc@command-line) (set! B28de@local-library-path (lambda (B29c3@filename) (B97c@B7b8@library-path))) (set! B2a39@B28de@local-library-path B28de@local-library-path) (set! B28e0@load/args (lambda (B29c5@filename . B29c7@args) (begin (apply B28f0@load-r6rs-top-level B29c5@filename 'load B29c7@args) (void)))) (set! B2a3a@B28e0@load/args B28e0@load/args) (set! B28e2@load (lambda (B29c9@filename) (begin (apply B28f0@load-r6rs-top-level B29c9@filename 'load (B28dc@command-line)) (void)))) (set! B2a3b@B28e2@load B28e2@load) (set! B28e4@ironscheme-build (lambda () (B28e2@load '"ironscheme-buildscript.ss"))) (set! B2a3c@B28e4@ironscheme-build B28e4@ironscheme-build) (set! B28e6@eval-top-level (lambda (B29cb@x) (B28a3@Be39@eval B29cb@x (B28ba@Be67@interaction-environment)))) (set! B2a3d@B28e6@eval-top-level B28e6@eval-top-level) (set! B28e8@compile-system-libraries (lambda () (B28e6@eval-top-level '(begin (include "system-libraries.ss") (compile "system-libraries.ss"))))) (set! B2a3e@B28e8@compile-system-libraries B28e8@compile-system-libraries) (set! B28ea@compile (lambda (B29cd@filename) (B28f0@load-r6rs-top-level B29cd@filename 'compile))) (set! B2a3f@B28ea@compile B28ea@compile) (set! B28ec@compile->closure (lambda (B29cf@filename) (B28f0@load-r6rs-top-level B29cf@filename 'closure))) (set! B2a40@B28ec@compile->closure B28ec@compile->closure) (set! B28ee@pre-compile-r6rs-file (lambda (B29d1@filename) (B28f0@load-r6rs-top-level B29d1@filename 'compile))) (set! B2a41@B28ee@pre-compile-r6rs-file B28ee@pre-compile-r6rs-file) (set! B28f0@load-r6rs-top-level (lambda (B29d3@filename B29d4@how . B29d7@args) (begin (B97c@B7b8@library-path (B28de@local-library-path B29d3@filename)) (let ((B29d9@x* (with-input-from-file B29d3@filename (lambda () (let B29db@f () (let ((B29dd@x (B6b4@B584@read-annotated))) (if (eof-object? B29dd@x) '() (cons B29dd@x (B29db@f))))))))) (let ((B29df@t B29d4@how)) (if (memv B29df@t '(closure)) (B28b9@Be65@pre-compile-r6rs-top-level B29d9@x*) (if (memv B29df@t '(load)) (begin (B28dc@command-line (cons B29d3@filename (car B29d7@args))) (B6c3@B5a2@mosh-cache-dir (create-mosh-cache-dir)) (if (B6c3@B5a2@mosh-cache-dir) (gensym-prefix-set! (B28f6@prefix-inc! (string-append (B6c3@B5a2@mosh-cache-dir) '"/prefix.txt"))) (void)) (if (symbol-value '%clean-acc) (for-each (lambda (B29e1@file) ((call/cc (lambda (B29e5@B29e3) (lambda () (with-exception-handler (lambda (B29e7@c) ((call/cc (lambda (B29e9@B29e4) (B29e5@B29e3 (lambda () (if '#t '#t (B29e9@B29e4 (lambda () (raise-continuable B29e7@c)))))))))) (lambda () (delete-file (string-append (B6c3@B5a2@mosh-cache-dir) '"/" B29e1@file))))))))) (directory-list (B6c3@B5a2@mosh-cache-dir))) (void)) (let ((B29eb@compiled (B28b8@Be63@compile-r6rs-top-level B29d9@x*))) (begin (if (and (B6c3@B5a2@mosh-cache-dir) (not (symbol-value '%disable-acc))) (B980@B7c0@serialize-all B6bd@B596@serialize-library B719@B6d2@compile-core-expr) (void)) (B29eb@compiled)))) (if (memv B29df@t '(compile)) (begin (B28b8@Be63@compile-r6rs-top-level B29d9@x*) (B980@B7c0@serialize-all B6bd@B596@serialize-library B719@B6d2@compile-core-expr)) (if '#f '#f (void)))))))))) (set! B2a42@B28f0@load-r6rs-top-level B28f0@load-r6rs-top-level) (set! B28f2@load-r6rs-top-level-sexp (lambda (B29ed@import-spec B29ee@thunk) (let ((B29f9@B29f2 B97c@B7b8@library-path) (B29fa@B29f4 B6c3@B5a2@mosh-cache-dir) (B29fb@B29f6 (B28de@local-library-path '"")) (B29fc@B29f8 (create-mosh-cache-dir))) (let ((B2a01@swap (lambda () (begin (let ((B2a03@t (B29f9@B29f2))) (begin (B29f9@B29f2 B29fb@B29f6) (set! B29fb@B29f6 B2a03@t))) (let ((B2a05@t (B29fa@B29f4))) (begin (B29fa@B29f4 B29fc@B29f8) (set! B29fc@B29f8 B2a05@t))))))) (dynamic-wind B2a01@swap (lambda () (begin (if (B6c3@B5a2@mosh-cache-dir) (gensym-prefix-set! (B28f6@prefix-inc! (string-append (B6c3@B5a2@mosh-cache-dir) '"/prefix.txt"))) (void)) (let ((B2a0b@B2a08 B28dc@command-line) (B2a0c@B2a0a '())) (let ((B2a0f@swap (lambda () (let ((B2a11@t (B2a0b@B2a08))) (begin (B2a0b@B2a08 B2a0c@B2a0a) (set! B2a0c@B2a0a B2a11@t)))))) (dynamic-wind B2a0f@swap (lambda () ((B28b8@Be63@compile-r6rs-top-level (list (cons 'import B29ed@import-spec) (list B29ee@thunk))))) B2a0f@swap))))) B2a01@swap))))) (set! B2a43@B28f2@load-r6rs-top-level-sexp B28f2@load-r6rs-top-level-sexp) (set! B28f4@prefix-inc (lambda (B2a13@prefix-string) (let ((B2a15@prefix (symbol->string B2a13@prefix-string))) (let ((B2a17@len (string-length B2a15@prefix))) (let B2a1f@loop ((B2a19@i (- B2a17@len '1)) (B2a1a@carry? '#t) (B2a1b@accum '())) (if (< B2a19@i '0) (string->symbol (list->string (if B2a1a@carry? (cons '#\a B2a1b@accum) B2a1b@accum))) (if B2a1a@carry? (let ((B2a21@next-integer (+ '1 (char->integer (string-ref B2a15@prefix B2a19@i))))) (if (= B2a21@next-integer '123) (B2a1f@loop (- B2a19@i '1) '#f (cons '#\A B2a1b@accum)) (if (= B2a21@next-integer '91) (B2a1f@loop (- B2a19@i '1) '#t (cons '#\a B2a1b@accum)) (B2a1f@loop (- B2a19@i '1) '#f (cons (integer->char B2a21@next-integer) B2a1b@accum))))) (B2a1f@loop (- B2a19@i '1) '#f (cons (string-ref B2a15@prefix B2a19@i) B2a1b@accum))))))))) (set! B2a44@B28f4@prefix-inc B28f4@prefix-inc) (set! B28f6@prefix-inc! (lambda (B2a23@file) (begin (if (not (file-exists? B2a23@file)) (call-with-output-file B2a23@file (lambda (B2a25@port) (write 'd B2a25@port))) (void)) (let ((B2a27@prefix (call-with-input-file B2a23@file read))) (if (main-vm?) (let ((B2a29@next-prefix (B28f4@prefix-inc B2a27@prefix))) (begin (call-with-port (open-file-output-port B2a23@file (make-file-options '(no-fail)) 'block (native-transcoder)) (lambda (B2a2b@port) (write B2a29@next-prefix B2a2b@port))) B2a27@prefix)) B2a27@prefix))))) (set! B2a45@B28f6@prefix-inc! B28f6@prefix-inc!) (begin (B981@B7c2@current-precompiled-library-loader B6be@B598@load-serialized-library) (set-symbol-value! 'load B28e2@load) (set-symbol-value! 'pre-compile-r6rs-file B28ee@pre-compile-r6rs-file) (set-symbol-value! 'eval-r6rs B28e6@eval-top-level) (set-symbol-value! 'int-env-syms B289a@Be27@interaction-environment-symbols) (set-symbol-value! 'expanded2core B718@B6d0@expanded->core) (set-symbol-value! 'trace-printer B28da@trace-printer) (set-symbol-value! 'compile-r6rs-top-level 'compile-r6rs-top-level) (set-symbol-value! 'create-non-continuable-violation (lambda (B28f7@c) (condition (make-non-continuable-violation) (make-who-condition 'raise) (make-message-condition '"returned from non-continuable exception") (make-irritants-condition (list B28f7@c))))) (B28cc@parse-and-add-library-path (get-environment-variable '"MOSH_LOADPATH") '"** WARN in environment variable 'MOSH_LOADPATH': directory ~s not exist\n") (B28cc@parse-and-add-library-path (symbol-value '%loadpath) '"** WARN in command-line option '--loadpath': directory ~s not exist\n") (if (mosh-executable-path) (if (file-exists? (string-append (mosh-executable-path) '"/lib")) (B28ca@add-library-path! (string-append (mosh-executable-path) '"/lib")) (void)) (if (file-exists? (string-append (current-directory) '"/lib")) (B28ca@add-library-path! (string-append (current-directory) '"/lib")) (void))) (if (file-exists? (string-append (standard-library-path) '"/lib")) (B28ca@add-library-path! (string-append (standard-library-path) '"/lib")) (void)) (let ((B28f9@prefix (lambda (B28fb@ext B28fc@ls) (append (map (lambda (B28ff@x) (string-append B28fb@ext B28ff@x)) B28fc@ls) B28fc@ls)))) (B97d@B7ba@library-extensions (B28f9@prefix '".mosh" (B97d@B7ba@library-extensions)))) (current-exception-handler (lambda (B2901@c) (begin (if (condition? B2901@c) (B28d2@condition-printer B2901@c (current-error-port)) (format (current-error-port) '"\n Non-condition object:\n     ~a\n" B2901@c)) B2901@c))) (if ((call/cc (lambda (B2905@B2903) (lambda () (with-exception-handler (lambda (B2907@c) ((call/cc (lambda (B2909@B2904) (B2905@B2903 (lambda () (if '#t '#f (B2909@B2904 (lambda () (raise-continuable B2907@c)))))))))) (lambda () (symbol-value '%vm-import-spec))))))) (B28f2@load-r6rs-top-level-sexp (symbol-value '%vm-import-spec) (symbol-value '%vm-thunk)) (if (null? (B28dc@command-line)) (let ((B2913@B290c B28dc@command-line) (B2914@B290e B6c3@B5a2@mosh-cache-dir) (B2915@B2910 '()) (B2916@B2912 (create-mosh-cache-dir))) (let ((B291b@swap (lambda () (begin (let ((B291d@t (B2913@B290c))) (begin (B2913@B290c B2915@B2910) (set! B2915@B2910 B291d@t))) (let ((B291f@t (B2914@B290e))) (begin (B2914@B290e B2916@B2912) (set! B2916@B2912 B291f@t))))))) (dynamic-wind B291b@swap (lambda () (begin (if (B6c3@B5a2@mosh-cache-dir) (gensym-prefix-set! (B28f6@prefix-inc! (string-append (B6c3@B5a2@mosh-cache-dir) '"/prefix.txt"))) (void)) (B28d8@repl))) B291b@swap))) (begin (B97c@B7b8@library-path (B28de@local-library-path (car (B28dc@command-line)))) (set! B28c8@x* (with-input-from-file (car (B28dc@command-line)) (lambda () (let B2921@f () (let ((B2923@x (B6b4@B584@read-annotated))) (if (eof-object? B2923@x) '() (cons B2923@x (B2921@f)))))))) (B28dc@command-line (cons (car (B28dc@command-line)) (cdr (B28dc@command-line)))) (B6c3@B5a2@mosh-cache-dir (create-mosh-cache-dir)) (if (B6c3@B5a2@mosh-cache-dir) (gensym-prefix-set! (B28f6@prefix-inc! (string-append (B6c3@B5a2@mosh-cache-dir) '"/prefix.txt"))) (void)) (if (symbol-value '%clean-acc) (for-each (lambda (B2925@file) ((call/cc (lambda (B2929@B2927) (lambda () (with-exception-handler (lambda (B292b@c) ((call/cc (lambda (B292d@B2928) (B2929@B2927 (lambda () (if '#t '#t (B292d@B2928 (lambda () (raise-continuable B292b@c)))))))))) (lambda () (delete-file (string-append (B6c3@B5a2@mosh-cache-dir) '"/" B2925@file))))))))) (directory-list (B6c3@B5a2@mosh-cache-dir))) (void)) (let ((B292f@compiled (B28b8@Be63@compile-r6rs-top-level B28c8@x*))) (begin (if (and (B6c3@B5a2@mosh-cache-dir) (not (symbol-value '%disable-acc))) (B980@B7c0@serialize-all B6bd@B596@serialize-library B719@B6d2@compile-core-expr) (void)) (B292f@compiled))))))))
