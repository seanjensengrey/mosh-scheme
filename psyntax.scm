;;; Copyright (c) 2006, 2007 Abdulaziz Ghuloum and Kent Dybvig
;;; automatically generated from psyntax sources
;;; for copyright details, see psyntax/main.ss

(begin (set! E28ca@library-file-path->cache-path (unspecified)) (set! E28cc@read-annotated (unspecified)) (set! E28ce@annotation-stripped (unspecified)) (set! E28d0@annotation? (unspecified)) (set! E28d2@annotation-source (unspecified)) (set! E28d4@annotation-expression (unspecified)) (set! E28d6@scm->fasl (unspecified)) (set! E28d8@fasl-save (unspecified)) (set! E28da@fasl-load (unspecified)) (set! E28dc@verbose? (unspecified)) (set! E28de@serialize-library (unspecified)) (set! E28e0@load-serialized-library (unspecified)) (set! E28e2@make-record-printer (unspecified)) (set! E28e4@compile-core (unspecified)) (set! E28e6@read-library-source-file (unspecified)) (set! E28e8@make-parameter (unspecified)) (set! E28ea@mosh-cache-dir (unspecified)) (set! E2980@file-options-spec (unspecified)) (set! E28ca@library-file-path->cache-path (lambda (E2981@x) (call-with-values (lambda () (open-string-output-port)) (lambda (E2987@E2984 E2988@E2986) (let ((E298b@extract E2988@E2986) (E298c@p E2987@E2984)) (letrec* ((E2990@display-hex (lambda (E2999@n) (if (<= '0 E2999@n '9) (display E2999@n E298c@p) (display (integer->char (+ (char->integer '#\a) (- E2999@n '10))) E298c@p))))) (begin (let E2993@f ((E2991@ls (string-split E2981@x '#\/))) (if (not (null? E2991@ls)) (begin (display '"_" E298c@p) (for-each (lambda (E2995@c) (if (or (char<=? '#\a E2995@c '#\z) (char<=? '#\A E2995@c '#\Z) (char<=? '#\0 E2995@c '#\9) (memv E2995@c '(#\- #\. #\_ #\~))) (display E2995@c E298c@p) (begin (display '"%" E298c@p) (let ((E2997@n (char->integer E2995@c))) (begin (E2990@display-hex (quotient E2997@n '16)) (E2990@display-hex (remainder E2997@n '16))))))) (string->list (car E2991@ls))) (E2993@f (cdr E2991@ls))) (void))) (E298b@extract)))))))) (set! E29fb@E28ca@library-file-path->cache-path E28ca@library-file-path->cache-path) (set! E28cc@read-annotated read) (set! E29fc@E28cc@read-annotated E28cc@read-annotated) (set! E28ce@annotation-stripped (lambda (E299b@x) (E28d4@annotation-expression E299b@x))) (set! E29fd@E28ce@annotation-stripped E28ce@annotation-stripped) (set! E28d0@annotation? (lambda (E299d@x) (source-info E299d@x))) (set! E29fe@E28d0@annotation? E28d0@annotation?) (set! E28d2@annotation-source (lambda (E299f@x) (source-info E299f@x))) (set! E29ff@E28d2@annotation-source E28d2@annotation-source) (set! E28d4@annotation-expression (lambda (E29a1@x) (if (pair? E29a1@x) (cons (car E29a1@x) (cdr E29a1@x)) (if (procedure? E29a1@x) (set-source-info! E29a1@x '#f) E29a1@x)))) (set! E2a00@E28d4@annotation-expression E28d4@annotation-expression) (set! E28d6@scm->fasl (lambda (E29a3@filename) (string-append (E28ea@mosh-cache-dir) '"/" (E28ca@library-file-path->cache-path E29a3@filename) '".mosh-fasl"))) (set! E2a01@E28d6@scm->fasl E28d6@scm->fasl) (set! E28d8@fasl-save (lambda (E29a5@filename E29a6@obj) (call-with-port (open-file-output-port E29a5@filename) (lambda (E29a9@port) ((symbol-value 'fasl-write!) E29a6@obj E29a9@port))))) (set! E2a02@E28d8@fasl-save E28d8@fasl-save) (set! E28da@fasl-load (lambda (E29ab@filename) (call-with-port (open-file-input-port E29ab@filename) (symbol-value 'fasl-read!)))) (set! E2a03@E28da@fasl-load E28da@fasl-load) (set! E28dc@verbose? (symbol-value '%verbose)) (set! E2a04@E28dc@verbose? E28dc@verbose?) (set! E28de@serialize-library (lambda (E29ad@filename E29ae@obj) (begin (if E28dc@verbose? (format (current-error-port) '"serialize-library ~a\n..." E29ad@filename) (void)) (let ((E29b1@expanded2core (symbol-value 'expanded2core))) (let ((E29b3@compile (symbol-value 'compile-w/o-halt))) (let ((E29b5@code E29ae@obj)) (let ((E29b7@pivot (cddddr (cddddr E29b5@code)))) (let ((E29b9@visit (E29b3@compile (E29b1@expanded2core (car E29b7@pivot))))) (begin (set-car! E29b7@pivot E29b9@visit) (let ((E29bb@pivot (cdr E29b7@pivot))) (let ((E29bd@invoke (E29b3@compile (E29b1@expanded2core (car E29bb@pivot))))) (set-car! E29bb@pivot E29bd@invoke))))))))) (let ((E29bf@fasl-file (E28d6@scm->fasl E29ad@filename))) (begin (if (file-exists? E29bf@fasl-file) (delete-file E29bf@fasl-file) (void)) ((call/cc (lambda (E29c3@E29c1) (lambda () (with-exception-handler (lambda (E29c5@c) ((call/cc (lambda (E29c7@E29c2) (E29c3@E29c1 (lambda () (if '#t (begin (if E28dc@verbose? (format (current-error-port) '"Warning:serialize-library failed ~a\n" E29ad@filename) (void)) (if (file-exists? E29bf@fasl-file) (delete-file E29bf@fasl-file) (void)) '#f) (E29c7@E29c2 (lambda () (raise-continuable E29c5@c)))))))))) (lambda () (E28d8@fasl-save E29bf@fasl-file E29ae@obj)))))))))))) (set! E2a05@E28de@serialize-library E28de@serialize-library) (set! E28e0@load-serialized-library (lambda (E29c9@filename E29ca@obj) (and (E28ea@mosh-cache-dir) (let ((E29cd@fasl-file (E28d6@scm->fasl E29c9@filename))) (if (and (file-exists? E29cd@fasl-file) ((symbol-value 'file-newer?) E29cd@fasl-file E29c9@filename)) (let ((E29cf@expanded2core (symbol-value 'expanded2core))) (let ((E29d1@eval-compiled-core (symbol-value 'eval-compiled!))) (let ((E29d3@code (E28da@fasl-load E29cd@fasl-file))) (let ((E29d5@pivot (cddddr (cddddr E29d3@code)))) (let ((E29d7@visit (car E29d5@pivot))) (let ((E29d9@visit-proc (lambda () (E29d1@eval-compiled-core E29d7@visit)))) (begin (set-car! E29d5@pivot E29d9@visit-proc) (let ((E29db@pivot (cdr E29d5@pivot))) (let ((E29dd@invoke (car E29db@pivot))) (begin (set-car! E29db@pivot (lambda () (E29d1@eval-compiled-core E29dd@invoke))) (apply E29ca@obj E29d3@code))))))))))) '#f))))) (set! E2a06@E28e0@load-serialized-library E28e0@load-serialized-library) (set! E28e2@make-record-printer (lambda (E29df@name E29e0@printer) (lambda E29e3@x (begin (display '"record printer") (for-each display E29e3@x))))) (set! E2a07@E28e2@make-record-printer E28e2@make-record-printer) (set! E28e4@compile-core (lambda E29e5@x (apply error 'comile-core '"not implementated" E29e5@x))) (set! E2a08@E28e4@compile-core E28e4@compile-core) (set! E28e6@read-library-source-file (lambda (E29e7@file-name) (with-input-from-file E29e7@file-name E28cc@read-annotated))) (set! E2a09@E28e6@read-library-source-file E28e6@read-library-source-file) (set! E28e8@make-parameter (lambda E29f7 (let ((E29f8 (length E29f7))) (if (= E29f8 '1) (apply (lambda (E29e9@x) (E28e8@make-parameter E29e9@x (lambda (E29eb@x) E29eb@x))) E29f7) (if (= E29f8 '2) (apply (lambda (E29ed@x E29ee@fender) (let ((E29f1@x (E29ee@fender E29ed@x))) (lambda E29f5 (let ((E29f6 (length E29f5))) (if (= E29f6 '0) (apply (lambda () E29f1@x) E29f5) (if (= E29f6 '1) (apply (lambda (E29f3@v) (set! E29f1@x (E29ee@fender E29f3@v))) E29f5) (error 'apply '"invalid arg count"))))))) E29f7) (error 'apply '"invalid arg count")))))) (set! E2a0a@E28e8@make-parameter E28e8@make-parameter) (set! E28ea@mosh-cache-dir (E28e8@make-parameter '#f)) (set! E2a0b@E28ea@mosh-cache-dir E28ea@mosh-cache-dir) (set! E2980@file-options-spec (lambda (E29f9@x) E29f9@x)) (set! E2a0c@E2980@file-options-spec E2980@file-options-spec) (void))
(begin (set! E2a12@current-primitive-locations (unspecified)) (set! E2a14@mutable? (unspecified)) (set! E2a16@rewriter (unspecified)) (set! E2a18@expanded->core (unspecified)) (set! E2a1a@compile-core-expr (unspecified)) (set! E2a1c@pretty-print (unspecified)) (set! E2a1e@compile-core-expr-to-port (unspecified)) (set! E2a12@current-primitive-locations (E2a0a@E28e8@make-parameter (lambda (E2a1f@x) '#f) (lambda (E2a21@p) E2a21@p))) (set! E2a5d@E2a12@current-primitive-locations E2a12@current-primitive-locations) (set! E2a14@mutable? (lambda (E2a23@x) (or (pair? E2a23@x) (vector? E2a23@x) (hashtable? E2a23@x)))) (set! E2a5e@E2a14@mutable? E2a14@mutable?) (set! E2a16@rewriter (lambda (E2a25@quote-hack?) (letrec* ((E2a28@f (lambda (E2a29@x) (if (pair? E2a29@x) (let ((E2a2b@t (car E2a29@x))) (if (memv E2a2b@t '(quote)) (if (and E2a25@quote-hack? (E2a14@mutable? (cadr E2a29@x))) (let ((E2a2d@g (gensym))) (begin (set-symbol-value! E2a2d@g (cadr E2a29@x)) E2a2d@g)) E2a29@x) (if (memv E2a2b@t '(case-lambda)) (cons 'case-lambda (map (lambda (E2a2f@x) (cons (car E2a2f@x) (map E2a28@f (cdr E2a2f@x)))) (cdr E2a29@x))) (if (memv E2a2b@t '(lambda)) (cons* 'lambda (cadr E2a29@x) (map E2a28@f (cddr E2a29@x))) (if (memv E2a2b@t '(letrec)) (let ((E2a31@bindings (cadr E2a29@x)) (E2a32@body* (cddr E2a29@x))) (let ((E2a35@lhs* (map car E2a31@bindings)) (E2a36@rhs* (map cadr E2a31@bindings))) (cons* 'letrec (map list E2a35@lhs* (map E2a28@f E2a36@rhs*)) (map E2a28@f E2a32@body*)))) (if (memv E2a2b@t '(letrec*)) (let ((E2a39@bindings (cadr E2a29@x)) (E2a3a@body* (cddr E2a29@x))) (let ((E2a3d@lhs* (map car E2a39@bindings)) (E2a3e@rhs* (map cadr E2a39@bindings))) (cons* 'letrec* (map list E2a3d@lhs* (map E2a28@f E2a3e@rhs*)) (map E2a28@f E2a3a@body*)))) (if (memv E2a2b@t '(library-letrec*)) (let ((E2a41@name (cadr E2a29@x)) (E2a42@x (cdr E2a29@x))) (let ((E2a45@bindings (cadr E2a42@x)) (E2a46@body* (cddr E2a42@x))) (let ((E2a49@lhs* (map car E2a45@bindings)) (E2a4a@lhs** (map cadr E2a45@bindings)) (E2a4b@rhs* (map caddr E2a45@bindings))) (cons* 'library-letrec* E2a41@name (map list E2a49@lhs* E2a4a@lhs** (map E2a28@f E2a4b@rhs*)) (map E2a28@f E2a46@body*))))) (if (memv E2a2b@t '(begin)) (cons 'begin (map E2a28@f (cdr E2a29@x))) (if (memv E2a2b@t '(set!)) (list 'set! (cadr E2a29@x) (E2a28@f (caddr E2a29@x))) (if (memv E2a2b@t '(primitive)) (let ((E2a4f@op (cadr E2a29@x))) (let ((E2a51@t ((E2a12@current-primitive-locations) E2a4f@op))) (if E2a51@t ((lambda (E2a53@loc) E2a53@loc) E2a51@t) E2a4f@op))) (if (memv E2a2b@t '(define)) E2a29@x (if (list? E2a29@x) (map E2a28@f E2a29@x) (error 'rewrite '"invalid form ~s ~s" E2a29@x (list? E2a29@x)))))))))))))) E2a29@x)))) E2a28@f))) (set! E2a5f@E2a16@rewriter E2a16@rewriter) (set! E2a18@expanded->core (lambda (E2a55@x) ((E2a16@rewriter '#f) E2a55@x))) (set! E2a60@E2a18@expanded->core E2a18@expanded->core) (set! E2a1a@compile-core-expr (lambda (E2a57@x) ((E2a16@rewriter '#f) E2a57@x))) (set! E2a61@E2a1a@compile-core-expr E2a1a@compile-core-expr) (set! E2a1c@pretty-print write) (set! E2a62@E2a1c@pretty-print E2a1c@pretty-print) (set! E2a1e@compile-core-expr-to-port (lambda (E2a59@x E2a5a@p) (E2a1c@pretty-print ((E2a16@rewriter '#f) E2a59@x) E2a5a@p))) (set! E2a63@E2a1e@compile-core-expr-to-port E2a1e@compile-core-expr-to-port) (void))
(begin (void))
(begin (set! E2ab2@make-collection (unspecified)) (set! E2ab4@current-library-collection (unspecified)) (set! E2ab6@rp (unspecified)) (set! E2ac0@library? (unspecified)) (set! E2ac2@library-id (unspecified)) (set! E2ac4@set-library-id! (unspecified)) (set! E2ac6@library-name (unspecified)) (set! E2ac8@set-library-name! (unspecified)) (set! E2aca@library-version (unspecified)) (set! E2acc@set-library-version! (unspecified)) (set! E2ace@library-imp* (unspecified)) (set! E2ad0@set-library-imp*! (unspecified)) (set! E2ad2@library-vis* (unspecified)) (set! E2ad4@set-library-vis*! (unspecified)) (set! E2ad6@library-inv* (unspecified)) (set! E2ad8@set-library-inv*! (unspecified)) (set! E2ada@library-subst (unspecified)) (set! E2adc@set-library-subst! (unspecified)) (set! E2ade@library-env (unspecified)) (set! E2ae0@set-library-env! (unspecified)) (set! E2ae2@library-visit-state (unspecified)) (set! E2ae4@set-library-visit-state! (unspecified)) (set! E2ae6@library-invoke-state (unspecified)) (set! E2ae8@set-library-invoke-state! (unspecified)) (set! E2aea@library-visit-code (unspecified)) (set! E2aec@set-library-visit-code! (unspecified)) (set! E2aee@library-invoke-code (unspecified)) (set! E2af0@set-library-invoke-code! (unspecified)) (set! E2af2@library-visible? (unspecified)) (set! E2af4@set-library-visible?! (unspecified)) (set! E2af6@library-source-file-name (unspecified)) (set! E2af8@set-library-source-file-name! (unspecified)) (set! E2afa@dummy (unspecified)) (set! E2afc@find-dependencies (unspecified)) (set! E2afe@find-library-by (unspecified)) (set! E2b00@library-path (unspecified)) (set! E2b02@library-extensions (unspecified)) (set! E2b04@library-name->file-name (unspecified)) (set! E2b06@file-locator (unspecified)) (set! E2b08@serialize-all (unspecified)) (set! E2b0a@current-precompiled-library-loader (unspecified)) (set! E2b0c@try-load-from-file (unspecified)) (set! E2b0e@library-loader (unspecified)) (set! E2b10@current-library-expander (unspecified)) (set! E2b12@external-pending-libraries (unspecified)) (set! E2b14@find-external-library (unspecified)) (set! E2b16@find-library-by-name (unspecified)) (set! E2b18@library-exists? (unspecified)) (set! E2b1a@find-library-by-spec/die (unspecified)) (set! E2b1c@label->binding-table (unspecified)) (set! E2b1e@install-library-record (unspecified)) (set! E2b20@install-library (unspecified)) (set! E2b22@imported-label->binding (unspecified)) (set! E2b24@invoke-library (unspecified)) (set! E2b26@visit-library (unspecified)) (set! E2b28@invoke-library-by-spec (unspecified)) (set! E2b2a@installed-libraries (unspecified)) (set! E2b2c@library-spec (unspecified)) (set! E2ab2@make-collection (lambda () (let ((E2b2d@set '())) (letrec* ((E2b30@set-cons (lambda (E2b35@x E2b36@ls) (if (memq E2b35@x E2b36@ls) E2b36@ls (cons E2b35@x E2b36@ls))))) (lambda E2b33 (let ((E2b34 (length E2b33))) (if (= E2b34 '0) (apply (lambda () E2b2d@set) E2b33) (if (= E2b34 '1) (apply (lambda (E2b31@x) (set! E2b2d@set (E2b30@set-cons E2b31@x E2b2d@set))) E2b33) (error 'apply '"invalid arg count"))))))))) (set! E2ca1@E2ab2@make-collection E2ab2@make-collection) (set! E2ab4@current-library-collection (E2a0a@E28e8@make-parameter (E2ab2@make-collection) (lambda (E2b39@x) (begin (if (not (procedure? E2b39@x)) (assertion-violation 'current-library-collection '"not a procedure" E2b39@x) (void)) E2b39@x)))) (set! E2ca2@E2ab4@current-library-collection E2ab4@current-library-collection) (set! E2ab6@rp (E2a07@E28e2@make-record-printer 'library (lambda (E2b3b@x E2b3c@p E2b3d@wr) (begin (if (not (E2ac0@library? E2b3b@x)) (assertion-violation 'record-type-printer '"not a library") (void)) (display (format '"#<library ~s>" (if (null? (E2aca@library-version E2b3b@x)) (E2ac6@library-name E2b3b@x) (append (E2ac6@library-name E2b3b@x) (list (E2aca@library-version E2b3b@x))))) E2b3c@p))))) (set! E2ca3@E2ab6@rp E2ab6@rp) (set! E2ac0@library? (lambda (E2b41@x) (and (simple-struct? E2b41@x) (eq? (simple-struct-name E2b41@x) 'library)))) (set! E2ca4@E2ac0@library? E2ac0@library?) (set! E2ac2@library-id (lambda (E2b43@x) (simple-struct-ref E2b43@x '0))) (set! E2ca5@E2ac2@library-id E2ac2@library-id) (set! E2ac4@set-library-id! (lambda (E2b45@x E2b46@val) (simple-struct-set! E2b45@x '0 E2b46@val))) (set! E2ca6@E2ac4@set-library-id! E2ac4@set-library-id!) (set! E2ac6@library-name (lambda (E2b49@x) (simple-struct-ref E2b49@x '1))) (set! E2ca7@E2ac6@library-name E2ac6@library-name) (set! E2ac8@set-library-name! (lambda (E2b4b@x E2b4c@val) (simple-struct-set! E2b4b@x '1 E2b4c@val))) (set! E2ca8@E2ac8@set-library-name! E2ac8@set-library-name!) (set! E2aca@library-version (lambda (E2b4f@x) (simple-struct-ref E2b4f@x '2))) (set! E2ca9@E2aca@library-version E2aca@library-version) (set! E2acc@set-library-version! (lambda (E2b51@x E2b52@val) (simple-struct-set! E2b51@x '2 E2b52@val))) (set! E2caa@E2acc@set-library-version! E2acc@set-library-version!) (set! E2ace@library-imp* (lambda (E2b55@x) (simple-struct-ref E2b55@x '3))) (set! E2cab@E2ace@library-imp* E2ace@library-imp*) (set! E2ad0@set-library-imp*! (lambda (E2b57@x E2b58@val) (simple-struct-set! E2b57@x '3 E2b58@val))) (set! E2cac@E2ad0@set-library-imp*! E2ad0@set-library-imp*!) (set! E2ad2@library-vis* (lambda (E2b5b@x) (simple-struct-ref E2b5b@x '4))) (set! E2cad@E2ad2@library-vis* E2ad2@library-vis*) (set! E2ad4@set-library-vis*! (lambda (E2b5d@x E2b5e@val) (simple-struct-set! E2b5d@x '4 E2b5e@val))) (set! E2cae@E2ad4@set-library-vis*! E2ad4@set-library-vis*!) (set! E2ad6@library-inv* (lambda (E2b61@x) (simple-struct-ref E2b61@x '5))) (set! E2caf@E2ad6@library-inv* E2ad6@library-inv*) (set! E2ad8@set-library-inv*! (lambda (E2b63@x E2b64@val) (simple-struct-set! E2b63@x '5 E2b64@val))) (set! E2cb0@E2ad8@set-library-inv*! E2ad8@set-library-inv*!) (set! E2ada@library-subst (lambda (E2b67@x) (simple-struct-ref E2b67@x '6))) (set! E2cb1@E2ada@library-subst E2ada@library-subst) (set! E2adc@set-library-subst! (lambda (E2b69@x E2b6a@val) (simple-struct-set! E2b69@x '6 E2b6a@val))) (set! E2cb2@E2adc@set-library-subst! E2adc@set-library-subst!) (set! E2ade@library-env (lambda (E2b6d@x) (simple-struct-ref E2b6d@x '7))) (set! E2cb3@E2ade@library-env E2ade@library-env) (set! E2ae0@set-library-env! (lambda (E2b6f@x E2b70@val) (simple-struct-set! E2b6f@x '7 E2b70@val))) (set! E2cb4@E2ae0@set-library-env! E2ae0@set-library-env!) (set! E2ae2@library-visit-state (lambda (E2b73@x) (simple-struct-ref E2b73@x '8))) (set! E2cb5@E2ae2@library-visit-state E2ae2@library-visit-state) (set! E2ae4@set-library-visit-state! (lambda (E2b75@x E2b76@val) (simple-struct-set! E2b75@x '8 E2b76@val))) (set! E2cb6@E2ae4@set-library-visit-state! E2ae4@set-library-visit-state!) (set! E2ae6@library-invoke-state (lambda (E2b79@x) (simple-struct-ref E2b79@x '9))) (set! E2cb7@E2ae6@library-invoke-state E2ae6@library-invoke-state) (set! E2ae8@set-library-invoke-state! (lambda (E2b7b@x E2b7c@val) (simple-struct-set! E2b7b@x '9 E2b7c@val))) (set! E2cb8@E2ae8@set-library-invoke-state! E2ae8@set-library-invoke-state!) (set! E2aea@library-visit-code (lambda (E2b7f@x) (simple-struct-ref E2b7f@x '10))) (set! E2cb9@E2aea@library-visit-code E2aea@library-visit-code) (set! E2aec@set-library-visit-code! (lambda (E2b81@x E2b82@val) (simple-struct-set! E2b81@x '10 E2b82@val))) (set! E2cba@E2aec@set-library-visit-code! E2aec@set-library-visit-code!) (set! E2aee@library-invoke-code (lambda (E2b85@x) (simple-struct-ref E2b85@x '11))) (set! E2cbb@E2aee@library-invoke-code E2aee@library-invoke-code) (set! E2af0@set-library-invoke-code! (lambda (E2b87@x E2b88@val) (simple-struct-set! E2b87@x '11 E2b88@val))) (set! E2cbc@E2af0@set-library-invoke-code! E2af0@set-library-invoke-code!) (set! E2af2@library-visible? (lambda (E2b8b@x) (simple-struct-ref E2b8b@x '12))) (set! E2cbd@E2af2@library-visible? E2af2@library-visible?) (set! E2af4@set-library-visible?! (lambda (E2b8d@x E2b8e@val) (simple-struct-set! E2b8d@x '12 E2b8e@val))) (set! E2cbe@E2af4@set-library-visible?! E2af4@set-library-visible?!) (set! E2af6@library-source-file-name (lambda (E2b91@x) (simple-struct-ref E2b91@x '13))) (set! E2cbf@E2af6@library-source-file-name E2af6@library-source-file-name) (set! E2af8@set-library-source-file-name! (lambda (E2b93@x E2b94@val) (simple-struct-set! E2b93@x '13 E2b94@val))) (set! E2cc0@E2af8@set-library-source-file-name! E2af8@set-library-source-file-name!) (set! E2afa@dummy '3) (set! E2cc1@E2afa@dummy E2afa@dummy) (set! E2afc@find-dependencies (lambda (E2b97@ls) (if (null? E2b97@ls) '() (assertion-violation 'find-dependencies '"cannot handle deps yet")))) (set! E2cc2@E2afc@find-dependencies E2afc@find-dependencies) (set! E2afe@find-library-by (lambda (E2b99@pred) (let E2b9d@f ((E2b9b@ls ((E2ab4@current-library-collection)))) (if (null? E2b9b@ls) '#f (if (E2b99@pred (car E2b9b@ls)) (car E2b9b@ls) (E2b9d@f (cdr E2b9b@ls))))))) (set! E2cc3@E2afe@find-library-by E2afe@find-library-by) (set! E2b00@library-path (E2a0a@E28e8@make-parameter '(".") (lambda (E2b9f@x) (if (and (list? E2b9f@x) (for-all string? E2b9f@x)) (map (lambda (E2ba1@x) E2ba1@x) E2b9f@x) (assertion-violation 'library-path '"not a list of strings" E2b9f@x))))) (set! E2cc4@E2b00@library-path E2b00@library-path) (set! E2b02@library-extensions (E2a0a@E28e8@make-parameter '(".sls" ".ss" ".scm") (lambda (E2ba3@x) (if (and (list? E2ba3@x) (for-all string? E2ba3@x)) (map (lambda (E2ba5@x) E2ba5@x) E2ba3@x) (assertion-violation 'library-extensions '"not a list of strings" E2ba3@x))))) (set! E2cc5@E2b02@library-extensions E2b02@library-extensions) (set! E2b04@library-name->file-name (lambda (E2ba7@x) (call-with-values (lambda () (open-string-output-port)) (lambda (E2bad@E2baa E2bae@E2bac) (let ((E2bb1@extract E2bae@E2bac) (E2bb2@p E2bad@E2baa)) (letrec* ((E2bb6@display-hex (lambda (E2bbf@n) (if (<= '0 E2bbf@n '9) (display E2bbf@n E2bb2@p) (display (integer->char (+ (char->integer '#\a) (- E2bbf@n '10))) E2bb2@p))))) (begin (let E2bb9@f ((E2bb7@ls E2ba7@x)) (if (not (null? E2bb7@ls)) (begin (display '"/" E2bb2@p) (for-each (lambda (E2bbb@c) (if (or (char<=? '#\a E2bbb@c '#\z) (char<=? '#\A E2bbb@c '#\Z) (char<=? '#\0 E2bbb@c '#\9) (memv E2bbb@c '(#\- #\. #\_ #\~))) (display E2bbb@c E2bb2@p) (begin (display '"%" E2bb2@p) (let ((E2bbd@n (char->integer E2bbb@c))) (begin (E2bb6@display-hex (quotient E2bbd@n '16)) (E2bb6@display-hex (remainder E2bbd@n '16))))))) (string->list (symbol->string (car E2bb7@ls)))) (E2bb9@f (cdr E2bb7@ls))) (void))) (E2bb1@extract)))))))) (set! E2cc6@E2b04@library-name->file-name E2b04@library-name->file-name) (set! E2b06@file-locator (E2a0a@E28e8@make-parameter (lambda (E2bc1@x) (let ((E2bc3@str (E2b04@library-name->file-name E2bc1@x))) (let E2bcb@f ((E2bc5@ls (E2b00@library-path)) (E2bc6@exts (E2b02@library-extensions)) (E2bc7@failed-list '())) (if (null? E2bc5@ls) (letrec* ((E2bd5@E2bd0 (make-record-type-descriptor '&library-resolution &condition-rtd 'E2bd3 '#f '#f '#((immutable library) (immutable files)))) (E2bd7@E2bd2 '#f) (E2bd9@E2bd1 (make-record-constructor-descriptor E2bd5@E2bd0 &condition-rcd E2bd7@E2bd2)) (E2bdc@E2bcf (record-predicate E2bd5@E2bd0)) (E2bde@make-library-resolution-condition (record-constructor E2bd9@E2bd1)) (E2be0@E2bcd (record-accessor E2bd5@E2bd0 '0)) (E2be2@E2bce (record-accessor E2bd5@E2bd0 '1)) (E2be4@library-resolution-condition? (condition-predicate E2bd5@E2bd0)) (E2be6@condition-library (condition-accessor E2bd5@E2bd0 E2be0@E2bcd)) (E2be8@condition-files (condition-accessor E2bd5@E2bd0 E2be2@E2bce))) (raise (condition (make-error) (make-who-condition 'expander) (make-message-condition '"cannot locate library in library-path") (E2bde@make-library-resolution-condition E2bc1@x (reverse E2bc7@failed-list))))) (if (null? E2bc6@exts) (E2bcb@f (cdr E2bc5@ls) (E2b02@library-extensions) E2bc7@failed-list) (let ((E2be9@name (string-append (car E2bc5@ls) E2bc3@str (car E2bc6@exts)))) (if (file-exists? E2be9@name) E2be9@name (E2bcb@f E2bc5@ls (cdr E2bc6@exts) (cons E2be9@name E2bc7@failed-list))))))))) (lambda (E2beb@f) (if (procedure? E2beb@f) E2beb@f (assertion-violation 'file-locator '"not a procedure" E2beb@f))))) (set! E2cc7@E2b06@file-locator E2b06@file-locator) (set! E2b08@serialize-all (lambda (E2bed@serialize E2bee@compile) (letrec* ((E2bf2@library-desc (lambda (E2bf5@x) (list (E2ac2@library-id E2bf5@x) (E2ac6@library-name E2bf5@x))))) (for-each (lambda (E2bf3@x) (if (E2af6@library-source-file-name E2bf3@x) (E2bed@serialize (E2af6@library-source-file-name E2bf3@x) (list (E2ac2@library-id E2bf3@x) (E2ac6@library-name E2bf3@x) (E2aca@library-version E2bf3@x) (map E2bf2@library-desc (E2ace@library-imp* E2bf3@x)) (map E2bf2@library-desc (E2ad2@library-vis* E2bf3@x)) (map E2bf2@library-desc (E2ad6@library-inv* E2bf3@x)) (E2ada@library-subst E2bf3@x) (E2ade@library-env E2bf3@x) (E2bee@compile (E2aea@library-visit-code E2bf3@x)) (E2bee@compile (E2aee@library-invoke-code E2bf3@x)) (E2af2@library-visible? E2bf3@x))) (void))) ((E2ab4@current-library-collection)))))) (set! E2cc8@E2b08@serialize-all E2b08@serialize-all) (set! E2b0a@current-precompiled-library-loader (E2a0a@E28e8@make-parameter (lambda (E2bf7@filename E2bf8@sk) '#f))) (set! E2cc9@E2b0a@current-precompiled-library-loader E2b0a@current-precompiled-library-loader) (set! E2b0c@try-load-from-file (lambda (E2bfb@filename) ((E2b0a@current-precompiled-library-loader) E2bfb@filename (lambda E2c21 (let ((E2c22 (length E2c21))) (if (= E2c22 '11) (apply (lambda (E2bfd@id E2bfe@name E2bff@ver E2c00@imp* E2c01@vis* E2c02@inv* E2c03@exp-subst E2c04@exp-env E2c05@visit-proc E2c06@invoke-proc E2c07@visible?) (let E2c15@f ((E2c13@deps (append E2c00@imp* E2c01@vis* E2c02@inv*))) (if (null? E2c13@deps) (begin (E2b20@install-library E2bfd@id E2bfe@name E2bff@ver E2c00@imp* E2c01@vis* E2c02@inv* E2c03@exp-subst E2c04@exp-env E2c05@visit-proc E2c06@invoke-proc '#f '#f E2c07@visible? '#f) '#t) (let ((E2c17@d (car E2c13@deps))) (let ((E2c19@label (car E2c17@d)) (E2c1a@dname (cadr E2c17@d))) (let ((E2c1d@l (E2b16@find-library-by-name E2c1a@dname))) (if (and (E2ac0@library? E2c1d@l) (eq? E2c19@label (E2ac2@library-id E2c1d@l))) (E2c15@f (cdr E2c13@deps)) (begin (if E2a04@E28dc@verbose? (format (current-error-port) '"WARNING: library ~e has an inconsistent dependency on library ~e; file ~e will be recompiled from source. \n" E2bfe@name E2c1a@dname E2bfb@filename) (void)) '#f)))))))) E2c21) (if (>= E2c22 '0) (apply (lambda E2c1f@others '#f) E2c21) (error 'apply '"invalid arg count")))))))) (set! E2cca@E2b0c@try-load-from-file E2b0c@try-load-from-file) (set! E2b0e@library-loader (E2a0a@E28e8@make-parameter (lambda (E2c23@x) (let ((E2c25@file-name ((E2b06@file-locator) E2c23@x))) (if (not E2c25@file-name) (assertion-violation '#f '"cannot file library" E2c23@x) (or (E2b0c@try-load-from-file E2c25@file-name) ((E2b10@current-library-expander) (E2a09@E28e6@read-library-source-file E2c25@file-name) E2c25@file-name (lambda (E2c27@name) (if (not (fast-equal? E2c27@name E2c23@x)) (assertion-violation 'import (call-with-values (lambda () (open-string-output-port)) (lambda (E2c2d@E2c2a E2c2e@E2c2c) (let ((E2c31@e E2c2e@E2c2c) (E2c32@p E2c2d@E2c2a)) (begin (display '"expected to find library " E2c32@p) (write E2c23@x E2c32@p) (display '" in file " E2c32@p) (display E2c25@file-name E2c32@p) (display '", found " E2c32@p) (write E2c27@name E2c32@p) (display '" instead" E2c32@p) (E2c31@e)))))) (void)))))))) (lambda (E2c35@f) (if (procedure? E2c35@f) E2c35@f (assertion-violation 'library-locator '"not a procedure" E2c35@f))))) (set! E2ccb@E2b0e@library-loader E2b0e@library-loader) (set! E2b10@current-library-expander (E2a0a@E28e8@make-parameter (lambda (E2c37@x) (assertion-violation 'library-expander '"not initialized")) (lambda (E2c39@f) (if (procedure? E2c39@f) E2c39@f (assertion-violation 'library-expander '"not a procedure" E2c39@f))))) (set! E2ccc@E2b10@current-library-expander E2b10@current-library-expander) (set! E2b12@external-pending-libraries (E2a0a@E28e8@make-parameter '())) (set! E2ccd@E2b12@external-pending-libraries E2b12@external-pending-libraries) (set! E2b14@find-external-library (lambda (E2c3b@name) (begin (if (member E2c3b@name (E2b12@external-pending-libraries)) (assertion-violation '#f '"circular attempt to import library was detected" E2c3b@name) (void)) (let ((E2c41@E2c3e E2b12@external-pending-libraries) (E2c42@E2c40 (cons E2c3b@name (E2b12@external-pending-libraries)))) (let ((E2c45@swap (lambda () (let ((E2c47@t (E2c41@E2c3e))) (begin (E2c41@E2c3e E2c42@E2c40) (set! E2c42@E2c40 E2c47@t)))))) (dynamic-wind E2c45@swap (lambda () (begin ((E2b0e@library-loader) E2c3b@name) (or (E2afe@find-library-by (lambda (E2c49@x) (fast-equal? (E2ac6@library-name E2c49@x) E2c3b@name))) (assertion-violation '#f '"handling external library did not yield the correct library" E2c3b@name)))) E2c45@swap)))))) (set! E2cce@E2b14@find-external-library E2b14@find-external-library) (set! E2b16@find-library-by-name (lambda (E2c4b@name) (or (E2afe@find-library-by (lambda (E2c4d@x) (fast-equal? (E2ac6@library-name E2c4d@x) E2c4b@name))) (E2b14@find-external-library E2c4b@name)))) (set! E2ccf@E2b16@find-library-by-name E2b16@find-library-by-name) (set! E2b18@library-exists? (lambda (E2c4f@name) (and (E2afe@find-library-by (lambda (E2c51@x) (fast-equal? (E2ac6@library-name E2c51@x) E2c4f@name))) '#t))) (set! E2cd0@E2b18@library-exists? E2b18@library-exists?) (set! E2b1a@find-library-by-spec/die (lambda (E2c53@spec) (let ((E2c55@id (car E2c53@spec))) (or (E2afe@find-library-by (lambda (E2c57@x) (eq? E2c55@id (E2ac2@library-id E2c57@x)))) (assertion-violation '#f '"cannot find library with required spec" E2c53@spec))))) (set! E2cd1@E2b1a@find-library-by-spec/die E2b1a@find-library-by-spec/die) (set! E2b1c@label->binding-table (make-eq-hashtable)) (set! E2cd2@E2b1c@label->binding-table E2b1c@label->binding-table) (set! E2b1e@install-library-record (lambda (E2c59@lib) (begin (let ((E2c5b@exp-env (E2ade@library-env E2c59@lib))) (for-each (lambda (E2c5d@x) (let ((E2c5f@label (car E2c5d@x)) (E2c60@binding (cdr E2c5d@x))) (let ((E2c63@binding (let ((E2c65@t (car E2c60@binding))) (if (memv E2c65@t '(global)) (cons 'global (cons E2c59@lib (cdr E2c60@binding))) (if (memv E2c65@t '(global-macro)) (cons 'global-macro (cons E2c59@lib (cdr E2c60@binding))) (if (memv E2c65@t '(global-macro!)) (cons 'global-macro! (cons E2c59@lib (cdr E2c60@binding))) E2c60@binding)))))) (begin (if (hashtable-ref E2b1c@label->binding-table E2c5f@label '#f) (begin (format (current-error-port) '"FATAL overwrite !! key=~a value=~a to ~a\n" E2c5f@label (hashtable-ref E2b1c@label->binding-table E2c5f@label '#f) E2c63@binding) (exit)) (void)) (hashtable-set! E2b1c@label->binding-table E2c5f@label E2c63@binding))))) E2c5b@exp-env)) ((E2ab4@current-library-collection) E2c59@lib)))) (set! E2cd3@E2b1e@install-library-record E2b1e@install-library-record) (set! E2b20@install-library (lambda (E2c67@id E2c68@name E2c69@ver E2c6a@imp* E2c6b@vis* E2c6c@inv* E2c6d@exp-subst E2c6e@exp-env E2c6f@visit-proc E2c70@invoke-proc E2c71@visit-code E2c72@invoke-code E2c73@visible? E2c74@source-file-name) (let ((E2c83@imp-lib* (map E2b1a@find-library-by-spec/die E2c6a@imp*)) (E2c84@vis-lib* (map E2b1a@find-library-by-spec/die E2c6b@vis*)) (E2c85@inv-lib* (map E2b1a@find-library-by-spec/die E2c6c@inv*))) (begin (if (not (and (symbol? E2c67@id) (list? E2c68@name) (list? E2c69@ver))) (assertion-violation 'install-library '"invalid spec with id/name/ver" E2c67@id E2c68@name E2c69@ver) (void)) (if (E2b18@library-exists? E2c68@name) (assertion-violation 'install-library '"library is already installed" E2c68@name) (void)) (let ((E2c89@lib (make-simple-struct 'library '15 (list E2c67@id E2c68@name E2c69@ver E2c83@imp-lib* E2c84@vis-lib* E2c85@inv-lib* E2c6d@exp-subst E2c6e@exp-env E2c6f@visit-proc E2c70@invoke-proc E2c71@visit-code E2c72@invoke-code E2c73@visible? E2c74@source-file-name)))) (E2b1e@install-library-record E2c89@lib)))))) (set! E2cd4@E2b20@install-library E2b20@install-library) (set! E2b22@imported-label->binding (lambda (E2c8b@lab) (hashtable-ref E2b1c@label->binding-table E2c8b@lab '#f))) (set! E2cd5@E2b22@imported-label->binding E2b22@imported-label->binding) (set! E2b24@invoke-library (lambda (E2c8d@lib) (let ((E2c8f@invoke (E2ae6@library-invoke-state E2c8d@lib))) (if (procedure? E2c8f@invoke) (begin (E2ae8@set-library-invoke-state! E2c8d@lib (lambda () (assertion-violation 'invoke '"circularity detected" E2c8d@lib))) (for-each E2b24@invoke-library (E2ad6@library-inv* E2c8d@lib)) (E2ae8@set-library-invoke-state! E2c8d@lib (lambda () (assertion-violation 'invoke '"first invoke did not return" E2c8d@lib))) (E2c8f@invoke) (E2ae8@set-library-invoke-state! E2c8d@lib '#t)) (void))))) (set! E2cd6@E2b24@invoke-library E2b24@invoke-library) (set! E2b26@visit-library (lambda (E2c91@lib) (let ((E2c93@visit (E2ae2@library-visit-state E2c91@lib))) (if (procedure? E2c93@visit) (begin (E2ae4@set-library-visit-state! E2c91@lib (lambda () (assertion-violation 'visit '"circularity detected" E2c91@lib))) (for-each E2b24@invoke-library (E2ad2@library-vis* E2c91@lib)) (E2ae4@set-library-visit-state! E2c91@lib (lambda () (assertion-violation 'invoke '"first visit did not return" E2c91@lib))) (E2c93@visit) (E2ae4@set-library-visit-state! E2c91@lib '#t)) (void))))) (set! E2cd7@E2b26@visit-library E2b26@visit-library) (set! E2b28@invoke-library-by-spec (lambda (E2c95@spec) (E2b24@invoke-library (E2b1a@find-library-by-spec/die E2c95@spec)))) (set! E2cd8@E2b28@invoke-library-by-spec E2b28@invoke-library-by-spec) (set! E2b2a@installed-libraries (lambda E2c9d (let ((E2c9e (length E2c9d))) (if (= E2c9e '1) (apply (lambda (E2c97@all?) (let E2c9b@f ((E2c99@ls ((E2ab4@current-library-collection)))) (if (null? E2c99@ls) '() (if (or E2c97@all? (E2af2@library-visible? (car E2c99@ls))) (cons (car E2c99@ls) (E2c9b@f (cdr E2c99@ls))) (E2c9b@f (cdr E2c99@ls)))))) E2c9d) (if (= E2c9e '0) (apply (lambda () (E2b2a@installed-libraries '#f)) E2c9d) (error 'apply '"invalid arg count")))))) (set! E2cd9@E2b2a@installed-libraries E2b2a@installed-libraries) (set! E2b2c@library-spec (lambda (E2c9f@x) (begin (if (not (E2ac0@library? E2c9f@x)) (assertion-violation 'library-spec '"not a library" E2c9f@x) (void)) (list (E2ac2@library-id E2c9f@x) (E2ac6@library-name E2c9f@x) (E2aca@library-version E2c9f@x))))) (set! E2cda@E2b2c@library-spec E2b2c@library-spec) (void))
(begin (set! E2cde@build-global-define (unspecified)) (set! E2d4f@build-lambda (unspecified)) (set! E2d51@build-case-lambda (unspecified)) (set! E2d7f@build-sequence (unspecified)) (set! E2d81@build-void (unspecified)) (set! E2d83@build-letrec (unspecified)) (set! E2d85@build-let (unspecified)) (set! E2d87@build-named-let (unspecified)) (set! E2d89@build-letrec* (unspecified)) (set! E2d8b@build-library-letrec* (unspecified)) (set! E2d8d@build-receive (unspecified)) (set! E2cde@build-global-define (lambda (E2d8e@x) (E2d81@build-void))) (set! E2e1c@E2cde@build-global-define E2cde@build-global-define) (set! E2d4f@build-lambda (lambda (E2d90@ae E2d91@vars E2d92@exp) (list 'lambda E2d91@vars E2d92@exp))) (set! E2e1d@E2d4f@build-lambda E2d4f@build-lambda) (set! E2d51@build-case-lambda (lambda (E2d96@ae E2d97@vars* E2d98@exp*) (letrec* ((E2d9d@build-error (lambda (E2dd4@ae) (list '(primitive error) ''apply (list 'quote '"invalid arg count")))) (E2d9f@build-pred (lambda (E2dbc@ae E2dbd@n E2dbe@vars) (call-with-values (lambda () (let E2dca@f ((E2dc6@vars E2dbe@vars) (E2dc7@count '0)) (if (pair? E2dc6@vars) (E2dca@f (cdr E2dc6@vars) (+ E2dc7@count '1)) (if (null? E2dc6@vars) (values E2dc7@count '=) (values E2dc7@count '>=))))) (lambda (E2dcc@E2dc3 E2dcd@E2dc5) (let ((E2dd0@pred E2dcd@E2dc5) (E2dd1@count E2dcc@E2dc3)) (list (list 'primitive E2dd0@pred) E2dbd@n (list 'quote E2dd1@count))))))) (E2da1@build-apply (lambda (E2db4@ae E2db5@g E2db6@vars E2db7@exp) (list '(primitive apply) (E2d4f@build-lambda E2db4@ae E2db6@vars E2db7@exp) E2db5@g))) (E2da3@expand-case-lambda (lambda (E2da4@ae E2da5@vars E2da6@exp*) (let ((E2daa@g (gensym)) (E2dab@n (gensym))) (list 'lambda E2daa@g (E2d85@build-let E2da4@ae (list E2dab@n) (list (list '(primitive length) E2daa@g)) (let E2db2@f ((E2dae@vars* E2d97@vars*) (E2daf@exp* E2da6@exp*)) (if (null? E2dae@vars*) (E2d9d@build-error E2da4@ae) (list 'if (E2d9f@build-pred E2da4@ae E2dab@n (car E2dae@vars*)) (E2da1@build-apply E2da4@ae E2daa@g (car E2dae@vars*) (car E2daf@exp*)) (E2db2@f (cdr E2dae@vars*) (cdr E2daf@exp*))))))))))) (if (= (length E2d98@exp*) '1) (E2d4f@build-lambda E2d96@ae (car E2d97@vars*) (car E2d98@exp*)) (E2da3@expand-case-lambda E2d96@ae E2d97@vars* E2d98@exp*))))) (set! E2e1e@E2d51@build-case-lambda E2d51@build-case-lambda) (set! E2d7f@build-sequence (lambda (E2dd6@ae E2dd7@exps) (let E2ddc@loop ((E2dda@exps E2dd7@exps)) (if (null? (cdr E2dda@exps)) (car E2dda@exps) (if (equal? (car E2dda@exps) (E2d81@build-void)) (E2ddc@loop (cdr E2dda@exps)) (cons 'begin E2dda@exps)))))) (set! E2e1f@E2d7f@build-sequence E2d7f@build-sequence) (set! E2d81@build-void (lambda () '((primitive void)))) (set! E2e20@E2d81@build-void E2d81@build-void) (set! E2d83@build-letrec (lambda (E2dde@ae E2ddf@vars E2de0@val-exps E2de1@body-exp) (if (null? E2ddf@vars) E2de1@body-exp (list 'letrec (map list E2ddf@vars E2de0@val-exps) E2de1@body-exp)))) (set! E2e21@E2d83@build-letrec E2d83@build-letrec) (set! E2d85@build-let (lambda (E2de6@ae E2de7@vars E2de8@val-exps E2de9@body-exp) (if (null? E2de7@vars) E2de9@body-exp (list 'let (map list E2de7@vars E2de8@val-exps) E2de9@body-exp)))) (set! E2e22@E2d85@build-let E2d85@build-let) (set! E2d87@build-named-let (lambda (E2dee@ae E2def@name E2df0@vars E2df1@val-exps E2df2@body-exp) (list 'let E2def@name (map list E2df0@vars E2df1@val-exps) E2df2@body-exp))) (set! E2e23@E2d87@build-named-let E2d87@build-named-let) (set! E2d89@build-letrec* (lambda (E2df8@ae E2df9@vars E2dfa@val-exps E2dfb@body-exp) (if (null? E2df9@vars) E2dfb@body-exp (list 'letrec* (map list E2df9@vars E2dfa@val-exps) E2dfb@body-exp)))) (set! E2e24@E2d89@build-letrec* E2d89@build-letrec*) (set! E2d8b@build-library-letrec* (lambda (E2e00@ae E2e01@name E2e02@vars E2e03@locs E2e04@val-exps E2e05@body-exp) (cons 'begin (append (map (lambda (E2e0c@var) (cons 'set! (cons E2e0c@var '((unspecified))))) E2e02@vars) (append (apply append (map (lambda (E2e0e@var E2e0f@loc E2e10@val-exp) (list (list 'set! E2e0e@var E2e10@val-exp) (list 'set! E2e0f@loc E2e0e@var))) E2e02@vars E2e03@locs E2e04@val-exps)) (list E2e05@body-exp)))))) (set! E2e25@E2d8b@build-library-letrec* E2d8b@build-library-letrec*) (set! E2d8d@build-receive (lambda (E2e14@ae E2e15@vars E2e16@producer E2e17@body*) (begin (display '"************** in ") (cons 'receive (cons E2e15@vars (cons E2e16@producer E2e17@body*)))))) (set! E2e26@E2d8d@build-receive E2d8d@build-receive) (void))
(begin (set! E2e35@file-options-macro (unspecified)) (set! E2e37@set-cons (unspecified)) (set! E2e39@set-union (unspecified)) (set! E2e3e@top-mark* (unspecified)) (set! E2e40@top-marked? (unspecified)) (set! E2e42@gen-lexical (unspecified)) (set! E2e44@gen-global (unspecified)) (set! E2e46@gen-label (unspecified)) (set! E2e48@gen-top-level-label (unspecified)) (set! E2e4a@gen-define-label+loc (unspecified)) (set! E2e4c@gen-define-label (unspecified)) (set! E2e56@rib? (unspecified)) (set! E2e58@rib-sym* (unspecified)) (set! E2e5a@set-rib-sym*! (unspecified)) (set! E2e5c@rib-mark** (unspecified)) (set! E2e5e@set-rib-mark**! (unspecified)) (set! E2e60@rib-label* (unspecified)) (set! E2e62@set-rib-label*! (unspecified)) (set! E2e64@rib-sealed/freq (unspecified)) (set! E2e66@set-rib-sealed/freq! (unspecified)) (set! E2e68@rib-cache (unspecified)) (set! E2e6a@set-rib-cache! (unspecified)) (set! E2e6c@dummy (unspecified)) (set! E2e6e@make-empty-rib (unspecified)) (set! E2e70@extend-rib! (unspecified)) (set! E2e72@extend-rib/nc! (unspecified)) (set! E2e74@make-rib-map (unspecified)) (set! E2e76@seal-rib! (unspecified)) (set! E2e78@unseal-rib! (unspecified)) (set! E2e7a@make-full-rib (unspecified)) (set! E2e7c@rp (unspecified)) (set! E2e86@stx? (unspecified)) (set! E2e88@stx-expr (unspecified)) (set! E2e8a@set-stx-expr! (unspecified)) (set! E2e8c@stx-mark* (unspecified)) (set! E2e8e@set-stx-mark*! (unspecified)) (set! E2e90@stx-subst* (unspecified)) (set! E2e92@set-stx-subst*! (unspecified)) (set! E2e94@stx-ae* (unspecified)) (set! E2e96@set-stx-ae*! (unspecified)) (set! E2e98@dummy (unspecified)) (set! E2e9a@datum->stx (unspecified)) (set! E2e9c@gen-mark (unspecified)) (set! E2e9e@anti-mark (unspecified)) (set! E2ea0@anti-mark? (unspecified)) (set! E2ea2@mkstx (unspecified)) (set! E2ea4@add-mark (unspecified)) (set! E2ea6@add-subst (unspecified)) (set! E2ea8@syntax-kind? (unspecified)) (set! E2eaa@syntax-vector->list (unspecified)) (set! E2eac@syntax-pair? (unspecified)) (set! E2eae@syntax-vector? (unspecified)) (set! E2eb0@syntax-null? (unspecified)) (set! E2eb2@syntax-list? (unspecified)) (set! E2eb4@syntax-car (unspecified)) (set! E2eb6@syntax-cdr (unspecified)) (set! E2eb8@syntax->list (unspecified)) (set! E2eba@id? (unspecified)) (set! E2ebc@id->sym (unspecified)) (set! E2ebe@bound-id=? (unspecified)) (set! E2ec0@free-id=? (unspecified)) (set! E2ec2@valid-bound-ids? (unspecified)) (set! E2ec4@distinct-bound-ids? (unspecified)) (set! E2ec6@bound-id-member? (unspecified)) (set! E2ec8@self-evaluating? (unspecified)) (set! E2eca@strip-annotations (unspecified)) (set! E2ecc@strip (unspecified)) (set! E2ece@stx->datum (unspecified)) (set! E2ed0@id->label (unspecified)) (set! E2ed2@label->binding (unspecified)) (set! E2ed4@make-binding (unspecified)) (set! E2ed6@binding-type (unspecified)) (set! E2ed8@binding-value (unspecified)) (set! E2eda@raise-unbound-error (unspecified)) (set! E2edc@syntax-type (unspecified)) (set! E2eea@sanitize-binding (unspecified)) (set! E2eec@make-variable-transformer (unspecified)) (set! E2eee@variable-transformer? (unspecified)) (set! E2ef0@variable-transformer-procedure (unspecified)) (set! E2ef2@make-eval-transformer (unspecified)) (set! E3043@parse-define (unspecified)) (set! E3045@parse-define-syntax (unspecified)) (set! E3047@scheme-stx-hashtable (unspecified)) (set! E3049@scheme-stx (unspecified)) (set! E304b@lexical-var (unspecified)) (set! E304d@lexical-mutable? (unspecified)) (set! E304f@set-lexical-mutable! (unspecified)) (set! E3051@add-lexical (unspecified)) (set! E3053@add-lexicals (unspecified)) (set! E3055@letrec-helper (unspecified)) (set! E3057@let-transformer (unspecified)) (set! E3059@letrec-transformer (unspecified)) (set! E305b@letrec*-transformer (unspecified)) (set! E305d@fluid-let-syntax-transformer (unspecified)) (set! E305f@type-descriptor-transformer (unspecified)) (set! E3061@record-type-descriptor-transformer (unspecified)) (set! E3063@record-constructor-descriptor-transformer (unspecified)) (set! E3065@when-macro (unspecified)) (set! E3067@unless-macro (unspecified)) (set! E3069@if-transformer (unspecified)) (set! E306b@and-transformer (unspecified)) (set! E306d@or-transformer (unspecified)) (set! E306f@case-macro (unspecified)) (set! E3071@quote-transformer (unspecified)) (set! E3073@case-lambda-transformer (unspecified)) (set! E3075@lambda-transformer (unspecified)) (set! E3077@bless (unspecified)) (set! E3079@with-syntax-macro (unspecified)) (set! E307b@invalid-fmls-error (unspecified)) (set! E307d@let-macro (unspecified)) (set! E307f@let-values-macro (unspecified)) (set! E3081@let*-values-macro (unspecified)) (set! E3083@trace-lambda-macro (unspecified)) (set! E3085@trace-define-macro (unspecified)) (set! E3087@trace-define-syntax-macro (unspecified)) (set! E3089@trace-let/rec-syntax (unspecified)) (set! E308b@trace-let-syntax-macro (unspecified)) (set! E308d@trace-letrec-syntax-macro (unspecified)) (set! E308f@guard-macro (unspecified)) (set! E3091@define-enumeration-macro (unspecified)) (set! E3093@time-macro (unspecified)) (set! E3095@delay-macro (unspecified)) (set! E3097@assert-macro (unspecified)) (set! E3099@endianness-macro (unspecified)) (set! E309b@identifier-syntax-macro (unspecified)) (set! E309d@do-macro (unspecified)) (set! E309f@let*-macro (unspecified)) (set! E30a1@or-macro (unspecified)) (set! E30a3@and-macro (unspecified)) (set! E30a5@cond-macro (unspecified)) (set! E30a7@do-include (unspecified)) (set! E30a9@include-macro (unspecified)) (set! E30ab@include-into-macro (unspecified)) (set! E30ad@syntax-rules-macro (unspecified)) (set! E30af@quasiquote-macro (unspecified)) (set! E30b1@quasisyntax-macro (unspecified)) (set! E30b3@define-struct-macro (unspecified)) (set! E30b5@define-record-type-macro (unspecified)) (set! E30b7@define-condition-type-macro (unspecified)) (set! E30b9@incorrect-usage-macro (unspecified)) (set! E30bb@parameterize-macro (unspecified)) (set! E30bd@foreign-call-transformer (unspecified)) (set! E30bf@convert-pattern (unspecified)) (set! E30c1@syntax-dispatch (unspecified)) (set! E30c3@ellipsis? (unspecified)) (set! E30c5@underscore? (unspecified)) (set! E30c7@verify-literals (unspecified)) (set! E30c9@syntax-case-transformer (unspecified)) (set! E30cb@ellipsis-map (unspecified)) (set! E30cd@syntax-transformer (unspecified)) (set! E30cf@core-macro-transformer (unspecified)) (set! E30d1@symbol-macro (unspecified)) (set! E30d3@macro-transformer (unspecified)) (set! E30d5@local-macro-transformer (unspecified)) (set! E30d7@do-macro-call (unspecified)) (set! E30d9@chi-macro (unspecified)) (set! E30db@chi-local-macro (unspecified)) (set! E30dd@chi-global-macro (unspecified)) (set! E30df@chi-expr* (unspecified)) (set! E30e1@chi-application (unspecified)) (set! E30e3@chi-expr (unspecified)) (set! E30e5@chi-set! (unspecified)) (set! E30e7@verify-formals (unspecified)) (set! E30e9@chi-lambda-clause (unspecified)) (set! E30eb@chi-lambda-clause* (unspecified)) (set! E30ed@chi-defun (unspecified)) (set! E30ef@chi-rhs (unspecified)) (set! E30f1@expand-interaction-rhs*/init* (unspecified)) (set! E30f3@chi-rhs* (unspecified)) (set! E30f5@find-bound=? (unspecified)) (set! E30f7@find-dups (unspecified)) (set! E30f9@chi-internal (unspecified)) (set! E30fb@parse-module (unspecified)) (set! E3105@module-interface? (unspecified)) (set! E3107@module-interface-first-mark (unspecified)) (set! E3109@set-module-interface-first-mark! (unspecified)) (set! E310b@module-interface-exp-id-vec (unspecified)) (set! E310d@set-module-interface-exp-id-vec! (unspecified)) (set! E310f@module-interface-exp-lab-vec (unspecified)) (set! E3111@set-module-interface-exp-lab-vec! (unspecified)) (set! E3113@dummy (unspecified)) (set! E3115@module-interface-exp-id* (unspecified)) (set! E3117@chi-internal-module (unspecified)) (set! E3119@chi-body* (unspecified)) (set! E311b@expand-transformer (unspecified)) (set! E311d@parse-exports (unspecified)) (set! E311f@parse-library-name (unspecified)) (set! E3121@parse-library (unspecified)) (set! E3123@parse-import-spec* (unspecified)) (set! E3125@make-top-rib (unspecified)) (set! E3127@make-collector (unspecified)) (set! E3129@inv-collector (unspecified)) (set! E312b@vis-collector (unspecified)) (set! E312d@imp-collector (unspecified)) (set! E312f@chi-library-internal (unspecified)) (set! E3131@chi-interaction-expr (unspecified)) (set! E3133@library-body-expander (unspecified)) (set! E3135@core-library-expander (unspecified)) (set! E3137@parse-top-level-program (unspecified)) (set! E3139@top-level-expander (unspecified)) (set! E313b@rp (unspecified)) (set! E3145@env? (unspecified)) (set! E3147@env-names (unspecified)) (set! E3149@set-env-names! (unspecified)) (set! E314b@env-labels (unspecified)) (set! E314d@set-env-labels! (unspecified)) (set! E314f@env-itc (unspecified)) (set! E3151@set-env-itc! (unspecified)) (set! E3153@dummy (unspecified)) (set! E3155@rp (unspecified)) (set! E315f@interaction-env? (unspecified)) (set! E3161@interaction-env-rib (unspecified)) (set! E3163@set-interaction-env-rib! (unspecified)) (set! E3165@interaction-env-r (unspecified)) (set! E3167@set-interaction-env-r! (unspecified)) (set! E3169@interaction-env-locs (unspecified)) (set! E316b@set-interaction-env-locs! (unspecified)) (set! E316d@dummy (unspecified)) (set! E316f@interaction-environment-symbols (unspecified)) (set! E3171@environment-bindings (unspecified)) (set! E3173@parse-binding (unspecified)) (set! E3175@environment? (unspecified)) (set! E3177@environment-symbols (unspecified)) (set! E3179@environment (unspecified)) (set! E317b@null-environment (unspecified)) (set! E317d@scheme-report-environment (unspecified)) (set! E317f@expand (unspecified)) (set! E3181@eval (unspecified)) (set! E3183@library-expander (unspecified)) (set! E3185@boot-library-expand (unspecified)) (set! E3187@rev-map-append (unspecified)) (set! E3189@build-exports (unspecified)) (set! E318b@make-export-subst (unspecified)) (set! E318d@make-export-env/macros (unspecified)) (set! E318f@generate-temporaries (unspecified)) (set! E3191@free-identifier=? (unspecified)) (set! E3193@bound-identifier=? (unspecified)) (set! E3195@make-source-condition (unspecified)) (set! E3197@extract-position-condition (unspecified)) (set! E3199@expression-position (unspecified)) (set! E319b@assertion-error (unspecified)) (set! E319d@syntax-error (unspecified)) (set! E319f@syntax-violation* (unspecified)) (set! E31a1@syntax-violation (unspecified)) (set! E31a3@identifier? (unspecified)) (set! E31a5@datum->syntax (unspecified)) (set! E31a7@syntax->datum (unspecified)) (set! E31a9@ungensym-all (unspecified)) (set! E31ab@compile-r6rs-top-level (unspecified)) (set! E31ad@pre-compile-r6rs-top-level (unspecified)) (set! E31af@interaction-environment (unspecified)) (set! E31b1@top-level-context (unspecified)) (set! E2e35@file-options-macro (lambda (E31b2@x) (letrec* ((E31b5@valid-option? (lambda (E31be@x) (and (E2eba@id? E31be@x) (memq (E2ebc@id->sym E31be@x) '(no-fail no-create no-truncate)))))) (let ((E31b6@t E31b2@x)) (let ((E31b8@ls/false (E30c1@syntax-dispatch E31b6@t '(_ . each-any)))) (if (and E31b8@ls/false (apply (lambda (E31ba@opt*) (for-all E31b5@valid-option? E31ba@opt*)) E31b8@ls/false)) (apply (lambda (E31bc@opt*) (E3077@bless (list 'make-file-options (list 'quote E31bc@opt*)))) E31b8@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E31b6@t))))))) (set! E4b08@E2e35@file-options-macro E2e35@file-options-macro) (set! E2e37@set-cons (lambda (E31c0@x E31c1@ls) (if (memq E31c0@x E31c1@ls) E31c1@ls (cons E31c0@x E31c1@ls)))) (set! E4b09@E2e37@set-cons E2e37@set-cons) (set! E2e39@set-union (lambda (E31c4@ls1 E31c5@ls2) (if (null? E31c4@ls1) E31c5@ls2 (if (memq (car E31c4@ls1) E31c5@ls2) (E2e39@set-union (cdr E31c4@ls1) E31c5@ls2) (cons (car E31c4@ls1) (E2e39@set-union (cdr E31c4@ls1) E31c5@ls2)))))) (set! E4b0a@E2e39@set-union E2e39@set-union) (set! E2e3e@top-mark* '(top)) (set! E4b0b@E2e3e@top-mark* E2e3e@top-mark*) (set! E2e40@top-marked? (lambda (E31c8@m*) (memq 'top E31c8@m*))) (set! E4b0c@E2e40@top-marked? E2e40@top-marked?) (set! E2e42@gen-lexical (lambda (E31ca@sym) (if (symbol? E31ca@sym) (gensym E31ca@sym) (if (E2e86@stx? E31ca@sym) (E2e42@gen-lexical (E2ebc@id->sym E31ca@sym)) (assertion-violation 'gen-lexical '"BUG: invalid arg" E31ca@sym))))) (set! E4b0d@E2e42@gen-lexical E2e42@gen-lexical) (set! E2e44@gen-global (lambda (E31cc@x) (E2e42@gen-lexical E31cc@x))) (set! E4b0e@E2e44@gen-global E2e44@gen-global) (set! E2e46@gen-label (lambda (E31ce@_) (gensym))) (set! E4b0f@E2e46@gen-label E2e46@gen-label) (set! E2e48@gen-top-level-label (lambda (E31d0@id E31d1@rib) (letrec* ((E31d5@find (lambda (E31e0@sym E31e1@mark* E31e2@sym* E31e3@mark** E31e4@label*) (and (pair? E31e2@sym*) (if (and (eq? E31e0@sym (car E31e2@sym*)) (same-marks? E31e1@mark* (car E31e3@mark**))) (car E31e4@label*) (E31d5@find E31e0@sym E31e1@mark* (cdr E31e2@sym*) (cdr E31e3@mark**) (cdr E31e4@label*))))))) (let ((E31d6@sym (E2ebc@id->sym E31d0@id)) (E31d7@mark* (E2e8c@stx-mark* E31d0@id))) (let ((E31da@sym* (E2e58@rib-sym* E31d1@rib))) (let ((E31dc@t (and (memq E31d6@sym (E2e58@rib-sym* E31d1@rib)) (E31d5@find E31d6@sym E31d7@mark* E31da@sym* (E2e5c@rib-mark** E31d1@rib) (E2e60@rib-label* E31d1@rib))))) (if E31dc@t ((lambda (E31de@label) (if (E2cd5@E2b22@imported-label->binding E31de@label) (gensym) E31de@label)) E31dc@t) (gensym)))))))) (set! E4b10@E2e48@gen-top-level-label E2e48@gen-top-level-label) (set! E2e4a@gen-define-label+loc (lambda (E31ea@id E31eb@rib) (let ((E31ee@t (E31b1@top-level-context))) (if E31ee@t ((lambda (E31f0@env) (let ((E31f2@label (E2e48@gen-top-level-label E31ea@id E31eb@rib)) (E31f3@locs (E3169@interaction-env-locs E31f0@env))) (values E31f2@label (let ((E31f6@t (assq E31f2@label E31f3@locs))) (if E31f6@t (cdr E31f6@t) (let ((E31f8@loc (E2e42@gen-lexical E31ea@id))) (begin (E316b@set-interaction-env-locs! E31f0@env (cons (cons E31f2@label E31f8@loc) E31f3@locs)) E31f8@loc))))))) E31ee@t) (values (gensym) (E2e42@gen-lexical E31ea@id)))))) (set! E4b11@E2e4a@gen-define-label+loc E2e4a@gen-define-label+loc) (set! E2e4c@gen-define-label (lambda (E31fa@id E31fb@rib) (if (E31b1@top-level-context) (E2e48@gen-top-level-label E31fa@id E31fb@rib) (gensym)))) (set! E4b12@E2e4c@gen-define-label E2e4c@gen-define-label) (set! E2e56@rib? (lambda (E31fe@x) (and (simple-struct? E31fe@x) (eq? (simple-struct-name E31fe@x) 'rib)))) (set! E4b13@E2e56@rib? E2e56@rib?) (set! E2e58@rib-sym* (lambda (E3200@x) (simple-struct-ref E3200@x '0))) (set! E4b14@E2e58@rib-sym* E2e58@rib-sym*) (set! E2e5a@set-rib-sym*! (lambda (E3202@x E3203@val) (simple-struct-set! E3202@x '0 E3203@val))) (set! E4b15@E2e5a@set-rib-sym*! E2e5a@set-rib-sym*!) (set! E2e5c@rib-mark** (lambda (E3206@x) (simple-struct-ref E3206@x '1))) (set! E4b16@E2e5c@rib-mark** E2e5c@rib-mark**) (set! E2e5e@set-rib-mark**! (lambda (E3208@x E3209@val) (simple-struct-set! E3208@x '1 E3209@val))) (set! E4b17@E2e5e@set-rib-mark**! E2e5e@set-rib-mark**!) (set! E2e60@rib-label* (lambda (E320c@x) (simple-struct-ref E320c@x '2))) (set! E4b18@E2e60@rib-label* E2e60@rib-label*) (set! E2e62@set-rib-label*! (lambda (E320e@x E320f@val) (simple-struct-set! E320e@x '2 E320f@val))) (set! E4b19@E2e62@set-rib-label*! E2e62@set-rib-label*!) (set! E2e64@rib-sealed/freq (lambda (E3212@x) (simple-struct-ref E3212@x '3))) (set! E4b1a@E2e64@rib-sealed/freq E2e64@rib-sealed/freq) (set! E2e66@set-rib-sealed/freq! (lambda (E3214@x E3215@val) (simple-struct-set! E3214@x '3 E3215@val))) (set! E4b1b@E2e66@set-rib-sealed/freq! E2e66@set-rib-sealed/freq!) (set! E2e68@rib-cache (lambda (E3218@x) (simple-struct-ref E3218@x '4))) (set! E4b1c@E2e68@rib-cache E2e68@rib-cache) (set! E2e6a@set-rib-cache! (lambda (E321a@x E321b@val) (simple-struct-set! E321a@x '4 E321b@val))) (set! E4b1d@E2e6a@set-rib-cache! E2e6a@set-rib-cache!) (set! E2e6c@dummy '3) (set! E4b1e@E2e6c@dummy E2e6c@dummy) (set! E2e6e@make-empty-rib (lambda () (make-simple-struct 'rib '6 (list '() '() '() '#f '#f)))) (set! E4b1f@E2e6e@make-empty-rib E2e6e@make-empty-rib) (set! E2e70@extend-rib! (lambda (E321e@rib E321f@id E3220@label) (letrec* ((E3225@find (lambda (E3232@sym E3233@mark* E3234@sym* E3235@mark** E3236@label*) (and (pair? E3234@sym*) (if (and (eq? E3232@sym (car E3234@sym*)) (same-marks? E3233@mark* (car E3235@mark**))) E3236@label* (E3225@find E3232@sym E3233@mark* (cdr E3234@sym*) (cdr E3235@mark**) (cdr E3236@label*))))))) (begin (if (E2e64@rib-sealed/freq E321e@rib) (assertion-violation 'extend-rib! '"BUG: rib is sealed" E321e@rib) (void)) (let ((E3226@sym (E2ebc@id->sym E321f@id)) (E3227@mark* (E2e8c@stx-mark* E321f@id))) (let ((E322a@sym* (E2e58@rib-sym* E321e@rib))) (let ((E322c@t (and (memq E3226@sym (E2e58@rib-sym* E321e@rib)) (E3225@find E3226@sym E3227@mark* E322a@sym* (E2e5c@rib-mark** E321e@rib) (E2e60@rib-label* E321e@rib))))) (if E322c@t ((lambda (E322e@p) (if (not (eq? E3220@label (car E322e@p))) (if (E31b1@top-level-context) (set-car! E322e@p E3220@label) (E31a1@syntax-violation '#f '"multiple definitions of identifier" E321f@id)) (void))) E322c@t) (begin (if (E2e68@rib-cache E321e@rib) (hashtable-update! (E2e68@rib-cache E321e@rib) E3226@sym (lambda (E3230@e) (cons (cons E3227@mark* E3220@label) E3230@e)) '()) (void)) (E2e5a@set-rib-sym*! E321e@rib (cons E3226@sym E322a@sym*)) (E2e5e@set-rib-mark**! E321e@rib (cons E3227@mark* (E2e5c@rib-mark** E321e@rib))) (E2e62@set-rib-label*! E321e@rib (cons E3220@label (E2e60@rib-label* E321e@rib)))))))))))) (set! E4b20@E2e70@extend-rib! E2e70@extend-rib!) (set! E2e72@extend-rib/nc! (lambda (E323c@rib E323d@id E323e@label) (let ((E3242@sym (E2ebc@id->sym E323d@id)) (E3243@mark* (E2e8c@stx-mark* E323d@id))) (let ((E3246@sym* (E2e58@rib-sym* E323c@rib))) (begin (if (E2e68@rib-cache E323c@rib) (hashtable-update! (E2e68@rib-cache E323c@rib) E3242@sym (lambda (E3248@e) (cons (cons E3243@mark* E323e@label) E3248@e)) '()) (void)) (E2e5a@set-rib-sym*! E323c@rib (cons E3242@sym E3246@sym*)) (E2e5e@set-rib-mark**! E323c@rib (cons E3243@mark* (E2e5c@rib-mark** E323c@rib))) (E2e62@set-rib-label*! E323c@rib (cons E323e@label (E2e60@rib-label* E323c@rib)))))))) (set! E4b21@E2e72@extend-rib/nc! E2e72@extend-rib/nc!) (set! E2e74@make-rib-map (lambda (E324a@sym*) (let ((E324c@ht (make-eq-hashtable))) (let E3252@f ((E324e@i '0) (E324f@sym* E324a@sym*)) (if (null? E324f@sym*) E324c@ht (begin (hashtable-update! E324c@ht (car E324f@sym*) (lambda (E3254@x) (cons E324e@i E3254@x)) '()) (E3252@f (+ E324e@i '1) (cdr E324f@sym*)))))))) (set! E4b22@E2e74@make-rib-map E2e74@make-rib-map) (set! E2e76@seal-rib! (lambda (E3256@rib) (let ((E3258@sym* (E2e58@rib-sym* E3256@rib))) (if (not (null? E3258@sym*)) (begin (E2e5a@set-rib-sym*! E3256@rib (list->vector E3258@sym*)) (E2e5e@set-rib-mark**! E3256@rib (list->vector (E2e5c@rib-mark** E3256@rib))) (E2e62@set-rib-label*! E3256@rib (list->vector (E2e60@rib-label* E3256@rib))) (E2e66@set-rib-sealed/freq! E3256@rib (E2e74@make-rib-map E3258@sym*))) (void))))) (set! E4b23@E2e76@seal-rib! E2e76@seal-rib!) (set! E2e78@unseal-rib! (lambda (E325a@rib) (if (E2e64@rib-sealed/freq E325a@rib) (begin (E2e66@set-rib-sealed/freq! E325a@rib '#f) (E2e5a@set-rib-sym*! E325a@rib (vector->list (E2e58@rib-sym* E325a@rib))) (E2e5e@set-rib-mark**! E325a@rib (vector->list (E2e5c@rib-mark** E325a@rib))) (E2e62@set-rib-label*! E325a@rib (vector->list (E2e60@rib-label* E325a@rib)))) (void)))) (set! E4b24@E2e78@unseal-rib! E2e78@unseal-rib!) (set! E2e7a@make-full-rib (lambda (E325c@id* E325d@label*) (let ((E3260@r (make-simple-struct 'rib '6 (list (map E2ebc@id->sym E325c@id*) (map E2e8c@stx-mark* E325c@id*) E325d@label* '#f '#f)))) (begin (E2e76@seal-rib! E3260@r) E3260@r)))) (set! E4b25@E2e7a@make-full-rib E2e7a@make-full-rib) (set! E2e7c@rp (E2a07@E28e2@make-record-printer 'stx (lambda (E3262@x E3263@p E3264@wr) (begin (display '"#<syntax " E3263@p) (write (E2ece@stx->datum E3262@x) E3263@p) (let ((E3268@expr (E2e88@stx-expr E3262@x))) (if (E29fe@E28d0@annotation? E3268@expr) (let ((E326a@src (E29ff@E28d2@annotation-source E3268@expr))) (if (pair? E326a@src) (begin (display '" [" E3263@p) (display (cdr E326a@src) E3263@p) (display '" of " E3263@p) (display (car E326a@src) E3263@p) (display '"]" E3263@p)) (void))) (void))) (display '">" E3263@p))))) (set! E4b26@E2e7c@rp E2e7c@rp) (set! E2e86@stx? (lambda (E326c@x) (and (simple-struct? E326c@x) (eq? (simple-struct-name E326c@x) 'stx)))) (set! E4b27@E2e86@stx? E2e86@stx?) (set! E2e88@stx-expr (lambda (E326e@x) (simple-struct-ref E326e@x '0))) (set! E4b28@E2e88@stx-expr E2e88@stx-expr) (set! E2e8a@set-stx-expr! (lambda (E3270@x E3271@val) (simple-struct-set! E3270@x '0 E3271@val))) (set! E4b29@E2e8a@set-stx-expr! E2e8a@set-stx-expr!) (set! E2e8c@stx-mark* (lambda (E3274@x) (simple-struct-ref E3274@x '1))) (set! E4b2a@E2e8c@stx-mark* E2e8c@stx-mark*) (set! E2e8e@set-stx-mark*! (lambda (E3276@x E3277@val) (simple-struct-set! E3276@x '1 E3277@val))) (set! E4b2b@E2e8e@set-stx-mark*! E2e8e@set-stx-mark*!) (set! E2e90@stx-subst* (lambda (E327a@x) (simple-struct-ref E327a@x '2))) (set! E4b2c@E2e90@stx-subst* E2e90@stx-subst*) (set! E2e92@set-stx-subst*! (lambda (E327c@x E327d@val) (simple-struct-set! E327c@x '2 E327d@val))) (set! E4b2d@E2e92@set-stx-subst*! E2e92@set-stx-subst*!) (set! E2e94@stx-ae* (lambda (E3280@x) (simple-struct-ref E3280@x '3))) (set! E4b2e@E2e94@stx-ae* E2e94@stx-ae*) (set! E2e96@set-stx-ae*! (lambda (E3282@x E3283@val) (simple-struct-set! E3282@x '3 E3283@val))) (set! E4b2f@E2e96@set-stx-ae*! E2e96@set-stx-ae*!) (set! E2e98@dummy '3) (set! E4b30@E2e98@dummy E2e98@dummy) (set! E2e9a@datum->stx (lambda (E3286@id E3287@datum) (make-simple-struct 'stx '5 (list E3287@datum (E2e8c@stx-mark* E3286@id) (E2e90@stx-subst* E3286@id) (E2e94@stx-ae* E3286@id))))) (set! E4b31@E2e9a@datum->stx E2e9a@datum->stx) (set! E2e9c@gen-mark (lambda () (string '#\m))) (set! E4b32@E2e9c@gen-mark E2e9c@gen-mark) (set! E2e9e@anti-mark '#f) (set! E4b33@E2e9e@anti-mark E2e9e@anti-mark) (set! E2ea0@anti-mark? not) (set! E4b34@E2ea0@anti-mark? E2ea0@anti-mark?) (set! E2ea2@mkstx (lambda (E328a@e E328b@m* E328c@s* E328d@ae*) (if (and (E2e86@stx? E328a@e) (not (E2e40@top-marked? E328b@m*))) (call-with-values (lambda () (join-wraps E328b@m* E328c@s* E328d@ae* E328a@e)) (lambda (E3298@E3293 E3299@E3295 E329a@E3297) (let ((E329e@ae* E329a@E3297) (E329f@s* E3299@E3295) (E32a0@m* E3298@E3293)) (make-simple-struct 'stx '5 (list (E2e88@stx-expr E328a@e) E32a0@m* E329f@s* E329e@ae*))))) (make-simple-struct 'stx '5 (list E328a@e E328b@m* E328c@s* E328d@ae*))))) (set! E4b35@E2ea2@mkstx E2ea2@mkstx) (set! E2ea4@add-mark (lambda (E32a4@m E32a5@e E32a6@ae) (E2ea2@mkstx E32a5@e (list E32a4@m) '(shift) (list E32a6@ae)))) (set! E4b36@E2ea4@add-mark E2ea4@add-mark) (set! E2ea6@add-subst (lambda (E32aa@subst E32ab@e) (E2ea2@mkstx E32ab@e '() (list E32aa@subst) '()))) (set! E4b37@E2ea6@add-subst E2ea6@add-subst) (set! E2ea8@syntax-kind? (lambda (E32ae@x E32af@p?) (if (E2e86@stx? E32ae@x) (E2ea8@syntax-kind? (E2e88@stx-expr E32ae@x) E32af@p?) (if (E29fe@E28d0@annotation? E32ae@x) (E2ea8@syntax-kind? (E2a00@E28d4@annotation-expression E32ae@x) E32af@p?) (E32af@p? E32ae@x))))) (set! E4b38@E2ea8@syntax-kind? E2ea8@syntax-kind?) (set! E2eaa@syntax-vector->list (lambda (E32b2@x) (if (E2e86@stx? E32b2@x) (let ((E32b4@ls (E2eaa@syntax-vector->list (E2e88@stx-expr E32b2@x))) (E32b5@m* (E2e8c@stx-mark* E32b2@x)) (E32b6@s* (E2e90@stx-subst* E32b2@x)) (E32b7@ae* (E2e94@stx-ae* E32b2@x))) (map (lambda (E32bc@x) (E2ea2@mkstx E32bc@x E32b5@m* E32b6@s* E32b7@ae*)) E32b4@ls)) (if (E29fe@E28d0@annotation? E32b2@x) (E2eaa@syntax-vector->list (E2a00@E28d4@annotation-expression E32b2@x)) (if (vector? E32b2@x) (vector->list E32b2@x) (assertion-violation 'syntax-vector->list '"BUG: not a syntax vector" E32b2@x)))))) (set! E4b39@E2eaa@syntax-vector->list E2eaa@syntax-vector->list) (set! E2eac@syntax-pair? (lambda (E32be@x) (E2ea8@syntax-kind? E32be@x pair?))) (set! E4b3a@E2eac@syntax-pair? E2eac@syntax-pair?) (set! E2eae@syntax-vector? (lambda (E32c0@x) (E2ea8@syntax-kind? E32c0@x vector?))) (set! E4b3b@E2eae@syntax-vector? E2eae@syntax-vector?) (set! E2eb0@syntax-null? (lambda (E32c2@x) (E2ea8@syntax-kind? E32c2@x null?))) (set! E4b3c@E2eb0@syntax-null? E2eb0@syntax-null?) (set! E2eb2@syntax-list? (lambda (E32c4@x) (or (E2eb0@syntax-null? E32c4@x) (and (E2eac@syntax-pair? E32c4@x) (E2eb2@syntax-list? (E2eb6@syntax-cdr E32c4@x)))))) (set! E4b3d@E2eb2@syntax-list? E2eb2@syntax-list?) (set! E2eb4@syntax-car (lambda (E32c6@x) (if (E2e86@stx? E32c6@x) (E2ea2@mkstx (E2eb4@syntax-car (E2e88@stx-expr E32c6@x)) (E2e8c@stx-mark* E32c6@x) (E2e90@stx-subst* E32c6@x) (E2e94@stx-ae* E32c6@x)) (if (E29fe@E28d0@annotation? E32c6@x) (E2eb4@syntax-car (E2a00@E28d4@annotation-expression E32c6@x)) (if (pair? E32c6@x) (car E32c6@x) (assertion-violation 'syntax-car '"BUG: not a pair" E32c6@x)))))) (set! E4b3e@E2eb4@syntax-car E2eb4@syntax-car) (set! E2eb6@syntax-cdr (lambda (E32c8@x) (if (E2e86@stx? E32c8@x) (E2ea2@mkstx (E2eb6@syntax-cdr (E2e88@stx-expr E32c8@x)) (E2e8c@stx-mark* E32c8@x) (E2e90@stx-subst* E32c8@x) (E2e94@stx-ae* E32c8@x)) (if (E29fe@E28d0@annotation? E32c8@x) (E2eb6@syntax-cdr (E2a00@E28d4@annotation-expression E32c8@x)) (if (pair? E32c8@x) (cdr E32c8@x) (assertion-violation 'syntax-cdr '"BUG: not a pair" E32c8@x)))))) (set! E4b3f@E2eb6@syntax-cdr E2eb6@syntax-cdr) (set! E2eb8@syntax->list (lambda (E32ca@x) (if (E2eac@syntax-pair? E32ca@x) (cons (E2eb4@syntax-car E32ca@x) (E2eb8@syntax->list (E2eb6@syntax-cdr E32ca@x))) (if (E2eb0@syntax-null? E32ca@x) '() (assertion-violation 'syntax->list '"BUG: invalid argument" E32ca@x))))) (set! E4b40@E2eb8@syntax->list E2eb8@syntax->list) (set! E2eba@id? (lambda (E32cc@x) (and (E2e86@stx? E32cc@x) (symbol? (E2e88@stx-expr E32cc@x))))) (set! E4b41@E2eba@id? E2eba@id?) (set! E2ebc@id->sym (lambda (E32ce@x) (E2e88@stx-expr E32ce@x))) (set! E4b42@E2ebc@id->sym E2ebc@id->sym) (set! E2ebe@bound-id=? (lambda (E32d0@x E32d1@y) (and (eq? (E2ebc@id->sym E32d0@x) (E2ebc@id->sym E32d1@y)) (same-marks? (E2e8c@stx-mark* E32d0@x) (E2e8c@stx-mark* E32d1@y))))) (set! E4b43@E2ebe@bound-id=? E2ebe@bound-id=?) (set! E2ec0@free-id=? (lambda (E32d4@i E32d5@j) (let ((E32d8@t0 (id->real-label E32d4@i)) (E32d9@t1 (id->real-label E32d5@j))) (if (or E32d8@t0 E32d9@t1) (eq? E32d8@t0 E32d9@t1) (eq? (E2ebc@id->sym E32d4@i) (E2ebc@id->sym E32d5@j)))))) (set! E4b44@E2ec0@free-id=? E2ec0@free-id=?) (set! E2ec2@valid-bound-ids? (lambda (E32dc@id*) (and (for-all E2eba@id? E32dc@id*) (E2ec4@distinct-bound-ids? E32dc@id*)))) (set! E4b45@E2ec2@valid-bound-ids? E2ec2@valid-bound-ids?) (set! E2ec4@distinct-bound-ids? (lambda (E32de@id*) (or (null? E32de@id*) (and (not (E2ec6@bound-id-member? (car E32de@id*) (cdr E32de@id*))) (E2ec4@distinct-bound-ids? (cdr E32de@id*)))))) (set! E4b46@E2ec4@distinct-bound-ids? E2ec4@distinct-bound-ids?) (set! E2ec6@bound-id-member? (lambda (E32e0@id E32e1@id*) (and (pair? E32e1@id*) (or (E2ebe@bound-id=? E32e0@id (car E32e1@id*)) (E2ec6@bound-id-member? E32e0@id (cdr E32e1@id*)))))) (set! E4b47@E2ec6@bound-id-member? E2ec6@bound-id-member?) (set! E2ec8@self-evaluating? (lambda (E32e4@x) (or (number? E32e4@x) (string? E32e4@x) (char? E32e4@x) (boolean? E32e4@x) (regexp? E32e4@x) (bytevector? E32e4@x)))) (set! E4b48@E2ec8@self-evaluating? E2ec8@self-evaluating?) (set! E2eca@strip-annotations (lambda (E32e6@x) (if (pair? E32e6@x) (cons (E2eca@strip-annotations (car E32e6@x)) (E2eca@strip-annotations (cdr E32e6@x))) (if (vector? E32e6@x) (vector-map E2eca@strip-annotations E32e6@x) (if (E29fe@E28d0@annotation? E32e6@x) (E29fd@E28ce@annotation-stripped E32e6@x) E32e6@x))))) (set! E4b49@E2eca@strip-annotations E2eca@strip-annotations) (set! E2ecc@strip (lambda (E32e8@x E32e9@m*) (if (E2e40@top-marked? E32e9@m*) (if (or (E29fe@E28d0@annotation? E32e8@x) (and (pair? E32e8@x) (E29fe@E28d0@annotation? (car E32e8@x))) (and (vector? E32e8@x) (> (vector-length E32e8@x) '0) (E29fe@E28d0@annotation? (vector-ref E32e8@x '0)))) (E2eca@strip-annotations E32e8@x) E32e8@x) (let E32ee@f ((E32ec@x E32e8@x)) (if (E2e86@stx? E32ec@x) (begin (if (pair? (E2e88@stx-expr E32ec@x)) (begin (set-source-info! (E2e88@stx-expr E32ec@x) '#f) (set-source-info! (cdr (E2e88@stx-expr E32ec@x)) '#f) (set-source-info! (car (E2e88@stx-expr E32ec@x)) '#f)) (void)) (E2ecc@strip (E2e88@stx-expr E32ec@x) (E2e8c@stx-mark* E32ec@x))) (if (E29fe@E28d0@annotation? E32ec@x) (E29fd@E28ce@annotation-stripped E32ec@x) (if (pair? E32ec@x) (let ((E32f0@a (E32ee@f (car E32ec@x))) (E32f1@d (E32ee@f (cdr E32ec@x)))) (if (and (eq? E32f0@a (car E32ec@x)) (eq? E32f1@d (cdr E32ec@x))) E32ec@x (cons E32f0@a E32f1@d))) (if (vector? E32ec@x) (let ((E32f4@old (vector->list E32ec@x))) (let ((E32f6@new (map E32ee@f E32f4@old))) (if (for-all eq? E32f4@old E32f6@new) E32ec@x (list->vector E32f6@new)))) E32ec@x)))))))) (set! E4b4a@E2ecc@strip E2ecc@strip) (set! E2ece@stx->datum (lambda (E32f8@x) (E2ecc@strip E32f8@x '()))) (set! E4b4b@E2ece@stx->datum E2ece@stx->datum) (set! E2ed0@id->label (lambda (E32fa@id) (or (id->real-label E32fa@id) (let ((E32fc@t (E31b1@top-level-context))) (if E32fc@t ((lambda (E32fe@env) (let ((E3300@rib (E3161@interaction-env-rib E32fe@env))) (call-with-values (lambda () (E2e4a@gen-define-label+loc E32fa@id E3300@rib)) (lambda (E3306@E3303 E3307@E3305) (let ((E330a@loc_ E3307@E3305) (E330b@lab E3306@E3303)) (begin (E2e70@extend-rib! E3300@rib E32fa@id E330b@lab) E330b@lab)))))) E32fc@t) '#f))))) (set! E4b4c@E2ed0@id->label E2ed0@id->label) (set! E2ed2@label->binding (lambda (E330e@x E330f@r) (let ((E3312@t (E2cd5@E2b22@imported-label->binding E330e@x))) (if E3312@t ((lambda (E3314@b) (if (and (pair? E3314@b) (eq? (car E3314@b) '$core-rtd)) (cons '$rtd (map E3077@bless (cdr E3314@b))) (if (and (pair? E3314@b) (eq? (car E3314@b) 'global-rtd)) (let ((E3316@lib (cadr E3314@b)) (E3317@loc (cddr E3314@b))) (cons '$rtd (symbol-value E3317@loc))) E3314@b))) E3312@t) (let ((E331a@t (assq E330e@x E330f@r))) (if E331a@t (cdr E331a@t) (let ((E331c@t (E31b1@top-level-context))) (if E331c@t ((lambda (E331e@env) (let ((E3320@t (assq E330e@x (E3169@interaction-env-locs E331e@env)))) (if E3320@t ((lambda (E3322@p) (cons* 'lexical (cdr E3322@p) '#f)) E3320@t) '(displaced-lexical . #f)))) E331c@t) '(displaced-lexical . #f))))))))) (set! E4b4d@E2ed2@label->binding E2ed2@label->binding) (set! E2ed4@make-binding cons) (set! E4b4e@E2ed4@make-binding E2ed4@make-binding) (set! E2ed6@binding-type car) (set! E4b4f@E2ed6@binding-type E2ed6@binding-type) (set! E2ed8@binding-value cdr) (set! E4b50@E2ed8@binding-value E2ed8@binding-value) (set! E2eda@raise-unbound-error (lambda (E3324@id) (E319f@syntax-violation* '#f '"unbound identifier" E3324@id (make-undefined-violation)))) (set! E4b51@E2eda@raise-unbound-error E2eda@raise-unbound-error) (set! E2edc@syntax-type (lambda (E3326@e E3327@r) (if (E2eba@id? E3326@e) (let ((E332a@id E3326@e)) (let ((E332c@label (E2ed0@id->label E332a@id))) (let ((E332e@b (E2ed2@label->binding E332c@label E3327@r))) (let ((E3330@type (E2ed6@binding-type E332e@b))) (begin (if (not E332c@label) (E2eda@raise-unbound-error E332a@id) (void)) (let ((E3332@t E3330@type)) (if (memv E3332@t '(lexical core-prim macro macro! global local-macro local-macro! global-macro global-macro! displaced-lexical syntax import export $module $core-rtd library mutable)) (values E3330@type (E2ed8@binding-value E332e@b) E332a@id) (values 'other '#f '#f)))))))) (if (E2eac@syntax-pair? E3326@e) (let ((E3334@id (E2eb4@syntax-car E3326@e))) (if (E2eba@id? E3334@id) (let ((E3336@label (E2ed0@id->label E3334@id))) (let ((E3338@b (E2ed2@label->binding E3336@label E3327@r))) (let ((E333a@type (E2ed6@binding-type E3338@b))) (begin (if (not E3336@label) (E2eda@raise-unbound-error E3334@id) (void)) (let ((E333c@t E333a@type)) (if (memv E333c@t '(define define-syntax core-macro begin macro macro! local-macro local-macro! global-macro global-macro! module library set! let-syntax letrec-syntax import export $core-rtd)) (values E333a@type (E2ed8@binding-value E3338@b) E3334@id) (values 'call '#f '#f))))))) (values 'call '#f '#f))) (let ((E333e@d (E2ece@stx->datum E3326@e))) (if (E2ec8@self-evaluating? E333e@d) (values 'constant E333e@d '#f) (values 'other '#f '#f))))))) (set! E4b52@E2edc@syntax-type E2edc@syntax-type) (set! E2eea@sanitize-binding (lambda (E3340@x E3341@src) (if (procedure? E3340@x) (cons* 'local-macro E3340@x E3341@src) (if (and (pair? E3340@x) (eq? (car E3340@x) 'macro!) (procedure? (cdr E3340@x))) (cons* 'local-macro! (cdr E3340@x) E3341@src) (if (and (pair? E3340@x) (eq? (car E3340@x) '$rtd)) E3340@x (assertion-violation 'expand '"invalid transformer" E3340@x)))))) (set! E4b53@E2eea@sanitize-binding E2eea@sanitize-binding) (set! E2eec@make-variable-transformer (lambda (E3344@x) (if (procedure? E3344@x) (cons 'macro! E3344@x) (assertion-violation 'make-variable-transformer '"not a procedure" E3344@x)))) (set! E4b54@E2eec@make-variable-transformer E2eec@make-variable-transformer) (set! E2eee@variable-transformer? (lambda (E3346@x) (and (pair? E3346@x) (eq? (car E3346@x) 'macro!) (procedure? (cdr E3346@x))))) (set! E4b55@E2eee@variable-transformer? E2eee@variable-transformer?) (set! E2ef0@variable-transformer-procedure (lambda (E3348@x) (if (E2eee@variable-transformer? E3348@x) (cdr E3348@x) (assertion-violation 'variable-transformer-procedure '"not a variable transformer" E3348@x)))) (set! E4b56@E2ef0@variable-transformer-procedure E2ef0@variable-transformer-procedure) (set! E2ef2@make-eval-transformer (lambda (E334a@x) (E2eea@sanitize-binding (eval-core (E2a60@E2a18@expanded->core E334a@x)) E334a@x))) (set! E4b57@E2ef2@make-eval-transformer E2ef2@make-eval-transformer) (set! E3043@parse-define (lambda (E334c@x) (let ((E334e@t E334c@x)) (let ((E3350@ls/false (E30c1@syntax-dispatch E334e@t '(_ (any . any) any . each-any)))) (if (and E3350@ls/false (apply (lambda (E3352@id E3353@fmls E3354@b E3355@b*) (E2eba@id? E3352@id)) E3350@ls/false)) (apply (lambda (E335a@id E335b@fmls E335c@b E335d@b*) (begin (E30e7@verify-formals E335b@fmls E334c@x) (values E335a@id (cons 'defun (cons E335b@fmls (cons E335c@b E335d@b*)))))) E3350@ls/false) (let ((E3362@t E334e@t)) (let ((E3364@ls/false (E30c1@syntax-dispatch E3362@t '(_ any any)))) (if (and E3364@ls/false (apply (lambda (E3366@id E3367@val) (E2eba@id? E3366@id)) E3364@ls/false)) (apply (lambda (E336a@id E336b@val) (values E336a@id (cons 'expr E336b@val))) E3364@ls/false) (let ((E336e@t E3362@t)) (let ((E3370@ls/false (E30c1@syntax-dispatch E336e@t '(_ any)))) (if (and E3370@ls/false (apply (lambda (E3372@id) (E2eba@id? E3372@id)) E3370@ls/false)) (apply (lambda (E3374@id) (values E3374@id (cons 'expr (E3077@bless '(void))))) E3370@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E336e@t)))))))))))) (set! E4b58@E3043@parse-define E3043@parse-define) (set! E3045@parse-define-syntax (lambda (E3376@x) (let ((E3378@t E3376@x)) (let ((E337a@ls/false (E30c1@syntax-dispatch E3378@t '(_ any any)))) (if (and E337a@ls/false (apply (lambda (E337c@id E337d@val) (E2eba@id? E337c@id)) E337a@ls/false)) (apply (lambda (E3380@id E3381@val) (values E3380@id E3381@val)) E337a@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3378@t)))))) (set! E4b59@E3045@parse-define-syntax E3045@parse-define-syntax) (set! E3047@scheme-stx-hashtable (make-eq-hashtable)) (set! E4b5a@E3047@scheme-stx-hashtable E3047@scheme-stx-hashtable) (set! E3049@scheme-stx (lambda (E3384@sym) (or (hashtable-ref E3047@scheme-stx-hashtable E3384@sym '#f) (let ((E3386@subst (E2cb1@E2ada@library-subst (E2ccf@E2b16@find-library-by-name '(psyntax system $all))))) (let ((E3388@stx (make-simple-struct 'stx '5 (list E3384@sym E2e3e@top-mark* '() '())))) (let ((E338a@stx (let ((E338c@t (assq E3384@sym E3386@subst))) (if E338c@t ((lambda (E338e@x) (let ((E3390@name (car E338e@x)) (E3391@label (cdr E338e@x))) (E2ea6@add-subst (make-simple-struct 'rib '6 (list (list E3390@name) (list E2e3e@top-mark*) (list E3391@label) '#f '#f)) E3388@stx))) E338c@t) E3388@stx)))) (begin (hashtable-set! E3047@scheme-stx-hashtable E3384@sym E338a@stx) E338a@stx))))))) (set! E4b5b@E3049@scheme-stx E3049@scheme-stx) (set! E304b@lexical-var car) (set! E4b5c@E304b@lexical-var E304b@lexical-var) (set! E304d@lexical-mutable? cdr) (set! E4b5d@E304d@lexical-mutable? E304d@lexical-mutable?) (set! E304f@set-lexical-mutable! set-cdr!) (set! E4b5e@E304f@set-lexical-mutable! E304f@set-lexical-mutable!) (set! E3051@add-lexical (lambda (E3394@lab E3395@lex E3396@r) (cons (cons* E3394@lab 'lexical E3395@lex '#f) E3396@r))) (set! E4b5f@E3051@add-lexical E3051@add-lexical) (set! E3053@add-lexicals (lambda (E339a@lab* E339b@lex* E339c@r) (if (null? E339a@lab*) E339c@r (E3053@add-lexicals (cdr E339a@lab*) (cdr E339b@lex*) (E3051@add-lexical (car E339a@lab*) (car E339b@lex*) E339c@r))))) (set! E4b60@E3053@add-lexicals E3053@add-lexicals) (set! E3055@letrec-helper (lambda (E33a0@e E33a1@r E33a2@mr E33a3@build) (let ((E33a8@t E33a0@e)) (let ((E33aa@ls/false (E30c1@syntax-dispatch E33a8@t '(_ #(each (any any)) any . each-any)))) (if E33aa@ls/false (apply (lambda (E33ac@lhs* E33ad@rhs* E33ae@b E33af@b*) (if (not (E2ec2@valid-bound-ids? E33ac@lhs*)) (E307b@invalid-fmls-error E33a0@e E33ac@lhs*) (let ((E33b4@lex* (map E2e42@gen-lexical E33ac@lhs*)) (E33b5@lab* (map E2e46@gen-label E33ac@lhs*))) (let ((E33b8@rib (E2e7a@make-full-rib E33ac@lhs* E33b5@lab*)) (E33b9@r (E3053@add-lexicals E33b5@lab* E33b4@lex* E33a1@r))) (let ((E33bc@body (E30f9@chi-internal (E2ea6@add-subst E33b8@rib (cons E33ae@b E33af@b*)) E33b9@r E33a2@mr)) (E33bd@rhs* (E30df@chi-expr* (map (lambda (E33c0@x) (E2ea6@add-subst E33b8@rib E33c0@x)) E33ad@rhs*) E33b9@r E33a2@mr))) (E33a3@build '#f E33b4@lex* E33bd@rhs* E33bc@body)))))) E33aa@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E33a8@t)))))) (set! E4b61@E3055@letrec-helper E3055@letrec-helper) (set! E3057@let-transformer (lambda (E33c2@e E33c3@r E33c4@mr) (let ((E33c8@t E33c2@e)) (let ((E33ca@ls/false (E30c1@syntax-dispatch E33c8@t '(_ #(each (any any)) any . each-any)))) (if E33ca@ls/false (apply (lambda (E33cc@lhs* E33cd@rhs* E33ce@b E33cf@b*) (if (not (E2ec2@valid-bound-ids? E33cc@lhs*)) (E307b@invalid-fmls-error E33c2@e E33cc@lhs*) (let ((E33d4@lex* (map E2e42@gen-lexical E33cc@lhs*)) (E33d5@lab* (map E2e46@gen-label E33cc@lhs*)) (E33d6@rhs* (E30df@chi-expr* E33cd@rhs* E33c3@r E33c4@mr))) (let ((E33da@rib (E2e7a@make-full-rib E33cc@lhs* E33d5@lab*)) (E33db@r (E3053@add-lexicals E33d5@lab* E33d4@lex* E33c3@r))) (let ((E33de@body (E30f9@chi-internal (E2ea6@add-subst E33da@rib (cons E33ce@b E33cf@b*)) E33db@r E33c4@mr))) (E2e22@E2d85@build-let '#f E33d4@lex* E33d6@rhs* E33de@body)))))) E33ca@ls/false) (let ((E33e0@t E33c8@t)) (let ((E33e2@ls/false (E30c1@syntax-dispatch E33e0@t '(_ any #(each (any any)) any . each-any)))) (if E33e2@ls/false (apply (lambda (E33e4@loop E33e5@lhs* E33e6@rhs* E33e7@b E33e8@b*) (if (not (E2ec2@valid-bound-ids? E33e5@lhs*)) (E307b@invalid-fmls-error E33c2@e E33e5@lhs*) (let ((E33ee@lex* (map E2e42@gen-lexical E33e5@lhs*)) (E33ef@lab* (map E2e46@gen-label E33e5@lhs*)) (E33f0@rhs* (E30df@chi-expr* E33e6@rhs* E33c3@r E33c4@mr)) (E33f1@loop-lex (E2e42@gen-lexical E33e4@loop)) (E33f2@loop-lab (E2e46@gen-label E33e4@loop))) (let ((E33f8@loop-rib (E2e7a@make-full-rib (list E33e4@loop) (list E33f2@loop-lab))) (E33f9@rib (E2e7a@make-full-rib E33e5@lhs* E33ef@lab*)) (E33fa@r (E3053@add-lexicals (cons E33f2@loop-lab E33ef@lab*) (cons E33f1@loop-lex E33ee@lex*) E33c3@r))) (let ((E33fe@body (E30f9@chi-internal (E2ea6@add-subst E33f8@loop-rib (E2ea6@add-subst E33f9@rib (cons E33e7@b E33e8@b*))) E33fa@r E33c4@mr))) (E2e23@E2d87@build-named-let '#f E33f1@loop-lex E33ee@lex* E33f0@rhs* E33fe@body)))))) E33e2@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E33e0@t))))))))) (set! E4b62@E3057@let-transformer E3057@let-transformer) (set! E3059@letrec-transformer (lambda (E3400@e E3401@r E3402@mr) (E3055@letrec-helper E3400@e E3401@r E3402@mr E2e21@E2d83@build-letrec))) (set! E4b63@E3059@letrec-transformer E3059@letrec-transformer) (set! E305b@letrec*-transformer (lambda (E3406@e E3407@r E3408@mr) (E3055@letrec-helper E3406@e E3407@r E3408@mr E2e24@E2d89@build-letrec*))) (set! E4b64@E305b@letrec*-transformer E305b@letrec*-transformer) (set! E305d@fluid-let-syntax-transformer (lambda (E340c@e E340d@r E340e@mr) (letrec* ((E3413@lookup (lambda (E3426@x) (or (E2ed0@id->label E3426@x) (E31a1@syntax-violation '#f '"unbound identifier" E340c@e E3426@x))))) (let ((E3414@t E340c@e)) (let ((E3416@ls/false (E30c1@syntax-dispatch E3414@t '(_ #(each (any any)) any . each-any)))) (if E3416@ls/false (apply (lambda (E3418@lhs* E3419@rhs* E341a@b E341b@b*) (if (not (E2ec2@valid-bound-ids? E3418@lhs*)) (E307b@invalid-fmls-error E340c@e E3418@lhs*) (let ((E3420@lab* (map E3413@lookup E3418@lhs*)) (E3421@rhs* (map (lambda (E3424@x) (E2ef2@make-eval-transformer (E311b@expand-transformer E3424@x E340e@mr))) E3419@rhs*))) (E30f9@chi-internal (cons E341a@b E341b@b*) (append (map cons E3420@lab* E3421@rhs*) E340d@r) (append (map cons E3420@lab* E3421@rhs*) E340e@mr))))) E3416@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3414@t))))))) (set! E4b65@E305d@fluid-let-syntax-transformer E305d@fluid-let-syntax-transformer) (set! E305f@type-descriptor-transformer (lambda (E3428@e E3429@r E342a@mr) (let ((E342e@t E3428@e)) (let ((E3430@ls/false (E30c1@syntax-dispatch E342e@t '(_ any)))) (if (and E3430@ls/false (apply (lambda (E3432@id) (E2eba@id? E3432@id)) E3430@ls/false)) (apply (lambda (E3434@id) (let ((E3436@lab (E2ed0@id->label E3434@id))) (let ((E3438@b (E2ed2@label->binding E3436@lab E3429@r))) (let ((E343a@type (E2ed6@binding-type E3438@b))) (begin (if (not E3436@lab) (E2eda@raise-unbound-error E3434@id) (void)) (if (not (and (eq? E343a@type '$rtd) (not (list? (E2ed8@binding-value E3438@b))))) (E31a1@syntax-violation '#f '"not a record type" E3428@e) (void)) (list 'quote (E2ed8@binding-value E3438@b))))))) E3430@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E342e@t)))))) (set! E4b66@E305f@type-descriptor-transformer E305f@type-descriptor-transformer) (set! E3061@record-type-descriptor-transformer (lambda (E343c@e E343d@r E343e@mr) (let ((E3442@t E343c@e)) (let ((E3444@ls/false (E30c1@syntax-dispatch E3442@t '(_ any)))) (if (and E3444@ls/false (apply (lambda (E3446@id) (E2eba@id? E3446@id)) E3444@ls/false)) (apply (lambda (E3448@id) (let ((E344a@lab (E2ed0@id->label E3448@id))) (let ((E344c@b (E2ed2@label->binding E344a@lab E343d@r))) (let ((E344e@type (E2ed6@binding-type E344c@b))) (begin (if (not E344a@lab) (E2eda@raise-unbound-error E3448@id) (void)) (if (not (and (eq? E344e@type '$rtd) (list? (E2ed8@binding-value E344c@b)))) (E31a1@syntax-violation '#f '"not a record type" E343c@e) (void)) (E30e3@chi-expr (car (E2ed8@binding-value E344c@b)) E343d@r E343e@mr)))))) E3444@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3442@t)))))) (set! E4b67@E3061@record-type-descriptor-transformer E3061@record-type-descriptor-transformer) (set! E3063@record-constructor-descriptor-transformer (lambda (E3450@e E3451@r E3452@mr) (let ((E3456@t E3450@e)) (let ((E3458@ls/false (E30c1@syntax-dispatch E3456@t '(_ any)))) (if (and E3458@ls/false (apply (lambda (E345a@id) (E2eba@id? E345a@id)) E3458@ls/false)) (apply (lambda (E345c@id) (let ((E345e@lab (E2ed0@id->label E345c@id))) (let ((E3460@b (E2ed2@label->binding E345e@lab E3451@r))) (let ((E3462@type (E2ed6@binding-type E3460@b))) (begin (if (not E345e@lab) (E2eda@raise-unbound-error E345c@id) (void)) (if (not (and (eq? E3462@type '$rtd) (list? (E2ed8@binding-value E3460@b)))) (E31a1@syntax-violation '#f '"invalid type" E3450@e) (void)) (E30e3@chi-expr (cadr (E2ed8@binding-value E3460@b)) E3451@r E3452@mr)))))) E3458@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3456@t)))))) (set! E4b68@E3063@record-constructor-descriptor-transformer E3063@record-constructor-descriptor-transformer) (set! E3065@when-macro (lambda (E3464@e) (let ((E3466@t E3464@e)) (let ((E3468@ls/false (E30c1@syntax-dispatch E3466@t '(_ any any . each-any)))) (if E3468@ls/false (apply (lambda (E346a@test E346b@e E346c@e*) (E3077@bless (list 'if E346a@test (cons 'begin (cons E346b@e E346c@e*))))) E3468@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3466@t)))))) (set! E4b69@E3065@when-macro E3065@when-macro) (set! E3067@unless-macro (lambda (E3470@e) (let ((E3472@t E3470@e)) (let ((E3474@ls/false (E30c1@syntax-dispatch E3472@t '(_ any any . each-any)))) (if E3474@ls/false (apply (lambda (E3476@test E3477@e E3478@e*) (E3077@bless (list 'if (list 'not E3476@test) (cons 'begin (cons E3477@e E3478@e*))))) E3474@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3472@t)))))) (set! E4b6a@E3067@unless-macro E3067@unless-macro) (set! E3069@if-transformer (lambda (E347c@e E347d@r E347e@mr) (let ((E3482@t E347c@e)) (let ((E3484@ls/false (E30c1@syntax-dispatch E3482@t '(_ any any any)))) (if E3484@ls/false (apply (lambda (E3486@e0 E3487@e1 E3488@e2) (list 'if (E30e3@chi-expr E3486@e0 E347d@r E347e@mr) (E30e3@chi-expr E3487@e1 E347d@r E347e@mr) (E30e3@chi-expr E3488@e2 E347d@r E347e@mr))) E3484@ls/false) (let ((E348c@t E3482@t)) (let ((E348e@ls/false (E30c1@syntax-dispatch E348c@t '(_ any any)))) (if E348e@ls/false (apply (lambda (E3490@e0 E3491@e1) (list 'if (E30e3@chi-expr E3490@e0 E347d@r E347e@mr) (E30e3@chi-expr E3491@e1 E347d@r E347e@mr) (E2e20@E2d81@build-void))) E348e@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E348c@t))))))))) (set! E4b6b@E3069@if-transformer E3069@if-transformer) (set! E306b@and-transformer (lambda (E3494@e E3495@r E3496@mr) (let ((E349a@t E3494@e)) (let ((E349c@ls/false (E30c1@syntax-dispatch E349a@t '(_ . each-any)))) (if E349c@ls/false (apply (lambda (E349e@e*) (cons 'and (E30df@chi-expr* E349e@e* E3495@r E3496@mr))) E349c@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E349a@t)))))) (set! E4b6c@E306b@and-transformer E306b@and-transformer) (set! E306d@or-transformer (lambda (E34a0@e E34a1@r E34a2@mr) (let ((E34a6@t E34a0@e)) (let ((E34a8@ls/false (E30c1@syntax-dispatch E34a6@t '(_ . each-any)))) (if E34a8@ls/false (apply (lambda (E34aa@e*) (cons 'or (E30df@chi-expr* E34aa@e* E34a1@r E34a2@mr))) E34a8@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E34a6@t)))))) (set! E4b6d@E306d@or-transformer E306d@or-transformer) (set! E306f@case-macro (lambda (E34ac@e) (letrec* ((E34af@build-last (lambda (E34d6@cls) (let ((E34d8@t E34d6@cls)) (let ((E34da@ls/false (E30c1@syntax-dispatch E34d8@t '(#(scheme-id else) any . each-any)))) (if E34da@ls/false (apply (lambda (E34dc@e E34dd@e*) (cons 'begin (cons E34dc@e E34dd@e*))) E34da@ls/false) (let ((E34e0@t E34d8@t)) (let ((E34e2@ls/false (E30c1@syntax-dispatch E34e0@t '_))) (if E34e2@ls/false (apply (lambda () (E34b1@build-one E34d6@cls '(if #f #f))) E34e2@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E34e0@t))))))))) (E34b1@build-one (lambda (E34c8@cls E34c9@k) (let ((E34cc@t E34c8@cls)) (let ((E34ce@ls/false (E30c1@syntax-dispatch E34cc@t '(each-any any . each-any)))) (if E34ce@ls/false (apply (lambda (E34d0@d* E34d1@e E34d2@e*) (list 'if (list 'memv 't (list 'quote E34d0@d*)) (cons 'begin (cons E34d1@e E34d2@e*)) E34c9@k)) E34ce@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E34cc@t))))))) (let ((E34b2@t E34ac@e)) (let ((E34b4@ls/false (E30c1@syntax-dispatch E34b2@t '(_ any)))) (if E34b4@ls/false (apply (lambda (E34b6@expr) (E3077@bless (cons 'let (cons (list (list 't E34b6@expr)) '((if #f #f)))))) E34b4@ls/false) (let ((E34b8@t E34b2@t)) (let ((E34ba@ls/false (E30c1@syntax-dispatch E34b8@t '(_ any any . each-any)))) (if E34ba@ls/false (apply (lambda (E34bc@expr E34bd@cls E34be@cls*) (E3077@bless (list 'let (list (list 't E34bc@expr)) (let E34c6@f ((E34c2@cls E34bd@cls) (E34c3@cls* E34be@cls*)) (if (null? E34c3@cls*) (E34af@build-last E34c2@cls) (E34b1@build-one E34c2@cls (E34c6@f (car E34c3@cls*) (cdr E34c3@cls*)))))))) E34ba@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E34b8@t)))))))))) (set! E4b6e@E306f@case-macro E306f@case-macro) (set! E3071@quote-transformer (lambda (E34e4@e E34e5@r E34e6@mr) (let ((E34ea@t E34e4@e)) (let ((E34ec@ls/false (E30c1@syntax-dispatch E34ea@t '(_ any)))) (if E34ec@ls/false (apply (lambda (E34ee@datum) (list 'quote (E2ece@stx->datum E34ee@datum))) E34ec@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E34ea@t)))))) (set! E4b6f@E3071@quote-transformer E3071@quote-transformer) (set! E3073@case-lambda-transformer (lambda (E34f0@e E34f1@r E34f2@mr) (let ((E34f6@t E34f0@e)) (let ((E34f8@ls/false (E30c1@syntax-dispatch E34f6@t '(_ . #(each (any any . each-any)))))) (if E34f8@ls/false (apply (lambda (E34fa@fmls* E34fb@b* E34fc@b**) (call-with-values (lambda () (E30eb@chi-lambda-clause* E34f0@e E34fa@fmls* (map cons E34fb@b* E34fc@b**) E34f1@r E34f2@mr)) (lambda (E3504@E3501 E3505@E3503) (let ((E3508@body* E3505@E3503) (E3509@fmls* E3504@E3501)) (E2e1e@E2d51@build-case-lambda '#f E3509@fmls* E3508@body*))))) E34f8@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E34f6@t)))))) (set! E4b70@E3073@case-lambda-transformer E3073@case-lambda-transformer) (set! E3075@lambda-transformer (lambda (E350c@e E350d@r E350e@mr) (let ((E3512@t E350c@e)) (let ((E3514@ls/false (E30c1@syntax-dispatch E3512@t '(_ any any . each-any)))) (if E3514@ls/false (apply (lambda (E3516@fmls E3517@b E3518@b*) (call-with-values (lambda () (E30e9@chi-lambda-clause E350c@e E3516@fmls (cons E3517@b E3518@b*) E350d@r E350e@mr)) (lambda (E3520@E351d E3521@E351f) (let ((E3524@body E3521@E351f) (E3525@fmls E3520@E351d)) (E2e1d@E2d4f@build-lambda '#f E3525@fmls E3524@body))))) E3514@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3512@t)))))) (set! E4b71@E3075@lambda-transformer E3075@lambda-transformer) (set! E3077@bless (lambda (E3528@x) (E2ea2@mkstx (let E352c@f ((E352a@x E3528@x)) (if (E2e86@stx? E352a@x) E352a@x (if (pair? E352a@x) (cons (E352c@f (car E352a@x)) (E352c@f (cdr E352a@x))) (if (symbol? E352a@x) (E3049@scheme-stx E352a@x) (if (vector? E352a@x) (vector-map E352c@f E352a@x) E352a@x))))) '() '() '()))) (set! E4b72@E3077@bless E3077@bless) (set! E3079@with-syntax-macro (lambda (E352e@e) (let ((E3530@t E352e@e)) (let ((E3532@ls/false (E30c1@syntax-dispatch E3530@t '(_ #(each (any any)) any . each-any)))) (if E3532@ls/false (apply (lambda (E3534@pat* E3535@expr* E3536@b E3537@b*) (let ((E353c@idn* (let E3540@f ((E353e@pat* E3534@pat*)) (if (null? E353e@pat*) '() (call-with-values (lambda () (E30bf@convert-pattern (car E353e@pat*) '())) (lambda (E3546@E3543 E3547@E3545) (let ((E354a@idn* E3547@E3545) (E354b@pat E3546@E3543)) (append E354a@idn* (E3540@f (cdr E353e@pat*)))))))))) (begin (E30e7@verify-formals (map car E353c@idn*) E352e@e) (let ((E354e@t* (E318f@generate-temporaries E3535@expr*))) (E3077@bless (list 'let (map list E354e@t* E3535@expr*) (let E3554@f ((E3550@pat* E3534@pat*) (E3551@t* E354e@t*)) (if (null? E3550@pat*) (cons 'begin (cons '#f (cons E3536@b E3537@b*))) (list 'syntax-case (car E3551@t*) '() (list (car E3550@pat*) (E3554@f (cdr E3550@pat*) (cdr E3551@t*))) (list '_ (list 'assertion-violation ''with-syntax '"pattern does not match value" (list 'quote (car E3550@pat*)) (car E3551@t*)))))))))))) E3532@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3530@t)))))) (set! E4b73@E3079@with-syntax-macro E3079@with-syntax-macro) (set! E307b@invalid-fmls-error (lambda (E3556@stx E3557@fmls) (let ((E355a@t E3557@fmls)) (let ((E355c@ls/false (E30c1@syntax-dispatch E355a@t '#(each+ any () any)))) (if E355c@ls/false (apply (lambda (E355e@id* E355f@last) (let E3564@f ((E3562@id* (if (E2eba@id? E355f@last) (cons E355f@last E355e@id*) (if (E2eb0@syntax-null? E355f@last) E355e@id* (E31a1@syntax-violation '#f '"not an identifier" E3556@stx E355f@last))))) (if (null? E3562@id*) (values) (if (not (E2eba@id? (car E3562@id*))) (E31a1@syntax-violation '#f '"not an identifier" E3556@stx (car E3562@id*)) (begin (E3564@f (cdr E3562@id*)) (if (E2ec6@bound-id-member? (car E3562@id*) (cdr E3562@id*)) (E31a1@syntax-violation '#f '"duplicate binding" E3556@stx (car E3562@id*)) (void))))))) E355c@ls/false) (let ((E3566@t E355a@t)) (let ((E3568@ls/false (E30c1@syntax-dispatch E3566@t '_))) (if E3568@ls/false (apply (lambda () (E31a1@syntax-violation '#f '"malformed binding form" E3556@stx E3557@fmls)) E3568@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3566@t))))))))) (set! E4b74@E307b@invalid-fmls-error E307b@invalid-fmls-error) (set! E307d@let-macro (lambda (E356a@stx) (let ((E356c@t E356a@stx)) (let ((E356e@ls/false (E30c1@syntax-dispatch E356c@t '(_ #(each (any any)) any . each-any)))) (if E356e@ls/false (apply (lambda (E3570@lhs* E3571@rhs* E3572@b E3573@b*) (if (E2ec2@valid-bound-ids? E3570@lhs*) (E3077@bless (cons (cons 'lambda (cons E3570@lhs* (cons E3572@b E3573@b*))) E3571@rhs*)) (E307b@invalid-fmls-error E356a@stx E3570@lhs*))) E356e@ls/false) (let ((E3578@t E356c@t)) (let ((E357a@ls/false (E30c1@syntax-dispatch E3578@t '(_ any #(each (any any)) any . each-any)))) (if (and E357a@ls/false (apply (lambda (E357c@f E357d@lhs* E357e@rhs* E357f@b E3580@b*) (E2eba@id? E357c@f)) E357a@ls/false)) (apply (lambda (E3586@f E3587@lhs* E3588@rhs* E3589@b E358a@b*) (if (E2ec2@valid-bound-ids? E3587@lhs*) (E3077@bless (cons (list 'letrec (list (list E3586@f (cons 'lambda (cons E3587@lhs* (cons E3589@b E358a@b*))))) E3586@f) E3588@rhs*)) (E307b@invalid-fmls-error E356a@stx E3587@lhs*))) E357a@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3578@t))))))))) (set! E4b75@E307d@let-macro E307d@let-macro) (set! E307f@let-values-macro (lambda (E3590@stx) (letrec* ((E3593@rename (lambda (E35f8@x E35f9@old* E35fa@new*) (begin (if (not (E2eba@id? E35f8@x)) (E31a1@syntax-violation '#f '"not an indentifier" E3590@stx E35f8@x) (void)) (if (E2ec6@bound-id-member? E35f8@x E35f9@old*) (E31a1@syntax-violation '#f '"duplicate binding" E3590@stx E35f8@x) (void)) (let ((E35fe@y (gensym (E31a7@syntax->datum E35f8@x)))) (values E35fe@y (cons E35f8@x E35f9@old*) (cons E35fe@y E35fa@new*)))))) (E3595@rename* (lambda (E35e6@x* E35e7@old* E35e8@new*) (if (null? E35e6@x*) (values '() E35e7@old* E35e8@new*) (call-with-values (lambda () (E3593@rename (car E35e6@x*) E35e7@old* E35e8@new*)) (lambda (E35ec@x E35ed@old* E35ee@new*) (call-with-values (lambda () (E3595@rename* (cdr E35e6@x*) E35ed@old* E35ee@new*)) (lambda (E35f2@x* E35f3@old* E35f4@new*) (values (cons E35ec@x E35f2@x*) E35f3@old* E35f4@new*))))))))) (let ((E3596@t E3590@stx)) (let ((E3598@ls/false (E30c1@syntax-dispatch E3596@t '(_ () any . each-any)))) (if E3598@ls/false (apply (lambda (E359a@b E359b@b*) (cons* (E3077@bless 'let) '() E359a@b E359b@b*)) E3598@ls/false) (let ((E359e@t E3596@t)) (let ((E35a0@ls/false (E30c1@syntax-dispatch E359e@t '(_ #(each (any any)) any . each-any)))) (if E35a0@ls/false (apply (lambda (E35a2@lhs* E35a3@rhs* E35a4@b E35a5@b*) (E3077@bless (let E35b2@f ((E35aa@lhs* E35a2@lhs*) (E35ab@rhs* E35a3@rhs*) (E35ac@old* '()) (E35ad@new* '())) (if (null? E35aa@lhs*) (cons 'let (cons (map list E35ac@old* E35ad@new*) (cons E35a4@b E35a5@b*))) (let ((E35b4@t (car E35aa@lhs*))) (let ((E35b6@ls/false (E30c1@syntax-dispatch E35b4@t 'each-any))) (if E35b6@ls/false (apply (lambda (E35b8@x*) (call-with-values (lambda () (E3595@rename* E35b8@x* E35ac@old* E35ad@new*)) (lambda (E35c0@E35bb E35c1@E35bd E35c2@E35bf) (let ((E35c6@new* E35c2@E35bf) (E35c7@old* E35c1@E35bd) (E35c8@y* E35c0@E35bb)) (list 'call-with-values (list 'lambda '() (car E35ab@rhs*)) (list 'lambda E35c8@y* (E35b2@f (cdr E35aa@lhs*) (cdr E35ab@rhs*) E35c7@old* E35c6@new*))))))) E35b6@ls/false) (let ((E35cc@t E35b4@t)) (let ((E35ce@ls/false (E30c1@syntax-dispatch E35cc@t '#(each+ any () any)))) (if E35ce@ls/false (apply (lambda (E35d0@x* E35d1@x) (call-with-values (lambda () (E3593@rename E35d1@x E35ac@old* E35ad@new*)) (lambda (E35d4@y E35d5@old* E35d6@new*) (call-with-values (lambda () (E3595@rename* E35d0@x* E35d5@old* E35d6@new*)) (lambda (E35da@y* E35db@old* E35dc@new*) (list 'call-with-values (list 'lambda '() (car E35ab@rhs*)) (list 'lambda (append E35da@y* E35d4@y) (E35b2@f (cdr E35aa@lhs*) (cdr E35ab@rhs*) E35db@old* E35dc@new*)))))))) E35ce@ls/false) (let ((E35e0@t E35cc@t)) (let ((E35e2@ls/false (E30c1@syntax-dispatch E35e0@t 'any))) (if E35e2@ls/false (apply (lambda (E35e4@others) (E31a1@syntax-violation '#f '"malformed bindings" E3590@stx E35e4@others)) E35e2@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E35e0@t)))))))))))))) E35a0@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E359e@t)))))))))) (set! E4b76@E307f@let-values-macro E307f@let-values-macro) (set! E3081@let*-values-macro (lambda (E3600@stx) (letrec* ((E3603@check (lambda (E3632@x*) (if (not (null? E3632@x*)) (let ((E3634@x (car E3632@x*))) (begin (if (not (E2eba@id? E3634@x)) (E31a1@syntax-violation '#f '"not an identifier" E3600@stx E3634@x) (void)) (E3603@check (cdr E3632@x*)) (if (E2ec6@bound-id-member? E3634@x (cdr E3632@x*)) (E31a1@syntax-violation '#f '"duplicate identifier" E3600@stx E3634@x) (void)))) (void))))) (let ((E3604@t E3600@stx)) (let ((E3606@ls/false (E30c1@syntax-dispatch E3604@t '(_ () any . each-any)))) (if E3606@ls/false (apply (lambda (E3608@b E3609@b*) (cons* (E3077@bless 'let) '() E3608@b E3609@b*)) E3606@ls/false) (let ((E360c@t E3604@t)) (let ((E360e@ls/false (E30c1@syntax-dispatch E360c@t '(_ #(each (any any)) any . each-any)))) (if E360e@ls/false (apply (lambda (E3610@lhs* E3611@rhs* E3612@b E3613@b*) (E3077@bless (let E361c@f ((E3618@lhs* E3610@lhs*) (E3619@rhs* E3611@rhs*)) (if (null? E3618@lhs*) (cons 'begin (cons E3612@b E3613@b*)) (let ((E361e@t (car E3618@lhs*))) (let ((E3620@ls/false (E30c1@syntax-dispatch E361e@t 'each-any))) (if E3620@ls/false (apply (lambda (E3622@x*) (begin (E3603@check E3622@x*) (list 'call-with-values (list 'lambda '() (car E3619@rhs*)) (list 'lambda E3622@x* (E361c@f (cdr E3618@lhs*) (cdr E3619@rhs*)))))) E3620@ls/false) (let ((E3624@t E361e@t)) (let ((E3626@ls/false (E30c1@syntax-dispatch E3624@t '#(each+ any () any)))) (if E3626@ls/false (apply (lambda (E3628@x* E3629@x) (begin (E3603@check (cons E3629@x E3628@x*)) (list 'call-with-values (list 'lambda '() (car E3619@rhs*)) (list 'lambda (append E3628@x* E3629@x) (E361c@f (cdr E3618@lhs*) (cdr E3619@rhs*)))))) E3626@ls/false) (let ((E362c@t E3624@t)) (let ((E362e@ls/false (E30c1@syntax-dispatch E362c@t 'any))) (if E362e@ls/false (apply (lambda (E3630@others) (E31a1@syntax-violation '#f '"malformed bindings" E3600@stx E3630@others)) E362e@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E362c@t)))))))))))))) E360e@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E360c@t)))))))))) (set! E4b77@E3081@let*-values-macro E3081@let*-values-macro) (set! E3083@trace-lambda-macro (lambda (E3636@stx) (let ((E3638@t E3636@stx)) (let ((E363a@ls/false (E30c1@syntax-dispatch E3638@t '(_ any each-any any . each-any)))) (if E363a@ls/false (apply (lambda (E363c@who E363d@fmls E363e@b E363f@b*) (if (E2ec2@valid-bound-ids? E363d@fmls) (E3077@bless (list 'make-traced-procedure (list 'quote E363c@who) (cons 'lambda (cons E363d@fmls (cons E363e@b E363f@b*))))) (E307b@invalid-fmls-error E3636@stx E363d@fmls))) E363a@ls/false) (let ((E3644@t E3638@t)) (let ((E3646@ls/false (E30c1@syntax-dispatch E3644@t '(_ any #(each+ any () any) any . each-any)))) (if E3646@ls/false (apply (lambda (E3648@who E3649@fmls E364a@last E364b@b E364c@b*) (if (E2ec2@valid-bound-ids? (cons E364a@last E3649@fmls)) (E3077@bless (list 'make-traced-procedure (list 'quote E3648@who) (cons 'lambda (cons (append E3649@fmls E364a@last) (cons E364b@b E364c@b*))))) (E307b@invalid-fmls-error E3636@stx (append E3649@fmls E364a@last)))) E3646@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3644@t))))))))) (set! E4b78@E3083@trace-lambda-macro E3083@trace-lambda-macro) (set! E3085@trace-define-macro (lambda (E3652@stx) (let ((E3654@t E3652@stx)) (let ((E3656@ls/false (E30c1@syntax-dispatch E3654@t '(_ (any . each-any) any . each-any)))) (if E3656@ls/false (apply (lambda (E3658@who E3659@fmls E365a@b E365b@b*) (if (E2ec2@valid-bound-ids? E3659@fmls) (E3077@bless (list 'define E3658@who (list 'make-traced-procedure (list 'quote E3658@who) (cons 'lambda (cons E3659@fmls (cons E365a@b E365b@b*)))))) (E307b@invalid-fmls-error E3652@stx E3659@fmls))) E3656@ls/false) (let ((E3660@t E3654@t)) (let ((E3662@ls/false (E30c1@syntax-dispatch E3660@t '(_ (any . #(each+ any () any)) any . each-any)))) (if E3662@ls/false (apply (lambda (E3664@who E3665@fmls E3666@last E3667@b E3668@b*) (if (E2ec2@valid-bound-ids? (cons E3666@last E3665@fmls)) (E3077@bless (list 'define E3664@who (list 'make-traced-procedure (list 'quote E3664@who) (cons 'lambda (cons (append E3665@fmls E3666@last) (cons E3667@b E3668@b*)))))) (E307b@invalid-fmls-error E3652@stx (append E3665@fmls E3666@last)))) E3662@ls/false) (let ((E366e@t E3660@t)) (let ((E3670@ls/false (E30c1@syntax-dispatch E366e@t '(_ any any)))) (if E3670@ls/false (apply (lambda (E3672@who E3673@expr) (if (E2eba@id? E3672@who) (E3077@bless (list 'define E3672@who (list 'let (list (list 'v E3673@expr)) (cons 'if (cons '(procedure? v) (cons (cons 'make-traced-procedure (cons (list 'quote E3672@who) '(v))) '((assertion-violation 'trace-define "not a procedure" v)))))))) (E31a1@syntax-violation '#f '"invalid name" E3652@stx))) E3670@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E366e@t)))))))))))) (set! E4b79@E3085@trace-define-macro E3085@trace-define-macro) (set! E3087@trace-define-syntax-macro (lambda (E3676@stx) (let ((E3678@t E3676@stx)) (let ((E367a@ls/false (E30c1@syntax-dispatch E3678@t '(_ any any)))) (if E367a@ls/false (apply (lambda (E367c@who E367d@expr) (if (E2eba@id? E367c@who) (E3077@bless (list 'define-syntax E367c@who (list 'make-traced-macro (list 'quote E367c@who) E367d@expr))) (E31a1@syntax-violation '#f '"invalid name" E3676@stx))) E367a@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3678@t)))))) (set! E4b7a@E3087@trace-define-syntax-macro E3087@trace-define-syntax-macro) (set! E3089@trace-let/rec-syntax (lambda (E3680@who) (lambda (E3682@stx) (let ((E3684@t E3682@stx)) (let ((E3686@ls/false (E30c1@syntax-dispatch E3684@t '(_ #(each (any any)) any . each-any)))) (if E3686@ls/false (apply (lambda (E3688@lhs* E3689@rhs* E368a@b E368b@b*) (if (E2ec2@valid-bound-ids? E3688@lhs*) (let ((E3690@rhs* (map (lambda (E3692@lhs E3693@rhs) (list 'make-traced-macro (list 'quote E3692@lhs) E3693@rhs)) E3688@lhs* E3689@rhs*))) (E3077@bless (cons E3680@who (cons (map list E3688@lhs* E3690@rhs*) (cons E368a@b E368b@b*))))) (E307b@invalid-fmls-error E3682@stx E3688@lhs*))) E3686@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3684@t))))))) (set! E4b7b@E3089@trace-let/rec-syntax E3089@trace-let/rec-syntax) (set! E308b@trace-let-syntax-macro (E3089@trace-let/rec-syntax 'let-syntax)) (set! E4b7c@E308b@trace-let-syntax-macro E308b@trace-let-syntax-macro) (set! E308d@trace-letrec-syntax-macro (E3089@trace-let/rec-syntax 'letrec-syntax)) (set! E4b7d@E308d@trace-letrec-syntax-macro E308d@trace-letrec-syntax-macro) (set! E308f@guard-macro (lambda (E3696@x) (letrec* ((E3699@gen-clauses (lambda (E36b0@con E36b1@outerk E36b2@clause*) (letrec* ((E36b7@f (lambda (E36f0@x E36f1@k) (let ((E36f4@t E36f0@x)) (let ((E36f6@ls/false (E30c1@syntax-dispatch E36f4@t '(any #(scheme-id =>) any)))) (if E36f6@ls/false (apply (lambda (E36f8@e E36f9@p) (let ((E36fc@t (gensym))) (list 'let (list (list E36fc@t E36f8@e)) (list 'if E36fc@t (list E36f9@p E36fc@t) E36f1@k)))) E36f6@ls/false) (let ((E36fe@t E36f4@t)) (let ((E3700@ls/false (E30c1@syntax-dispatch E36fe@t '(any)))) (if E3700@ls/false (apply (lambda (E3702@e) (let ((E3704@t (gensym))) (list 'let (list (list E3704@t E3702@e)) (list 'if E3704@t E3704@t E36f1@k)))) E3700@ls/false) (let ((E3706@t E36fe@t)) (let ((E3708@ls/false (E30c1@syntax-dispatch E3706@t '(any any . each-any)))) (if E3708@ls/false (apply (lambda (E370a@e E370b@v E370c@v*) (list 'if E370a@e (cons 'begin (cons E370b@v E370c@v*)) E36f1@k)) E3708@ls/false) (let ((E3710@t E3706@t)) (let ((E3712@ls/false (E30c1@syntax-dispatch E3710@t '_))) (if E3712@ls/false (apply (lambda () (E31a1@syntax-violation '#f '"invalid guard clause" E36f0@x)) E3712@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3710@t))))))))))))))) (E36b9@f* (lambda (E36c6@x*) (let ((E36c8@t E36c6@x*)) (let ((E36ca@ls/false (E30c1@syntax-dispatch E36c8@t '()))) (if E36ca@ls/false (apply (lambda () (let ((E36cc@g (gensym))) (values (list E36cc@g (list 'lambda '() (list 'raise-continuable E36b0@con))) E36cc@g))) E36ca@ls/false) (let ((E36ce@t E36c8@t)) (let ((E36d0@ls/false (E30c1@syntax-dispatch E36ce@t '((#(scheme-id else) any . each-any))))) (if E36d0@ls/false (apply (lambda (E36d2@e E36d3@e*) (values (cons 'begin (cons E36d2@e E36d3@e*)) '#f)) E36d0@ls/false) (let ((E36d6@t E36ce@t)) (let ((E36d8@ls/false (E30c1@syntax-dispatch E36d6@t '(any . any)))) (if E36d8@ls/false (apply (lambda (E36da@cls E36db@cls*) (call-with-values (lambda () (E36b9@f* E36db@cls*)) (lambda (E36e2@E36df E36e3@E36e1) (let ((E36e6@g E36e3@E36e1) (E36e7@e E36e2@E36df)) (values (E36b7@f E36da@cls E36e7@e) E36e6@g))))) E36d8@ls/false) (let ((E36ea@t E36d6@t)) (let ((E36ec@ls/false (E30c1@syntax-dispatch E36ea@t 'any))) (if E36ec@ls/false (apply (lambda (E36ee@others) (E31a1@syntax-violation '#f '"invalid guard clause" E36ee@others)) E36ec@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E36ea@t)))))))))))))))) (call-with-values (lambda () (E36b9@f* E36b2@clause*)) (lambda (E36be@E36bb E36bf@E36bd) (let ((E36c2@raisek E36bf@E36bd) (E36c3@code E36be@E36bb)) (if E36c2@raisek (list (list 'call/cc (list 'lambda (list E36c2@raisek) (list E36b1@outerk (list 'lambda '() E36c3@code))))) (list E36b1@outerk (list 'lambda '() E36c3@code)))))))))) (let ((E369a@t E3696@x)) (let ((E369c@ls/false (E30c1@syntax-dispatch E369a@t '(_ (any . each-any) any . each-any)))) (if (and E369c@ls/false (apply (lambda (E369e@con E369f@clause* E36a0@b E36a1@b*) (E2eba@id? E369e@con)) E369c@ls/false)) (apply (lambda (E36a6@con E36a7@clause* E36a8@b E36a9@b*) (let ((E36ae@outerk (gensym))) (E3077@bless (list (list 'call/cc (list 'lambda (list E36ae@outerk) (list 'lambda '() (list 'with-exception-handler (list 'lambda (list E36a6@con) (E3699@gen-clauses E36a6@con E36ae@outerk E36a7@clause*)) (cons 'lambda (cons '() (cons E36a8@b E36a9@b*))))))))))) E369c@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E369a@t))))))) (set! E4b7e@E308f@guard-macro E308f@guard-macro) (set! E3091@define-enumeration-macro (lambda (E3714@stx) (letrec* ((E3717@set? (lambda (E3730@x) (or (null? E3730@x) (and (not (memq (car E3730@x) (cdr E3730@x))) (E3717@set? (cdr E3730@x)))))) (E3719@remove-dups (lambda (E372e@ls) (if (null? E372e@ls) '() (cons (car E372e@ls) (E3719@remove-dups (remq (car E372e@ls) (cdr E372e@ls)))))))) (let ((E371a@t E3714@stx)) (let ((E371c@ls/false (E30c1@syntax-dispatch E371a@t '(_ any each-any any)))) (if (and E371c@ls/false (apply (lambda (E371e@name E371f@id* E3720@maker) (and (E2eba@id? E371e@name) (E2eba@id? E3720@maker) (for-all E2eba@id? E371f@id*))) E371c@ls/false)) (apply (lambda (E3724@name E3725@id* E3726@maker) (let ((E372a@name* (E3719@remove-dups (E31a7@syntax->datum E3725@id*))) (E372b@mk (gensym))) (E3077@bless (list 'begin (list 'define E372b@mk (list 'enum-set-constructor (list 'make-enumeration (list 'quote E372a@name*)))) (list 'define-syntax E3724@name (list 'lambda '(x) (list 'syntax-case 'x '() (list '(_ n) '(identifier? (syntax n)) (list 'if (list 'memq '(syntax->datum (syntax n)) (list 'quote E372a@name*)) '(syntax 'n) (cons 'syntax-violation (cons (list 'quote E3724@name) '("not a member of set" x (syntax n))))))))) (list 'define-syntax E3726@maker (list 'lambda '(x) (list 'syntax-case 'x '() (list '(_ n* ...) (list 'begin (cons 'for-each (cons (list 'lambda '(n) (list 'unless '(identifier? n) (cons 'syntax-violation (cons (list 'quote E3726@maker) '("non-identifier argument" x n)))) (list 'unless (list 'memq '(syntax->datum n) (list 'quote E372a@name*)) (cons 'syntax-violation (cons (list 'quote E3726@maker) '("not a member of set" x n))))) '((syntax (n* ...))))) (list 'syntax (cons E372b@mk '('(n* ...))))))))))))) E371c@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E371a@t))))))) (set! E4b7f@E3091@define-enumeration-macro E3091@define-enumeration-macro) (set! E3093@time-macro (lambda (E3732@stx) (let ((E3734@t E3732@stx)) (let ((E3736@ls/false (E30c1@syntax-dispatch E3734@t '(_ any)))) (if E3736@ls/false (apply (lambda (E3738@expr) (E3077@bless (cons 'let* (cons (cons '(start (time-usage)) (cons (list 'result (list (list 'lambda '() E3738@expr))) '((end (time-usage)) (used (map - end start)) (real (car used)) (user (cadr used)) (sys (caddr used))))) '((format #t "~%;;~a real ~a user ~a sys~%~!" real user sys) result))))) E3736@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3734@t)))))) (set! E4b80@E3093@time-macro E3093@time-macro) (set! E3095@delay-macro (lambda (E373a@stx) (let ((E373c@t E373a@stx)) (let ((E373e@ls/false (E30c1@syntax-dispatch E373c@t '(_ any)))) (if E373e@ls/false (apply (lambda (E3740@expr) (E3077@bless (list 'make-promise (list 'lambda '() E3740@expr)))) E373e@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E373c@t)))))) (set! E4b81@E3095@delay-macro E3095@delay-macro) (set! E3097@assert-macro (lambda (E3742@stx) (let ((E3744@t E3742@stx)) (let ((E3746@ls/false (E30c1@syntax-dispatch E3744@t '(_ any)))) (if E3746@ls/false (apply (lambda (E3748@expr) (let ((E374a@pos (or (E3199@expression-position E3742@stx) (E3199@expression-position E3748@expr)))) (E3077@bless (list 'let (list (list 'x E3748@expr)) (list 'if 'x 'x (list 'assertion-error (list 'quote E3748@expr) (list 'quote E374a@pos))))))) E3746@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3744@t)))))) (set! E4b82@E3097@assert-macro E3097@assert-macro) (set! E3099@endianness-macro (lambda (E374c@stx) (let ((E374e@t E374c@stx)) (let ((E3750@ls/false (E30c1@syntax-dispatch E374e@t '(_ any)))) (if E3750@ls/false (apply (lambda (E3752@e) (let ((E3754@t (E31a7@syntax->datum E3752@e))) (if (memv E3754@t '(little)) (E3077@bless ''little) (if (memv E3754@t '(big)) (E3077@bless ''big) (E31a1@syntax-violation '#f '"endianness must be big or little" E374c@stx))))) E3750@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E374e@t)))))) (set! E4b83@E3099@endianness-macro E3099@endianness-macro) (set! E309b@identifier-syntax-macro (lambda (E3756@stx) (let ((E3758@t E3756@stx)) (let ((E375a@ls/false (E30c1@syntax-dispatch E3758@t '(_ any)))) (if E375a@ls/false (apply (lambda (E375c@expr) (E3077@bless (list 'lambda '(x) (list 'syntax-case 'x '() (list 'id '(identifier? (syntax id)) (list 'syntax E375c@expr)) (list '(id e* ...) '(identifier? (syntax id)) (cons 'cons (cons (list 'syntax E375c@expr) '((syntax (e* ...)))))))))) E375a@ls/false) (let ((E375e@t E3758@t)) (let ((E3760@ls/false (E30c1@syntax-dispatch E375e@t '(_ (any any) ((#(scheme-id set!) any any) any))))) (if (and E3760@ls/false (apply (lambda (E3762@id1 E3763@expr1 E3764@id2 E3765@expr2 E3766@expr3) (and (E2eba@id? E3762@id1) (E2eba@id? E3764@id2) (E2eba@id? E3765@expr2))) E3760@ls/false)) (apply (lambda (E376c@id1 E376d@expr1 E376e@id2 E376f@expr2 E3770@expr3) (E3077@bless (list 'cons ''macro! (list 'lambda '(x) (list 'syntax-case 'x '(set!) (list 'id '(identifier? (syntax id)) (list 'syntax E376d@expr1)) (list (list 'set! 'id E376f@expr2) (list 'syntax E3770@expr3)) (list '(id e* ...) '(identifier? (syntax id)) (list 'syntax (cons E376d@expr1 '(e* ...))))))))) E3760@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E375e@t))))))))) (set! E4b84@E309b@identifier-syntax-macro E309b@identifier-syntax-macro) (set! E309d@do-macro (lambda (E3776@stx) (letrec* ((E3779@bind (lambda (E3790@x) (let ((E3792@t E3790@x)) (let ((E3794@ls/false (E30c1@syntax-dispatch E3792@t '(any any)))) (if E3794@ls/false (apply (lambda (E3796@x E3797@init) (list E3796@x E3797@init E3796@x)) E3794@ls/false) (let ((E379a@t E3792@t)) (let ((E379c@ls/false (E30c1@syntax-dispatch E379a@t '(any any any)))) (if E379c@ls/false (apply (lambda (E379e@x E379f@init E37a0@step) (list E379e@x E379f@init E37a0@step)) E379c@ls/false) (let ((E37a4@t E379a@t)) (let ((E37a6@ls/false (E30c1@syntax-dispatch E37a4@t '_))) (if E37a6@ls/false (apply (lambda () (E31a1@syntax-violation '#f '"invalid binding" E3776@stx)) E37a6@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E37a4@t))))))))))))) (let ((E377a@t E3776@stx)) (let ((E377c@ls/false (E30c1@syntax-dispatch E377a@t '(_ each-any (any . each-any) . each-any)))) (if E377c@ls/false (apply (lambda (E377e@binding* E377f@test E3780@expr* E3781@command*) (let ((E3786@t (map E3779@bind E377e@binding*))) (let ((E3788@ls/false (E30c1@syntax-dispatch E3786@t '#(each (any any any))))) (if E3788@ls/false (apply (lambda (E378a@x* E378b@init* E378c@step*) (if (E2ec2@valid-bound-ids? E378a@x*) (E3077@bless (list 'letrec (list (list 'loop (list 'lambda E378a@x* (list 'if E377f@test (cons 'begin (cons '(if #f #f) E3780@expr*)) (cons 'begin (append E3781@command* (list (cons 'loop E378c@step*)))))))) (cons 'loop E378b@init*))) (E31a1@syntax-violation '#f '"invalid bindings" E3776@stx))) E3788@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3786@t))))) E377c@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E377a@t))))))) (set! E4b85@E309d@do-macro E309d@do-macro) (set! E309f@let*-macro (lambda (E37a8@stx) (let ((E37aa@t E37a8@stx)) (let ((E37ac@ls/false (E30c1@syntax-dispatch E37aa@t '(_ #(each (any any)) any . each-any)))) (if (and E37ac@ls/false (apply (lambda (E37ae@lhs* E37af@rhs* E37b0@b E37b1@b*) (for-all E2eba@id? E37ae@lhs*)) E37ac@ls/false)) (apply (lambda (E37b6@lhs* E37b7@rhs* E37b8@b E37b9@b*) (E3077@bless (let E37c0@f ((E37be@x* (map list E37b6@lhs* E37b7@rhs*))) (if (null? E37be@x*) (cons 'let (cons '() (cons E37b8@b E37b9@b*))) (list 'let (list (car E37be@x*)) (E37c0@f (cdr E37be@x*))))))) E37ac@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E37aa@t)))))) (set! E4b86@E309f@let*-macro E309f@let*-macro) (set! E30a1@or-macro (lambda (E37c2@stx) (let ((E37c4@t E37c2@stx)) (let ((E37c6@ls/false (E30c1@syntax-dispatch E37c4@t '(_)))) (if E37c6@ls/false (apply (lambda () '#f) E37c6@ls/false) (let ((E37c8@t E37c4@t)) (let ((E37ca@ls/false (E30c1@syntax-dispatch E37c8@t '(_ any . each-any)))) (if E37ca@ls/false (apply (lambda (E37cc@e E37cd@e*) (E3077@bless (let E37d4@f ((E37d0@e E37cc@e) (E37d1@e* E37cd@e*)) (if (null? E37d1@e*) (list 'begin '#f E37d0@e) (list 'let (list (list 't E37d0@e)) (list 'if 't 't (E37d4@f (car E37d1@e*) (cdr E37d1@e*)))))))) E37ca@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E37c8@t))))))))) (set! E4b87@E30a1@or-macro E30a1@or-macro) (set! E30a3@and-macro (lambda (E37d6@stx) (let ((E37d8@t E37d6@stx)) (let ((E37da@ls/false (E30c1@syntax-dispatch E37d8@t '(_)))) (if E37da@ls/false (apply (lambda () '#t) E37da@ls/false) (let ((E37dc@t E37d8@t)) (let ((E37de@ls/false (E30c1@syntax-dispatch E37dc@t '(_ any . each-any)))) (if E37de@ls/false (apply (lambda (E37e0@e E37e1@e*) (E3077@bless (let E37e8@f ((E37e4@e E37e0@e) (E37e5@e* E37e1@e*)) (if (null? E37e5@e*) (list 'begin '#f E37e4@e) (cons 'if (cons E37e4@e (cons (E37e8@f (car E37e5@e*) (cdr E37e5@e*)) '(#f)))))))) E37de@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E37dc@t))))))))) (set! E4b88@E30a3@and-macro E30a3@and-macro) (set! E30a5@cond-macro (lambda (E37ea@stx) (let ((E37ec@t E37ea@stx)) (let ((E37ee@ls/false (E30c1@syntax-dispatch E37ec@t '(_ any . each-any)))) (if E37ee@ls/false (apply (lambda (E37f0@cls E37f1@cls*) (E3077@bless (let E37f8@f ((E37f4@cls E37f0@cls) (E37f5@cls* E37f1@cls*)) (if (null? E37f5@cls*) (let ((E37fa@t E37f4@cls)) (let ((E37fc@ls/false (E30c1@syntax-dispatch E37fa@t '(#(scheme-id else) any . each-any)))) (if E37fc@ls/false (apply (lambda (E37fe@e E37ff@e*) (cons 'begin (cons E37fe@e E37ff@e*))) E37fc@ls/false) (let ((E3802@t E37fa@t)) (let ((E3804@ls/false (E30c1@syntax-dispatch E3802@t '(any #(scheme-id =>) any)))) (if E3804@ls/false (apply (lambda (E3806@e E3807@p) (list 'let (list (list 't E3806@e)) (list 'if 't (cons E3807@p '(t))))) E3804@ls/false) (let ((E380a@t E3802@t)) (let ((E380c@ls/false (E30c1@syntax-dispatch E380a@t '(any)))) (if E380c@ls/false (apply (lambda (E380e@e) (cons 'or (cons E380e@e '((if #f #f))))) E380c@ls/false) (let ((E3810@t E380a@t)) (let ((E3812@ls/false (E30c1@syntax-dispatch E3810@t '(any . each-any)))) (if E3812@ls/false (apply (lambda (E3814@e E3815@e*) (list 'if E3814@e (cons 'begin E3815@e*))) E3812@ls/false) (let ((E3818@t E3810@t)) (let ((E381a@ls/false (E30c1@syntax-dispatch E3818@t '_))) (if E381a@ls/false (apply (lambda () (E31a1@syntax-violation '#f '"invalid last clause" E37ea@stx)) E381a@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3818@t)))))))))))))))) (let ((E381c@t E37f4@cls)) (let ((E381e@ls/false (E30c1@syntax-dispatch E381c@t '(#(scheme-id else) any . each-any)))) (if E381e@ls/false (apply (lambda (E3820@e E3821@e*) (E31a1@syntax-violation '#f '"incorrect position of keyword else" E37ea@stx)) E381e@ls/false) (let ((E3824@t E381c@t)) (let ((E3826@ls/false (E30c1@syntax-dispatch E3824@t '(any #(scheme-id =>) any)))) (if E3826@ls/false (apply (lambda (E3828@e E3829@p) (list 'let (list (list 't E3828@e)) (list 'if 't (cons E3829@p '(t)) (E37f8@f (car E37f5@cls*) (cdr E37f5@cls*))))) E3826@ls/false) (let ((E382c@t E3824@t)) (let ((E382e@ls/false (E30c1@syntax-dispatch E382c@t '(any)))) (if E382e@ls/false (apply (lambda (E3830@e) (list 'or E3830@e (E37f8@f (car E37f5@cls*) (cdr E37f5@cls*)))) E382e@ls/false) (let ((E3832@t E382c@t)) (let ((E3834@ls/false (E30c1@syntax-dispatch E3832@t '(any . each-any)))) (if E3834@ls/false (apply (lambda (E3836@e E3837@e*) (list 'if E3836@e (cons 'begin E3837@e*) (E37f8@f (car E37f5@cls*) (cdr E37f5@cls*)))) E3834@ls/false) (let ((E383a@t E3832@t)) (let ((E383c@ls/false (E30c1@syntax-dispatch E383a@t '_))) (if E383c@ls/false (apply (lambda () (E31a1@syntax-violation '#f '"invalid last clause" E37ea@stx)) E383c@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E383a@t)))))))))))))))))))) E37ee@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E37ec@t)))))) (set! E4b89@E30a5@cond-macro E30a5@cond-macro) (set! E30a7@do-include (lambda (E383e@stx E383f@id E3840@filename) (let ((E3844@filename (E2ece@stx->datum E3840@filename))) (begin (if (not (and (string? E3844@filename) (E2eba@id? E383f@id))) (E31a1@syntax-violation '#f '"invalid syntax" E383e@stx) (void)) (cons (E3077@bless 'begin) (with-input-from-file E3844@filename (lambda () (let E3848@f ((E3846@ls '())) (let ((E384a@x (E29fc@E28cc@read-annotated))) (if (eof-object? E384a@x) (reverse E3846@ls) (E3848@f (cons (E2e9a@datum->stx E383f@id E384a@x) E3846@ls)))))))))))) (set! E4b8a@E30a7@do-include E30a7@do-include) (set! E30a9@include-macro (lambda (E384c@e) (let ((E384e@t E384c@e)) (let ((E3850@ls/false (E30c1@syntax-dispatch E384e@t '(any any)))) (if E3850@ls/false (apply (lambda (E3852@id E3853@filename) (E30a7@do-include E384c@e E3852@id E3853@filename)) E3850@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E384e@t)))))) (set! E4b8b@E30a9@include-macro E30a9@include-macro) (set! E30ab@include-into-macro (lambda (E3856@e) (let ((E3858@t E3856@e)) (let ((E385a@ls/false (E30c1@syntax-dispatch E3858@t '(_ any any)))) (if E385a@ls/false (apply (lambda (E385c@id E385d@filename) (E30a7@do-include E3856@e E385c@id E385d@filename)) E385a@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3858@t)))))) (set! E4b8c@E30ab@include-into-macro E30ab@include-into-macro) (set! E30ad@syntax-rules-macro (lambda (E3860@e) (let ((E3862@t E3860@e)) (let ((E3864@ls/false (E30c1@syntax-dispatch E3862@t '(_ each-any . #(each (any any)))))) (if E3864@ls/false (apply (lambda (E3866@lits E3867@pat* E3868@tmp*) (begin (E30c7@verify-literals E3866@lits E3860@e) (E3077@bless (list 'lambda '(x) (cons 'syntax-case (cons 'x (cons E3866@lits (map (lambda (E386c@pat E386d@tmp) (let ((E3870@t E386c@pat)) (let ((E3872@ls/false (E30c1@syntax-dispatch E3870@t '(_ . any)))) (if E3872@ls/false (apply (lambda (E3874@rest) (list (cons 'g E3874@rest) (list 'syntax E386d@tmp))) E3872@ls/false) (let ((E3876@t E3870@t)) (let ((E3878@ls/false (E30c1@syntax-dispatch E3876@t '_))) (if E3878@ls/false (apply (lambda () (E31a1@syntax-violation '#f '"invalid syntax-rules pattern" E3860@e E386c@pat)) E3878@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3876@t)))))))) E3867@pat* E3868@tmp*)))))))) E3864@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3862@t)))))) (set! E4b8d@E30ad@syntax-rules-macro E30ad@syntax-rules-macro) (set! E30af@quasiquote-macro (letrec* ((E387b@datum (lambda (E397c@x) (list (E3049@scheme-stx 'quote) (E2ea2@mkstx E397c@x '() '() '())))) (E3897@quasicons* (lambda (E3974@x E3975@y) (let E397a@f ((E3978@x E3974@x)) (if (null? E3978@x) E3975@y (E3899@quasicons (car E3978@x) (E397a@f (cdr E3978@x))))))) (E3899@quasicons (lambda (E394e@x E394f@y) (let ((E3952@t E394f@y)) (let ((E3954@ls/false (E30c1@syntax-dispatch E3952@t '(#(scheme-id quote) any)))) (if E3954@ls/false (apply (lambda (E3956@dy) (let ((E3958@t E394e@x)) (let ((E395a@ls/false (E30c1@syntax-dispatch E3958@t '(#(scheme-id quote) any)))) (if E395a@ls/false (apply (lambda (E395c@dx) (list (E3049@scheme-stx 'quote) (cons E395c@dx E3956@dy))) E395a@ls/false) (let ((E395e@t E3958@t)) (let ((E3960@ls/false (E30c1@syntax-dispatch E395e@t '_))) (if E3960@ls/false (apply (lambda () (let ((E3962@t E3956@dy)) (let ((E3964@ls/false (E30c1@syntax-dispatch E3962@t '()))) (if E3964@ls/false (apply (lambda () (list (E3049@scheme-stx 'list) E394e@x)) E3964@ls/false) (let ((E3966@t E3962@t)) (let ((E3968@ls/false (E30c1@syntax-dispatch E3966@t '_))) (if E3968@ls/false (apply (lambda () (list (E3049@scheme-stx 'cons) E394e@x E394f@y)) E3968@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3966@t)))))))) E3960@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E395e@t)))))))) E3954@ls/false) (let ((E396a@t E3952@t)) (let ((E396c@ls/false (E30c1@syntax-dispatch E396a@t '(#(scheme-id list) . each-any)))) (if E396c@ls/false (apply (lambda (E396e@stuff) (cons* (E3049@scheme-stx 'list) E394e@x E396e@stuff)) E396c@ls/false) (let ((E3970@t E396a@t)) (let ((E3972@ls/false (E30c1@syntax-dispatch E3970@t '_))) (if E3972@ls/false (apply (lambda () (list (E3049@scheme-stx 'cons) E394e@x E394f@y)) E3972@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3970@t)))))))))))) (E389b@quasiappend (lambda (E3934@x E3935@y) (let ((E3938@ls (let E393c@f ((E393a@x E3934@x)) (if (null? E393a@x) (let ((E393e@t E3935@y)) (let ((E3940@ls/false (E30c1@syntax-dispatch E393e@t '(#(scheme-id quote) ())))) (if E3940@ls/false (apply (lambda () '()) E3940@ls/false) (let ((E3942@t E393e@t)) (let ((E3944@ls/false (E30c1@syntax-dispatch E3942@t '_))) (if E3944@ls/false (apply (lambda () (list E3935@y)) E3944@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3942@t))))))) (let ((E3946@t (car E393a@x))) (let ((E3948@ls/false (E30c1@syntax-dispatch E3946@t '(#(scheme-id quote) ())))) (if E3948@ls/false (apply (lambda () (E393c@f (cdr E393a@x))) E3948@ls/false) (let ((E394a@t E3946@t)) (let ((E394c@ls/false (E30c1@syntax-dispatch E394a@t '_))) (if E394c@ls/false (apply (lambda () (cons (car E393a@x) (E393c@f (cdr E393a@x)))) E394c@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E394a@t))))))))))) (if (null? E3938@ls) (list (E3049@scheme-stx 'quote) '()) (if (null? (cdr E3938@ls)) (car E3938@ls) (cons* (E3049@scheme-stx 'append) E3938@ls)))))) (E389d@quasivector (lambda (E3902@x) (let ((E3904@pat-x E3902@x)) (let ((E3906@t E3904@pat-x)) (let ((E3908@ls/false (E30c1@syntax-dispatch E3906@t '(#(scheme-id quote) each-any)))) (if E3908@ls/false (apply (lambda (E390a@x*) (list (E3049@scheme-stx 'quote) (list->vector E390a@x*))) E3908@ls/false) (let ((E390c@t E3906@t)) (let ((E390e@ls/false (E30c1@syntax-dispatch E390c@t '_))) (if E390e@ls/false (apply (lambda () (let E3916@f ((E3910@x E3902@x) (E3911@k (lambda (E3914@ls) (cons* (E3049@scheme-stx 'vector) E3914@ls)))) (let ((E3918@t E3910@x)) (let ((E391a@ls/false (E30c1@syntax-dispatch E3918@t '(#(scheme-id quote) each-any)))) (if E391a@ls/false (apply (lambda (E391c@x*) (E3911@k (map (lambda (E391e@x) (list (E3049@scheme-stx 'quote) E391e@x)) E391c@x*))) E391a@ls/false) (let ((E3920@t E3918@t)) (let ((E3922@ls/false (E30c1@syntax-dispatch E3920@t '(#(scheme-id list) . each-any)))) (if E3922@ls/false (apply (lambda (E3924@x*) (E3911@k E3924@x*)) E3922@ls/false) (let ((E3926@t E3920@t)) (let ((E3928@ls/false (E30c1@syntax-dispatch E3926@t '(#(scheme-id cons) any any)))) (if E3928@ls/false (apply (lambda (E392a@x E392b@y) (E3916@f E392b@y (lambda (E392e@ls) (E3911@k (cons E392a@x E392e@ls))))) E3928@ls/false) (let ((E3930@t E3926@t)) (let ((E3932@ls/false (E30c1@syntax-dispatch E3930@t '_))) (if E3932@ls/false (apply (lambda () (list (E3049@scheme-stx 'list->vector) E3904@pat-x)) E3932@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3930@t))))))))))))))) E390e@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E390c@t)))))))))) (E389f@vquasi (lambda (E38e0@p E38e1@lev) (let ((E38e4@t E38e0@p)) (let ((E38e6@ls/false (E30c1@syntax-dispatch E38e4@t '(any . any)))) (if E38e6@ls/false (apply (lambda (E38e8@p E38e9@q) (let ((E38ec@t E38e8@p)) (let ((E38ee@ls/false (E30c1@syntax-dispatch E38ec@t '(#(scheme-id unquote) . each-any)))) (if E38ee@ls/false (apply (lambda (E38f0@p) (if (= E38e1@lev '0) (E3897@quasicons* E38f0@p (E389f@vquasi E38e9@q E38e1@lev)) (E3899@quasicons (E3899@quasicons (E387b@datum 'unquote) (E38a1@quasi E38f0@p (- E38e1@lev '1))) (E389f@vquasi E38e9@q E38e1@lev)))) E38ee@ls/false) (let ((E38f2@t E38ec@t)) (let ((E38f4@ls/false (E30c1@syntax-dispatch E38f2@t '(#(scheme-id unquote-splicing) . each-any)))) (if E38f4@ls/false (apply (lambda (E38f6@p) (if (= E38e1@lev '0) (E389b@quasiappend E38f6@p (E389f@vquasi E38e9@q E38e1@lev)) (E3899@quasicons (E3899@quasicons (E387b@datum 'unquote-splicing) (E38a1@quasi E38f6@p (- E38e1@lev '1))) (E389f@vquasi E38e9@q E38e1@lev)))) E38f4@ls/false) (let ((E38f8@t E38f2@t)) (let ((E38fa@ls/false (E30c1@syntax-dispatch E38f8@t 'any))) (if E38fa@ls/false (apply (lambda (E38fc@p) (E3899@quasicons (E38a1@quasi E38fc@p E38e1@lev) (E389f@vquasi E38e9@q E38e1@lev))) E38fa@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E38f8@t))))))))))) E38e6@ls/false) (let ((E38fe@t E38e4@t)) (let ((E3900@ls/false (E30c1@syntax-dispatch E38fe@t '()))) (if E3900@ls/false (apply (lambda () (list (E3049@scheme-stx 'quote) '())) E3900@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E38fe@t))))))))) (E38a1@quasi (lambda (E38aa@p E38ab@lev) (let ((E38ae@t E38aa@p)) (let ((E38b0@ls/false (E30c1@syntax-dispatch E38ae@t '(#(scheme-id unquote) any)))) (if E38b0@ls/false (apply (lambda (E38b2@p) (if (= E38ab@lev '0) E38b2@p (E3899@quasicons (E387b@datum 'unquote) (E38a1@quasi (list E38b2@p) (- E38ab@lev '1))))) E38b0@ls/false) (let ((E38b4@t E38ae@t)) (let ((E38b6@ls/false (E30c1@syntax-dispatch E38b4@t '((#(scheme-id unquote) . each-any) . any)))) (if E38b6@ls/false (apply (lambda (E38b8@p E38b9@q) (if (= E38ab@lev '0) (E3897@quasicons* E38b8@p (E38a1@quasi E38b9@q E38ab@lev)) (E3899@quasicons (E3899@quasicons (E387b@datum 'unquote) (E38a1@quasi E38b8@p (- E38ab@lev '1))) (E38a1@quasi E38b9@q E38ab@lev)))) E38b6@ls/false) (let ((E38bc@t E38b4@t)) (let ((E38be@ls/false (E30c1@syntax-dispatch E38bc@t '((#(scheme-id unquote-splicing) . each-any) . any)))) (if E38be@ls/false (apply (lambda (E38c0@p E38c1@q) (if (= E38ab@lev '0) (E389b@quasiappend E38c0@p (E38a1@quasi E38c1@q E38ab@lev)) (E3899@quasicons (E3899@quasicons (E387b@datum 'unquote-splicing) (E38a1@quasi E38c0@p (- E38ab@lev '1))) (E38a1@quasi E38c1@q E38ab@lev)))) E38be@ls/false) (let ((E38c4@t E38bc@t)) (let ((E38c6@ls/false (E30c1@syntax-dispatch E38c4@t '(#(scheme-id quasiquote) any)))) (if E38c6@ls/false (apply (lambda (E38c8@p) (E3899@quasicons (E387b@datum 'quasiquote) (E38a1@quasi (list E38c8@p) (+ E38ab@lev '1)))) E38c6@ls/false) (let ((E38ca@t E38c4@t)) (let ((E38cc@ls/false (E30c1@syntax-dispatch E38ca@t '(any . any)))) (if E38cc@ls/false (apply (lambda (E38ce@p E38cf@q) (E3899@quasicons (E38a1@quasi E38ce@p E38ab@lev) (E38a1@quasi E38cf@q E38ab@lev))) E38cc@ls/false) (let ((E38d2@t E38ca@t)) (let ((E38d4@ls/false (E30c1@syntax-dispatch E38d2@t '#(vector each-any)))) (if (and E38d4@ls/false (apply (lambda (E38d6@x) (not (E2e86@stx? E38d6@x))) E38d4@ls/false)) (apply (lambda (E38d8@x) (E389d@quasivector (E389f@vquasi E38d8@x E38ab@lev))) E38d4@ls/false) (let ((E38da@t E38d2@t)) (let ((E38dc@ls/false (E30c1@syntax-dispatch E38da@t 'any))) (if E38dc@ls/false (apply (lambda (E38de@p) (list (E3049@scheme-stx 'quote) E38de@p)) E38dc@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E38da@t))))))))))))))))))))))))) (lambda (E38a2@x) (let ((E38a4@t E38a2@x)) (let ((E38a6@ls/false (E30c1@syntax-dispatch E38a4@t '(_ any)))) (if E38a6@ls/false (apply (lambda (E38a8@e) (E38a1@quasi E38a8@e '0)) E38a6@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E38a4@t))))))) (set! E4b8e@E30af@quasiquote-macro E30af@quasiquote-macro) (set! E30b1@quasisyntax-macro (letrec* ((E397f@quasi (lambda (E399a@p E399b@lev) (let ((E399e@t E399a@p)) (let ((E39a0@ls/false (E30c1@syntax-dispatch E399e@t '(#(scheme-id unsyntax) any)))) (if E39a0@ls/false (apply (lambda (E39a2@p) (if (= E399b@lev '0) (let ((E39a4@g (gensym))) (values (list E39a4@g) (list E39a2@p) E39a4@g)) (call-with-values (lambda () (E397f@quasi E39a2@p (- E399b@lev '1))) (lambda (E39ac@E39a7 E39ad@E39a9 E39ae@E39ab) (let ((E39b2@p E39ae@E39ab) (E39b3@rhs* E39ad@E39a9) (E39b4@lhs* E39ac@E39a7)) (values E39b4@lhs* E39b3@rhs* (list 'unsyntax E39b2@p))))))) E39a0@ls/false) (let ((E39b8@t E399e@t)) (let ((E39ba@ls/false (E30c1@syntax-dispatch E39b8@t '#(scheme-id unsyntax)))) (if (and E39ba@ls/false (apply (lambda () (= E399b@lev '0)) E39ba@ls/false)) (apply (lambda () (E31a1@syntax-violation '#f '"incorrect use of unsyntax" E399a@p)) E39ba@ls/false) (let ((E39bc@t E39b8@t)) (let ((E39be@ls/false (E30c1@syntax-dispatch E39bc@t '((#(scheme-id unsyntax) . each-any) . any)))) (if E39be@ls/false (apply (lambda (E39c0@p* E39c1@q) (call-with-values (lambda () (E397f@quasi E39c1@q E399b@lev)) (lambda (E39ca@E39c5 E39cb@E39c7 E39cc@E39c9) (let ((E39d0@q E39cc@E39c9) (E39d1@rhs* E39cb@E39c7) (E39d2@lhs* E39ca@E39c5)) (if (= E399b@lev '0) (let ((E39d6@g* (map (lambda (E39d8@x) (gensym)) E39c0@p*))) (values (append E39d6@g* E39d2@lhs*) (append E39c0@p* E39d1@rhs*) (append E39d6@g* E39d0@q))) (call-with-values (lambda () (E397f@quasi E39c0@p* (- E399b@lev '1))) (lambda (E39e0@E39db E39e1@E39dd E39e2@E39df) (let ((E39e6@p* E39e2@E39df) (E39e7@rhs2* E39e1@E39dd) (E39e8@lhs2* E39e0@E39db)) (values (append E39e8@lhs2* E39d2@lhs*) (append E39e7@rhs2* E39d1@rhs*) (cons (cons 'unsyntax E39e6@p*) E39d0@q)))))))))) E39be@ls/false) (let ((E39ec@t E39bc@t)) (let ((E39ee@ls/false (E30c1@syntax-dispatch E39ec@t '((#(scheme-id unsyntax-splicing) . each-any) . any)))) (if E39ee@ls/false (apply (lambda (E39f0@p* E39f1@q) (call-with-values (lambda () (E397f@quasi E39f1@q E399b@lev)) (lambda (E39fa@E39f5 E39fb@E39f7 E39fc@E39f9) (let ((E3a00@q E39fc@E39f9) (E3a01@rhs* E39fb@E39f7) (E3a02@lhs* E39fa@E39f5)) (if (= E399b@lev '0) (let ((E3a06@g* (map (lambda (E3a08@x) (gensym)) E39f0@p*))) (values (append (map (lambda (E3a0a@g) (cons E3a0a@g '(...))) E3a06@g*) E3a02@lhs*) (append E39f0@p* E3a01@rhs*) (append (apply append (map (lambda (E3a0c@g) (cons E3a0c@g '(...))) E3a06@g*)) E3a00@q))) (call-with-values (lambda () (E397f@quasi E39f0@p* (- E399b@lev '1))) (lambda (E3a14@E3a0f E3a15@E3a11 E3a16@E3a13) (let ((E3a1a@p* E3a16@E3a13) (E3a1b@rhs2* E3a15@E3a11) (E3a1c@lhs2* E3a14@E3a0f)) (values (append E3a1c@lhs2* E3a02@lhs*) (append E3a1b@rhs2* E3a01@rhs*) (cons (cons 'unsyntax-splicing E3a1a@p*) E3a00@q)))))))))) E39ee@ls/false) (let ((E3a20@t E39ec@t)) (let ((E3a22@ls/false (E30c1@syntax-dispatch E3a20@t '#(scheme-id unsyntax-splicing)))) (if (and E3a22@ls/false (apply (lambda () (= E399b@lev '0)) E3a22@ls/false)) (apply (lambda () (E31a1@syntax-violation '#f '"incorrect use of unsyntax-splicing" E399a@p)) E3a22@ls/false) (let ((E3a24@t E3a20@t)) (let ((E3a26@ls/false (E30c1@syntax-dispatch E3a24@t '(#(scheme-id quasisyntax) any)))) (if E3a26@ls/false (apply (lambda (E3a28@p) (call-with-values (lambda () (E397f@quasi E3a28@p (+ E399b@lev '1))) (lambda (E3a30@E3a2b E3a31@E3a2d E3a32@E3a2f) (let ((E3a36@p E3a32@E3a2f) (E3a37@rhs* E3a31@E3a2d) (E3a38@lhs* E3a30@E3a2b)) (values E3a38@lhs* E3a37@rhs* (list 'quasisyntax E3a36@p)))))) E3a26@ls/false) (let ((E3a3c@t E3a24@t)) (let ((E3a3e@ls/false (E30c1@syntax-dispatch E3a3c@t '(any . any)))) (if E3a3e@ls/false (apply (lambda (E3a40@p E3a41@q) (call-with-values (lambda () (E397f@quasi E3a40@p E399b@lev)) (lambda (E3a50@E3a45 E3a51@E3a47 E3a52@E3a49) (call-with-values (lambda () (E397f@quasi E3a41@q E399b@lev)) (lambda (E3a56@E3a4b E3a57@E3a4d E3a58@E3a4f) (let ((E3a5c@q E3a58@E3a4f) (E3a5d@rhs2* E3a57@E3a4d) (E3a5e@lhs2* E3a56@E3a4b) (E3a5f@p E3a52@E3a49) (E3a60@rhs* E3a51@E3a47) (E3a61@lhs* E3a50@E3a45)) (values (append E3a5e@lhs2* E3a61@lhs*) (append E3a5d@rhs2* E3a60@rhs*) (cons E3a5f@p E3a5c@q)))))))) E3a3e@ls/false) (let ((E3a68@t E3a3c@t)) (let ((E3a6a@ls/false (E30c1@syntax-dispatch E3a68@t '#(vector each-any)))) (if E3a6a@ls/false (apply (lambda (E3a6c@x*) (call-with-values (lambda () (E397f@quasi E3a6c@x* E399b@lev)) (lambda (E3a74@E3a6f E3a75@E3a71 E3a76@E3a73) (let ((E3a7a@x* E3a76@E3a73) (E3a7b@rhs* E3a75@E3a71) (E3a7c@lhs* E3a74@E3a6f)) (values E3a7c@lhs* E3a7b@rhs* (list->vector E3a7a@x*)))))) E3a6a@ls/false) (let ((E3a80@t E3a68@t)) (let ((E3a82@ls/false (E30c1@syntax-dispatch E3a80@t '_))) (if E3a82@ls/false (apply (lambda () (values '() '() E399a@p)) E3a82@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3a80@t))))))))))))))))))))))))))))))) (lambda (E3980@x) (let ((E3982@t E3980@x)) (let ((E3984@ls/false (E30c1@syntax-dispatch E3982@t '(_ any)))) (if E3984@ls/false (apply (lambda (E3986@e) (call-with-values (lambda () (E397f@quasi E3986@e '0)) (lambda (E398e@E3989 E398f@E398b E3990@E398d) (let ((E3994@v E3990@E398d) (E3995@rhs* E398f@E398b) (E3996@lhs* E398e@E3989)) (E3077@bless (list 'syntax-case (cons 'list E3995@rhs*) '() (list E3996@lhs* (list 'syntax E3994@v)))))))) E3984@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3982@t))))))) (set! E4b8f@E30b1@quasisyntax-macro E30b1@quasisyntax-macro) (set! E30b3@define-struct-macro (lambda (E3a84@stx) (E31a1@syntax-violation '#f '"define-struct not supported" E3a84@stx))) (set! E4b90@E30b3@define-struct-macro E30b3@define-struct-macro) (set! E30b5@define-record-type-macro (lambda (E3a86@x) (letrec* ((E3a89@id (lambda (E3c7c@ctxt . E3c7e@str*) (E31a5@datum->syntax E3c7c@ctxt (string->symbol (apply string-append (map (lambda (E3c80@x) (if (symbol? E3c80@x) (symbol->string E3c80@x) (if (string? E3c80@x) E3c80@x (assertion-violation 'define-record-type '"BUG")))) E3c7e@str*)))))) (E3a8b@get-record-name (lambda (E3c6a@spec) (let ((E3c6c@t E3c6a@spec)) (let ((E3c6e@ls/false (E30c1@syntax-dispatch E3c6c@t '(any any any)))) (if E3c6e@ls/false (apply (lambda (E3c70@foo E3c71@make-foo E3c72@foo?) E3c70@foo) E3c6e@ls/false) (let ((E3c76@t E3c6c@t)) (let ((E3c78@ls/false (E30c1@syntax-dispatch E3c76@t 'any))) (if E3c78@ls/false (apply (lambda (E3c7a@foo) E3c7a@foo) E3c78@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3c76@t))))))))) (E3a8d@get-record-constructor-name (lambda (E3c56@spec) (let ((E3c58@t E3c56@spec)) (let ((E3c5a@ls/false (E30c1@syntax-dispatch E3c58@t '(any any any)))) (if E3c5a@ls/false (apply (lambda (E3c5c@foo E3c5d@make-foo E3c5e@foo?) E3c5d@make-foo) E3c5a@ls/false) (let ((E3c62@t E3c58@t)) (let ((E3c64@ls/false (E30c1@syntax-dispatch E3c62@t 'any))) (if (and E3c64@ls/false (apply (lambda (E3c66@foo) (E2eba@id? E3c66@foo)) E3c64@ls/false)) (apply (lambda (E3c68@foo) (E3a89@id E3c68@foo '"make-" (E2ece@stx->datum E3c68@foo))) E3c64@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3c62@t))))))))) (E3a8f@get-record-predicate-name (lambda (E3c42@spec) (let ((E3c44@t E3c42@spec)) (let ((E3c46@ls/false (E30c1@syntax-dispatch E3c44@t '(any any any)))) (if E3c46@ls/false (apply (lambda (E3c48@foo E3c49@make-foo E3c4a@foo?) E3c4a@foo?) E3c46@ls/false) (let ((E3c4e@t E3c44@t)) (let ((E3c50@ls/false (E30c1@syntax-dispatch E3c4e@t 'any))) (if (and E3c50@ls/false (apply (lambda (E3c52@foo) (E2eba@id? E3c52@foo)) E3c50@ls/false)) (apply (lambda (E3c54@foo) (E3a89@id E3c54@foo (E2ece@stx->datum E3c54@foo) '"?")) E3c50@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3c4e@t))))))))) (E3a91@get-clause (lambda (E3c30@id E3c31@ls) (let ((E3c34@t E3c31@ls)) (let ((E3c36@ls/false (E30c1@syntax-dispatch E3c34@t '()))) (if E3c36@ls/false (apply (lambda () '#f) E3c36@ls/false) (let ((E3c38@t E3c34@t)) (let ((E3c3a@ls/false (E30c1@syntax-dispatch E3c38@t '((any . any) . any)))) (if E3c3a@ls/false (apply (lambda (E3c3c@x E3c3d@rest E3c3e@ls) (if (E2ec0@free-id=? (E3077@bless E3c30@id) E3c3c@x) (cons E3c3c@x E3c3d@rest) (E3a91@get-clause E3c30@id E3c3e@ls))) E3c3a@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3c38@t))))))))) (E3a93@foo-rtd-code (lambda (E3bde@name E3bdf@clause* E3be0@parent-rtd-code) (letrec* ((E3be5@convert-field-spec* (lambda (E3c16@ls) (list->vector (map (lambda (E3c18@x) (let ((E3c1a@t E3c18@x)) (let ((E3c1c@ls/false (E30c1@syntax-dispatch E3c1a@t '(#(scheme-id mutable) any . any)))) (if E3c1c@ls/false (apply (lambda (E3c1e@name E3c1f@rest) (list 'mutable E3c1e@name)) E3c1c@ls/false) (let ((E3c22@t E3c1a@t)) (let ((E3c24@ls/false (E30c1@syntax-dispatch E3c22@t '(#(scheme-id immutable) any . any)))) (if E3c24@ls/false (apply (lambda (E3c26@name E3c27@rest) (list 'immutable E3c26@name)) E3c24@ls/false) (let ((E3c2a@t E3c22@t)) (let ((E3c2c@ls/false (E30c1@syntax-dispatch E3c2a@t 'any))) (if E3c2c@ls/false (apply (lambda (E3c2e@name) (list 'immutable E3c2e@name)) E3c2c@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3c2a@t))))))))))) E3c16@ls))))) (let ((E3be6@uid-code (let ((E3bee@t (E3a91@get-clause 'nongenerative E3bdf@clause*))) (let ((E3bf0@ls/false (E30c1@syntax-dispatch E3bee@t '(_)))) (if E3bf0@ls/false (apply (lambda () (list 'quote (gensym))) E3bf0@ls/false) (let ((E3bf2@t E3bee@t)) (let ((E3bf4@ls/false (E30c1@syntax-dispatch E3bf2@t '(_ any)))) (if E3bf4@ls/false (apply (lambda (E3bf6@uid) (list 'quote E3bf6@uid)) E3bf4@ls/false) (let ((E3bf8@t E3bf2@t)) (let ((E3bfa@ls/false (E30c1@syntax-dispatch E3bf8@t '_))) (if E3bfa@ls/false (apply (lambda () '#f) E3bfa@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3bf8@t))))))))))) (E3be7@sealed? (let ((E3bfc@t (E3a91@get-clause 'sealed E3bdf@clause*))) (let ((E3bfe@ls/false (E30c1@syntax-dispatch E3bfc@t '(_ #(atom #t))))) (if E3bfe@ls/false (apply (lambda () '#t) E3bfe@ls/false) (let ((E3c00@t E3bfc@t)) (let ((E3c02@ls/false (E30c1@syntax-dispatch E3c00@t '_))) (if E3c02@ls/false (apply (lambda () '#f) E3c02@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3c00@t)))))))) (E3be8@opaque? (let ((E3c04@t (E3a91@get-clause 'opaque E3bdf@clause*))) (let ((E3c06@ls/false (E30c1@syntax-dispatch E3c04@t '(_ #(atom #t))))) (if E3c06@ls/false (apply (lambda () '#t) E3c06@ls/false) (let ((E3c08@t E3c04@t)) (let ((E3c0a@ls/false (E30c1@syntax-dispatch E3c08@t '_))) (if E3c0a@ls/false (apply (lambda () '#f) E3c0a@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3c08@t)))))))) (E3be9@fields (let ((E3c0c@t (E3a91@get-clause 'fields E3bdf@clause*))) (let ((E3c0e@ls/false (E30c1@syntax-dispatch E3c0c@t '(_ . each-any)))) (if E3c0e@ls/false (apply (lambda (E3c10@field-spec*) (list 'quote (E3be5@convert-field-spec* E3c10@field-spec*))) E3c0e@ls/false) (let ((E3c12@t E3c0c@t)) (let ((E3c14@ls/false (E30c1@syntax-dispatch E3c12@t '_))) (if E3c14@ls/false (apply (lambda () ''#()) E3c14@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3c12@t))))))))) (E3077@bless (list 'make-record-type-descriptor (list 'quote E3bde@name) E3be0@parent-rtd-code E3be6@uid-code E3be7@sealed? E3be8@opaque? E3be9@fields)))))) (E3a95@parent-rtd-code (lambda (E3bc6@clause*) (let ((E3bc8@t (E3a91@get-clause 'parent E3bc6@clause*))) (let ((E3bca@ls/false (E30c1@syntax-dispatch E3bc8@t '(_ any)))) (if E3bca@ls/false (apply (lambda (E3bcc@name) (list 'record-type-descriptor E3bcc@name)) E3bca@ls/false) (let ((E3bce@t E3bc8@t)) (let ((E3bd0@ls/false (E30c1@syntax-dispatch E3bce@t '#(atom #f)))) (if E3bd0@ls/false (apply (lambda () (let ((E3bd2@t (E3a91@get-clause 'parent-rtd E3bc6@clause*))) (let ((E3bd4@ls/false (E30c1@syntax-dispatch E3bd2@t '(_ any any)))) (if E3bd4@ls/false (apply (lambda (E3bd6@rtd E3bd7@rcd) E3bd6@rtd) E3bd4@ls/false) (let ((E3bda@t E3bd2@t)) (let ((E3bdc@ls/false (E30c1@syntax-dispatch E3bda@t '#(atom #f)))) (if E3bdc@ls/false (apply (lambda () '#f) E3bdc@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3bda@t)))))))) E3bd0@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3bce@t))))))))) (E3a97@parent-rcd-code (lambda (E3bae@clause*) (let ((E3bb0@t (E3a91@get-clause 'parent E3bae@clause*))) (let ((E3bb2@ls/false (E30c1@syntax-dispatch E3bb0@t '(_ any)))) (if E3bb2@ls/false (apply (lambda (E3bb4@name) (list 'record-constructor-descriptor E3bb4@name)) E3bb2@ls/false) (let ((E3bb6@t E3bb0@t)) (let ((E3bb8@ls/false (E30c1@syntax-dispatch E3bb6@t '#(atom #f)))) (if E3bb8@ls/false (apply (lambda () (let ((E3bba@t (E3a91@get-clause 'parent-rtd E3bae@clause*))) (let ((E3bbc@ls/false (E30c1@syntax-dispatch E3bba@t '(_ any any)))) (if E3bbc@ls/false (apply (lambda (E3bbe@rtd E3bbf@rcd) E3bbf@rcd) E3bbc@ls/false) (let ((E3bc2@t E3bba@t)) (let ((E3bc4@ls/false (E30c1@syntax-dispatch E3bc2@t '#(atom #f)))) (if E3bc4@ls/false (apply (lambda () '#f) E3bc4@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3bc2@t)))))))) E3bb8@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3bb6@t))))))))) (E3a99@foo-rcd-code (lambda (E3ba6@clause* E3ba7@foo-rtd E3ba8@protocol E3ba9@parent-rcd-code) (list 'make-record-constructor-descriptor E3ba7@foo-rtd E3ba9@parent-rcd-code E3ba8@protocol))) (E3a9b@get-protocol-code (lambda (E3b9a@clause*) (let ((E3b9c@t (E3a91@get-clause 'protocol E3b9a@clause*))) (let ((E3b9e@ls/false (E30c1@syntax-dispatch E3b9c@t '(_ any)))) (if E3b9e@ls/false (apply (lambda (E3ba0@expr) E3ba0@expr) E3b9e@ls/false) (let ((E3ba2@t E3b9c@t)) (let ((E3ba4@ls/false (E30c1@syntax-dispatch E3ba2@t '_))) (if E3ba4@ls/false (apply (lambda () '#f) E3ba4@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3ba2@t))))))))) (E3a9d@get-fields (lambda (E3b88@clause*) (let ((E3b8a@t E3b88@clause*)) (let ((E3b8c@ls/false (E30c1@syntax-dispatch E3b8a@t '()))) (if E3b8c@ls/false (apply (lambda () '()) E3b8c@ls/false) (let ((E3b8e@t E3b8a@t)) (let ((E3b90@ls/false (E30c1@syntax-dispatch E3b8e@t '((#(scheme-id fields) . each-any) . _)))) (if E3b90@ls/false (apply (lambda (E3b92@f*) E3b92@f*) E3b90@ls/false) (let ((E3b94@t E3b8e@t)) (let ((E3b96@ls/false (E30c1@syntax-dispatch E3b94@t '(_ . any)))) (if E3b96@ls/false (apply (lambda (E3b98@rest) (E3a9d@get-fields E3b98@rest)) E3b96@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3b94@t)))))))))))) (E3a9f@get-mutator-indices (lambda (E3b70@fields) (let E3b76@f ((E3b72@fields E3b70@fields) (E3b73@i '0)) (let ((E3b78@t E3b72@fields)) (let ((E3b7a@ls/false (E30c1@syntax-dispatch E3b78@t '()))) (if E3b7a@ls/false (apply (lambda () '()) E3b7a@ls/false) (let ((E3b7c@t E3b78@t)) (let ((E3b7e@ls/false (E30c1@syntax-dispatch E3b7c@t '((#(scheme-id mutable) . _) . any)))) (if E3b7e@ls/false (apply (lambda (E3b80@rest) (cons E3b73@i (E3b76@f E3b80@rest (+ E3b73@i '1)))) E3b7e@ls/false) (let ((E3b82@t E3b7c@t)) (let ((E3b84@ls/false (E30c1@syntax-dispatch E3b82@t '(_ . any)))) (if E3b84@ls/false (apply (lambda (E3b86@rest) (E3b76@f E3b86@rest (+ E3b73@i '1))) E3b84@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3b82@t))))))))))))) (E3aa1@get-mutators (lambda (E3b46@foo E3b47@fields) (letrec* ((E3b4b@gen-name (lambda (E3b6e@x) (E31a5@datum->syntax E3b46@foo (string->symbol (string-append (symbol->string (E31a7@syntax->datum E3b46@foo)) '"-" (symbol->string (E31a7@syntax->datum E3b6e@x)) '"-set!")))))) (let E3b4e@f ((E3b4c@fields E3b47@fields)) (let ((E3b50@t E3b4c@fields)) (let ((E3b52@ls/false (E30c1@syntax-dispatch E3b50@t '()))) (if E3b52@ls/false (apply (lambda () '()) E3b52@ls/false) (let ((E3b54@t E3b50@t)) (let ((E3b56@ls/false (E30c1@syntax-dispatch E3b54@t '((#(scheme-id mutable) any any any) . any)))) (if E3b56@ls/false (apply (lambda (E3b58@name E3b59@accessor E3b5a@mutator E3b5b@rest) (cons E3b5a@mutator (E3b4e@f E3b5b@rest))) E3b56@ls/false) (let ((E3b60@t E3b54@t)) (let ((E3b62@ls/false (E30c1@syntax-dispatch E3b60@t '((#(scheme-id mutable) any) . any)))) (if E3b62@ls/false (apply (lambda (E3b64@name E3b65@rest) (cons (E3b4b@gen-name E3b64@name) (E3b4e@f E3b65@rest))) E3b62@ls/false) (let ((E3b68@t E3b60@t)) (let ((E3b6a@ls/false (E30c1@syntax-dispatch E3b68@t '(_ . any)))) (if E3b6a@ls/false (apply (lambda (E3b6c@rest) (E3b4e@f E3b6c@rest)) E3b6a@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3b68@t))))))))))))))))) (E3aa3@get-accessors (lambda (E3b02@foo E3b03@fields) (letrec* ((E3b07@gen-name (lambda (E3b44@x) (E31a5@datum->syntax E3b02@foo (string->symbol (string-append (symbol->string (E31a7@syntax->datum E3b02@foo)) '"-" (symbol->string (E31a7@syntax->datum E3b44@x)))))))) (map (lambda (E3b08@field) (let ((E3b0a@t E3b08@field)) (let ((E3b0c@ls/false (E30c1@syntax-dispatch E3b0a@t '(#(scheme-id mutable) any any any)))) (if (and E3b0c@ls/false (apply (lambda (E3b0e@name E3b0f@accessor E3b10@mutator) (E2eba@id? E3b0f@accessor)) E3b0c@ls/false)) (apply (lambda (E3b14@name E3b15@accessor E3b16@mutator) E3b15@accessor) E3b0c@ls/false) (let ((E3b1a@t E3b0a@t)) (let ((E3b1c@ls/false (E30c1@syntax-dispatch E3b1a@t '(#(scheme-id immutable) any any)))) (if (and E3b1c@ls/false (apply (lambda (E3b1e@name E3b1f@accessor) (E2eba@id? E3b1f@accessor)) E3b1c@ls/false)) (apply (lambda (E3b22@name E3b23@accessor) E3b23@accessor) E3b1c@ls/false) (let ((E3b26@t E3b1a@t)) (let ((E3b28@ls/false (E30c1@syntax-dispatch E3b26@t '(#(scheme-id mutable) any)))) (if (and E3b28@ls/false (apply (lambda (E3b2a@name) (E2eba@id? E3b2a@name)) E3b28@ls/false)) (apply (lambda (E3b2c@name) (E3b07@gen-name E3b2c@name)) E3b28@ls/false) (let ((E3b2e@t E3b26@t)) (let ((E3b30@ls/false (E30c1@syntax-dispatch E3b2e@t '(#(scheme-id immutable) any)))) (if (and E3b30@ls/false (apply (lambda (E3b32@name) (E2eba@id? E3b32@name)) E3b30@ls/false)) (apply (lambda (E3b34@name) (E3b07@gen-name E3b34@name)) E3b30@ls/false) (let ((E3b36@t E3b2e@t)) (let ((E3b38@ls/false (E30c1@syntax-dispatch E3b36@t 'any))) (if (and E3b38@ls/false (apply (lambda (E3b3a@name) (E2eba@id? E3b3a@name)) E3b38@ls/false)) (apply (lambda (E3b3c@name) (E3b07@gen-name E3b3c@name)) E3b38@ls/false) (let ((E3b3e@t E3b36@t)) (let ((E3b40@ls/false (E30c1@syntax-dispatch E3b3e@t 'any))) (if E3b40@ls/false (apply (lambda (E3b42@others) (E31a1@syntax-violation '#f '"invalid field spec" E3b08@field)) E3b40@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3b3e@t)))))))))))))))))))) E3b03@fields)))) (E3aa5@enumerate (lambda (E3afa@ls) (let E3b00@f ((E3afc@ls E3afa@ls) (E3afd@i '0)) (if (null? E3afc@ls) '() (cons E3afd@i (E3b00@f (cdr E3afc@ls) (+ E3afd@i '1))))))) (E3aa7@do-define-record (lambda (E3ad2@namespec E3ad3@clause*) (let ((E3ad6@foo (E3a8b@get-record-name E3ad2@namespec))) (let ((E3ad8@foo-rtd (gensym))) (let ((E3ada@foo-rcd (gensym))) (let ((E3adc@protocol (gensym))) (let ((E3ade@make-foo (E3a8d@get-record-constructor-name E3ad2@namespec))) (let ((E3ae0@fields (E3a9d@get-fields E3ad3@clause*))) (let ((E3ae2@idx* (E3aa5@enumerate E3ae0@fields))) (let ((E3ae4@foo-x* (E3aa3@get-accessors E3ad6@foo E3ae0@fields))) (let ((E3ae6@set-foo-x!* (E3aa1@get-mutators E3ad6@foo E3ae0@fields))) (let ((E3ae8@set-foo-idx* (E3a9f@get-mutator-indices E3ae0@fields))) (let ((E3aea@foo? (E3a8f@get-record-predicate-name E3ad2@namespec))) (let ((E3aec@foo-rtd-code (E3a93@foo-rtd-code E3ad6@foo E3ad3@clause* (E3a95@parent-rtd-code E3ad3@clause*)))) (let ((E3aee@foo-rcd-code (E3a99@foo-rcd-code E3ad3@clause* E3ad8@foo-rtd E3adc@protocol (E3a97@parent-rcd-code E3ad3@clause*)))) (let ((E3af0@protocol-code (E3a9b@get-protocol-code E3ad3@clause*))) (E3077@bless (cons 'begin (cons (list 'define E3ad8@foo-rtd E3aec@foo-rtd-code) (cons (list 'define E3adc@protocol E3af0@protocol-code) (cons (list 'define E3ada@foo-rcd E3aee@foo-rcd-code) (cons (list 'define-syntax E3ad6@foo (list 'list ''$rtd (list 'syntax E3ad8@foo-rtd) (list 'syntax E3ada@foo-rcd))) (cons (list 'define E3aea@foo? (list 'record-predicate E3ad8@foo-rtd)) (cons (list 'define E3ade@make-foo (list 'record-constructor E3ada@foo-rcd)) (append (map (lambda (E3af2@foo-x E3af3@idx) (list 'define E3af2@foo-x (list 'record-accessor E3ad8@foo-rtd E3af3@idx))) E3ae4@foo-x* E3ae2@idx*) (map (lambda (E3af6@set-foo-x! E3af7@idx) (list 'define E3af6@set-foo-x! (list 'record-mutator E3ad8@foo-rtd E3af7@idx))) E3ae6@set-foo-x!* E3ae8@set-foo-idx*)))))))))))))))))))))))))) (E3aa9@verify-clauses (lambda (E3ab2@x E3ab3@cls*) (letrec* ((E3ab7@valid-kwds (map E3077@bless '(fields parent parent-rtd protocol sealed opaque nongenerative))) (E3ab9@free-id-member? (lambda (E3ace@x E3acf@ls) (and (pair? E3acf@ls) (or (E2ec0@free-id=? E3ace@x (car E3acf@ls)) (E3ab9@free-id-member? E3ace@x (cdr E3acf@ls))))))) (let E3abe@f ((E3aba@cls* E3ab3@cls*) (E3abb@seen* '())) (if (not (null? E3aba@cls*)) (let ((E3ac0@t (car E3aba@cls*))) (let ((E3ac2@ls/false (E30c1@syntax-dispatch E3ac0@t '(any . any)))) (if E3ac2@ls/false (apply (lambda (E3ac4@kwd E3ac5@rest) (if (or (not (E2eba@id? E3ac4@kwd)) (not (E3ab9@free-id-member? E3ac4@kwd E3ab7@valid-kwds))) (E31a1@syntax-violation '#f '"not a valid define-record-type keyword" E3ac4@kwd) (if (E2ec6@bound-id-member? E3ac4@kwd E3abb@seen*) (E31a1@syntax-violation '#f '"duplicate use of keyword " E3ab2@x E3ac4@kwd) (E3abe@f (cdr E3aba@cls*) (cons E3ac4@kwd E3abb@seen*))))) E3ac2@ls/false) (let ((E3ac8@t E3ac0@t)) (let ((E3aca@ls/false (E30c1@syntax-dispatch E3ac8@t 'any))) (if E3aca@ls/false (apply (lambda (E3acc@cls) (E31a1@syntax-violation '#f '"malformed define-record-type clause" E3acc@cls)) E3aca@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3ac8@t))))))) (void))))))) (let ((E3aaa@t E3a86@x)) (let ((E3aac@ls/false (E30c1@syntax-dispatch E3aaa@t '(_ any . each-any)))) (if E3aac@ls/false (apply (lambda (E3aae@namespec E3aaf@clause*) (begin (E3aa9@verify-clauses E3a86@x E3aaf@clause*) (E3aa7@do-define-record E3aae@namespec E3aaf@clause*))) E3aac@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3aaa@t))))))) (set! E4b91@E30b5@define-record-type-macro E30b5@define-record-type-macro) (set! E30b7@define-condition-type-macro (lambda (E3c82@x) (letrec* ((E3c85@mkname (lambda (E3cb2@name E3cb3@suffix) (E31a5@datum->syntax E3cb2@name (string->symbol (string-append (symbol->string (E31a7@syntax->datum E3cb2@name)) E3cb3@suffix)))))) (let ((E3c86@t E3c82@x)) (let ((E3c88@ls/false (E30c1@syntax-dispatch E3c86@t '(any any any any any . #(each (any any)))))) (if (and E3c88@ls/false (apply (lambda (E3c8a@ctxt E3c8b@name E3c8c@super E3c8d@constructor E3c8e@predicate E3c8f@field* E3c90@accessor*) (and (E2eba@id? E3c8b@name) (E2eba@id? E3c8c@super) (E2eba@id? E3c8d@constructor) (E2eba@id? E3c8e@predicate) (for-all E2eba@id? E3c8f@field*) (for-all E2eba@id? E3c90@accessor*))) E3c88@ls/false)) (apply (lambda (E3c98@ctxt E3c99@name E3c9a@super E3c9b@constructor E3c9c@predicate E3c9d@field* E3c9e@accessor*) (let ((E3ca6@aux-accessor* (map (lambda (E3ca8@x) (gensym)) E3c9e@accessor*))) (E3077@bless (cons 'begin (cons (cons 'define-record-type (cons (list E3c99@name E3c9b@constructor (gensym)) (cons (list 'parent E3c9a@super) (cons (cons 'fields (map (lambda (E3caa@field E3cab@aux) (list 'immutable E3caa@field E3cab@aux)) E3c9d@field* E3ca6@aux-accessor*)) '((nongenerative) (sealed #f) (opaque #f)))))) (cons (list 'define E3c9c@predicate (list 'condition-predicate (list 'record-type-descriptor E3c99@name))) (map (lambda (E3cae@accessor E3caf@aux) (list 'define E3cae@accessor (list 'condition-accessor (list 'record-type-descriptor E3c99@name) E3caf@aux))) E3c9e@accessor* E3ca6@aux-accessor*))))))) E3c88@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3c86@t))))))) (set! E4b92@E30b7@define-condition-type-macro E30b7@define-condition-type-macro) (set! E30b9@incorrect-usage-macro (lambda (E3cb6@e) (E31a1@syntax-violation '#f '"incorrect usage of auxiliary keyword" E3cb6@e))) (set! E4b93@E30b9@incorrect-usage-macro E30b9@incorrect-usage-macro) (set! E30bb@parameterize-macro (lambda (E3cb8@e) (let ((E3cba@t E3cb8@e)) (let ((E3cbc@ls/false (E30c1@syntax-dispatch E3cba@t '(_ () any . each-any)))) (if E3cbc@ls/false (apply (lambda (E3cbe@b E3cbf@b*) (E3077@bless (cons 'let (cons '() (cons E3cbe@b E3cbf@b*))))) E3cbc@ls/false) (let ((E3cc2@t E3cba@t)) (let ((E3cc4@ls/false (E30c1@syntax-dispatch E3cc2@t '(_ #(each (any any)) any . each-any)))) (if E3cc4@ls/false (apply (lambda (E3cc6@olhs* E3cc7@orhs* E3cc8@b E3cc9@b*) (let ((E3cce@lhs* (E318f@generate-temporaries E3cc6@olhs*)) (E3ccf@rhs* (E318f@generate-temporaries E3cc7@orhs*))) (E3077@bless (cons (list 'lambda (append E3cce@lhs* E3ccf@rhs*) (list 'let (list (list 'swap (cons 'lambda (cons '() (map (lambda (E3cd2@lhs E3cd3@rhs) (list 'let (list (list 't (list E3cd2@lhs))) (list E3cd2@lhs E3cd3@rhs) (cons 'set! (cons E3cd3@rhs '(t))))) E3cce@lhs* E3ccf@rhs*))))) (cons 'dynamic-wind (cons 'swap (cons (cons 'lambda (cons '() (cons E3cc8@b E3cc9@b*))) '(swap)))))) (append E3cc6@olhs* E3cc7@orhs*))))) E3cc4@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3cc2@t))))))))) (set! E4b94@E30bb@parameterize-macro E30bb@parameterize-macro) (set! E30bd@foreign-call-transformer (lambda (E3cd6@e E3cd7@r E3cd8@mr) (let ((E3cdc@t E3cd6@e)) (let ((E3cde@ls/false (E30c1@syntax-dispatch E3cdc@t '(_ any . each-any)))) (if E3cde@ls/false (apply (lambda (E3ce0@name E3ce1@arg*) (cons 'foreign-call (cons (E30e3@chi-expr E3ce0@name E3cd7@r E3cd8@mr) (E30df@chi-expr* E3ce1@arg* E3cd7@r E3cd8@mr)))) E3cde@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3cdc@t)))))) (set! E4b95@E30bd@foreign-call-transformer E30bd@foreign-call-transformer) (set! E30bf@convert-pattern (lambda (E3ce4@pattern E3ce5@keys) (letrec* ((E3ce9@cvt* (lambda (E3d88@p* E3d89@n E3d8a@ids) (if (null? E3d88@p*) (values '() E3d8a@ids) (call-with-values (lambda () (E3ce9@cvt* (cdr E3d88@p*) E3d89@n E3d8a@ids)) (lambda (E3d92@E3d8f E3d93@E3d91) (let ((E3d96@ids E3d93@E3d91) (E3d97@y E3d92@E3d8f)) (call-with-values (lambda () (E3ceb@cvt (car E3d88@p*) E3d89@n E3d96@ids)) (lambda (E3d9e@E3d9b E3d9f@E3d9d) (let ((E3da2@ids E3d9f@E3d9d) (E3da3@x E3d9e@E3d9b)) (values (cons E3da3@x E3d97@y) E3da2@ids)))))))))) (E3ceb@cvt (lambda (E3cec@p E3ced@n E3cee@ids) (let ((E3cf2@t E3cec@p)) (let ((E3cf4@ls/false (E30c1@syntax-dispatch E3cf2@t 'any))) (if (and E3cf4@ls/false (apply (lambda (E3cf6@id) (E2eba@id? E3cf6@id)) E3cf4@ls/false)) (apply (lambda (E3cf8@id) (if (E2ec6@bound-id-member? E3cec@p E3ce5@keys) (values (vector 'free-id E3cec@p) E3cee@ids) (if (E2ec0@free-id=? E3cec@p (E3049@scheme-stx '_)) (values '_ E3cee@ids) (values 'any (cons (cons E3cec@p E3ced@n) E3cee@ids))))) E3cf4@ls/false) (let ((E3cfa@t E3cf2@t)) (let ((E3cfc@ls/false (E30c1@syntax-dispatch E3cfa@t '(any any)))) (if (and E3cfc@ls/false (apply (lambda (E3cfe@p E3cff@dots) (E30c3@ellipsis? E3cff@dots)) E3cfc@ls/false)) (apply (lambda (E3d02@p E3d03@dots) (call-with-values (lambda () (E3ceb@cvt E3d02@p (+ E3ced@n '1) E3cee@ids)) (lambda (E3d0a@E3d07 E3d0b@E3d09) (let ((E3d0e@ids E3d0b@E3d09) (E3d0f@p E3d0a@E3d07)) (values (if (eq? E3d0f@p 'any) 'each-any (vector 'each E3d0f@p)) E3d0e@ids))))) E3cfc@ls/false) (let ((E3d12@t E3cfa@t)) (let ((E3d14@ls/false (E30c1@syntax-dispatch E3d12@t '(any any . #(each+ any () any))))) (if (and E3d14@ls/false (apply (lambda (E3d16@x E3d17@dots E3d18@ys E3d19@z) (E30c3@ellipsis? E3d17@dots)) E3d14@ls/false)) (apply (lambda (E3d1e@x E3d1f@dots E3d20@ys E3d21@z) (call-with-values (lambda () (E3ceb@cvt E3d21@z E3ced@n E3cee@ids)) (lambda (E3d2a@E3d27 E3d2b@E3d29) (let ((E3d2e@ids E3d2b@E3d29) (E3d2f@z E3d2a@E3d27)) (call-with-values (lambda () (E3ce9@cvt* E3d20@ys E3ced@n E3d2e@ids)) (lambda (E3d36@E3d33 E3d37@E3d35) (let ((E3d3a@ids E3d37@E3d35) (E3d3b@ys E3d36@E3d33)) (call-with-values (lambda () (E3ceb@cvt E3d1e@x (+ E3ced@n '1) E3d3a@ids)) (lambda (E3d42@E3d3f E3d43@E3d41) (let ((E3d46@ids E3d43@E3d41) (E3d47@x E3d42@E3d3f)) (values (vector 'each+ E3d47@x (reverse E3d3b@ys) E3d2f@z) E3d46@ids))))))))))) E3d14@ls/false) (let ((E3d4a@t E3d12@t)) (let ((E3d4c@ls/false (E30c1@syntax-dispatch E3d4a@t '(any . any)))) (if E3d4c@ls/false (apply (lambda (E3d4e@x E3d4f@y) (call-with-values (lambda () (E3ceb@cvt E3d4f@y E3ced@n E3cee@ids)) (lambda (E3d56@E3d53 E3d57@E3d55) (let ((E3d5a@ids E3d57@E3d55) (E3d5b@y E3d56@E3d53)) (call-with-values (lambda () (E3ceb@cvt E3d4e@x E3ced@n E3d5a@ids)) (lambda (E3d62@E3d5f E3d63@E3d61) (let ((E3d66@ids E3d63@E3d61) (E3d67@x E3d62@E3d5f)) (values (cons E3d67@x E3d5b@y) E3d66@ids)))))))) E3d4c@ls/false) (let ((E3d6a@t E3d4a@t)) (let ((E3d6c@ls/false (E30c1@syntax-dispatch E3d6a@t '()))) (if E3d6c@ls/false (apply (lambda () (values '() E3cee@ids)) E3d6c@ls/false) (let ((E3d6e@t E3d6a@t)) (let ((E3d70@ls/false (E30c1@syntax-dispatch E3d6e@t '#(vector each-any)))) (if (and E3d70@ls/false (apply (lambda (E3d72@p) (not (E2e86@stx? E3d72@p))) E3d70@ls/false)) (apply (lambda (E3d74@p) (call-with-values (lambda () (E3ceb@cvt E3d74@p E3ced@n E3cee@ids)) (lambda (E3d7a@E3d77 E3d7b@E3d79) (let ((E3d7e@ids E3d7b@E3d79) (E3d7f@p E3d7a@E3d77)) (values (vector 'vector E3d7f@p) E3d7e@ids))))) E3d70@ls/false) (let ((E3d82@t E3d6e@t)) (let ((E3d84@ls/false (E30c1@syntax-dispatch E3d82@t 'any))) (if E3d84@ls/false (apply (lambda (E3d86@datum) (values (vector 'atom (E2ece@stx->datum E3d86@datum)) E3cee@ids)) E3d84@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3d82@t))))))))))))))))))))))))) (E3ceb@cvt E3ce4@pattern '0 '())))) (set! E4b96@E30bf@convert-pattern E30bf@convert-pattern) (set! E30c1@syntax-dispatch (letrec* ((E3da7@stx^ (lambda (E3e82@e E3e83@m* E3e84@s* E3e85@ae*) (if (and (null? E3e83@m*) (null? E3e84@s*) (null? E3e85@ae*)) E3e82@e (E2ea2@mkstx E3e82@e E3e83@m* E3e84@s* E3e85@ae*)))) (E3da9@match-each (lambda (E3e62@e E3e63@p E3e64@m* E3e65@s* E3e66@ae*) (if (pair? E3e62@e) (let ((E3e6c@first (E3db5@match (car E3e62@e) E3e63@p E3e64@m* E3e65@s* E3e66@ae* '()))) (and E3e6c@first (let ((E3e6e@rest (E3da9@match-each (cdr E3e62@e) E3e63@p E3e64@m* E3e65@s* E3e66@ae*))) (and E3e6e@rest (cons E3e6c@first E3e6e@rest))))) (if (null? E3e62@e) '() (if (E2e86@stx? E3e62@e) (and (not (E2e40@top-marked? E3e64@m*)) (call-with-values (lambda () (join-wraps E3e64@m* E3e65@s* E3e66@ae* E3e62@e)) (lambda (E3e76@E3e71 E3e77@E3e73 E3e78@E3e75) (let ((E3e7c@ae* E3e78@E3e75) (E3e7d@s* E3e77@E3e73) (E3e7e@m* E3e76@E3e71)) (E3da9@match-each (E2e88@stx-expr E3e62@e) E3e63@p E3e7e@m* E3e7d@s* E3e7c@ae*))))) (if (E29fe@E28d0@annotation? E3e62@e) (E3da9@match-each (E2a00@E28d4@annotation-expression E3e62@e) E3e63@p E3e64@m* E3e65@s* E3e66@ae*) '#f)))))) (E3dab@match-each+ (lambda (E3e22@e E3e23@x-pat E3e24@y-pat E3e25@z-pat E3e26@m* E3e27@s* E3e28@ae* E3e29@r) (let E3e3a@f ((E3e32@e E3e22@e) (E3e33@m* E3e26@m*) (E3e34@s* E3e27@s*) (E3e35@ae* E3e28@ae*)) (if (pair? E3e32@e) (call-with-values (lambda () (E3e3a@f (cdr E3e32@e) E3e33@m* E3e34@s* E3e35@ae*)) (lambda (E3e42@E3e3d E3e43@E3e3f E3e44@E3e41) (let ((E3e48@r E3e44@E3e41) (E3e49@y-pat E3e43@E3e3f) (E3e4a@xr* E3e42@E3e3d)) (if E3e48@r (if (null? E3e49@y-pat) (let ((E3e4e@xr (E3db5@match (car E3e32@e) E3e23@x-pat E3e33@m* E3e34@s* E3e35@ae* '()))) (if E3e4e@xr (values (cons E3e4e@xr E3e4a@xr*) E3e49@y-pat E3e48@r) (values '#f '#f '#f))) (values '() (cdr E3e49@y-pat) (E3db5@match (car E3e32@e) (car E3e49@y-pat) E3e33@m* E3e34@s* E3e35@ae* E3e48@r))) (values '#f '#f '#f))))) (if (E2e86@stx? E3e32@e) (if (E2e40@top-marked? E3e33@m*) (values '() E3e24@y-pat (E3db5@match E3e32@e E3e25@z-pat E3e33@m* E3e34@s* E3e35@ae* E3e29@r)) (call-with-values (lambda () (join-wraps E3e33@m* E3e34@s* E3e35@ae* E3e32@e)) (lambda (E3e56@E3e51 E3e57@E3e53 E3e58@E3e55) (let ((E3e5c@ae* E3e58@E3e55) (E3e5d@s* E3e57@E3e53) (E3e5e@m* E3e56@E3e51)) (E3e3a@f (E2e88@stx-expr E3e32@e) E3e5e@m* E3e5d@s* E3e5c@ae*))))) (if (E29fe@E28d0@annotation? E3e32@e) (E3e3a@f (E2a00@E28d4@annotation-expression E3e32@e) E3e33@m* E3e34@s* E3e35@ae*) (values '() E3e24@y-pat (E3db5@match E3e32@e E3e25@z-pat E3e33@m* E3e34@s* E3e35@ae* E3e29@r)))))))) (E3dad@match-each-any (lambda (E3e06@e E3e07@m* E3e08@s* E3e09@ae*) (if (pair? E3e06@e) (let ((E3e0e@l (E3dad@match-each-any (cdr E3e06@e) E3e07@m* E3e08@s* E3e09@ae*))) (and E3e0e@l (cons (E3da7@stx^ (car E3e06@e) E3e07@m* E3e08@s* E3e09@ae*) E3e0e@l))) (if (null? E3e06@e) '() (if (E2e86@stx? E3e06@e) (and (not (E2e40@top-marked? E3e07@m*)) (call-with-values (lambda () (join-wraps E3e07@m* E3e08@s* E3e09@ae* E3e06@e)) (lambda (E3e16@E3e11 E3e17@E3e13 E3e18@E3e15) (let ((E3e1c@ae* E3e18@E3e15) (E3e1d@s* E3e17@E3e13) (E3e1e@m* E3e16@E3e11)) (E3dad@match-each-any (E2e88@stx-expr E3e06@e) E3e1e@m* E3e1d@s* E3e1c@ae*))))) (if (E29fe@E28d0@annotation? E3e06@e) (E3dad@match-each-any (E2a00@E28d4@annotation-expression E3e06@e) E3e07@m* E3e08@s* E3e09@ae*) '#f)))))) (E3daf@match-empty (lambda (E3e00@p E3e01@r) (if (null? E3e00@p) E3e01@r (if (eq? E3e00@p '_) E3e01@r (if (eq? E3e00@p 'any) (cons '() E3e01@r) (if (pair? E3e00@p) (E3daf@match-empty (car E3e00@p) (E3daf@match-empty (cdr E3e00@p) E3e01@r)) (if (eq? E3e00@p 'each-any) (cons '() E3e01@r) (let ((E3e04@t (vector-ref E3e00@p '0))) (if (memv E3e04@t '(each)) (E3daf@match-empty (vector-ref E3e00@p '1) E3e01@r) (if (memv E3e04@t '(each+)) (E3daf@match-empty (vector-ref E3e00@p '1) (E3daf@match-empty (reverse (vector-ref E3e00@p '2)) (E3daf@match-empty (vector-ref E3e00@p '3) E3e01@r))) (if (memv E3e04@t '(free-id atom)) E3e01@r (if (memv E3e04@t '(scheme-id atom)) E3e01@r (if (memv E3e04@t '(vector)) (E3daf@match-empty (vector-ref E3e00@p '1) E3e01@r) (assertion-violation 'syntax-dispatch '"invalid pattern" E3e00@p)))))))))))))) (E3db1@combine (lambda (E3dfc@r* E3dfd@r) (if (null? (car E3dfc@r*)) E3dfd@r (cons (map car E3dfc@r*) (E3db1@combine (map cdr E3dfc@r*) E3dfd@r))))) (E3db3@match* (lambda (E3dd8@e E3dd9@p E3dda@m* E3ddb@s* E3ddc@ae* E3ddd@r) (if (null? E3dd9@p) (and (null? E3dd8@e) E3ddd@r) (if (pair? E3dd9@p) (and (pair? E3dd8@e) (E3db5@match (car E3dd8@e) (car E3dd9@p) E3dda@m* E3ddb@s* E3ddc@ae* (E3db5@match (cdr E3dd8@e) (cdr E3dd9@p) E3dda@m* E3ddb@s* E3ddc@ae* E3ddd@r))) (if (eq? E3dd9@p 'each-any) (let ((E3de4@l (E3dad@match-each-any E3dd8@e E3dda@m* E3ddb@s* E3ddc@ae*))) (and E3de4@l (cons E3de4@l E3ddd@r))) (let ((E3de6@t (vector-ref E3dd9@p '0))) (if (memv E3de6@t '(each)) (if (null? E3dd8@e) (E3daf@match-empty (vector-ref E3dd9@p '1) E3ddd@r) (let ((E3de8@r* (E3da9@match-each E3dd8@e (vector-ref E3dd9@p '1) E3dda@m* E3ddb@s* E3ddc@ae*))) (and E3de8@r* (E3db1@combine E3de8@r* E3ddd@r)))) (if (memv E3de6@t '(free-id)) (and (symbol? E3dd8@e) (E2e40@top-marked? E3dda@m*) (E2ec0@free-id=? (E3da7@stx^ E3dd8@e E3dda@m* E3ddb@s* E3ddc@ae*) (vector-ref E3dd9@p '1)) E3ddd@r) (if (memv E3de6@t '(scheme-id)) (and (symbol? E3dd8@e) (E2e40@top-marked? E3dda@m*) (E2ec0@free-id=? (E3da7@stx^ E3dd8@e E3dda@m* E3ddb@s* E3ddc@ae*) (E3049@scheme-stx (vector-ref E3dd9@p '1))) E3ddd@r) (if (memv E3de6@t '(each+)) (call-with-values (lambda () (E3dab@match-each+ E3dd8@e (vector-ref E3dd9@p '1) (vector-ref E3dd9@p '2) (vector-ref E3dd9@p '3) E3dda@m* E3ddb@s* E3ddc@ae* E3ddd@r)) (lambda (E3df0@E3deb E3df1@E3ded E3df2@E3def) (let ((E3df6@r E3df2@E3def) (E3df7@y-pat E3df1@E3ded) (E3df8@xr* E3df0@E3deb)) (and E3df6@r (null? E3df7@y-pat) (if (null? E3df8@xr*) (E3daf@match-empty (vector-ref E3dd9@p '1) E3df6@r) (E3db1@combine E3df8@xr* E3df6@r)))))) (if (memv E3de6@t '(atom)) (and (fast-equal? (vector-ref E3dd9@p '1) (E2ecc@strip E3dd8@e E3dda@m*)) E3ddd@r) (if (memv E3de6@t '(vector)) (and (vector? E3dd8@e) (E3db5@match (vector->list E3dd8@e) (vector-ref E3dd9@p '1) E3dda@m* E3ddb@s* E3ddc@ae* E3ddd@r)) (assertion-violation 'syntax-dispatch '"invalid pattern" E3dd9@p))))))))))))) (E3db5@match (lambda (E3dba@e E3dbb@p E3dbc@m* E3dbd@s* E3dbe@ae* E3dbf@r) (if (not E3dbf@r) '#f (if (eq? E3dbb@p '_) E3dbf@r (if (eq? E3dbb@p 'any) (cons (E3da7@stx^ E3dba@e E3dbc@m* E3dbd@s* E3dbe@ae*) E3dbf@r) (if (E2e86@stx? E3dba@e) (and (not (E2e40@top-marked? E3dbc@m*)) (call-with-values (lambda () (join-wraps E3dbc@m* E3dbd@s* E3dbe@ae* E3dba@e)) (lambda (E3dcc@E3dc7 E3dcd@E3dc9 E3dce@E3dcb) (let ((E3dd2@ae* E3dce@E3dcb) (E3dd3@s* E3dcd@E3dc9) (E3dd4@m* E3dcc@E3dc7)) (E3db5@match (E2e88@stx-expr E3dba@e) E3dbb@p E3dd4@m* E3dd3@s* E3dd2@ae* E3dbf@r))))) (if (E29fe@E28d0@annotation? E3dba@e) (E3db5@match (E2a00@E28d4@annotation-expression E3dba@e) E3dbb@p E3dbc@m* E3dbd@s* E3dbe@ae* E3dbf@r) (E3db3@match* E3dba@e E3dbb@p E3dbc@m* E3dbd@s* E3dbe@ae* E3dbf@r))))))))) (lambda (E3db6@e E3db7@p) (E3db5@match E3db6@e E3db7@p '() '() '() '())))) (set! E4b97@E30c1@syntax-dispatch E30c1@syntax-dispatch) (set! E30c3@ellipsis? (lambda (E3e8a@x) (and (E2eba@id? E3e8a@x) (E2ec0@free-id=? E3e8a@x (E3049@scheme-stx '...))))) (set! E4b98@E30c3@ellipsis? E30c3@ellipsis?) (set! E30c5@underscore? (lambda (E3e8c@x) (and (E2eba@id? E3e8c@x) (E2ec0@free-id=? E3e8c@x (E3049@scheme-stx '_))))) (set! E4b99@E30c5@underscore? E30c5@underscore?) (set! E30c7@verify-literals (lambda (E3e8e@lits E3e8f@expr) (for-each (lambda (E3e92@x) (if (or (not (E2eba@id? E3e92@x)) (E30c3@ellipsis? E3e92@x) (E30c5@underscore? E3e92@x)) (E31a1@syntax-violation '#f '"invalid literal" E3e8f@expr E3e92@x) (void))) E3e8e@lits))) (set! E4b9a@E30c7@verify-literals E30c7@verify-literals) (set! E30c9@syntax-case-transformer (letrec* ((E3e95@build-dispatch-call (lambda (E3f06@pvars E3f07@expr E3f08@y E3f09@r E3f0a@mr) (let ((E3f10@ids (map car E3f06@pvars)) (E3f11@levels (map cdr E3f06@pvars))) (let ((E3f14@labels (map E2e46@gen-label E3f10@ids)) (E3f15@new-vars (map E2e42@gen-lexical E3f10@ids))) (let ((E3f18@body (E30e3@chi-expr (E2ea6@add-subst (E2e7a@make-full-rib E3f10@ids E3f14@labels) E3f07@expr) (append (map (lambda (E3f1a@label E3f1b@var E3f1c@level) (cons E3f1a@label (E2ed4@make-binding 'syntax (cons E3f1b@var E3f1c@level)))) E3f14@labels E3f15@new-vars (map cdr E3f06@pvars)) E3f09@r) E3f0a@mr))) (list '(primitive apply) (E2e1d@E2d4f@build-lambda '#f E3f15@new-vars E3f18@body) E3f08@y)))))) (E3e97@invalid-ids-error (lambda (E3efa@id* E3efb@e E3efc@class) (let E3f04@find ((E3f00@id* E3efa@id*) (E3f01@ok* '())) (if (null? E3f00@id*) (E31a1@syntax-violation '#f '"invalid syntax" E3efb@e) (if (E2eba@id? (car E3f00@id*)) (if (E2ec6@bound-id-member? (car E3f00@id*) E3f01@ok*) (E319d@syntax-error (car E3f00@id*) '"duplicate " E3efc@class) (E3f04@find (cdr E3f00@id*) (cons (car E3f00@id*) E3f01@ok*))) (E319d@syntax-error (car E3f00@id*) '"invalid " E3efc@class)))))) (E3e99@gen-clause (lambda (E3ed2@x E3ed3@keys E3ed4@clauses E3ed5@r E3ed6@mr E3ed7@pat E3ed8@fender E3ed9@expr) (call-with-values (lambda () (E30bf@convert-pattern E3ed7@pat E3ed3@keys)) (lambda (E3ee6@E3ee3 E3ee7@E3ee5) (let ((E3eea@pvars E3ee7@E3ee5) (E3eeb@p E3ee6@E3ee3)) (if (not (E2ec4@distinct-bound-ids? (map car E3eea@pvars))) (E3e97@invalid-ids-error (map car E3eea@pvars) E3ed7@pat '"pattern variable") (if (not (for-all (lambda (E3eee@x) (not (E30c3@ellipsis? (car E3eee@x)))) E3eea@pvars)) (E31a1@syntax-violation '#f '"misplaced ellipsis in syntax-case pattern" E3ed7@pat) (let ((E3ef0@y (E2e42@gen-lexical 'tmp))) (let ((E3ef2@test (if (eq? E3ed8@fender '#t) E3ef0@y (let ((E3ef4@call (E3e95@build-dispatch-call E3eea@pvars E3ed8@fender E3ef0@y E3ed5@r E3ed6@mr))) (list 'if E3ef0@y E3ef4@call (list 'quote '#f)))))) (let ((E3ef6@conseq (E3e95@build-dispatch-call E3eea@pvars E3ed9@expr E3ef0@y E3ed5@r E3ed6@mr))) (let ((E3ef8@altern (E3e9b@gen-syntax-case E3ed2@x E3ed3@keys E3ed4@clauses E3ed5@r E3ed6@mr))) (list (E2e1d@E2d4f@build-lambda '#f (list E3ef0@y) (list 'if E3ef2@test E3ef6@conseq E3ef8@altern)) (list '(primitive syntax-dispatch) E3ed2@x (list 'quote E3eeb@p)))))))))))))) (E3e9b@gen-syntax-case (lambda (E3eb0@x E3eb1@keys E3eb2@clauses E3eb3@r E3eb4@mr) (if (null? E3eb2@clauses) (list '(primitive syntax-error) E3eb0@x) (let ((E3eba@t (car E3eb2@clauses))) (let ((E3ebc@ls/false (E30c1@syntax-dispatch E3eba@t '(any any)))) (if E3ebc@ls/false (apply (lambda (E3ebe@pat E3ebf@expr) (if (and (E2eba@id? E3ebe@pat) (not (E2ec6@bound-id-member? E3ebe@pat E3eb1@keys)) (not (E30c3@ellipsis? E3ebe@pat))) (if (E2ec0@free-id=? E3ebe@pat (E3049@scheme-stx '_)) (E30e3@chi-expr E3ebf@expr E3eb3@r E3eb4@mr) (let ((E3ec2@lab (E2e46@gen-label E3ebe@pat)) (E3ec3@lex (E2e42@gen-lexical E3ebe@pat))) (let ((E3ec6@body (E30e3@chi-expr (E2ea6@add-subst (E2e7a@make-full-rib (list E3ebe@pat) (list E3ec2@lab)) E3ebf@expr) (cons (cons E3ec2@lab (E2ed4@make-binding 'syntax (cons E3ec3@lex '0))) E3eb3@r) E3eb4@mr))) (list (E2e1d@E2d4f@build-lambda '#f (list E3ec3@lex) E3ec6@body) E3eb0@x)))) (E3e99@gen-clause E3eb0@x E3eb1@keys (cdr E3eb2@clauses) E3eb3@r E3eb4@mr E3ebe@pat '#t E3ebf@expr))) E3ebc@ls/false) (let ((E3ec8@t E3eba@t)) (let ((E3eca@ls/false (E30c1@syntax-dispatch E3ec8@t '(any any any)))) (if E3eca@ls/false (apply (lambda (E3ecc@pat E3ecd@fender E3ece@expr) (E3e99@gen-clause E3eb0@x E3eb1@keys (cdr E3eb2@clauses) E3eb3@r E3eb4@mr E3ecc@pat E3ecd@fender E3ece@expr)) E3eca@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3ec8@t))))))))))) (lambda (E3e9c@e E3e9d@r E3e9e@mr) (let ((E3ea2@t E3e9c@e)) (let ((E3ea4@ls/false (E30c1@syntax-dispatch E3ea2@t '(_ any each-any . each-any)))) (if E3ea4@ls/false (apply (lambda (E3ea6@expr E3ea7@keys E3ea8@clauses) (begin (E30c7@verify-literals E3ea7@keys E3e9c@e) (let ((E3eac@x (E2e42@gen-lexical 'tmp))) (let ((E3eae@body (E3e9b@gen-syntax-case E3eac@x E3ea7@keys E3ea8@clauses E3e9d@r E3e9e@mr))) (list (E2e1d@E2d4f@build-lambda '#f (list E3eac@x) E3eae@body) (E30e3@chi-expr E3ea6@expr E3e9d@r E3e9e@mr)))))) E3ea4@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3ea2@t))))))) (set! E4b9b@E30c9@syntax-case-transformer E30c9@syntax-case-transformer) (set! E30cb@ellipsis-map (lambda (E3f20@proc E3f21@ls . E3f24@ls*) (letrec* ((E3f27@who '...)) (begin (if (not (list? E3f21@ls)) (assertion-violation E3f27@who '"not a list" E3f21@ls) (void)) (if (not (null? E3f24@ls*)) (let ((E3f28@n (length E3f21@ls))) (for-each (lambda (E3f2a@x) (begin (if (not (list? E3f2a@x)) (assertion-violation E3f27@who '"not a list" E3f2a@x) (void)) (if (not (= (length E3f2a@x) E3f28@n)) (assertion-violation E3f27@who '"length mismatch" E3f21@ls E3f2a@x) (void)))) E3f24@ls*)) (void)) (apply map E3f20@proc E3f21@ls E3f24@ls*))))) (set! E4b9c@E30cb@ellipsis-map E30cb@ellipsis-map) (set! E30cd@syntax-transformer (letrec* ((E3f2d@gen-syntax (lambda (E3fa4@src E3fa5@e E3fa6@r E3fa7@maps E3fa8@ellipsis? E3fa9@vec?) (let ((E3fb0@t E3fa5@e)) (let ((E3fb2@ls/false (E30c1@syntax-dispatch E3fb0@t 'any))) (if (and E3fb2@ls/false (apply (lambda (E3fb4@dots) (E3fa8@ellipsis? E3fb4@dots)) E3fb2@ls/false)) (apply (lambda (E3fb6@dots) (E31a1@syntax-violation '#f '"misplaced ellipsis in syntax form" E3fa4@src)) E3fb2@ls/false) (let ((E3fb8@t E3fb0@t)) (let ((E3fba@ls/false (E30c1@syntax-dispatch E3fb8@t 'any))) (if (and E3fba@ls/false (apply (lambda (E3fbc@id) (E2eba@id? E3fbc@id)) E3fba@ls/false)) (apply (lambda (E3fbe@id) (let ((E3fc0@label (E2ed0@id->label E3fa5@e))) (let ((E3fc2@b (E2ed2@label->binding E3fc0@label E3fa6@r))) (if (eq? (E2ed6@binding-type E3fc2@b) 'syntax) (call-with-values (lambda () (let ((E3fc8@var.lev (E2ed8@binding-value E3fc2@b))) (E3f2f@gen-ref E3fa4@src (car E3fc8@var.lev) (cdr E3fc8@var.lev) E3fa7@maps))) (lambda (E3fca@E3fc5 E3fcb@E3fc7) (let ((E3fce@maps E3fcb@E3fc7) (E3fcf@var E3fca@E3fc5)) (values (list 'ref E3fcf@var) E3fce@maps)))) (values (list 'quote E3fa5@e) E3fa7@maps))))) E3fba@ls/false) (let ((E3fd2@t E3fb8@t)) (let ((E3fd4@ls/false (E30c1@syntax-dispatch E3fd2@t '(any any)))) (if (and E3fd4@ls/false (apply (lambda (E3fd6@dots E3fd7@e) (E3fa8@ellipsis? E3fd6@dots)) E3fd4@ls/false)) (apply (lambda (E3fda@dots E3fdb@e) (if E3fa9@vec? (E31a1@syntax-violation '#f '"misplaced ellipsis in syntax form" E3fa4@src) (E3f2d@gen-syntax E3fa4@src E3fdb@e E3fa6@r E3fa7@maps (lambda (E3fde@x) '#f) '#f))) E3fd4@ls/false) (let ((E3fe0@t E3fd2@t)) (let ((E3fe2@ls/false (E30c1@syntax-dispatch E3fe0@t '(any any . any)))) (if (and E3fe2@ls/false (apply (lambda (E3fe4@x E3fe5@dots E3fe6@y) (E3fa8@ellipsis? E3fe5@dots)) E3fe2@ls/false)) (apply (lambda (E3fea@x E3feb@dots E3fec@y) (let E4002@f ((E3ff0@y E3fec@y) (E3ff1@k (lambda (E3ff4@maps) (call-with-values (lambda () (E3f2d@gen-syntax E3fa4@src E3fea@x E3fa6@r (cons '() E3ff4@maps) E3fa8@ellipsis? '#f)) (lambda (E3ffa@E3ff7 E3ffb@E3ff9) (let ((E3ffe@maps E3ffb@E3ff9) (E3fff@x E3ffa@E3ff7)) (if (null? (car E3ffe@maps)) (E31a1@syntax-violation '#f '"extra ellipsis in syntax form" E3fa4@src) (values (E3f35@gen-map E3fff@x (car E3ffe@maps)) (cdr E3ffe@maps))))))))) (let ((E4004@t E3ff0@y)) (let ((E4006@ls/false (E30c1@syntax-dispatch E4004@t '()))) (if E4006@ls/false (apply (lambda () (E3ff1@k E3fa7@maps)) E4006@ls/false) (let ((E4008@t E4004@t)) (let ((E400a@ls/false (E30c1@syntax-dispatch E4008@t '(any . any)))) (if (and E400a@ls/false (apply (lambda (E400c@dots E400d@y) (E3fa8@ellipsis? E400c@dots)) E400a@ls/false)) (apply (lambda (E4010@dots E4011@y) (E4002@f E4011@y (lambda (E4014@maps) (call-with-values (lambda () (E3ff1@k (cons '() E4014@maps))) (lambda (E401a@E4017 E401b@E4019) (let ((E401e@maps E401b@E4019) (E401f@x E401a@E4017)) (if (null? (car E401e@maps)) (E31a1@syntax-violation '#f '"extra ellipsis in syntax form" E3fa4@src) (values (E3f33@gen-mappend E401f@x (car E401e@maps)) (cdr E401e@maps))))))))) E400a@ls/false) (let ((E4022@t E4008@t)) (let ((E4024@ls/false (E30c1@syntax-dispatch E4022@t '_))) (if E4024@ls/false (apply (lambda () (call-with-values (lambda () (E3f2d@gen-syntax E3fa4@src E3ff0@y E3fa6@r E3fa7@maps E3fa8@ellipsis? E3fa9@vec?)) (lambda (E402a@E4027 E402b@E4029) (let ((E402e@maps E402b@E4029) (E402f@y E402a@E4027)) (call-with-values (lambda () (E3ff1@k E402e@maps)) (lambda (E4036@E4033 E4037@E4035) (let ((E403a@maps E4037@E4035) (E403b@x E4036@E4033)) (values (E3f31@gen-append E403b@x E402f@y) E403a@maps)))))))) E4024@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E4022@t)))))))))))) E3fe2@ls/false) (let ((E403e@t E3fe0@t)) (let ((E4040@ls/false (E30c1@syntax-dispatch E403e@t '(any . any)))) (if E4040@ls/false (apply (lambda (E4042@x E4043@y) (call-with-values (lambda () (E3f2d@gen-syntax E3fa4@src E4042@x E3fa6@r E3fa7@maps E3fa8@ellipsis? '#f)) (lambda (E404a@E4047 E404b@E4049) (let ((E404e@maps E404b@E4049) (E404f@xnew E404a@E4047)) (call-with-values (lambda () (E3f2d@gen-syntax E3fa4@src E4043@y E3fa6@r E404e@maps E3fa8@ellipsis? E3fa9@vec?)) (lambda (E4056@E4053 E4057@E4055) (let ((E405a@maps E4057@E4055) (E405b@ynew E4056@E4053)) (values (E3f37@gen-cons E3fa5@e E4042@x E4043@y E404f@xnew E405b@ynew) E405a@maps)))))))) E4040@ls/false) (let ((E405e@t E403e@t)) (let ((E4060@ls/false (E30c1@syntax-dispatch E405e@t '#(vector each-any)))) (if E4060@ls/false (apply (lambda (E4062@ls) (call-with-values (lambda () (E3f2d@gen-syntax E3fa4@src E4062@ls E3fa6@r E3fa7@maps E3fa8@ellipsis? '#t)) (lambda (E4068@E4065 E4069@E4067) (let ((E406c@maps E4069@E4067) (E406d@lsnew E4068@E4065)) (values (E3f39@gen-vector E3fa5@e E4062@ls E406d@lsnew) E406c@maps))))) E4060@ls/false) (let ((E4070@t E405e@t)) (let ((E4072@ls/false (E30c1@syntax-dispatch E4070@t '_))) (if E4072@ls/false (apply (lambda () (values (list 'quote E3fa5@e) E3fa7@maps)) E4072@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E4070@t)))))))))))))))))))))))) (E3f2f@gen-ref (lambda (E3f8a@src E3f8b@var E3f8c@level E3f8d@maps) (if (= E3f8c@level '0) (values E3f8b@var E3f8d@maps) (if (null? E3f8d@maps) (E31a1@syntax-violation '#f '"missing ellipsis in syntax form" E3f8a@src) (call-with-values (lambda () (E3f2f@gen-ref E3f8a@src E3f8b@var (- E3f8c@level '1) (cdr E3f8d@maps))) (lambda (E3f96@E3f93 E3f97@E3f95) (let ((E3f9a@outer-maps E3f97@E3f95) (E3f9b@outer-var E3f96@E3f93)) (let ((E3f9e@t (assq E3f9b@outer-var (car E3f8d@maps)))) (if E3f9e@t ((lambda (E3fa0@b) (values (cdr E3fa0@b) E3f8d@maps)) E3f9e@t) (let ((E3fa2@inner-var (E2e42@gen-lexical 'tmp))) (values E3fa2@inner-var (cons (cons (cons E3f9b@outer-var E3fa2@inner-var) (car E3f8d@maps)) E3f9a@outer-maps)))))))))))) (E3f31@gen-append (lambda (E3f86@x E3f87@y) (if (fast-equal? E3f87@y ''()) E3f86@x (list 'append E3f86@x E3f87@y)))) (E3f33@gen-mappend (lambda (E3f82@e E3f83@map-env) (list 'apply '(primitive append) (E3f35@gen-map E3f82@e E3f83@map-env)))) (E3f35@gen-map (lambda (E3f70@e E3f71@map-env) (let ((E3f74@formals (map cdr E3f71@map-env)) (E3f75@actuals (map (lambda (E3f78@x) (list 'ref (car E3f78@x))) E3f71@map-env))) (if (eq? (car E3f70@e) 'ref) (car E3f75@actuals) (if (for-all (lambda (E3f7a@x) (and (eq? (car E3f7a@x) 'ref) (memq (cadr E3f7a@x) E3f74@formals))) (cdr E3f70@e)) (let ((E3f7c@args (map (let ((E3f7e@r (map cons E3f74@formals E3f75@actuals))) (lambda (E3f80@x) (cdr (assq (cadr E3f80@x) E3f7e@r)))) (cdr E3f70@e)))) (cons 'map (cons (list 'primitive (car E3f70@e)) E3f7c@args))) (cons* 'map (list 'lambda E3f74@formals E3f70@e) E3f75@actuals)))))) (E3f37@gen-cons (lambda (E3f60@e E3f61@x E3f62@y E3f63@xnew E3f64@ynew) (let ((E3f6a@t (car E3f64@ynew))) (if (memv E3f6a@t '(quote)) (if (eq? (car E3f63@xnew) 'quote) (let ((E3f6c@xnew (cadr E3f63@xnew)) (E3f6d@ynew (cadr E3f64@ynew))) (if (and (eq? E3f6c@xnew E3f61@x) (eq? E3f6d@ynew E3f62@y)) (list 'quote E3f60@e) (list 'quote (cons E3f6c@xnew E3f6d@ynew)))) (if (null? (cadr E3f64@ynew)) (list 'list E3f63@xnew) (list 'cons E3f63@xnew E3f64@ynew))) (if (memv E3f6a@t '(list)) (cons 'list (cons E3f63@xnew (cdr E3f64@ynew))) (list 'cons E3f63@xnew E3f64@ynew)))))) (E3f39@gen-vector (lambda (E3f5a@e E3f5b@ls E3f5c@lsnew) (if (eq? (car E3f5c@lsnew) 'quote) (if (eq? (cadr E3f5c@lsnew) E3f5b@ls) (list 'quote E3f5a@e) (list 'quote (list->vector (cadr E3f5c@lsnew)))) (if (eq? (car E3f5c@lsnew) 'list) (cons 'vector (cdr E3f5c@lsnew)) (list 'list->vector E3f5c@lsnew))))) (E3f3b@regen (lambda (E3f54@x) (let ((E3f56@t (car E3f54@x))) (if (memv E3f56@t '(ref)) (cadr E3f54@x) (if (memv E3f56@t '(primitive)) (list 'primitive (cadr E3f54@x)) (if (memv E3f56@t '(quote)) (list 'quote (cadr E3f54@x)) (if (memv E3f56@t '(lambda)) (E2e1d@E2d4f@build-lambda '#f (cadr E3f54@x) (E3f3b@regen (caddr E3f54@x))) (if (memv E3f56@t '(map)) (let ((E3f58@ls (map E3f3b@regen (cdr E3f54@x)))) (cons '(primitive ellipsis-map) E3f58@ls)) (cons (list 'primitive (car E3f54@x)) (map E3f3b@regen (cdr E3f54@x)))))))))))) (lambda (E3f3c@e E3f3d@r E3f3e@mr) (let ((E3f42@t E3f3c@e)) (let ((E3f44@ls/false (E30c1@syntax-dispatch E3f42@t '(_ any)))) (if E3f44@ls/false (apply (lambda (E3f46@x) (call-with-values (lambda () (E3f2d@gen-syntax E3f3c@e E3f46@x E3f3d@r '() E30c3@ellipsis? '#f)) (lambda (E3f4c@E3f49 E3f4d@E3f4b) (let ((E3f50@maps E3f4d@E3f4b) (E3f51@e E3f4c@E3f49)) (E3f3b@regen E3f51@e))))) E3f44@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E3f42@t))))))) (set! E4b9d@E30cd@syntax-transformer E30cd@syntax-transformer) (set! E30cf@core-macro-transformer (lambda (E4074@name) (let ((E4076@t E4074@name)) (if (memv E4076@t '(quote)) E3071@quote-transformer (if (memv E4076@t '(lambda)) E3075@lambda-transformer (if (memv E4076@t '(case-lambda)) E3073@case-lambda-transformer (if (memv E4076@t '(letrec)) E3059@letrec-transformer (if (memv E4076@t '(letrec*)) E305b@letrec*-transformer (if (memv E4076@t '(let)) E3057@let-transformer (if (memv E4076@t '(if)) E3069@if-transformer (if (memv E4076@t '(and)) E306b@and-transformer (if (memv E4076@t '(or)) E306d@or-transformer (if (memv E4076@t '(foreign-call)) E30bd@foreign-call-transformer (if (memv E4076@t '(syntax-case)) E30c9@syntax-case-transformer (if (memv E4076@t '(syntax)) E30cd@syntax-transformer (if (memv E4076@t '(type-descriptor)) E305f@type-descriptor-transformer (if (memv E4076@t '(record-type-descriptor)) E3061@record-type-descriptor-transformer (if (memv E4076@t '(record-constructor-descriptor)) E3063@record-constructor-descriptor-transformer (if (memv E4076@t '(fluid-let-syntax)) E305d@fluid-let-syntax-transformer (assertion-violation 'macro-transformer '"BUG: cannot find transformer" E4074@name)))))))))))))))))))) (set! E4b9e@E30cf@core-macro-transformer E30cf@core-macro-transformer) (set! E30d1@symbol-macro (lambda (E4078@x E4079@set) (let ((E407c@t E4078@x)) (let ((E407e@ls/false (E30c1@syntax-dispatch E407c@t '(_ any)))) (if (and E407e@ls/false (apply (lambda (E4080@name) (and (E2eba@id? E4080@name) (memq (E2ebc@id->sym E4080@name) E4079@set))) E407e@ls/false)) (apply (lambda (E4082@name) (E3077@bless (list 'quote E4082@name))) E407e@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E407c@t)))))) (set! E4b9f@E30d1@symbol-macro E30d1@symbol-macro) (set! E30d3@macro-transformer (lambda (E4084@x) (if (procedure? E4084@x) E4084@x (if (symbol? E4084@x) (let ((E4086@t E4084@x)) (if (memv E4086@t '(define-record-type)) E30b5@define-record-type-macro (if (memv E4086@t '(define-struct)) E30b3@define-struct-macro (if (memv E4086@t '(include)) E30a9@include-macro (if (memv E4086@t '(cond)) E30a5@cond-macro (if (memv E4086@t '(let)) E307d@let-macro (if (memv E4086@t '(do)) E309d@do-macro (if (memv E4086@t '(or)) E30a1@or-macro (if (memv E4086@t '(and)) E30a3@and-macro (if (memv E4086@t '(let*)) E309f@let*-macro (if (memv E4086@t '(let-values)) E307f@let-values-macro (if (memv E4086@t '(let*-values)) E3081@let*-values-macro (if (memv E4086@t '(syntax-rules)) E30ad@syntax-rules-macro (if (memv E4086@t '(quasiquote)) E30af@quasiquote-macro (if (memv E4086@t '(quasisyntax)) E30b1@quasisyntax-macro (if (memv E4086@t '(with-syntax)) E3079@with-syntax-macro (if (memv E4086@t '(when)) E3065@when-macro (if (memv E4086@t '(unless)) E3067@unless-macro (if (memv E4086@t '(case)) E306f@case-macro (if (memv E4086@t '(identifier-syntax)) E309b@identifier-syntax-macro (if (memv E4086@t '(time)) E3093@time-macro (if (memv E4086@t '(delay)) E3095@delay-macro (if (memv E4086@t '(assert)) E3097@assert-macro (if (memv E4086@t '(endianness)) E3099@endianness-macro (if (memv E4086@t '(guard)) E308f@guard-macro (if (memv E4086@t '(define-enumeration)) E3091@define-enumeration-macro (if (memv E4086@t '(trace-lambda)) E3083@trace-lambda-macro (if (memv E4086@t '(trace-define)) E3085@trace-define-macro (if (memv E4086@t '(trace-define-syntax)) E3087@trace-define-syntax-macro (if (memv E4086@t '(trace-let-syntax)) E308b@trace-let-syntax-macro (if (memv E4086@t '(trace-letrec-syntax)) E308d@trace-letrec-syntax-macro (if (memv E4086@t '(define-condition-type)) E30b7@define-condition-type-macro (if (memv E4086@t '(parameterize)) E30bb@parameterize-macro (if (memv E4086@t '(include-into)) E30ab@include-into-macro (if (memv E4086@t '(eol-style)) (lambda (E4088@x) (E30d1@symbol-macro E4088@x '(none lf cr crlf nel crnel ls))) (if (memv E4086@t '(error-handling-mode)) (lambda (E408a@x) (E30d1@symbol-macro E408a@x '(ignore raise replace))) (if (memv E4086@t '(buffer-mode)) (lambda (E408c@x) (E30d1@symbol-macro E408c@x '(none line block))) (if (memv E4086@t '(file-options)) E2e35@file-options-macro (if (memv E4086@t '(... => _ else unquote unquote-splicing unsyntax unsyntax-splicing fields mutable immutable parent protocol sealed opaque nongenerative parent-rtd)) E30b9@incorrect-usage-macro (error 'macro-transformer '"BUG: invalid macro" E4084@x)))))))))))))))))))))))))))))))))))))))) (error 'core-macro-transformer '"BUG: invalid macro" E4084@x))))) (set! E4ba0@E30d3@macro-transformer E30d3@macro-transformer) (set! E30d5@local-macro-transformer (lambda (E408e@x) (car E408e@x))) (set! E4ba1@E30d5@local-macro-transformer E30d5@local-macro-transformer) (set! E30d7@do-macro-call (lambda (E4090@transformer E4091@expr) (let ((E4094@out (E4090@transformer (E2ea4@add-mark E2e9e@anti-mark E4091@expr '#f)))) (begin (let E4098@f ((E4096@x E4094@out)) (if (not (E2e86@stx? E4096@x)) (if (pair? E4096@x) (begin (E4098@f (car E4096@x)) (E4098@f (cdr E4096@x))) (if (vector? E4096@x) (vector-for-each E4098@f E4096@x) (if (symbol? E4096@x) (E31a1@syntax-violation '#f '"raw symbol encountered in output of macro" E4091@expr E4096@x) (void)))) (void))) (E2ea4@add-mark (E2e9c@gen-mark) E4094@out E4091@expr))))) (set! E4ba2@E30d7@do-macro-call E30d7@do-macro-call) (set! E30d9@chi-macro (lambda (E409a@p E409b@e) (E30d7@do-macro-call (E30d3@macro-transformer E409a@p) E409b@e))) (set! E4ba3@E30d9@chi-macro E30d9@chi-macro) (set! E30db@chi-local-macro (lambda (E409e@p E409f@e) (E30d7@do-macro-call (E30d5@local-macro-transformer E409e@p) E409f@e))) (set! E4ba4@E30db@chi-local-macro E30db@chi-local-macro) (set! E30dd@chi-global-macro (lambda (E40a2@p E40a3@e) (let ((E40a6@lib (car E40a2@p)) (E40a7@loc (cdr E40a2@p))) (begin (E2cd7@E2b26@visit-library E40a6@lib) (let ((E40aa@x (symbol-value E40a7@loc))) (let ((E40ac@transformer (if (procedure? E40aa@x) E40aa@x (assertion-violation 'chi-global-macro '"BUG: not a procedure" E40aa@x)))) (E30d7@do-macro-call E40ac@transformer E40a3@e))))))) (set! E4ba5@E30dd@chi-global-macro E30dd@chi-global-macro) (set! E30df@chi-expr* (lambda (E40ae@e* E40af@r E40b0@mr) (if (null? E40ae@e*) '() (let ((E40b4@e (E30e3@chi-expr (car E40ae@e*) E40af@r E40b0@mr))) (cons E40b4@e (E30df@chi-expr* (cdr E40ae@e*) E40af@r E40b0@mr)))))) (set! E4ba6@E30df@chi-expr* E30df@chi-expr*) (set! E30e1@chi-application (lambda (E40b6@e E40b7@r E40b8@mr) (let ((E40bc@t E40b6@e)) (let ((E40be@ls/false (E30c1@syntax-dispatch E40bc@t '(any . each-any)))) (if E40be@ls/false (apply (lambda (E40c0@rator E40c1@rands) (let ((E40c4@rator (E30e3@chi-expr E40c0@rator E40b7@r E40b8@mr))) (cons E40c4@rator (E30df@chi-expr* E40c1@rands E40b7@r E40b8@mr)))) E40be@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E40bc@t)))))) (set! E4ba7@E30e1@chi-application E30e1@chi-application) (set! E30e3@chi-expr (lambda (E40c6@e E40c7@r E40c8@mr) (call-with-values (lambda () (E2edc@syntax-type E40c6@e E40c7@r)) (lambda (E40d2@E40cd E40d3@E40cf E40d4@E40d1) (let ((E40d8@kwd E40d4@E40d1) (E40d9@value E40d3@E40cf) (E40da@type E40d2@E40cd)) (let ((E40de@t E40da@type)) (if (memv E40de@t '(core-macro)) (let ((E40e0@transformer (E30cf@core-macro-transformer E40d9@value))) (E40e0@transformer E40c6@e E40c7@r E40c8@mr)) (if (memv E40de@t '(global)) (let ((E40e2@lib (car E40d9@value))) (let ((E40e4@loc (cdr E40d9@value))) (begin ((E3129@inv-collector) E40e2@lib) E40e4@loc))) (if (memv E40de@t '(core-prim)) (let ((E40e6@name E40d9@value)) (list 'primitive E40e6@name)) (if (memv E40de@t '(call)) (E30e1@chi-application E40c6@e E40c7@r E40c8@mr) (if (memv E40de@t '(lexical)) (let ((E40e8@lex (E304b@lexical-var E40d9@value))) E40e8@lex) (if (memv E40de@t '(global-macro global-macro!)) (E30e3@chi-expr (E30dd@chi-global-macro E40d9@value E40c6@e) E40c7@r E40c8@mr) (if (memv E40de@t '(local-macro local-macro!)) (E30e3@chi-expr (E30db@chi-local-macro E40d9@value E40c6@e) E40c7@r E40c8@mr) (if (memv E40de@t '(macro macro!)) (E30e3@chi-expr (E30d9@chi-macro E40d9@value E40c6@e) E40c7@r E40c8@mr) (if (memv E40de@t '(constant)) (let ((E40ea@datum E40d9@value)) (list 'quote E40ea@datum)) (if (memv E40de@t '(set!)) (E30e5@chi-set! E40c6@e E40c7@r E40c8@mr) (if (memv E40de@t '(begin)) (let ((E40ec@t E40c6@e)) (let ((E40ee@ls/false (E30c1@syntax-dispatch E40ec@t '(_ any . each-any)))) (if E40ee@ls/false (apply (lambda (E40f0@x E40f1@x*) (E2e1f@E2d7f@build-sequence '#f (E30df@chi-expr* (cons E40f0@x E40f1@x*) E40c7@r E40c8@mr))) E40ee@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E40ec@t)))) (if (memv E40de@t '(let-syntax letrec-syntax)) (let ((E40f4@t E40c6@e)) (let ((E40f6@ls/false (E30c1@syntax-dispatch E40f4@t '(_ #(each (any any)) any . each-any)))) (if (and E40f6@ls/false (apply (lambda (E40f8@xlhs* E40f9@xrhs* E40fa@xbody E40fb@xbody*) (if (not (E2ec2@valid-bound-ids? E40f8@xlhs*)) (E31a1@syntax-violation '#f '"invalid identifiers" E40c6@e) (void))) E40f6@ls/false)) (apply (lambda (E4100@xlhs* E4101@xrhs* E4102@xbody E4103@xbody*) (let ((E4108@xlab* (map E2e46@gen-label E4100@xlhs*))) (let ((E410a@xrib (E2e7a@make-full-rib E4100@xlhs* E4108@xlab*))) (let ((E410c@xb* (map (lambda (E410e@x) (E2ef2@make-eval-transformer (E311b@expand-transformer (if (eq? E40da@type 'let-syntax) E410e@x (E2ea6@add-subst E410a@xrib E410e@x)) E40c8@mr))) E4101@xrhs*))) (E2e1f@E2d7f@build-sequence '#f (E30df@chi-expr* (map (lambda (E4110@x) (E2ea6@add-subst E410a@xrib E4110@x)) (cons E4102@xbody E4103@xbody*)) (append (map cons E4108@xlab* E410c@xb*) E40c7@r) (append (map cons E4108@xlab* E410c@xb*) E40c8@mr))))))) E40f6@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E40f4@t)))) (if (memv E40de@t '(displaced-lexical)) (E31a1@syntax-violation '#f '"identifier out of context" E40c6@e) (if (memv E40de@t '(syntax)) (E31a1@syntax-violation '#f '"reference to pattern variable outside a syntax form" E40c6@e) (if (memv E40de@t '(define define-syntax module import library)) (E31a1@syntax-violation '#f (string-append (let ((E4112@t E40da@type)) (if (memv E4112@t '(define)) '"a definition" (if (memv E4112@t '(define-syntax)) '"a define-syntax" (if (memv E4112@t '(module)) '"a module definition" (if (memv E4112@t '(library)) '"a library definition" (if (memv E4112@t '(import)) '"an import declaration" (if (memv E4112@t '(export)) '"an export declaration" '"a non-expression"))))))) '" was found where an expression was expected") E40c6@e) (if (memv E40de@t '(mutable)) (E31a1@syntax-violation '#f '"attempt to reference an unexportable variable" E40c6@e) (E31a1@syntax-violation '#f '"invalid expression" E40c6@e))))))))))))))))))))))) (set! E4ba8@E30e3@chi-expr E30e3@chi-expr) (set! E30e5@chi-set! (lambda (E4114@e E4115@r E4116@mr) (let ((E411a@t E4114@e)) (let ((E411c@ls/false (E30c1@syntax-dispatch E411a@t '(_ any any)))) (if (and E411c@ls/false (apply (lambda (E411e@x E411f@v) (E2eba@id? E411e@x)) E411c@ls/false)) (apply (lambda (E4122@x E4123@v) (call-with-values (lambda () (E2edc@syntax-type E4122@x E4115@r)) (lambda (E412c@E4127 E412d@E4129 E412e@E412b) (let ((E4132@kwd E412e@E412b) (E4133@value E412d@E4129) (E4134@type E412c@E4127)) (let ((E4138@t E4134@type)) (if (memv E4138@t '(lexical)) (begin (E304f@set-lexical-mutable! E4133@value '#t) (list 'set! (E304b@lexical-var E4133@value) (E30e3@chi-expr E4123@v E4115@r E4116@mr))) (if (memv E4138@t '(core-prim)) (E31a1@syntax-violation '#f '"cannot modify imported core primitive" E4114@e) (if (memv E4138@t '(global)) (E31a1@syntax-violation '#f '"attempt to modify imported binding" E4114@e) (if (memv E4138@t '(global-macro!)) (E30e3@chi-expr (E30dd@chi-global-macro E4133@value E4114@e) E4115@r E4116@mr) (if (memv E4138@t '(local-macro!)) (E30e3@chi-expr (E30db@chi-local-macro E4133@value E4114@e) E4115@r E4116@mr) (if (memv E4138@t '(mutable)) (E31a1@syntax-violation '#f '"attempt to assign to an unexportable variable" E4114@e) (E31a1@syntax-violation '#f '"invalid syntax" E4114@e)))))))))))) E411c@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E411a@t)))))) (set! E4ba9@E30e5@chi-set! E30e5@chi-set!) (set! E30e7@verify-formals (lambda (E413a@fmls E413b@stx) (let ((E413e@t E413a@fmls)) (let ((E4140@ls/false (E30c1@syntax-dispatch E413e@t 'each-any))) (if E4140@ls/false (apply (lambda (E4142@x*) (if (not (E2ec2@valid-bound-ids? E4142@x*)) (E307b@invalid-fmls-error E413b@stx E413a@fmls) (void))) E4140@ls/false) (let ((E4144@t E413e@t)) (let ((E4146@ls/false (E30c1@syntax-dispatch E4144@t '#(each+ any () any)))) (if E4146@ls/false (apply (lambda (E4148@x* E4149@x) (if (not (E2ec2@valid-bound-ids? (cons E4149@x E4148@x*))) (E307b@invalid-fmls-error E413b@stx E413a@fmls) (void))) E4146@ls/false) (let ((E414c@t E4144@t)) (let ((E414e@ls/false (E30c1@syntax-dispatch E414c@t '_))) (if E414e@ls/false (apply (lambda () (E31a1@syntax-violation '#f '"invalid syntax" E413b@stx)) E414e@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E414c@t)))))))))))) (set! E4baa@E30e7@verify-formals E30e7@verify-formals) (set! E30e9@chi-lambda-clause (lambda (E4150@stx E4151@fmls E4152@body* E4153@r E4154@mr) (let ((E415a@t E4151@fmls)) (let ((E415c@ls/false (E30c1@syntax-dispatch E415a@t 'each-any))) (if E415c@ls/false (apply (lambda (E415e@x*) (begin (E30e7@verify-formals E4151@fmls E4150@stx) (let ((E4160@lex* (map E2e42@gen-lexical E415e@x*)) (E4161@lab* (map E2e46@gen-label E415e@x*))) (values E4160@lex* (E30f9@chi-internal (E2ea6@add-subst (E2e7a@make-full-rib E415e@x* E4161@lab*) E4152@body*) (E3053@add-lexicals E4161@lab* E4160@lex* E4153@r) E4154@mr))))) E415c@ls/false) (let ((E4164@t E415a@t)) (let ((E4166@ls/false (E30c1@syntax-dispatch E4164@t '#(each+ any () any)))) (if E4166@ls/false (apply (lambda (E4168@x* E4169@x) (begin (E30e7@verify-formals E4151@fmls E4150@stx) (let ((E416c@lex* (map E2e42@gen-lexical E4168@x*)) (E416d@lab* (map E2e46@gen-label E4168@x*)) (E416e@lex (E2e42@gen-lexical E4169@x)) (E416f@lab (E2e46@gen-label E4169@x))) (values (append E416c@lex* E416e@lex) (E30f9@chi-internal (E2ea6@add-subst (E2e7a@make-full-rib (cons E4169@x E4168@x*) (cons E416f@lab E416d@lab*)) E4152@body*) (E3053@add-lexicals (cons E416f@lab E416d@lab*) (cons E416e@lex E416c@lex*) E4153@r) E4154@mr))))) E4166@ls/false) (let ((E4174@t E4164@t)) (let ((E4176@ls/false (E30c1@syntax-dispatch E4174@t '_))) (if E4176@ls/false (apply (lambda () (E31a1@syntax-violation '#f '"invalid syntax" E4151@fmls)) E4176@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E4174@t)))))))))))) (set! E4bab@E30e9@chi-lambda-clause E30e9@chi-lambda-clause) (set! E30eb@chi-lambda-clause* (lambda (E4178@stx E4179@fmls* E417a@body** E417b@r E417c@mr) (if (null? E4179@fmls*) (values '() '()) (call-with-values (lambda () (E30e9@chi-lambda-clause E4178@stx (car E4179@fmls*) (car E417a@body**) E417b@r E417c@mr)) (lambda (E4186@E4183 E4187@E4185) (let ((E418a@b E4187@E4185) (E418b@a E4186@E4183)) (call-with-values (lambda () (E30eb@chi-lambda-clause* E4178@stx (cdr E4179@fmls*) (cdr E417a@body**) E417b@r E417c@mr)) (lambda (E4192@E418f E4193@E4191) (let ((E4196@b* E4193@E4191) (E4197@a* E4192@E418f)) (values (cons E418b@a E4197@a*) (cons E418a@b E4196@b*))))))))))) (set! E4bac@E30eb@chi-lambda-clause* E30eb@chi-lambda-clause*) (set! E30ed@chi-defun (lambda (E419a@x E419b@r E419c@mr) (let ((E41a0@fmls (car E419a@x)) (E41a1@body* (cdr E419a@x))) (call-with-values (lambda () (E30e9@chi-lambda-clause E41a0@fmls E41a0@fmls E41a1@body* E419b@r E419c@mr)) (lambda (E41a8@E41a5 E41a9@E41a7) (let ((E41ac@body E41a9@E41a7) (E41ad@fmls E41a8@E41a5)) (E2e1d@E2d4f@build-lambda '#f E41ad@fmls E41ac@body))))))) (set! E4bad@E30ed@chi-defun E30ed@chi-defun) (set! E30ef@chi-rhs (lambda (E41b0@rhs E41b1@r E41b2@mr) (let ((E41b6@t (car E41b0@rhs))) (if (memv E41b6@t '(defun)) (E30ed@chi-defun (cdr E41b0@rhs) E41b1@r E41b2@mr) (if (memv E41b6@t '(expr)) (let ((E41b8@expr (cdr E41b0@rhs))) (E30e3@chi-expr E41b8@expr E41b1@r E41b2@mr)) (if (memv E41b6@t '(top-expr)) (let ((E41ba@expr (cdr E41b0@rhs))) (E2e1f@E2d7f@build-sequence '#f (list (E30e3@chi-expr E41ba@expr E41b1@r E41b2@mr) (E2e20@E2d81@build-void)))) (assertion-violation 'chi-rhs '"BUG: invalid rhs" E41b0@rhs))))))) (set! E4bae@E30ef@chi-rhs E30ef@chi-rhs) (set! E30f1@expand-interaction-rhs*/init* (lambda (E41bc@lhs* E41bd@rhs* E41be@init* E41bf@r E41c0@mr) (let E41ca@f ((E41c6@lhs* E41bc@lhs*) (E41c7@rhs* E41bd@rhs*)) (if (null? E41c6@lhs*) (map (lambda (E41cc@x) (E30e3@chi-expr E41cc@x E41bf@r E41c0@mr)) E41be@init*) (let ((E41ce@lhs (car E41c6@lhs*)) (E41cf@rhs (car E41c7@rhs*))) (let ((E41d2@t (car E41cf@rhs))) (if (memv E41d2@t '(defun)) (let ((E41d4@rhs (E30ed@chi-defun (cdr E41cf@rhs) E41bf@r E41c0@mr))) (cons (list 'set! E41ce@lhs E41d4@rhs) (E41ca@f (cdr E41c6@lhs*) (cdr E41c7@rhs*)))) (if (memv E41d2@t '(expr)) (let ((E41d6@rhs (E30e3@chi-expr (cdr E41cf@rhs) E41bf@r E41c0@mr))) (cons (list 'set! E41ce@lhs E41d6@rhs) (E41ca@f (cdr E41c6@lhs*) (cdr E41c7@rhs*)))) (if (memv E41d2@t '(top-expr)) (let ((E41d8@e (E30e3@chi-expr (cdr E41cf@rhs) E41bf@r E41c0@mr))) (cons E41d8@e (E41ca@f (cdr E41c6@lhs*) (cdr E41c7@rhs*)))) (error 'expand-interaction '"invallid" E41cf@rhs)))))))))) (set! E4baf@E30f1@expand-interaction-rhs*/init* E30f1@expand-interaction-rhs*/init*) (set! E30f3@chi-rhs* (lambda (E41da@rhs* E41db@r E41dc@mr) (let E41e2@f ((E41e0@ls E41da@rhs*)) (if (null? E41e0@ls) '() (let ((E41e4@a (E30ef@chi-rhs (car E41e0@ls) E41db@r E41dc@mr))) (cons E41e4@a (E41e2@f (cdr E41e0@ls)))))))) (set! E4bb0@E30f3@chi-rhs* E30f3@chi-rhs*) (set! E30f5@find-bound=? (lambda (E41e6@x E41e7@lhs* E41e8@rhs*) (if (null? E41e7@lhs*) '#f (if (E2ebe@bound-id=? E41e6@x (car E41e7@lhs*)) (car E41e8@rhs*) (E30f5@find-bound=? E41e6@x (cdr E41e7@lhs*) (cdr E41e8@rhs*)))))) (set! E4bb1@E30f5@find-bound=? E30f5@find-bound=?) (set! E30f7@find-dups (lambda (E41ec@ls) (let E41f2@f ((E41ee@ls E41ec@ls) (E41ef@dups '())) (if (null? E41ee@ls) E41ef@dups (let ((E41f4@t (E30f5@find-bound=? (car E41ee@ls) (cdr E41ee@ls) (cdr E41ee@ls)))) (if E41f4@t ((lambda (E41f6@x) (E41f2@f (cdr E41ee@ls) (cons (list (car E41ee@ls) E41f6@x) E41ef@dups))) E41f4@t) (E41f2@f (cdr E41ee@ls) E41ef@dups))))))) (set! E4bb2@E30f7@find-dups E30f7@find-dups) (set! E30f9@chi-internal (lambda (E41f8@e* E41f9@r E41fa@mr) (let ((E41fe@rib (E2e6e@make-empty-rib))) (call-with-values (lambda () (E3119@chi-body* (map (lambda (E4210@x) (E2ea6@add-subst E41fe@rib E4210@x)) (E2eb8@syntax->list E41f8@e*)) E41f9@r E41fa@mr '() '() '() '() '() E41fe@rib '#f)) (lambda (E4212@E4201 E4213@E4203 E4214@E4205 E4215@E4207 E4216@E4209 E4217@E420b E4218@E420d E4219@E420f) (let ((E4222@_exp* E4219@E420f) (E4223@kwd* E4218@E420d) (E4224@mod** E4217@E420b) (E4225@rhs* E4216@E4209) (E4226@lex* E4215@E4207) (E4227@mr E4214@E4205) (E4228@r E4213@E4203) (E4229@e* E4212@E4201)) (begin (if (null? E4229@e*) (E31a1@syntax-violation '#f '"no expression in body" E4229@e*) (void)) (let ((E4232@init* (E30df@chi-expr* (append (apply append (reverse E4224@mod**)) E4229@e*) E4228@r E4227@mr))) (let ((E4234@rhs* (E30f3@chi-rhs* E4225@rhs* E4228@r E4227@mr))) (E2e24@E2d89@build-letrec* '#f (reverse E4226@lex*) (reverse E4234@rhs*) (E2e1f@E2d7f@build-sequence '#f E4232@init*))))))))))) (set! E4bb3@E30f9@chi-internal E30f9@chi-internal) (set! E30fb@parse-module (lambda (E4236@e) (let ((E4238@t E4236@e)) (let ((E423a@ls/false (E30c1@syntax-dispatch E4238@t '(_ each-any . each-any)))) (if E423a@ls/false (apply (lambda (E423c@export* E423d@b*) (begin (if (not (for-all E2eba@id? E423c@export*)) (E31a1@syntax-violation '#f '"module exports must be identifiers" E4236@e) (void)) (values '#f (list->vector E423c@export*) E423d@b*))) E423a@ls/false) (let ((E4240@t E4238@t)) (let ((E4242@ls/false (E30c1@syntax-dispatch E4240@t '(_ any each-any . each-any)))) (if E4242@ls/false (apply (lambda (E4244@name E4245@export* E4246@b*) (begin (if (not (E2eba@id? E4244@name)) (E31a1@syntax-violation '#f '"module name must be an identifier" E4236@e) (void)) (if (not (for-all E2eba@id? E4245@export*)) (E31a1@syntax-violation '#f '"module exports must be identifiers" E4236@e) (void)) (values E4244@name (list->vector E4245@export*) E4246@b*))) E4242@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E4240@t))))))))) (set! E4bb4@E30fb@parse-module E30fb@parse-module) (set! E3105@module-interface? (lambda (E424a@x) (and (simple-struct? E424a@x) (eq? (simple-struct-name E424a@x) 'module-interface)))) (set! E4bb5@E3105@module-interface? E3105@module-interface?) (set! E3107@module-interface-first-mark (lambda (E424c@x) (simple-struct-ref E424c@x '0))) (set! E4bb6@E3107@module-interface-first-mark E3107@module-interface-first-mark) (set! E3109@set-module-interface-first-mark! (lambda (E424e@x E424f@val) (simple-struct-set! E424e@x '0 E424f@val))) (set! E4bb7@E3109@set-module-interface-first-mark! E3109@set-module-interface-first-mark!) (set! E310b@module-interface-exp-id-vec (lambda (E4252@x) (simple-struct-ref E4252@x '1))) (set! E4bb8@E310b@module-interface-exp-id-vec E310b@module-interface-exp-id-vec) (set! E310d@set-module-interface-exp-id-vec! (lambda (E4254@x E4255@val) (simple-struct-set! E4254@x '1 E4255@val))) (set! E4bb9@E310d@set-module-interface-exp-id-vec! E310d@set-module-interface-exp-id-vec!) (set! E310f@module-interface-exp-lab-vec (lambda (E4258@x) (simple-struct-ref E4258@x '2))) (set! E4bba@E310f@module-interface-exp-lab-vec E310f@module-interface-exp-lab-vec) (set! E3111@set-module-interface-exp-lab-vec! (lambda (E425a@x E425b@val) (simple-struct-set! E425a@x '2 E425b@val))) (set! E4bbb@E3111@set-module-interface-exp-lab-vec! E3111@set-module-interface-exp-lab-vec!) (set! E3113@dummy '3) (set! E4bbc@E3113@dummy E3113@dummy) (set! E3115@module-interface-exp-id* (lambda (E425e@iface E425f@id) (letrec* ((E4263@diff-marks (lambda (E426a@ls E426b@x) (begin (if (null? E426a@ls) (error 'diff-marks '"BUG: should not happen") (void)) (let ((E426e@a (car E426a@ls))) (if (eq? E426e@a E426b@x) '() (cons E426e@a (E4263@diff-marks (cdr E426a@ls) E426b@x)))))))) (let ((E4264@diff (E4263@diff-marks (E2e8c@stx-mark* E425f@id) (E3107@module-interface-first-mark E425e@iface))) (E4265@id-vec (E310b@module-interface-exp-id-vec E425e@iface))) (if (null? E4264@diff) E4265@id-vec (vector-map (lambda (E4268@x) (make-simple-struct 'stx '5 (list (E2e88@stx-expr E4268@x) (append E4264@diff (E2e8c@stx-mark* E4268@x)) '() '()))) E4265@id-vec)))))) (set! E4bbd@E3115@module-interface-exp-id* E3115@module-interface-exp-id*) (set! E3117@chi-internal-module (lambda (E4270@e E4271@r E4272@mr E4273@lex* E4274@rhs* E4275@mod** E4276@kwd*) (call-with-values (lambda () (E30fb@parse-module E4270@e)) (lambda (E4284@E427f E4285@E4281 E4286@E4283) (let ((E428a@e* E4286@E4283) (E428b@exp-id* E4285@E4281) (E428c@name E4284@E427f)) (let ((E4290@rib (E2e6e@make-empty-rib))) (let ((E4292@e* (map (lambda (E4294@x) (E2ea6@add-subst E4290@rib E4294@x)) (E2eb8@syntax->list E428a@e*)))) (call-with-values (lambda () (E3119@chi-body* E4292@e* E4271@r E4272@mr E4273@lex* E4274@rhs* E4275@mod** E4276@kwd* '() E4290@rib '#f)) (lambda (E42a6@E4297 E42a7@E4299 E42a8@E429b E42a9@E429d E42aa@E429f E42ab@E42a1 E42ac@E42a3 E42ad@E42a5) (let ((E42b6@_exp* E42ad@E42a5) (E42b7@kwd* E42ac@E42a3) (E42b8@mod** E42ab@E42a1) (E42b9@rhs* E42aa@E429f) (E42ba@lex* E42a9@E429d) (E42bb@mr E42a8@E429b) (E42bc@r E42a7@E4299) (E42bd@e* E42a6@E4297)) (let ((E42c6@exp-lab* (vector-map (lambda (E42ca@x) (or (E2ed0@id->label (make-simple-struct 'stx '5 (list (E2ebc@id->sym E42ca@x) (E2e8c@stx-mark* E42ca@x) (list E4290@rib) '()))) (E31a1@syntax-violation '#f '"cannot find module export" E42ca@x))) E428b@exp-id*)) (E42c7@mod** (cons E42bd@e* E42b8@mod**))) (if (not E428c@name) (values E42ba@lex* E42b9@rhs* E428b@exp-id* E42c6@exp-lab* E42bc@r E42bb@mr E42c7@mod** E42b7@kwd*) (let ((E42cc@lab (E2e46@gen-label 'module)) (E42cd@iface (make-simple-struct 'module-interface '4 (list (car (E2e8c@stx-mark* E428c@name)) (vector-map (lambda (E42d0@x) (make-simple-struct 'stx '5 (list (E2e88@stx-expr E42d0@x) (E2e8c@stx-mark* E42d0@x) '() '()))) E428b@exp-id*) E42c6@exp-lab*)))) (values E42ba@lex* E42b9@rhs* (vector E428c@name) (vector E42cc@lab) (cons (cons E42cc@lab (cons '$module E42cd@iface)) E42bc@r) (cons (cons E42cc@lab (cons '$module E42cd@iface)) E42bb@mr) E42c7@mod** E42b7@kwd*)))))))))))))) (set! E4bbe@E3117@chi-internal-module E3117@chi-internal-module) (set! E3119@chi-body* (lambda (E42d2@e* E42d3@r E42d4@mr E42d5@lex* E42d6@rhs* E42d7@mod** E42d8@kwd* E42d9@exp* E42da@rib E42db@top?) (if (null? E42d2@e*) (values E42d2@e* E42d3@r E42d4@mr E42d5@lex* E42d6@rhs* E42d7@mod** E42d8@kwd* E42d9@exp*) (let ((E42e6@e (car E42d2@e*))) (call-with-values (lambda () (E2edc@syntax-type E42e6@e E42d3@r)) (lambda (E42ee@E42e9 E42ef@E42eb E42f0@E42ed) (let ((E42f4@kwd E42f0@E42ed) (E42f5@value E42ef@E42eb) (E42f6@type E42ee@E42e9)) (let ((E42fa@kwd* (if (E2eba@id? E42f4@kwd) (cons E42f4@kwd E42d8@kwd*) E42d8@kwd*))) (let ((E42fc@t E42f6@type)) (if (memv E42fc@t '(define)) (call-with-values (lambda () (E3043@parse-define E42e6@e)) (lambda (E4302@E42ff E4303@E4301) (let ((E4306@rhs E4303@E4301) (E4307@id E4302@E42ff)) (begin (if (E2ec6@bound-id-member? E4307@id E42fa@kwd*) (E31a1@syntax-violation '#f '"cannot redefine keyword" E42e6@e) (void)) (call-with-values (lambda () (E2e4a@gen-define-label+loc E4307@id E42da@rib)) (lambda (E430e@E430b E430f@E430d) (let ((E4312@lex E430f@E430d) (E4313@lab E430e@E430b)) (begin (E2e70@extend-rib! E42da@rib E4307@id E4313@lab) (E3119@chi-body* (cdr E42d2@e*) (E3051@add-lexical E4313@lab E4312@lex E42d3@r) E42d4@mr (cons E4312@lex E42d5@lex*) (cons E4306@rhs E42d6@rhs*) E42d7@mod** E42fa@kwd* E42d9@exp* E42da@rib E42db@top?))))))))) (if (memv E42fc@t '(define-syntax)) (call-with-values (lambda () (E3045@parse-define-syntax E42e6@e)) (lambda (E431a@E4317 E431b@E4319) (let ((E431e@rhs E431b@E4319) (E431f@id E431a@E4317)) (begin (if (E2ec6@bound-id-member? E431f@id E42fa@kwd*) (E31a1@syntax-violation '#f '"cannot redefine keyword" E42e6@e) (void)) (let ((E4322@lab (E2e4c@gen-define-label E431f@id E42da@rib)) (E4323@expanded-rhs (E311b@expand-transformer E431e@rhs E42d4@mr))) (begin (E2e70@extend-rib! E42da@rib E431f@id E4322@lab) (let ((E4326@b (E2ef2@make-eval-transformer E4323@expanded-rhs))) (E3119@chi-body* (cdr E42d2@e*) (cons (cons E4322@lab E4326@b) E42d3@r) (cons (cons E4322@lab E4326@b) E42d4@mr) E42d5@lex* E42d6@rhs* E42d7@mod** E42fa@kwd* E42d9@exp* E42da@rib E42db@top?)))))))) (if (memv E42fc@t '(let-syntax letrec-syntax)) (let ((E4328@t E42e6@e)) (let ((E432a@ls/false (E30c1@syntax-dispatch E4328@t '(_ #(each (any any)) . each-any)))) (if (and E432a@ls/false (apply (lambda (E432c@xlhs* E432d@xrhs* E432e@xbody*) (if (not (E2ec2@valid-bound-ids? E432c@xlhs*)) (E31a1@syntax-violation '#f '"invalid identifiers" E42e6@e) (void))) E432a@ls/false)) (apply (lambda (E4332@xlhs* E4333@xrhs* E4334@xbody*) (let ((E4338@xlab* (map E2e46@gen-label E4332@xlhs*))) (let ((E433a@xrib (E2e7a@make-full-rib E4332@xlhs* E4338@xlab*))) (let ((E433c@xb* (map (lambda (E433e@x) (E2ef2@make-eval-transformer (E311b@expand-transformer (if (eq? E42f6@type 'let-syntax) E433e@x (E2ea6@add-subst E433a@xrib E433e@x)) E42d4@mr))) E4333@xrhs*))) (E3119@chi-body* (append (map (lambda (E4340@x) (E2ea6@add-subst E433a@xrib E4340@x)) E4334@xbody*) (cdr E42d2@e*)) (append (map cons E4338@xlab* E433c@xb*) E42d3@r) (append (map cons E4338@xlab* E433c@xb*) E42d4@mr) E42d5@lex* E42d6@rhs* E42d7@mod** E42fa@kwd* E42d9@exp* E42da@rib E42db@top?))))) E432a@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E4328@t)))) (if (memv E42fc@t '(begin)) (let ((E4342@t E42e6@e)) (let ((E4344@ls/false (E30c1@syntax-dispatch E4342@t '(_ . each-any)))) (if E4344@ls/false (apply (lambda (E4346@x*) (E3119@chi-body* (append E4346@x* (cdr E42d2@e*)) E42d3@r E42d4@mr E42d5@lex* E42d6@rhs* E42d7@mod** E42fa@kwd* E42d9@exp* E42da@rib E42db@top?)) E4344@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E4342@t)))) (if (memv E42fc@t '(global-macro global-macro!)) (E3119@chi-body* (cons (E2ea6@add-subst E42da@rib (E30dd@chi-global-macro E42f5@value E42e6@e)) (cdr E42d2@e*)) E42d3@r E42d4@mr E42d5@lex* E42d6@rhs* E42d7@mod** E42fa@kwd* E42d9@exp* E42da@rib E42db@top?) (if (memv E42fc@t '(local-macro local-macro!)) (E3119@chi-body* (cons (E2ea6@add-subst E42da@rib (E30db@chi-local-macro E42f5@value E42e6@e)) (cdr E42d2@e*)) E42d3@r E42d4@mr E42d5@lex* E42d6@rhs* E42d7@mod** E42fa@kwd* E42d9@exp* E42da@rib E42db@top?) (if (memv E42fc@t '(macro macro!)) (E3119@chi-body* (cons (E2ea6@add-subst E42da@rib (E30d9@chi-macro E42f5@value E42e6@e)) (cdr E42d2@e*)) E42d3@r E42d4@mr E42d5@lex* E42d6@rhs* E42d7@mod** E42fa@kwd* E42d9@exp* E42da@rib E42db@top?) (if (memv E42fc@t '(module)) (call-with-values (lambda () (E3117@chi-internal-module E42e6@e E42d3@r E42d4@mr E42d5@lex* E42d6@rhs* E42d7@mod** E42fa@kwd*)) (lambda (E4358@E4349 E4359@E434b E435a@E434d E435b@E434f E435c@E4351 E435d@E4353 E435e@E4355 E435f@E4357) (let ((E4368@kwd* E435f@E4357) (E4369@mod** E435e@E4355) (E436a@mr E435d@E4353) (E436b@r E435c@E4351) (E436c@m-exp-lab* E435b@E434f) (E436d@m-exp-id* E435a@E434d) (E436e@rhs* E4359@E434b) (E436f@lex* E4358@E4349)) (begin (vector-for-each (lambda (E4378@id E4379@lab) (E2e70@extend-rib! E42da@rib E4378@id E4379@lab)) E436d@m-exp-id* E436c@m-exp-lab*) (E3119@chi-body* (cdr E42d2@e*) E436b@r E436a@mr E436f@lex* E436e@rhs* E4369@mod** E4368@kwd* E42d9@exp* E42da@rib E42db@top?))))) (if (memv E42fc@t '(library)) (begin (E3183@library-expander (E2ece@stx->datum E42e6@e)) (E3119@chi-body* (cdr E42d2@e*) E42d3@r E42d4@mr E42d5@lex* E42d6@rhs* E42d7@mod** E42fa@kwd* E42d9@exp* E42da@rib E42db@top?)) (if (memv E42fc@t '(export)) (let ((E437c@t E42e6@e)) (let ((E437e@ls/false (E30c1@syntax-dispatch E437c@t '(_ . each-any)))) (if E437e@ls/false (apply (lambda (E4380@exp-decl*) (E3119@chi-body* (cdr E42d2@e*) E42d3@r E42d4@mr E42d5@lex* E42d6@rhs* E42d7@mod** E42fa@kwd* (append E4380@exp-decl* E42d9@exp*) E42da@rib E42db@top?)) E437e@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E437c@t)))) (if (memv E42fc@t '(import)) (letrec* ((E4383@module-import? (lambda (E43d6@e) (let ((E43d8@t E43d6@e)) (let ((E43da@ls/false (E30c1@syntax-dispatch E43d8@t '(_ any)))) (if (and E43da@ls/false (apply (lambda (E43dc@id) (E2eba@id? E43dc@id)) E43da@ls/false)) (apply (lambda (E43de@id) '#t) E43da@ls/false) (let ((E43e0@t E43d8@t)) (let ((E43e2@ls/false (E30c1@syntax-dispatch E43e0@t '(_ . each-any)))) (if E43e2@ls/false (apply (lambda (E43e4@imp*) '#f) E43e2@ls/false) (let ((E43e6@t E43e0@t)) (let ((E43e8@ls/false (E30c1@syntax-dispatch E43e6@t '_))) (if E43e8@ls/false (apply (lambda () (E31a1@syntax-violation '#f '"malformed import form" E43d6@e)) E43e8@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E43e6@t)))))))))))) (E4385@module-import (lambda (E43b4@e E43b5@r) (let ((E43b8@t E43b4@e)) (let ((E43ba@ls/false (E30c1@syntax-dispatch E43b8@t '(_ any)))) (if (and E43ba@ls/false (apply (lambda (E43bc@id) (E2eba@id? E43bc@id)) E43ba@ls/false)) (apply (lambda (E43be@id) (call-with-values (lambda () (E2edc@syntax-type E43be@id E43b5@r)) (lambda (E43c6@E43c1 E43c7@E43c3 E43c8@E43c5) (let ((E43cc@kwd E43c8@E43c5) (E43cd@value E43c7@E43c3) (E43ce@type E43c6@E43c1)) (let ((E43d2@t E43ce@type)) (if (memv E43d2@t '($module)) (let ((E43d4@iface E43cd@value)) (values (E3115@module-interface-exp-id* E43d4@iface E43be@id) (E310f@module-interface-exp-lab-vec E43d4@iface))) (E31a1@syntax-violation '#f '"invalid import" E43b4@e))))))) E43ba@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E43b8@t)))))) (E4387@library-import (lambda (E4398@e) (let ((E439a@t E4398@e)) (let ((E439c@ls/false (E30c1@syntax-dispatch E439a@t '(any . each-any)))) (if E439c@ls/false (apply (lambda (E439e@ctxt E439f@imp*) (call-with-values (lambda () (E3123@parse-import-spec* (E31a7@syntax->datum E439f@imp*))) (lambda (E43a6@E43a3 E43a7@E43a5) (let ((E43aa@subst-labels E43a7@E43a5) (E43ab@subst-names E43a6@E43a3)) (values (vector-map (lambda (E43ae@name) (E2e9a@datum->stx E439e@ctxt E43ae@name)) E43ab@subst-names) E43aa@subst-labels))))) E439c@ls/false) (let ((E43b0@t E439a@t)) (let ((E43b2@ls/false (E30c1@syntax-dispatch E43b0@t '_))) (if E43b2@ls/false (apply (lambda () (E31a1@syntax-violation '#f '"invalid import form" E4398@e)) E43b2@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E43b0@t)))))))))) (begin (call-with-values (lambda () (if (E4383@module-import? E42e6@e) (E4385@module-import E42e6@e E42d3@r) (E4387@library-import E42e6@e))) (lambda (E438c@E4389 E438d@E438b) (let ((E4390@lab* E438d@E438b) (E4391@id* E438c@E4389)) (vector-for-each (lambda (E4394@id E4395@lab) (E2e70@extend-rib! E42da@rib E4394@id E4395@lab)) E4391@id* E4390@lab*)))) (E3119@chi-body* (cdr E42d2@e*) E42d3@r E42d4@mr E42d5@lex* E42d6@rhs* E42d7@mod** E42fa@kwd* E42d9@exp* E42da@rib E42db@top?))) (if E42db@top? (E3119@chi-body* (cdr E42d2@e*) E42d3@r E42d4@mr (cons (E2e42@gen-lexical 'dummy) E42d5@lex*) (cons (cons 'top-expr E42e6@e) E42d6@rhs*) E42d7@mod** E42fa@kwd* E42d9@exp* E42da@rib E42db@top?) (values E42d2@e* E42d3@r E42d4@mr E42d5@lex* E42d6@rhs* E42d7@mod** E42fa@kwd* E42d9@exp*)))))))))))))))))))))) (set! E4bbf@E3119@chi-body* E3119@chi-body*) (set! E311b@expand-transformer (lambda (E43ea@expr E43eb@r) (let ((E43ee@rtc (E3127@make-collector))) (let ((E43f0@expanded-rhs (let ((E43fa@E43f3 E3129@inv-collector) (E43fb@E43f5 E312b@vis-collector) (E43fc@E43f7 E43ee@rtc) (E43fd@E43f9 (lambda (E4402@x) (values)))) (let ((E4404@swap (lambda () (begin (let ((E4406@t (E43fa@E43f3))) (begin (E43fa@E43f3 E43fc@E43f7) (set! E43fc@E43f7 E4406@t))) (let ((E4408@t (E43fb@E43f5))) (begin (E43fb@E43f5 E43fd@E43f9) (set! E43fd@E43f9 E4408@t))))))) (dynamic-wind E4404@swap (lambda () (E30e3@chi-expr E43ea@expr E43eb@r E43eb@r)) E4404@swap))))) (begin (for-each (let ((E440a@mark-visit (E312b@vis-collector))) (lambda (E440c@x) (begin (E2cd6@E2b24@invoke-library E440c@x) (E440a@mark-visit E440c@x)))) (E43ee@rtc)) E43f0@expanded-rhs))))) (set! E4bc0@E311b@expand-transformer E311b@expand-transformer) (set! E311d@parse-exports (lambda (E440e@exp*) (let E4416@f ((E4410@exp* E440e@exp*) (E4411@int* '()) (E4412@ext* '())) (if (null? E4410@exp*) (begin (if (not (E2ec2@valid-bound-ids? E4412@ext*)) (E31a1@syntax-violation 'export '"invalid exports" (E30f7@find-dups E4412@ext*)) (void)) (values (map E31a7@syntax->datum E4412@ext*) E4411@int*)) (let ((E4418@t (car E4410@exp*))) (let ((E441a@ls/false (E30c1@syntax-dispatch E4418@t '(any . #(each (any any)))))) (if E441a@ls/false (apply (lambda (E441c@rename E441d@i* E441e@e*) (begin (if (not (and (eq? (E31a7@syntax->datum E441c@rename) 'rename) (for-all E2eba@id? E441d@i*) (for-all E2eba@id? E441e@e*))) (E31a1@syntax-violation 'export '"invalid export specifier" (car E4410@exp*)) (void)) (E4416@f (cdr E4410@exp*) (append E441d@i* E4411@int*) (append E441e@e* E4412@ext*)))) E441a@ls/false) (let ((E4422@t E4418@t)) (let ((E4424@ls/false (E30c1@syntax-dispatch E4422@t 'any))) (if E4424@ls/false (apply (lambda (E4426@ie) (begin (if (not (E2eba@id? E4426@ie)) (E31a1@syntax-violation 'export '"invalid export" E4426@ie) (void)) (E4416@f (cdr E4410@exp*) (cons E4426@ie E4411@int*) (cons E4426@ie E4412@ext*)))) E4424@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E4422@t))))))))))) (set! E4bc1@E311d@parse-exports E311d@parse-exports) (set! E311f@parse-library-name (lambda (E4428@spec) (letrec* ((E442b@parse (lambda (E4438@x) (let ((E443a@t E4438@x)) (let ((E443c@ls/false (E30c1@syntax-dispatch E443a@t '(each-any)))) (if (and E443c@ls/false (apply (lambda (E443e@v*) (for-all (lambda (E4440@x) (let ((E4442@x (E31a7@syntax->datum E4440@x))) (and (integer? E4442@x) (exact? E4442@x)))) E443e@v*)) E443c@ls/false)) (apply (lambda (E4444@v*) (values '() (map E31a7@syntax->datum E4444@v*))) E443c@ls/false) (let ((E4446@t E443a@t)) (let ((E4448@ls/false (E30c1@syntax-dispatch E4446@t '(any . any)))) (if (and E4448@ls/false (apply (lambda (E444a@x E444b@rest) (symbol? (E31a7@syntax->datum E444a@x))) E4448@ls/false)) (apply (lambda (E444e@x E444f@rest) (call-with-values (lambda () (E442b@parse E444f@rest)) (lambda (E4456@E4453 E4457@E4455) (let ((E445a@v* E4457@E4455) (E445b@x* E4456@E4453)) (values (cons (E31a7@syntax->datum E444e@x) E445b@x*) E445a@v*))))) E4448@ls/false) (let ((E445e@t E4446@t)) (let ((E4460@ls/false (E30c1@syntax-dispatch E445e@t '()))) (if E4460@ls/false (apply (lambda () (values '() '())) E4460@ls/false) (let ((E4462@t E445e@t)) (let ((E4464@ls/false (E30c1@syntax-dispatch E4462@t '_))) (if E4464@ls/false (apply (lambda () (E31a1@syntax-violation '#f '"invalid library name" E4428@spec)) E4464@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E4462@t)))))))))))))))) (call-with-values (lambda () (E442b@parse E4428@spec)) (lambda (E4430@E442d E4431@E442f) (let ((E4434@ver* E4431@E442f) (E4435@name* E4430@E442d)) (begin (if (null? E4435@name*) (E31a1@syntax-violation '#f '"empty library name" E4428@spec) (void)) (values E4435@name* E4434@ver*)))))))) (set! E4bc2@E311f@parse-library-name E311f@parse-library-name) (set! E3121@parse-library (lambda (E4466@e) (let ((E4468@t E4466@e)) (let ((E446a@ls/false (E30c1@syntax-dispatch E4468@t '(any each-any (any . each-any) (any . each-any) . each-any)))) (if (and E446a@ls/false (apply (lambda (E446c@library E446d@name* E446e@export E446f@exp* E4470@import E4471@imp* E4472@b*) (and (eq? (E31a7@syntax->datum E446e@export) 'export) (eq? (E31a7@syntax->datum E4470@import) 'import) (eq? (E31a7@syntax->datum E446c@library) 'library))) E446a@ls/false)) (apply (lambda (E447a@library E447b@name* E447c@export E447d@exp* E447e@import E447f@imp* E4480@b*) (values E447b@name* E447d@exp* E447f@imp* E4480@b*)) E446a@ls/false) (let ((E4488@t E4468@t)) (let ((E448a@ls/false (E30c1@syntax-dispatch E4488@t '_))) (if E448a@ls/false (apply (lambda () (E31a1@syntax-violation '#f '"malformed library" E4466@e)) E448a@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E4488@t))))))))) (set! E4bc3@E3121@parse-library E3121@parse-library) (set! E3123@parse-import-spec* (letrec* ((E448d@idsyn? (lambda (E4696@x) (symbol? (E31a7@syntax->datum E4696@x)))) (E448f@dup-error (lambda (E4694@name) (E31a1@syntax-violation 'import '"two imports with different bindings" E4694@name))) (E4491@merge-substs (lambda (E4682@s E4683@subst) (letrec* ((E4687@insert-to-subst (lambda (E4688@a E4689@subst) (let ((E468c@name (car E4688@a)) (E468d@label (cdr E4688@a))) (let ((E4690@t (assq E468c@name E4689@subst))) (if E4690@t ((lambda (E4692@x) (if (eq? (cdr E4692@x) E468d@label) E4689@subst (E448f@dup-error E468c@name))) E4690@t) (cons E4688@a E4689@subst))))))) (if (null? E4682@s) E4683@subst (E4687@insert-to-subst (car E4682@s) (E4491@merge-substs (cdr E4682@s) E4683@subst)))))) (E4493@exclude* (lambda (E4652@sym* E4653@subst) (letrec* ((E4657@exclude (lambda (E4670@sym E4671@subst) (if (null? E4671@subst) (E31a1@syntax-violation 'import '"cannot rename unbound identifier" E4670@sym) (if (eq? E4670@sym (caar E4671@subst)) (values (cdar E4671@subst) (cdr E4671@subst)) (let ((E4674@a (car E4671@subst))) (call-with-values (lambda () (E4657@exclude E4670@sym (cdr E4671@subst))) (lambda (E467a@E4677 E467b@E4679) (let ((E467e@subst E467b@E4679) (E467f@old E467a@E4677)) (values E467f@old (cons E4674@a E467e@subst))))))))))) (if (null? E4652@sym*) (values '() E4653@subst) (call-with-values (lambda () (E4657@exclude (car E4652@sym*) E4653@subst)) (lambda (E465c@E4659 E465d@E465b) (let ((E4660@subst E465d@E465b) (E4661@old E465c@E4659)) (call-with-values (lambda () (E4493@exclude* (cdr E4652@sym*) E4660@subst)) (lambda (E4668@E4665 E4669@E4667) (let ((E466c@subst E4669@E4667) (E466d@old* E4668@E4665)) (values (cons E4661@old E466d@old*) E466c@subst))))))))))) (E4495@find* (lambda (E464a@sym* E464b@subst) (map (lambda (E464e@x) (let ((E4650@t (assq E464e@x E464b@subst))) (if E4650@t (cdr E4650@t) (E31a1@syntax-violation 'import '"cannot find identifier" E464e@x)))) E464a@sym*))) (E4497@rem* (lambda (E4642@sym* E4643@subst) (let E4648@f ((E4646@subst E4643@subst)) (if (null? E4646@subst) '() (if (memq (caar E4646@subst) E4642@sym*) (E4648@f (cdr E4646@subst)) (cons (car E4646@subst) (E4648@f (cdr E4646@subst)))))))) (E4499@remove-dups (lambda (E4640@ls) (if (null? E4640@ls) '() (if (memq (car E4640@ls) (cdr E4640@ls)) (E4499@remove-dups (cdr E4640@ls)) (cons (car E4640@ls) (E4499@remove-dups (cdr E4640@ls))))))) (E449b@parse-library-name (lambda (E4558@spec) (letrec* ((E455b@subversion? (lambda (E463c@x) (let ((E463e@x (E31a7@syntax->datum E463c@x))) (and (integer? E463e@x) (exact? E463e@x) (>= E463e@x '0))))) (E455d@subversion-pred (lambda (E45dc@x*) (let ((E45de@t E45dc@x*)) (let ((E45e0@ls/false (E30c1@syntax-dispatch E45de@t 'any))) (if (and E45e0@ls/false (apply (lambda (E45e2@n) (E455b@subversion? E45e2@n)) E45e0@ls/false)) (apply (lambda (E45e4@n) (lambda (E45e6@x) (= E45e6@x (E31a7@syntax->datum E45e4@n)))) E45e0@ls/false) (let ((E45e8@t E45de@t)) (let ((E45ea@ls/false (E30c1@syntax-dispatch E45e8@t '(any . each-any)))) (if (and E45ea@ls/false (apply (lambda (E45ec@p? E45ed@sub*) (eq? (E31a7@syntax->datum E45ec@p?) 'and)) E45ea@ls/false)) (apply (lambda (E45f0@p? E45f1@sub*) (let ((E45f4@p* (map E455d@subversion-pred E45f1@sub*))) (lambda (E45f6@x) (for-all (lambda (E45f8@p) (E45f8@p E45f6@x)) E45f4@p*)))) E45ea@ls/false) (let ((E45fa@t E45e8@t)) (let ((E45fc@ls/false (E30c1@syntax-dispatch E45fa@t '(any . each-any)))) (if (and E45fc@ls/false (apply (lambda (E45fe@p? E45ff@sub*) (eq? (E31a7@syntax->datum E45fe@p?) 'or)) E45fc@ls/false)) (apply (lambda (E4602@p? E4603@sub*) (let ((E4606@p* (map E455d@subversion-pred E4603@sub*))) (lambda (E4608@x) (exists (lambda (E460a@p) (E460a@p E4608@x)) E4606@p*)))) E45fc@ls/false) (let ((E460c@t E45fa@t)) (let ((E460e@ls/false (E30c1@syntax-dispatch E460c@t '(any any)))) (if (and E460e@ls/false (apply (lambda (E4610@p? E4611@sub) (eq? (E31a7@syntax->datum E4610@p?) 'not)) E460e@ls/false)) (apply (lambda (E4614@p? E4615@sub) (let ((E4618@p (E455d@subversion-pred E4615@sub))) (lambda (E461a@x) (not (E4618@p E461a@x))))) E460e@ls/false) (let ((E461c@t E460c@t)) (let ((E461e@ls/false (E30c1@syntax-dispatch E461c@t '(any any)))) (if (and E461e@ls/false (apply (lambda (E4620@p? E4621@n) (and (eq? (E31a7@syntax->datum E4620@p?) '<=) (E455b@subversion? E4621@n))) E461e@ls/false)) (apply (lambda (E4624@p? E4625@n) (lambda (E4628@x) (<= E4628@x (E31a7@syntax->datum E4625@n)))) E461e@ls/false) (let ((E462a@t E461c@t)) (let ((E462c@ls/false (E30c1@syntax-dispatch E462a@t '(any any)))) (if (and E462c@ls/false (apply (lambda (E462e@p? E462f@n) (and (eq? (E31a7@syntax->datum E462e@p?) '>=) (E455b@subversion? E462f@n))) E462c@ls/false)) (apply (lambda (E4632@p? E4633@n) (lambda (E4636@x) (>= E4636@x (E31a7@syntax->datum E4633@n)))) E462c@ls/false) (let ((E4638@t E462a@t)) (let ((E463a@ls/false (E30c1@syntax-dispatch E4638@t '_))) (if E463a@ls/false (apply (lambda () (E31a1@syntax-violation 'import '"invalid sub-version spec" E4558@spec E45dc@x*)) E463a@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E4638@t)))))))))))))))))))))))) (E455f@version-pred (lambda (E458c@x*) (let ((E458e@t E458c@x*)) (let ((E4590@ls/false (E30c1@syntax-dispatch E458e@t '()))) (if E4590@ls/false (apply (lambda () (lambda (E4592@x) '#t)) E4590@ls/false) (let ((E4594@t E458e@t)) (let ((E4596@ls/false (E30c1@syntax-dispatch E4594@t '(any . each-any)))) (if (and E4596@ls/false (apply (lambda (E4598@c E4599@ver*) (eq? (E31a7@syntax->datum E4598@c) 'and)) E4596@ls/false)) (apply (lambda (E459c@c E459d@ver*) (let ((E45a0@p* (map E455f@version-pred E459d@ver*))) (lambda (E45a2@x) (for-all (lambda (E45a4@p) (E45a4@p E45a2@x)) E45a0@p*)))) E4596@ls/false) (let ((E45a6@t E4594@t)) (let ((E45a8@ls/false (E30c1@syntax-dispatch E45a6@t '(any . each-any)))) (if (and E45a8@ls/false (apply (lambda (E45aa@c E45ab@ver*) (eq? (E31a7@syntax->datum E45aa@c) 'or)) E45a8@ls/false)) (apply (lambda (E45ae@c E45af@ver*) (let ((E45b2@p* (map E455f@version-pred E45af@ver*))) (lambda (E45b4@x) (exists (lambda (E45b6@p) (E45b6@p E45b4@x)) E45b2@p*)))) E45a8@ls/false) (let ((E45b8@t E45a6@t)) (let ((E45ba@ls/false (E30c1@syntax-dispatch E45b8@t '(any any)))) (if (and E45ba@ls/false (apply (lambda (E45bc@c E45bd@ver) (eq? (E31a7@syntax->datum E45bc@c) 'not)) E45ba@ls/false)) (apply (lambda (E45c0@c E45c1@ver) (let ((E45c4@p (E455f@version-pred E45c1@ver))) (lambda (E45c6@x) (not (E45c4@p E45c6@x))))) E45ba@ls/false) (let ((E45c8@t E45b8@t)) (let ((E45ca@ls/false (E30c1@syntax-dispatch E45c8@t 'each-any))) (if E45ca@ls/false (apply (lambda (E45cc@sub*) (let ((E45ce@p* (map E455d@subversion-pred E45cc@sub*))) (lambda (E45d0@x) (let E45d6@f ((E45d2@p* E45ce@p*) (E45d3@x E45d0@x)) (if (null? E45d2@p*) '#t (if (null? E45d3@x) '#f (and ((car E45d2@p*) (car E45d3@x)) (E45d6@f (cdr E45d2@p*) (cdr E45d3@x))))))))) E45ca@ls/false) (let ((E45d8@t E45c8@t)) (let ((E45da@ls/false (E30c1@syntax-dispatch E45d8@t '_))) (if E45da@ls/false (apply (lambda () (E31a1@syntax-violation 'import '"invalid version spec" E4558@spec E458c@x*)) E45da@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E45d8@t)))))))))))))))))))))) (let E4562@f ((E4560@x E4558@spec)) (let ((E4564@t E4560@x)) (let ((E4566@ls/false (E30c1@syntax-dispatch E4564@t '(each-any)))) (if E4566@ls/false (apply (lambda (E4568@version-spec*) (values '() (E455f@version-pred E4568@version-spec*))) E4566@ls/false) (let ((E456a@t E4564@t)) (let ((E456c@ls/false (E30c1@syntax-dispatch E456a@t '(any . any)))) (if (and E456c@ls/false (apply (lambda (E456e@x E456f@x*) (E448d@idsyn? E456e@x)) E456c@ls/false)) (apply (lambda (E4572@x E4573@x*) (call-with-values (lambda () (E4562@f E4573@x*)) (lambda (E457a@E4577 E457b@E4579) (let ((E457e@pred E457b@E4579) (E457f@name E457a@E4577)) (values (cons (E31a7@syntax->datum E4572@x) E457f@name) E457e@pred))))) E456c@ls/false) (let ((E4582@t E456a@t)) (let ((E4584@ls/false (E30c1@syntax-dispatch E4582@t '()))) (if E4584@ls/false (apply (lambda () (values '() (lambda (E4586@x) '#t))) E4584@ls/false) (let ((E4588@t E4582@t)) (let ((E458a@ls/false (E30c1@syntax-dispatch E4588@t '_))) (if E458a@ls/false (apply (lambda () (E31a1@syntax-violation '#f '"invalid import spec" E4558@spec)) E458a@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E4588@t))))))))))))))))) (E449d@import-library (lambda (E4548@spec*) (call-with-values (lambda () (E449b@parse-library-name E4548@spec*)) (lambda (E454e@E454b E454f@E454d) (let ((E4552@pred E454f@E454d) (E4553@name E454e@E454b)) (begin (if (null? E4553@name) (E31a1@syntax-violation 'import '"empty library name" E4548@spec*) (void)) (let ((E4556@lib (E2ccf@E2b16@find-library-by-name E4553@name))) (begin (if (not E4556@lib) (E31a1@syntax-violation 'import '"cannot find library with required name" E4553@name) (void)) (if (not (E4552@pred (E2ca9@E2aca@library-version E4556@lib))) (E31a1@syntax-violation 'import '"library does not satisfy version specification" E4548@spec* E4556@lib) (void)) ((E312d@imp-collector) E4556@lib) (E2cb1@E2ada@library-subst E4556@lib))))))))) (E449f@get-import (lambda (E44ba@spec) (let ((E44bc@t E44ba@spec)) (let ((E44be@ls/false (E30c1@syntax-dispatch E44bc@t '(any . each-any)))) (if (and E44be@ls/false (apply (lambda (E44c0@x E44c1@x*) (not (memq (E31a7@syntax->datum E44c0@x) '(for rename except only prefix library)))) E44be@ls/false)) (apply (lambda (E44c4@x E44c5@x*) (E449d@import-library (cons E44c4@x E44c5@x*))) E44be@ls/false) (let ((E44c8@t E44bc@t)) (let ((E44ca@ls/false (E30c1@syntax-dispatch E44c8@t '(any any . #(each (any any)))))) (if (and E44ca@ls/false (apply (lambda (E44cc@rename E44cd@isp E44ce@old* E44cf@new*) (and (eq? (E31a7@syntax->datum E44cc@rename) 'rename) (for-all E448d@idsyn? E44ce@old*) (for-all E448d@idsyn? E44cf@new*))) E44ca@ls/false)) (apply (lambda (E44d4@rename E44d5@isp E44d6@old* E44d7@new*) (let ((E44dc@subst (E449f@get-import E44d5@isp)) (E44dd@old* (map E31a7@syntax->datum E44d6@old*)) (E44de@new* (map E31a7@syntax->datum E44d7@new*))) (let ((E44e2@old-label* (E4495@find* E44dd@old* E44dc@subst))) (let ((E44e4@subst (E4497@rem* E44dd@old* E44dc@subst))) (E4491@merge-substs (map cons E44de@new* E44e2@old-label*) E44e4@subst))))) E44ca@ls/false) (let ((E44e6@t E44c8@t)) (let ((E44e8@ls/false (E30c1@syntax-dispatch E44e6@t '(any any . each-any)))) (if (and E44e8@ls/false (apply (lambda (E44ea@except E44eb@isp E44ec@sym*) (and (eq? (E31a7@syntax->datum E44ea@except) 'except) (for-all E448d@idsyn? E44ec@sym*))) E44e8@ls/false)) (apply (lambda (E44f0@except E44f1@isp E44f2@sym*) (let ((E44f6@subst (E449f@get-import E44f1@isp))) (E4497@rem* (map E31a7@syntax->datum E44f2@sym*) E44f6@subst))) E44e8@ls/false) (let ((E44f8@t E44e6@t)) (let ((E44fa@ls/false (E30c1@syntax-dispatch E44f8@t '(any any . each-any)))) (if (and E44fa@ls/false (apply (lambda (E44fc@only E44fd@isp E44fe@sym*) (and (eq? (E31a7@syntax->datum E44fc@only) 'only) (for-all E448d@idsyn? E44fe@sym*))) E44fa@ls/false)) (apply (lambda (E4502@only E4503@isp E4504@sym*) (let ((E4508@subst (E449f@get-import E4503@isp)) (E4509@sym* (map E31a7@syntax->datum E4504@sym*))) (let ((E450c@sym* (E4499@remove-dups E4509@sym*))) (let ((E450e@lab* (E4495@find* E450c@sym* E4508@subst))) (map cons E450c@sym* E450e@lab*))))) E44fa@ls/false) (let ((E4510@t E44f8@t)) (let ((E4512@ls/false (E30c1@syntax-dispatch E4510@t '(any any any)))) (if (and E4512@ls/false (apply (lambda (E4514@prefix E4515@isp E4516@p) (and (eq? (E31a7@syntax->datum E4514@prefix) 'prefix) (E448d@idsyn? E4516@p))) E4512@ls/false)) (apply (lambda (E451a@prefix E451b@isp E451c@p) (let ((E4520@subst (E449f@get-import E451b@isp)) (E4521@prefix (symbol->string (E31a7@syntax->datum E451c@p)))) (map (lambda (E4524@x) (cons (string->symbol (string-append E4521@prefix (symbol->string (car E4524@x)))) (cdr E4524@x))) E4520@subst))) E4512@ls/false) (let ((E4526@t E4510@t)) (let ((E4528@ls/false (E30c1@syntax-dispatch E4526@t '(any each-any)))) (if (and E4528@ls/false (apply (lambda (E452a@library E452b@spec*) (eq? (E31a7@syntax->datum E452a@library) 'library)) E4528@ls/false)) (apply (lambda (E452e@library E452f@spec*) (E449d@import-library E452f@spec*)) E4528@ls/false) (let ((E4532@t E4526@t)) (let ((E4534@ls/false (E30c1@syntax-dispatch E4532@t '(any any . any)))) (if (and E4534@ls/false (apply (lambda (E4536@for E4537@isp E4538@rest) (eq? (E31a7@syntax->datum E4536@for) 'for)) E4534@ls/false)) (apply (lambda (E453c@for E453d@isp E453e@rest) (E449f@get-import E453d@isp)) E4534@ls/false) (let ((E4542@t E4532@t)) (let ((E4544@ls/false (E30c1@syntax-dispatch E4542@t 'any))) (if E4544@ls/false (apply (lambda (E4546@spec) (E31a1@syntax-violation 'import '"invalid import spec" E4546@spec)) E4544@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E4542@t))))))))))))))))))))))))))) (E44a1@add-imports! (lambda (E44aa@imp E44ab@h) (let ((E44ae@subst (E449f@get-import E44aa@imp))) (for-each (lambda (E44b0@x) (let ((E44b2@name (car E44b0@x)) (E44b3@label (cdr E44b0@x))) (let ((E44b6@t (hashtable-ref E44ab@h E44b2@name '#f))) (if E44b6@t ((lambda (E44b8@l) (if (not (eq? E44b8@l E44b3@label)) (E448f@dup-error E44b2@name) (void))) E44b6@t) (hashtable-set! E44ab@h E44b2@name E44b3@label))))) E44ae@subst))))) (lambda (E44a2@imp*) (let E44a8@f ((E44a4@imp* E44a2@imp*) (E44a5@h (make-eq-hashtable))) (if (null? E44a4@imp*) (hashtable-entries E44a5@h) (begin (E44a1@add-imports! (car E44a4@imp*) E44a5@h) (E44a8@f (cdr E44a4@imp*) E44a5@h))))))) (set! E4bc4@E3123@parse-import-spec* E3123@parse-import-spec*) (set! E3125@make-top-rib (lambda (E4698@names E4699@labels) (let ((E469c@rib (E2e6e@make-empty-rib))) (begin (vector-for-each (lambda (E469e@name E469f@label) (begin (if (not (symbol? E469e@name)) (error 'make-top-rib '"BUG: not a symbol" E469e@name) (void)) (E2e72@extend-rib/nc! E469c@rib (make-simple-struct 'stx '5 (list E469e@name E2e3e@top-mark* '() '())) E469f@label))) E4698@names E4699@labels) E469c@rib)))) (set! E4bc5@E3125@make-top-rib E3125@make-top-rib) (set! E3127@make-collector (lambda () (let ((E46a2@ls '())) (lambda E46a6 (let ((E46a7 (length E46a6))) (if (= E46a7 '0) (apply (lambda () E46a2@ls) E46a6) (if (= E46a7 '1) (apply (lambda (E46a4@x) (set! E46a2@ls (E2e37@set-cons E46a4@x E46a2@ls))) E46a6) (error 'apply '"invalid arg count")))))))) (set! E4bc6@E3127@make-collector E3127@make-collector) (set! E3129@inv-collector (E2a0a@E28e8@make-parameter (lambda E46a8@args (assertion-violation 'inv-collector '"BUG: not initialized")) (lambda (E46aa@x) (begin (if (not (procedure? E46aa@x)) (assertion-violation 'inv-collector '"BUG: not a procedure" E46aa@x) (void)) E46aa@x)))) (set! E4bc7@E3129@inv-collector E3129@inv-collector) (set! E312b@vis-collector (E2a0a@E28e8@make-parameter (lambda E46ac@args (assertion-violation 'vis-collector '"BUG: not initialized")) (lambda (E46ae@x) (begin (if (not (procedure? E46ae@x)) (assertion-violation 'vis-collector '"BUG: not a procedure" E46ae@x) (void)) E46ae@x)))) (set! E4bc8@E312b@vis-collector E312b@vis-collector) (set! E312d@imp-collector (E2a0a@E28e8@make-parameter (lambda E46b0@args (assertion-violation 'imp-collector '"BUG: not initialized")) (lambda (E46b2@x) (begin (if (not (procedure? E46b2@x)) (assertion-violation 'imp-collector '"BUG: not a procedure" E46b2@x) (void)) E46b2@x)))) (set! E4bc9@E312d@imp-collector E312d@imp-collector) (set! E312f@chi-library-internal (lambda (E46b4@e* E46b5@rib E46b6@top?) (call-with-values (lambda () (E3119@chi-body* E46b4@e* '() '() '() '() '() '() '() E46b5@rib E46b6@top?)) (lambda (E46ca@E46bb E46cb@E46bd E46cc@E46bf E46cd@E46c1 E46ce@E46c3 E46cf@E46c5 E46d0@E46c7 E46d1@E46c9) (let ((E46da@exp* E46d1@E46c9) (E46db@_kwd* E46d0@E46c7) (E46dc@mod** E46cf@E46c5) (E46dd@rhs* E46ce@E46c3) (E46de@lex* E46cd@E46c1) (E46df@mr E46cc@E46bf) (E46e0@r E46cb@E46bd) (E46e1@e* E46ca@E46bb)) (values (append (apply append (reverse E46dc@mod**)) E46e1@e*) E46e0@r E46df@mr (reverse E46de@lex*) (reverse E46dd@rhs*) E46da@exp*)))))) (set! E4bca@E312f@chi-library-internal E312f@chi-library-internal) (set! E3131@chi-interaction-expr (lambda (E46ea@e E46eb@rib E46ec@r) (call-with-values (lambda () (E3119@chi-body* (list E46ea@e) E46ec@r E46ec@r '() '() '() '() '() E46eb@rib '#t)) (lambda (E4700@E46f1 E4701@E46f3 E4702@E46f5 E4703@E46f7 E4704@E46f9 E4705@E46fb E4706@E46fd E4707@E46ff) (let ((E4710@_exp* E4707@E46ff) (E4711@_kwd* E4706@E46fd) (E4712@mod** E4705@E46fb) (E4713@rhs* E4704@E46f9) (E4714@lex* E4703@E46f7) (E4715@mr E4702@E46f5) (E4716@r E4701@E46f3) (E4717@e* E4700@E46f1)) (let ((E4720@e* (E30f1@expand-interaction-rhs*/init* (reverse E4714@lex*) (reverse E4713@rhs*) (append (apply append (reverse E4712@mod**)) E4717@e*) E4716@r E4715@mr))) (let ((E4722@e (if (null? E4720@e*) (E2e20@E2d81@build-void) (if (null? (cdr E4720@e*)) (car E4720@e*) (E2e1f@E2d7f@build-sequence '#f E4720@e*))))) (values E4722@e E4716@r)))))))) (set! E4bcb@E3131@chi-interaction-expr E3131@chi-interaction-expr) (set! E3133@library-body-expander (lambda (E4724@name E4725@main-exp* E4726@imp* E4727@b* E4728@top?) (letrec* ((E472f@itc (E3127@make-collector))) (let ((E4738@E4731 E312d@imp-collector) (E4739@E4733 E31b1@top-level-context) (E473a@E4735 E472f@itc) (E473b@E4737 '#f)) (let ((E4740@swap (lambda () (begin (let ((E4742@t (E4738@E4731))) (begin (E4738@E4731 E473a@E4735) (set! E473a@E4735 E4742@t))) (let ((E4744@t (E4739@E4733))) (begin (E4739@E4733 E473b@E4737) (set! E473b@E4737 E4744@t))))))) (dynamic-wind E4740@swap (lambda () (call-with-values (lambda () (E3123@parse-import-spec* E4726@imp*)) (lambda (E474a@E4747 E474b@E4749) (let ((E474e@subst-labels E474b@E4749) (E474f@subst-names E474a@E4747)) (let ((E4752@rib (E3125@make-top-rib E474f@subst-names E474e@subst-labels))) (letrec* ((E4755@wrap (lambda (E47d0@x) (make-simple-struct 'stx '5 (list E47d0@x E2e3e@top-mark* (list E4752@rib) '()))))) (let ((E4756@b* (map E4755@wrap E4727@b*)) (E4757@main-exp* (map E4755@wrap E4725@main-exp*)) (E4758@rtc (E3127@make-collector)) (E4759@vtc (E3127@make-collector))) (let ((E4766@E475f E3129@inv-collector) (E4767@E4761 E312b@vis-collector) (E4768@E4763 E4758@rtc) (E4769@E4765 E4759@vtc)) (let ((E476e@swap (lambda () (begin (let ((E4770@t (E4766@E475f))) (begin (E4766@E475f E4768@E4763) (set! E4768@E4763 E4770@t))) (let ((E4772@t (E4767@E4761))) (begin (E4767@E4761 E4769@E4765) (set! E4769@E4765 E4772@t))))))) (dynamic-wind E476e@swap (lambda () (call-with-values (lambda () (E312f@chi-library-internal E4756@b* E4752@rib E4728@top?)) (lambda (E4780@E4775 E4781@E4777 E4782@E4779 E4783@E477b E4784@E477d E4785@E477f) (let ((E478c@internal-exp* E4785@E477f) (E478d@rhs* E4784@E477d) (E478e@lex* E4783@E477b) (E478f@mr E4782@E4779) (E4790@r E4781@E4777) (E4791@init* E4780@E4775)) (call-with-values (lambda () (E311d@parse-exports (append E4757@main-exp* E478c@internal-exp*))) (lambda (E479c@E4799 E479d@E479b) (let ((E47a0@exp-id* E479d@E479b) (E47a1@exp-name* E479c@E4799)) (begin (E2e76@seal-rib! E4752@rib) (let ((E47a4@init* (E30df@chi-expr* E4791@init* E4790@r E478f@mr))) (let ((E47a6@rhs* (E30f3@chi-rhs* E478d@rhs* E4790@r E478f@mr))) (begin (E2e78@unseal-rib! E4752@rib) (let ((E47a8@loc* (map E2e44@gen-global E478e@lex*)) (E47a9@export-subst (E318b@make-export-subst E47a1@exp-name* E47a0@exp-id*))) (letrec* ((E47ad@errstr '"attempt to export mutated variable")) (call-with-values (lambda () (E318d@make-export-env/macros E478e@lex* E47a8@loc* E4790@r)) (lambda (E47b4@E47af E47b5@E47b1 E47b6@E47b3) (let ((E47ba@macro* E47b6@E47b3) (E47bb@global* E47b5@E47b1) (E47bc@export-env E47b4@E47af)) (begin (for-each (lambda (E47c0@s) (let ((E47c2@name (car E47c0@s)) (E47c3@label (cdr E47c0@s))) (let ((E47c6@p (assq E47c3@label E47bc@export-env))) (if E47c6@p (let ((E47c8@b (cdr E47c6@p))) (let ((E47ca@type (car E47c8@b))) (if (eq? E47ca@type 'mutable) (E31a1@syntax-violation 'export E47ad@errstr E47c2@name) (void)))) (void))))) E47a9@export-subst) (let ((E47cc@invoke-body (E2e25@E2d8b@build-library-letrec* '#f E4724@name E478e@lex* E47a8@loc* E47a6@rhs* (if (null? E47a4@init*) (E2e20@E2d81@build-void) (E2e1f@E2d7f@build-sequence '#f E47a4@init*)))) (E47cd@invoke-definitions (map E2e1c@E2cde@build-global-define (map cdr E47bb@global*)))) (values (E472f@itc) (E4758@rtc) (E4759@vtc) (E2e1f@E2d7f@build-sequence '#f (append E47cd@invoke-definitions (list E47cc@invoke-body))) E47ba@macro* E47a9@export-subst E47bc@export-env))))))))))))))))))) E476e@swap)))))))))) E4740@swap)))))) (set! E4bcc@E3133@library-body-expander E3133@library-body-expander) (set! E3135@core-library-expander (lambda (E47d2@e E47d3@verify-name) (call-with-values (lambda () (E3121@parse-library E47d2@e)) (lambda (E47de@E47d7 E47df@E47d9 E47e0@E47db E47e1@E47dd) (let ((E47e6@b* E47e1@E47dd) (E47e7@imp* E47e0@E47db) (E47e8@exp* E47df@E47d9) (E47e9@name* E47de@E47d7)) (call-with-values (lambda () (E311f@parse-library-name E47e9@name*)) (lambda (E47f2@E47ef E47f3@E47f1) (let ((E47f6@ver E47f3@E47f1) (E47f7@name E47f2@E47ef)) (begin (E47d3@verify-name E47f7@name) (call-with-values (lambda () (E3133@library-body-expander E47f7@name E47e8@exp* E47e7@imp* E47e6@b* '#f)) (lambda (E4808@E47fb E4809@E47fd E480a@E47ff E480b@E4801 E480c@E4803 E480d@E4805 E480e@E4807) (let ((E4816@export-env E480e@E4807) (E4817@export-subst E480d@E4805) (E4818@visit-code E480c@E4803) (E4819@invoke-code E480b@E4801) (E481a@visit-req* E480a@E47ff) (E481b@invoke-req* E4809@E47fd) (E481c@imp* E4808@E47fb)) (values E47f7@name E47f6@ver E481c@imp* E481b@invoke-req* E481a@visit-req* E4819@invoke-code E4818@visit-code E4817@export-subst E4816@export-env))))))))))))) (set! E4bcd@E3135@core-library-expander E3135@core-library-expander) (set! E3137@parse-top-level-program (lambda (E4824@e*) (let ((E4826@t E4824@e*)) (let ((E4828@ls/false (E30c1@syntax-dispatch E4826@t '((any . each-any) . each-any)))) (if (and E4828@ls/false (apply (lambda (E482a@import E482b@imp* E482c@b*) (eq? (E31a7@syntax->datum E482a@import) 'import)) E4828@ls/false)) (apply (lambda (E4830@import E4831@imp* E4832@b*) (values E4831@imp* E4832@b*)) E4828@ls/false) (let ((E4836@t E4826@t)) (let ((E4838@ls/false (E30c1@syntax-dispatch E4836@t '((any . any) . any)))) (if (and E4838@ls/false (apply (lambda (E483a@import E483b@x E483c@y) (eq? (E31a7@syntax->datum E483a@import) 'import)) E4838@ls/false)) (apply (lambda (E4840@import E4841@x E4842@y) (E31a1@syntax-violation 'expander '"invalid syntax of top-level program" (E2eb4@syntax-car E4824@e*))) E4838@ls/false) (let ((E4846@t E4836@t)) (let ((E4848@ls/false (E30c1@syntax-dispatch E4846@t '_))) (if E4848@ls/false (apply (lambda () (assertion-violation 'expander '"top-level program is missing an (import ---) clause")) E4848@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E4846@t)))))))))))) (set! E4bce@E3137@parse-top-level-program E3137@parse-top-level-program) (set! E3139@top-level-expander (lambda (E484a@e*) (call-with-values (lambda () (E3137@parse-top-level-program E484a@e*)) (lambda (E4850@E484d E4851@E484f) (let ((E4854@b* E4851@E484f) (E4855@imp* E4850@E484d)) (call-with-values (lambda () (E3133@library-body-expander '() '() E4855@imp* E4854@b* '#t)) (lambda (E4866@E4859 E4867@E485b E4868@E485d E4869@E485f E486a@E4861 E486b@E4863 E486c@E4865) (let ((E4874@export-env E486c@E4865) (E4875@export-subst E486b@E4863) (E4876@visit-code E486a@E4861) (E4877@invoke-code E4869@E485f) (E4878@visit-req* E4868@E485d) (E4879@invoke-req* E4867@E485b) (E487a@imp* E4866@E4859)) (values E4879@invoke-req* E4877@invoke-code))))))))) (set! E4bcf@E3139@top-level-expander E3139@top-level-expander) (set! E313b@rp (E2a07@E28e2@make-record-printer 'env (lambda (E4882@x E4883@p E4884@wr) (display '"#<environment>" E4883@p)))) (set! E4bd0@E313b@rp E313b@rp) (set! E3145@env? (lambda (E4888@x) (and (simple-struct? E4888@x) (eq? (simple-struct-name E4888@x) 'env)))) (set! E4bd1@E3145@env? E3145@env?) (set! E3147@env-names (lambda (E488a@x) (simple-struct-ref E488a@x '0))) (set! E4bd2@E3147@env-names E3147@env-names) (set! E3149@set-env-names! (lambda (E488c@x E488d@val) (simple-struct-set! E488c@x '0 E488d@val))) (set! E4bd3@E3149@set-env-names! E3149@set-env-names!) (set! E314b@env-labels (lambda (E4890@x) (simple-struct-ref E4890@x '1))) (set! E4bd4@E314b@env-labels E314b@env-labels) (set! E314d@set-env-labels! (lambda (E4892@x E4893@val) (simple-struct-set! E4892@x '1 E4893@val))) (set! E4bd5@E314d@set-env-labels! E314d@set-env-labels!) (set! E314f@env-itc (lambda (E4896@x) (simple-struct-ref E4896@x '2))) (set! E4bd6@E314f@env-itc E314f@env-itc) (set! E3151@set-env-itc! (lambda (E4898@x E4899@val) (simple-struct-set! E4898@x '2 E4899@val))) (set! E4bd7@E3151@set-env-itc! E3151@set-env-itc!) (set! E3153@dummy '3) (set! E4bd8@E3153@dummy E3153@dummy) (set! E3155@rp (E2a07@E28e2@make-record-printer 'interaction-env (lambda (E489c@x E489d@p E489e@wr) (display '"#<environment>" E489d@p)))) (set! E4bd9@E3155@rp E3155@rp) (set! E315f@interaction-env? (lambda (E48a2@x) (and (simple-struct? E48a2@x) (eq? (simple-struct-name E48a2@x) 'interaction-env)))) (set! E4bda@E315f@interaction-env? E315f@interaction-env?) (set! E3161@interaction-env-rib (lambda (E48a4@x) (simple-struct-ref E48a4@x '0))) (set! E4bdb@E3161@interaction-env-rib E3161@interaction-env-rib) (set! E3163@set-interaction-env-rib! (lambda (E48a6@x E48a7@val) (simple-struct-set! E48a6@x '0 E48a7@val))) (set! E4bdc@E3163@set-interaction-env-rib! E3163@set-interaction-env-rib!) (set! E3165@interaction-env-r (lambda (E48aa@x) (simple-struct-ref E48aa@x '1))) (set! E4bdd@E3165@interaction-env-r E3165@interaction-env-r) (set! E3167@set-interaction-env-r! (lambda (E48ac@x E48ad@val) (simple-struct-set! E48ac@x '1 E48ad@val))) (set! E4bde@E3167@set-interaction-env-r! E3167@set-interaction-env-r!) (set! E3169@interaction-env-locs (lambda (E48b0@x) (simple-struct-ref E48b0@x '2))) (set! E4bdf@E3169@interaction-env-locs E3169@interaction-env-locs) (set! E316b@set-interaction-env-locs! (lambda (E48b2@x E48b3@val) (simple-struct-set! E48b2@x '2 E48b3@val))) (set! E4be0@E316b@set-interaction-env-locs! E316b@set-interaction-env-locs!) (set! E316d@dummy '3) (set! E4be1@E316d@dummy E316d@dummy) (set! E316f@interaction-environment-symbols (lambda () (E3177@environment-symbols (E31af@interaction-environment)))) (set! E4be2@E316f@interaction-environment-symbols E316f@interaction-environment-symbols) (set! E3171@environment-bindings (lambda (E48b6@e) (vector->list (vector-map (lambda (E48b8@name E48b9@label) (E3173@parse-binding (cons E48b8@name (E2cd5@E2b22@imported-label->binding E48b9@label)))) (E3147@env-names E48b6@e) (E314b@env-labels E48b6@e))))) (set! E4be3@E3171@environment-bindings E3171@environment-bindings) (set! E3173@parse-binding (lambda (E48bc@b) (cons (car E48bc@b) (let ((E48be@t (cadr E48bc@b))) (if (memv E48be@t '(core-prim global)) 'procedure (if (memv E48be@t '(core-macro macro global-macro)) 'syntax (if (memv E48be@t '($core-rtd)) 'record (if (eq? (car E48bc@b) (cadr E48bc@b)) 'syntax 'unknown)))))))) (set! E4be4@E3173@parse-binding E3173@parse-binding) (set! E3175@environment? (lambda (E48c0@x) (or (E3145@env? E48c0@x) (E315f@interaction-env? E48c0@x)))) (set! E4be5@E3175@environment? E3175@environment?) (set! E3177@environment-symbols (lambda (E48c2@x) (if (E3145@env? E48c2@x) (vector->list (E3147@env-names E48c2@x)) (if (E315f@interaction-env? E48c2@x) (map values (E2e58@rib-sym* (E3161@interaction-env-rib E48c2@x))) (assertion-violation 'environment-symbols '"not an environment" E48c2@x))))) (set! E4be6@E3177@environment-symbols E3177@environment-symbols) (set! E3179@environment (lambda E48c4@imp* (let ((E48c6@itc (E3127@make-collector))) (let ((E48cc@E48c9 E312d@imp-collector) (E48cd@E48cb E48c6@itc)) (let ((E48d0@swap (lambda () (let ((E48d2@t (E48cc@E48c9))) (begin (E48cc@E48c9 E48cd@E48cb) (set! E48cd@E48cb E48d2@t)))))) (dynamic-wind E48d0@swap (lambda () (call-with-values (lambda () (E3123@parse-import-spec* E48c4@imp*)) (lambda (E48d8@E48d5 E48d9@E48d7) (let ((E48dc@subst-labels E48d9@E48d7) (E48dd@subst-names E48d8@E48d5)) (make-simple-struct 'env '4 (list E48dd@subst-names E48dc@subst-labels E48c6@itc)))))) E48d0@swap)))))) (set! E4be7@E3179@environment E3179@environment) (set! E317b@null-environment (lambda (E48e0@n) (begin (if (not (eqv? E48e0@n '5)) (assertion-violation 'null-environment '"not 5" E48e0@n) (void)) (E3179@environment '(psyntax null-environment-5))))) (set! E4be8@E317b@null-environment E317b@null-environment) (set! E317d@scheme-report-environment (lambda (E48e2@n) (begin (if (not (eqv? E48e2@n '5)) (assertion-violation 'scheme-report-environment '"not 5" E48e2@n) (void)) (E3179@environment '(psyntax scheme-report-environment-5))))) (set! E4be9@E317d@scheme-report-environment E317d@scheme-report-environment) (set! E317f@expand (lambda (E48e4@x E48e5@env) (if (E3145@env? E48e5@env) (let ((E48e8@rib (E3125@make-top-rib (E3147@env-names E48e5@env) (E314b@env-labels E48e5@env)))) (let ((E48ea@x (make-simple-struct 'stx '5 (list E48e4@x E2e3e@top-mark* (list E48e8@rib) '()))) (E48eb@itc (E314f@env-itc E48e5@env)) (E48ec@rtc (E3127@make-collector)) (E48ed@vtc (E3127@make-collector))) (let ((E48f2@x (let ((E4904@E48f5 E31b1@top-level-context) (E4905@E48f7 E3129@inv-collector) (E4906@E48f9 E312b@vis-collector) (E4907@E48fb E312d@imp-collector) (E4908@E48fd '#f) (E4909@E48ff E48ec@rtc) (E490a@E4901 E48ed@vtc) (E490b@E4903 E48eb@itc)) (let ((E4914@swap (lambda () (begin (let ((E4916@t (E4904@E48f5))) (begin (E4904@E48f5 E4908@E48fd) (set! E4908@E48fd E4916@t))) (let ((E4918@t (E4905@E48f7))) (begin (E4905@E48f7 E4909@E48ff) (set! E4909@E48ff E4918@t))) (let ((E491a@t (E4906@E48f9))) (begin (E4906@E48f9 E490a@E4901) (set! E490a@E4901 E491a@t))) (let ((E491c@t (E4907@E48fb))) (begin (E4907@E48fb E490b@E4903) (set! E490b@E4903 E491c@t))))))) (dynamic-wind E4914@swap (lambda () (E30e3@chi-expr E48ea@x '() '())) E4914@swap))))) (begin (E2e76@seal-rib! E48e8@rib) (values E48f2@x (E48ec@rtc)))))) (if (E315f@interaction-env? E48e5@env) (let ((E491e@rib (E3161@interaction-env-rib E48e5@env)) (E491f@r (E3165@interaction-env-r E48e5@env)) (E4920@rtc (E3127@make-collector))) (let ((E4924@x (make-simple-struct 'stx '5 (list E48e4@x E2e3e@top-mark* (list E491e@rib) '())))) (call-with-values (lambda () (let ((E493a@E492b E31b1@top-level-context) (E493b@E492d E3129@inv-collector) (E493c@E492f E312b@vis-collector) (E493d@E4931 E312d@imp-collector) (E493e@E4933 E48e5@env) (E493f@E4935 E4920@rtc) (E4940@E4937 (E3127@make-collector)) (E4941@E4939 (E3127@make-collector))) (let ((E494a@swap (lambda () (begin (let ((E494c@t (E493a@E492b))) (begin (E493a@E492b E493e@E4933) (set! E493e@E4933 E494c@t))) (let ((E494e@t (E493b@E492d))) (begin (E493b@E492d E493f@E4935) (set! E493f@E4935 E494e@t))) (let ((E4950@t (E493c@E492f))) (begin (E493c@E492f E4940@E4937) (set! E4940@E4937 E4950@t))) (let ((E4952@t (E493d@E4931))) (begin (E493d@E4931 E4941@E4939) (set! E4941@E4939 E4952@t))))))) (dynamic-wind E494a@swap (lambda () (E3131@chi-interaction-expr E4924@x E491e@rib E491f@r)) E494a@swap)))) (lambda (E4954@E4927 E4955@E4929) (let ((E4958@r^ E4955@E4929) (E4959@e E4954@E4927)) (begin (E3167@set-interaction-env-r! E48e5@env E4958@r^) (values E4959@e (E4920@rtc)))))))) (assertion-violation 'expand '"not an environment" E48e5@env))))) (set! E4bea@E317f@expand E317f@expand) (set! E3181@eval (lambda (E495c@x E495d@env) (begin (if (not (E3175@environment? E495d@env)) (error 'eval '"not an environment" E495d@env) (void)) (call-with-values (lambda () (E317f@expand E495c@x E495d@env)) (lambda (E4964@E4961 E4965@E4963) (let ((E4968@invoke-req* E4965@E4963) (E4969@x E4964@E4961)) (begin (for-each E2cd6@E2b24@invoke-library E4968@invoke-req*) (eval-core (E2a60@E2a18@expanded->core E4969@x))))))))) (set! E4beb@E3181@eval E3181@eval) (set! E3183@library-expander (lambda E49da (let ((E49db (length E49da))) (if (= E49db '3) (apply (lambda (E496c@x E496d@filename E496e@verify-name) (letrec* ((E4973@build-visit-code (lambda (E49c8@macro*) (if (null? E49c8@macro*) (E2e20@E2d81@build-void) (E2e1f@E2d7f@build-sequence '#f (map (lambda (E49ca@x) (let ((E49cc@loc (car E49ca@x)) (E49cd@src (cddr E49ca@x))) (list 'set! E49cc@loc E49cd@src))) E49c8@macro*))))) (E4975@visit! (lambda (E49c0@macro*) (for-each (lambda (E49c2@x) (let ((E49c4@loc (car E49c2@x)) (E49c5@proc (cadr E49c2@x))) (set-symbol-value! E49c4@loc E49c5@proc))) E49c0@macro*)))) (call-with-values (lambda () (E3135@core-library-expander E496c@x E496e@verify-name)) (lambda (E4988@E4977 E4989@E4979 E498a@E497b E498b@E497d E498c@E497f E498d@E4981 E498e@E4983 E498f@E4985 E4990@E4987) (let ((E499a@export-env E4990@E4987) (E499b@export-subst E498f@E4985) (E499c@macro* E498e@E4983) (E499d@invoke-code E498d@E4981) (E499e@vis* E498c@E497f) (E499f@inv* E498b@E497d) (E49a0@imp* E498a@E497b) (E49a1@ver E4989@E4979) (E49a2@name E4988@E4977)) (let ((E49ac@id (gensym)) (E49ad@name E49a2@name) (E49ae@ver E49a1@ver) (E49af@imp* (map E2cda@E2b2c@library-spec E49a0@imp*)) (E49b0@vis* (map E2cda@E2b2c@library-spec E499e@vis*)) (E49b1@inv* (map E2cda@E2b2c@library-spec E499f@inv*)) (E49b2@visit-proc (lambda () (E4975@visit! E499c@macro*))) (E49b3@invoke-proc (lambda () (eval-core (E2a60@E2a18@expanded->core E499d@invoke-code)))) (E49b4@visit-code (E4973@build-visit-code E499c@macro*)) (E49b5@invoke-code E499d@invoke-code)) (begin (E2cd4@E2b20@install-library E49ac@id E49ad@name E49ae@ver E49af@imp* E49b0@vis* E49b1@inv* E499b@export-subst E499a@export-env E49b2@visit-proc E49b3@invoke-proc E49b4@visit-code E49b5@invoke-code '#t E496d@filename) (values E49ac@id E49ad@name E49ae@ver E49af@imp* E49b0@vis* E49b1@inv* E49b5@invoke-code E49b4@visit-code E499b@export-subst E499a@export-env)))))))) E49da) (if (= E49db '2) (apply (lambda (E49d0@x E49d1@filename) (E3183@library-expander E49d0@x E49d1@filename (lambda (E49d4@x) (values)))) E49da) (if (= E49db '1) (apply (lambda (E49d6@x) (E3183@library-expander E49d6@x '#f (lambda (E49d8@x) (values)))) E49da) (error 'apply '"invalid arg count"))))))) (set! E4bec@E3183@library-expander E3183@library-expander) (set! E3185@boot-library-expand (lambda (E49dc@x) (call-with-values (lambda () (E3183@library-expander E49dc@x)) (lambda (E49f2@E49df E49f3@E49e1 E49f4@E49e3 E49f5@E49e5 E49f6@E49e7 E49f7@E49e9 E49f8@E49eb E49f9@E49ed E49fa@E49ef E49fb@E49f1) (let ((E4a06@export-env E49fb@E49f1) (E4a07@export-subst E49fa@E49ef) (E4a08@visit-code E49f9@E49ed) (E4a09@invoke-code E49f8@E49eb) (E4a0a@inv* E49f7@E49e9) (E4a0b@vis* E49f6@E49e7) (E4a0c@imp* E49f5@E49e5) (E4a0d@ver E49f4@E49e3) (E4a0e@name E49f3@E49e1) (E4a0f@id E49f2@E49df)) (values E4a0e@name E4a09@invoke-code E4a07@export-subst E4a06@export-env)))))) (set! E4bed@E3185@boot-library-expand E3185@boot-library-expand) (set! E3187@rev-map-append (lambda (E4a1a@f E4a1b@ls E4a1c@ac) (if (null? E4a1b@ls) E4a1c@ac (E3187@rev-map-append E4a1a@f (cdr E4a1b@ls) (cons (E4a1a@f (car E4a1b@ls)) E4a1c@ac))))) (set! E4bee@E3187@rev-map-append E3187@rev-map-append) (set! E3189@build-exports (lambda (E4a20@lex*+loc* E4a21@init*) (E2e1f@E2d7f@build-sequence '#f (cons (E2e20@E2d81@build-void) (E3187@rev-map-append (lambda (E4a24@x) (list 'set! (cdr E4a24@x) (car E4a24@x))) E4a20@lex*+loc* E4a21@init*))))) (set! E4bef@E3189@build-exports E3189@build-exports) (set! E318b@make-export-subst (lambda (E4a26@name* E4a27@id*) (map (lambda (E4a2a@name E4a2b@id) (let ((E4a2e@label (E2ed0@id->label E4a2b@id))) (begin (if (not E4a2e@label) (E31a1@syntax-violation '#f '"cannot export unbound identifier" E4a2b@id) (void)) (cons E4a2a@name E4a2e@label)))) E4a26@name* E4a27@id*))) (set! E4bf0@E318b@make-export-subst E318b@make-export-subst) (set! E318d@make-export-env/macros (lambda (E4a30@lex* E4a31@loc* E4a32@r) (letrec* ((E4a37@lookup (lambda (E4a54@x) (let E4a5c@f ((E4a56@x E4a54@x) (E4a57@lex* E4a30@lex*) (E4a58@loc* E4a31@loc*)) (if (pair? E4a57@lex*) (if (eq? E4a56@x (car E4a57@lex*)) (car E4a58@loc*) (E4a5c@f E4a56@x (cdr E4a57@lex*) (cdr E4a58@loc*))) (assertion-violation 'lookup-make-export '"BUG")))))) (let E4a40@f ((E4a38@r E4a32@r) (E4a39@env '()) (E4a3a@global* '()) (E4a3b@macro* '())) (if (null? E4a38@r) (values E4a39@env E4a3a@global* E4a3b@macro*) (let ((E4a42@x (car E4a38@r))) (let ((E4a44@label (car E4a42@x)) (E4a45@b (cdr E4a42@x))) (let ((E4a48@t (E2ed6@binding-type E4a45@b))) (if (memv E4a48@t '(lexical)) (let ((E4a4a@v (E2ed8@binding-value E4a45@b))) (let ((E4a4c@loc (E4a37@lookup (E304b@lexical-var E4a4a@v))) (E4a4d@type (if (E304d@lexical-mutable? E4a4a@v) 'mutable 'global))) (E4a40@f (cdr E4a38@r) (cons (cons* E4a44@label E4a4d@type E4a4c@loc) E4a39@env) (cons (cons (E304b@lexical-var E4a4a@v) E4a4c@loc) E4a3a@global*) E4a3b@macro*))) (if (memv E4a48@t '(local-macro)) (let ((E4a50@loc (gensym))) (E4a40@f (cdr E4a38@r) (cons (cons* E4a44@label 'global-macro E4a50@loc) E4a39@env) E4a3a@global* (cons (cons E4a50@loc (E2ed8@binding-value E4a45@b)) E4a3b@macro*))) (if (memv E4a48@t '(local-macro!)) (let ((E4a52@loc (gensym))) (E4a40@f (cdr E4a38@r) (cons (cons* E4a44@label 'global-macro! E4a52@loc) E4a39@env) E4a3a@global* (cons (cons E4a52@loc (E2ed8@binding-value E4a45@b)) E4a3b@macro*))) (if (memv E4a48@t '($rtd $module)) (E4a40@f (cdr E4a38@r) (cons E4a42@x E4a39@env) E4a3a@global* E4a3b@macro*) (assertion-violation 'expander '"BUG: do not know how to export" (E2ed6@binding-type E4a45@b) (E2ed8@binding-value E4a45@b)))))))))))))) (set! E4bf1@E318d@make-export-env/macros E318d@make-export-env/macros) (set! E318f@generate-temporaries (lambda (E4a5e@ls) (let ((E4a60@t E4a5e@ls)) (let ((E4a62@ls/false (E30c1@syntax-dispatch E4a60@t 'each-any))) (if E4a62@ls/false (apply (lambda (E4a64@ls) (map (lambda (E4a66@x) (make-simple-struct 'stx '5 (list (let ((E4a68@x (E31a7@syntax->datum E4a66@x))) (if (or (symbol? E4a68@x) (string? E4a68@x)) (gensym E4a68@x) (gensym 't))) E2e3e@top-mark* '() '()))) E4a64@ls)) E4a62@ls/false) (let ((E4a6a@t E4a60@t)) (let ((E4a6c@ls/false (E30c1@syntax-dispatch E4a6a@t '_))) (if E4a6c@ls/false (apply (lambda () (assertion-violation 'generate-temporaries '"not a list")) E4a6c@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E4a6a@t))))))))) (set! E4bf2@E318f@generate-temporaries E318f@generate-temporaries) (set! E3191@free-identifier=? (lambda (E4a6e@x E4a6f@y) (if (E2eba@id? E4a6e@x) (if (E2eba@id? E4a6f@y) (E2ec0@free-id=? E4a6e@x E4a6f@y) (assertion-violation 'free-identifier=? '"not an identifier" E4a6f@y)) (assertion-violation 'free-identifier=? '"not an identifier" E4a6e@x)))) (set! E4bf3@E3191@free-identifier=? E3191@free-identifier=?) (set! E3193@bound-identifier=? (lambda (E4a72@x E4a73@y) (if (E2eba@id? E4a72@x) (if (E2eba@id? E4a73@y) (E2ebe@bound-id=? E4a72@x E4a73@y) (assertion-violation 'bound-identifier=? '"not an identifier" E4a73@y)) (assertion-violation 'bound-identifier=? '"not an identifier" E4a72@x)))) (set! E4bf4@E3193@bound-identifier=? E3193@bound-identifier=?) (set! E3195@make-source-condition (lambda (E4a76@x) (letrec* ((E4a80@E4a7b (make-record-type-descriptor '&source-information &condition-rtd 'E4a7e '#f '#f '#((immutable file-name) (immutable line)))) (E4a82@E4a7d '#f) (E4a84@E4a7c (make-record-constructor-descriptor E4a80@E4a7b &condition-rcd E4a82@E4a7d)) (E4a87@E4a7a (record-predicate E4a80@E4a7b)) (E4a89@make-source-condition (record-constructor E4a84@E4a7c)) (E4a8b@E4a78 (record-accessor E4a80@E4a7b '0)) (E4a8d@E4a79 (record-accessor E4a80@E4a7b '1)) (E4a8f@source-condition? (condition-predicate E4a80@E4a7b)) (E4a91@source-filename (condition-accessor E4a80@E4a7b E4a8b@E4a78)) (E4a93@source-character (condition-accessor E4a80@E4a7b E4a8d@E4a79))) (if (and (pair? E4a76@x) (pair? (cdr E4a76@x))) (E4a89@make-source-condition (car E4a76@x) (cadr E4a76@x)) (condition))))) (set! E4bf5@E3195@make-source-condition E3195@make-source-condition) (set! E3197@extract-position-condition (lambda (E4a94@x) (E3195@make-source-condition (E3199@expression-position E4a94@x)))) (set! E4bf6@E3197@extract-position-condition E3197@extract-position-condition) (set! E3199@expression-position (lambda (E4a96@x) (and (E2e86@stx? E4a96@x) (let ((E4a98@x (E2e88@stx-expr E4a96@x))) (and (E29fe@E28d0@annotation? E4a98@x) (E29ff@E28d2@annotation-source E4a98@x)))))) (set! E4bf7@E3199@expression-position E3199@expression-position) (set! E319b@assertion-error (lambda (E4a9a@expr E4a9b@pos) (raise (condition (make-assertion-violation) (make-who-condition 'assert) (make-message-condition '"assertion failed") (make-irritants-condition (list E4a9a@expr)) (E3195@make-source-condition E4a9b@pos))))) (set! E4bf8@E319b@assertion-error E319b@assertion-error) (set! E319d@syntax-error (lambda (E4a9e@x . E4aa0@args) (begin (if (not (for-all string? E4aa0@args)) (assertion-violation 'syntax-error '"invalid argument" E4aa0@args) (void)) (raise (condition (make-message-condition (if (null? E4aa0@args) '"invalid syntax" (apply string-append E4aa0@args))) (make-syntax-violation (E31a7@syntax->datum E4a9e@x) '#f) (E3197@extract-position-condition E4a9e@x)))))) (set! E4bf9@E319d@syntax-error E319d@syntax-error) (set! E319f@syntax-violation* (lambda (E4aa2@who E4aa3@msg E4aa4@form E4aa5@condition-object) (begin (if (not (string? E4aa3@msg)) (assertion-violation 'syntax-violation '"message is not a string" E4aa3@msg) (void)) (let ((E4aaa@who (if (or (string? E4aa2@who) (symbol? E4aa2@who)) E4aa2@who (if (not E4aa2@who) (let ((E4aac@t E4aa4@form)) (let ((E4aae@ls/false (E30c1@syntax-dispatch E4aac@t 'any))) (if (and E4aae@ls/false (apply (lambda (E4ab0@id) (E2eba@id? E4ab0@id)) E4aae@ls/false)) (apply (lambda (E4ab2@id) (E31a7@syntax->datum E4ab2@id)) E4aae@ls/false) (let ((E4ab4@t E4aac@t)) (let ((E4ab6@ls/false (E30c1@syntax-dispatch E4ab4@t '(any . any)))) (if (and E4ab6@ls/false (apply (lambda (E4ab8@id E4ab9@rest) (E2eba@id? E4ab8@id)) E4ab6@ls/false)) (apply (lambda (E4abc@id E4abd@rest) (E31a7@syntax->datum E4abc@id)) E4ab6@ls/false) (let ((E4ac0@t E4ab4@t)) (let ((E4ac2@ls/false (E30c1@syntax-dispatch E4ac0@t '_))) (if E4ac2@ls/false (apply (lambda () '#f) E4ac2@ls/false) (E31a1@syntax-violation '#f '"invalid syntax" E4ac0@t)))))))))) (assertion-violation 'syntax-violation '"invalid who argument" E4aa2@who))))) (raise (condition (if E4aaa@who (make-who-condition E4aaa@who) (condition)) (make-message-condition E4aa3@msg) E4aa5@condition-object (E3197@extract-position-condition E4aa4@form))))))) (set! E4bfa@E319f@syntax-violation* E319f@syntax-violation*) (set! E31a1@syntax-violation (lambda E4ad2 (let ((E4ad3 (length E4ad2))) (if (= E4ad3 '3) (apply (lambda (E4ac4@who E4ac5@msg E4ac6@form) (E31a1@syntax-violation E4ac4@who E4ac5@msg E4ac6@form '#f)) E4ad2) (if (= E4ad3 '4) (apply (lambda (E4aca@who E4acb@msg E4acc@form E4acd@subform) (E319f@syntax-violation* E4aca@who E4acb@msg E4acc@form (make-syntax-violation (E31a7@syntax->datum E4acc@form) (E31a7@syntax->datum E4acd@subform)))) E4ad2) (error 'apply '"invalid arg count")))))) (set! E4bfb@E31a1@syntax-violation E31a1@syntax-violation) (set! E31a3@identifier? (lambda (E4ad4@x) (E2eba@id? E4ad4@x))) (set! E4bfc@E31a3@identifier? E31a3@identifier?) (set! E31a5@datum->syntax (lambda (E4ad6@id E4ad7@datum) (if (E2eba@id? E4ad6@id) (E2e9a@datum->stx E4ad6@id E4ad7@datum) (assertion-violation 'datum->syntax '"not an identifier" E4ad6@id)))) (set! E4bfd@E31a5@datum->syntax E31a5@datum->syntax) (set! E31a7@syntax->datum (lambda (E4ada@x) (E2ece@stx->datum E4ada@x))) (set! E4bfe@E31a7@syntax->datum E31a7@syntax->datum) (set! E31a9@ungensym-all (lambda (E4adc@code) (if (pair? E4adc@code) (cons (E31a9@ungensym-all (car E4adc@code)) (E31a9@ungensym-all (cdr E4adc@code))) (if (symbol? E4adc@code) (ungensym E4adc@code) E4adc@code)))) (set! E4bff@E31a9@ungensym-all E31a9@ungensym-all) (set! E31ab@compile-r6rs-top-level (lambda (E4ade@x*) (call-with-values (lambda () (E3139@top-level-expander E4ade@x*)) (lambda (E4ae4@E4ae1 E4ae5@E4ae3) (let ((E4ae8@invoke-code E4ae5@E4ae3) (E4ae9@lib* E4ae4@E4ae1)) (lambda () (begin (for-each E2cd6@E2b24@invoke-library E4ae9@lib*) (let ((E4aec@expanded (E2a60@E2a18@expanded->core E4ae8@invoke-code))) (begin (if (symbol-value 'debug-expand) (format '#t '"psyntax expanded=~a\n" (E31a9@ungensym-all E4aec@expanded)) (void)) (eval-core E4aec@expanded)))))))))) (set! E4c00@E31ab@compile-r6rs-top-level E31ab@compile-r6rs-top-level) (set! E31ad@pre-compile-r6rs-top-level (lambda (E4aee@x*) (call-with-values (lambda () (E3139@top-level-expander E4aee@x*)) (lambda (E4af4@E4af1 E4af5@E4af3) (let ((E4af8@invoke-code E4af5@E4af3) (E4af9@lib* E4af4@E4af1)) (begin (for-each E2cd6@E2b24@invoke-library E4af9@lib*) (E2a08@E28e4@compile-core (E2a60@E2a18@expanded->core E4af8@invoke-code)))))))) (set! E4c01@E31ad@pre-compile-r6rs-top-level E31ad@pre-compile-r6rs-top-level) (set! E31af@interaction-environment (let ((E4afc@the-env '#f)) (lambda () (or E4afc@the-env (let ((E4afe@lib (E2ccf@E2b16@find-library-by-name '(mosh interaction))) (E4aff@rib (E2e6e@make-empty-rib))) (begin (let ((E4b02@subst (E2cb1@E2ada@library-subst E4afe@lib))) (begin (E2e5a@set-rib-sym*! E4aff@rib (map car E4b02@subst)) (E2e5e@set-rib-mark**! E4aff@rib (map (lambda (E4b04@x) E2e3e@top-mark*) E4b02@subst)) (E2e62@set-rib-label*! E4aff@rib (map cdr E4b02@subst)))) (let ((E4b06@env (make-simple-struct 'interaction-env '4 (list E4aff@rib '() '())))) (begin (set! E4afc@the-env E4b06@env) E4b06@env)))))))) (set! E4c02@E31af@interaction-environment E31af@interaction-environment) (set! E31b1@top-level-context (E2a0a@E28e8@make-parameter '#f)) (set! E4c03@E31b1@top-level-context E31b1@top-level-context) (E2ccc@E2b10@current-library-expander E3183@library-expander))
(begin (begin (E2a5d@E2a12@current-primitive-locations (lambda (E5157@x) (let ((E5159@t (assq E5157@x '((syntax-error . E4bf9@E319d@syntax-error) (syntax-dispatch . E4b97@E30c1@syntax-dispatch) (load . E4d83@E4c2a@load) (interaction-environment . E4c02@E31af@interaction-environment) (library-path . E2cc4@E2b00@library-path) (mosh-cache-dir . E2a0b@E28ea@mosh-cache-dir) (make-parameter . E2a0a@E28e8@make-parameter) (make-variable-transformer . E4b54@E2eec@make-variable-transformer) (identifier? . E4bfc@E31a3@identifier?) (generate-temporaries . E4bf2@E318f@generate-temporaries) (free-identifier=? . E4bf3@E3191@free-identifier=?) (syntax->datum . E4bfe@E31a7@syntax->datum) (datum->syntax . E4bfd@E31a5@datum->syntax) (bound-identifier=? . E4bf4@E3193@bound-identifier=?) (scheme-report-environment . E4be9@E317d@scheme-report-environment) (null-environment . E4be8@E317b@null-environment) (command-line . E4d80@E4c24@command-line) (eval . E4beb@E3181@eval) (environment . E4be7@E3179@environment) (syntax-violation . E4bfb@E31a1@syntax-violation) (assertion-error . E4bf8@E319b@assertion-error))))) (if E5159@t (cdr E5159@t) '#f)))) (E2cd4@E2b20@install-library 'E5134 '(mosh interaction) '() '() '() '() '((regexp? . E50f4) (alist->eq-hash-table . E50f0) (format . E50ed) (string-split . E50dd) (call-process . E50d7) (set-current-directory! . E50d3) (expand-path . E50d2) (current-directory . E50d1) (%spawn . E50d0) (%waitpid . E50cf) (simple-struct-name . E50ce) (simple-struct-set! . E50cd) (simple-struct-ref . E50cc) (make-simple-struct . E50cb) (simple-struct? . E50ca) (pointer-ref-c-int64 . E50c9) (pointer-ref-c-int32 . E50c8) (pointer-ref-c-int16 . E50c7) (pointer-ref-c-int8 . E50c6) (pointer-ref-c-uint64 . E50c5) (pointer-ref-c-uint32 . E50c4) (pointer-ref-c-uint16 . E50c3) (pointer-ref-c-uint8 . E50c2) (pointer-set-c-uint64! . E50c1) (pointer-set-c-uint32! . E50c0) (pointer-set-c-uint16! . E50bf) (pointer-set-c-uint8! . E50be) (pointer-set-c-int64! . E50bd) (pointer-set-c-int32! . E50bc) (pointer-set-c-int16! . E50bb) (pointer-set-c-int8! . E50ba) (pointer-set-c-pointer! . E50b9) (pointer-set-c-double! . E50b8) (pointer-set-c-float! . E50b7) (pointer-set-c-long-long! . E50b6) (pointer-set-c-long! . E50b5) (pointer-set-c-int! . E50b4) (pointer-set-c-short! . E50b3) (pointer-set-c-char! . E50b2) (pointer-ref-c-pointer . E50b1) (pointer-ref-c-double . E50b0) (pointer-ref-c-float . E50af) (pointer-ref-c-unsigned-long-long . E50ae) (pointer-ref-c-signed-long-long . E50ad) (pointer-ref-c-unsigned-long . E50ac) (pointer-ref-c-signed-long . E50ab) (pointer-ref-c-unsigned-int . E50aa) (pointer-ref-c-signed-int . E50a9) (pointer-ref-c-unsigned-short . E50a8) (pointer-ref-c-signed-short . E50a7) (pointer-ref-c-unsigned-char . E50a6) (pointer-ref-c-signed-char . E50a5) (pointer->integer . E50a4) (integer->pointer . E50a3) (pointer? . E50a2) (shared-errno . E50a1) (%ffi-supported? . E509c) (%ffi-pointer->string . E509b) (%ffi-call . E509a) (%ffi-lookup . E5099) (%ffi-open . E5098) (null-terminated-utf8->string . E5097) (null-terminated-bytevector->string . E5096) (%exec . E5095) (%fork . E5094) (%pipe . E5093) (p . E5092) (whereis . E5076) (register . E5075) (vm-join! . E5074) (vm-set-value! . E5073) (vm? . E5072) (main-vm? . E5071) (vm-eval . E5070) (vm-self . E506f) (vm-start! . E506e) (make-vm . E506d) (mutex-try-lock! . E506c) (mutex-unlock! . E506b) (mutex-lock! . E506a) (mutex? . E5069) (make-mutex . E5068) (condition-variable-notify-all! . E5067) (condition-variable-notify! . E5066) (condition-variable-wait! . E5065) (make-condition-variable . E5064) (write/ss . E5063) (string-upcase . E504b) (string-titlecase . E504a) (string-normalize-nfkd . E5049) (string-normalize-nfkc . E5048) (string-normalize-nfd . E5047) (string-normalize-nfc . E5046) (string-foldcase . E5045) (string-downcase . E5044) (string-ci>? . E5043) (string-ci>=? . E5042) (string-ci=? . E5041) (string-ci<? . E5040) (string-ci<=? . E503f) (char-whitespace? . E503e) (char-upper-case? . E503d) (char-title-case? . E503c) (char-numeric? . E503b) (char-lower-case? . E503a) (char-general-category . E5039) (char-upcase . E5038) (char-titlecase . E5037) (char-foldcase . E5036) (char-downcase . E5035) (char-ci>? . E5034) (char-ci>=? . E5033) (char-ci=? . E5032) (char-ci<? . E5031) (char-ci<=? . E5030) (char-alphabetic? . E502f) (make-variable-transformer . E2eeb) (identifier? . E31a2) (generate-temporaries . E318e) (free-identifier=? . E3190) (syntax->datum . E31a6) (datum->syntax . E31a4) (bound-identifier=? . E3192) (record-type-descriptor? . E502e) (record-predicate . E502d) (record-mutator . E502c) (record-constructor . E502b) (record-accessor . E502a) (make-record-type-descriptor . E5029) (make-record-constructor-descriptor . E5028) (record? . E5027) (record-type-uid . E5026) (record-type-sealed? . E5025) (record-type-parent . E5024) (record-type-opaque? . E5023) (record-type-name . E5022) (record-type-generative? . E5021) (record-type-field-names . E5020) (record-rtd . E501f) (record-field-mutable? . E501e) (delete-file . E501d) (file-exists? . E501c) (vector-sort! . E501b) (vector-sort . E501a) (list-sort . E5019) (symbol-hash . E5018) (string-ci-hash . E5017) (string-hash . E5016) (equal-hash . E5015) (hashtable-equivalence-function . E5014) (make-hashtable . E5013) (hashtable-hash-function . E5012) (make-eqv-hashtable . E5011) (make-eq-hashtable . E5010) (hashtable? . E500f) (hashtable-update! . E500e) (hashtable-size . E500d) (hashtable-set! . E500c) (hashtable-ref . E500b) (hashtable-mutable? . E500a) (hashtable-keys . E5009) (hashtable-entries . E5008) (hashtable-delete! . E5007) (hashtable-copy . E5006) (hashtable-contains? . E5005) (hashtable-clear! . E5004) (call-with-output-file . E5003) (call-with-input-file . E5002) (write-char . E5001) (write . E5000) (with-output-to-file . E4fff) (with-input-from-file . E4ffe) (read-char . E4ffd) (read . E4ffc) (peek-char . E4ffb) (open-output-file . E4ffa) (open-input-file . E4ff9) (newline . E4ff8) (display . E4ff7) (close-output-port . E4ff6) (close-input-port . E4ff5) (eof-object? . E4ff4) (eof-object . E4ff3) (current-error-port . E4ff2) (current-output-port . E4ff1) (current-input-port . E4ff0) (output-port? . E4fef) (input-port? . E4fee) (utf-8-codec . E4fed) (utf-16-codec . E4fec) (transcoder-error-handling-mode . E4feb) (transcoder-eol-style . E4fea) (transcoder-codec . E4fe9) (transcoded-port . E4fe8) (textual-port? . E4fe7) (string->bytevector . E4fe6) (standard-output-port . E4fe5) (standard-input-port . E4fe4) (standard-error-port . E4fe3) (set-port-position! . E4fe2) (put-u8 . E4fe1) (put-string . E4fe0) (put-datum . E4fdf) (put-char . E4fde) (put-bytevector . E4fdd) (port? . E4fdc) (port-transcoder . E4fdb) (port-position . E4fda) (port-has-set-port-position!? . E4fd9) (port-has-port-position? . E4fd8) (port-eof? . E4fd7) (output-port-buffer-mode . E4fd6) (open-string-output-port . E4fd5) (open-string-input-port . E4fd4) (open-file-output-port . E4fd3) (open-file-input/output-port . E4fd2) (open-file-input-port . E4fd1) (open-bytevector-output-port . E4fd0) (open-bytevector-input-port . E4fcf) (native-transcoder . E4fce) (native-eol-style . E4fcd) (make-transcoder . E4fcc) (latin-1-codec . E4fcb) (make-i/o-write-error . E4fca) (make-i/o-read-error . E4fc9) (make-i/o-port-error . E4fc8) (make-i/o-invalid-position-error . E4fc7) (make-i/o-filename-error . E4fc6) (make-i/o-file-protection-error . E4fc5) (make-i/o-file-is-read-only-error . E4fc4) (make-i/o-file-does-not-exist-error . E4fc3) (make-i/o-file-already-exists-error . E4fc2) (make-i/o-error . E4fc1) (make-i/o-encoding-error . E4fc0) (make-i/o-decoding-error . E4fbf) (make-custom-textual-output-port . E4fbe) (make-custom-textual-input/output-port . E4fbd) (make-custom-textual-input-port . E4fbc) (make-custom-binary-output-port . E4fbb) (make-custom-binary-input/output-port . E4fba) (make-custom-binary-input-port . E4fb9) (make-bytevector . E4fb8) (lookahead-u8 . E4fb7) (lookahead-char . E4fb6) (i/o-write-error? . E4fb5) (i/o-read-error? . E4fb4) (i/o-port-error? . E4fb3) (i/o-invalid-position-error? . E4fb2) (i/o-filename-error? . E4fb1) (i/o-file-protection-error? . E4fb0) (i/o-file-is-read-only-error? . E4faf) (i/o-file-does-not-exist-error? . E4fae) (i/o-file-already-exists-error? . E4fad) (i/o-error? . E4fac) (i/o-error-position . E4fab) (i/o-error-port . E4faa) (i/o-error-filename . E4fa9) (i/o-encoding-error? . E4fa8) (i/o-encoding-error-char . E4fa7) (i/o-decoding-error? . E4fa6) (get-u8 . E4fa5) (get-string-n! . E4fa4) (get-string-n . E4fa3) (get-string-all . E4fa2) (get-line . E4fa1) (get-datum . E4fa0) (get-char . E4f9f) (get-bytevector-some . E4f9e) (get-bytevector-n! . E4f9d) (get-bytevector-n . E4f9c) (get-bytevector-all . E4f9b) (flush-output-port . E4f9a) (close-port . E4f99) (exit . E4f91) (command-line . E4c23) (string-fill! . E4f90) (string-set! . E4f8f) (set-cdr! . E4f8e) (set-car! . E4f8d) (remove . E4f8c) (remv . E4f8b) (remp . E4f8a) (remq . E4f89) (partition . E4f88) (memv . E4f87) (memq . E4f86) (memp . E4f85) (member . E4f84) (exists . E4f83) (for-all . E4f82) (fold-right . E4f81) (fold-left . E4f80) (find . E4f7f) (filter . E4f7e) (cons* . E4f7d) (assv . E4f7c) (assq . E4f7b) (assp . E4f7a) (assoc . E4f79) (call-with-string-output-port . E4f78) (call-with-port . E4f77) (call-with-bytevector-output-port . E4f76) (bytevector->string . E4f75) (buffer-mode? . E4f74) (binary-port? . E4f73) (with-exception-handler . E4f72) (raise-continuable . E4f71) (raise . E4f70) (eval . E3180) (environment . E3178) (make-enumeration . E4f6f) (enum-set=? . E4f6e) (enum-set-universe . E4f6d) (enum-set-union . E4f6c) (enum-set-subset? . E4f6b) (enum-set-projection . E4f6a) (enum-set-member? . E4f69) (enum-set-intersection . E4f68) (enum-set-indexer . E4f67) (enum-set-difference . E4f66) (enum-set-constructor . E4f65) (enum-set-complement . E4f64) (enum-set->list . E4f63) (who-condition? . E4f62) (warning? . E4f61) (violation? . E4f60) (undefined-violation? . E4f5f) (syntax-violation? . E4f5e) (syntax-violation-subform . E4f5d) (syntax-violation-form . E4f5c) (syntax-violation . E31a0) (simple-conditions . E4f5b) (serious-condition? . E4f5a) (non-continuable-violation? . E4f59) (message-condition? . E4f58) (make-who-condition . E4f57) (make-warning . E4f56) (make-violation . E4f55) (make-undefined-violation . E4f54) (make-syntax-violation . E4f53) (make-serious-condition . E4f52) (make-non-continuable-violation . E4f51) (make-message-condition . E4f50) (make-lexical-violation . E4f4f) (make-irritants-condition . E4f4e) (make-implementation-restriction-violation . E4f4d) (make-error . E4f4c) (make-assertion-violation . E4f4b) (lexical-violation? . E4f4a) (irritants-condition? . E4f49) (implementation-restriction-violation? . E4f48) (error? . E4f47) (condition-who . E4f46) (condition-predicate . E4f45) (condition-message . E4f44) (condition-irritants . E4f43) (condition-accessor . E4f42) (condition . E4f41) (assertion-violation? . E4f40) (condition? . E4f3f) (utf32->string . E4f3e) (utf16->string . E4f3d) (utf8->string . E4f3c) (uint-list->bytevector . E4f3b) (u8-list->bytevector . E4f3a) (string->utf8 . E4f39) (string->utf32 . E4f38) (string->utf16 . E4f37) (sint-list->bytevector . E4f36) (native-endianness . E4f35) (bytevector? . E4f34) (bytevector=? . E4f33) (bytevector-uint-set! . E4f32) (bytevector-uint-ref . E4f31) (bytevector-u8-set! . E4f30) (bytevector-u8-ref . E4f2f) (bytevector-u64-set! . E4f2e) (bytevector-u64-ref . E4f2d) (bytevector-u64-native-set! . E4f2c) (bytevector-u64-native-ref . E4f2b) (bytevector-u32-set! . E4f2a) (bytevector-u32-ref . E4f29) (bytevector-u32-native-set! . E4f28) (bytevector-u32-native-ref . E4f27) (bytevector-u16-set! . E4f26) (bytevector-u16-ref . E4f25) (bytevector-u16-native-set! . E4f24) (bytevector-u16-native-ref . E4f23) (bytevector-sint-set! . E4f22) (bytevector-sint-ref . E4f21) (bytevector-s8-set! . E4f20) (bytevector-s8-ref . E4f1f) (bytevector-s64-set! . E4f1e) (bytevector-s64-ref . E4f1d) (bytevector-s64-native-set! . E4f1c) (bytevector-s64-native-ref . E4f1b) (bytevector-s32-set! . E4f1a) (bytevector-s32-ref . E4f19) (bytevector-s32-native-set! . E4f18) (bytevector-s32-native-ref . E4f17) (bytevector-s16-set! . E4f16) (bytevector-s16-ref . E4f15) (bytevector-s16-native-set! . E4f14) (bytevector-s16-native-ref . E4f13) (bytevector-length . E4f12) (bytevector-ieee-single-ref . E4f11) (bytevector-ieee-single-set! . E4f10) (bytevector-ieee-single-native-set! . E4f0f) (bytevector-ieee-single-native-ref . E4f0e) (bytevector-ieee-double-set! . E4f0d) (bytevector-ieee-double-ref . E4f0c) (bytevector-ieee-double-native-set! . E4f0b) (bytevector-ieee-double-native-ref . E4f0a) (bytevector-fill! . E4f09) (bytevector-copy! . E4f08) (bytevector-copy . E4f07) (bytevector->uint-list . E4f06) (bytevector->u8-list . E4f05) (bytevector->sint-list . E4f04) (no-nans-violation? . E4f03) (no-infinities-violation? . E4f02) (make-no-nans-violation . E4f01) (make-no-infinities-violation . E4f00) (real->flonum . E4eff) (flzero? . E4efe) (fltruncate . E4efd) (fltan . E4efc) (flsqrt . E4efb) (flsin . E4efa) (flround . E4ef9) (flpositive? . E4ef8) (flonum? . E4ef7) (flodd? . E4ef6) (flnumerator . E4ef5) (flnegative? . E4ef4) (flnan? . E4ef3) (flmod0 . E4ef2) (flmod . E4ef1) (flmin . E4ef0) (flmax . E4eef) (fllog . E4eee) (flinteger? . E4eed) (flinfinite? . E4eec) (flfloor . E4eeb) (flfinite? . E4eea) (flexpt . E4ee9) (flexp . E4ee8) (fleven? . E4ee7) (fldiv0-and-mod0 . E4ee6) (fldiv0 . E4ee5) (fldiv-and-mod . E4ee4) (fldiv . E4ee3) (fldenominator . E4ee2) (flcos . E4ee1) (flceiling . E4ee0) (flatan . E4edf) (flasin . E4ede) (flacos . E4edd) (flabs . E4edc) (fl>? . E4edb) (fl>=? . E4eda) (fl=? . E4ed9) (fl<? . E4ed8) (fl<=? . E4ed7) (fl/ . E4ed6) (fl- . E4ed5) (fl+ . E4ed4) (fl* . E4ed3) (fixnum->flonum . E4ed2) (fxzero? . E4ed1) (fxxor . E4ed0) (fxrotate-bit-field . E4ecf) (fxreverse-bit-field . E4ece) (fxpositive? . E4ecd) (fxodd? . E4ecc) (fxnot . E4ecb) (fxnegative? . E4eca) (fxmod0 . E4ec9) (fxmod . E4ec8) (fxmin . E4ec7) (fxmax . E4ec6) (fxlength . E4ec5) (fxior . E4ec4) (fxif . E4ec3) (fxfirst-bit-set . E4ec2) (fxeven? . E4ec1) (fxdiv0-and-mod0 . E4ec0) (fxdiv0 . E4ebf) (fxdiv-and-mod . E4ebe) (fxdiv . E4ebd) (fxcopy-bit-field . E4ebc) (fxcopy-bit . E4ebb) (fxbit-set? . E4eba) (fxbit-field . E4eb9) (fxbit-count . E4eb8) (fxarithmetic-shift-right . E4eb7) (fxarithmetic-shift-left . E4eb6) (fxarithmetic-shift . E4eb5) (fxand . E4eb4) (fx>? . E4eb3) (fx>=? . E4eb2) (fx=? . E4eb1) (fx<? . E4eb0) (fx<=? . E4eaf) (fx-/carry . E4eae) (fx- . E4ead) (fx+/carry . E4eac) (fx+ . E4eab) (fx*/carry . E4eaa) (fx* . E4ea9) (greatest-fixnum . E4ea8) (least-fixnum . E4ea7) (fixnum-width . E4ea6) (fixnum? . E4ea5) (bitwise-rotate-bit-field . E4ea4) (bitwise-reverse-bit-field . E4ea3) (bitwise-length . E4ea2) (bitwise-if . E4ea1) (bitwise-first-bit-set . E4ea0) (bitwise-copy-bit-field . E4e9f) (bitwise-copy-bit . E4e9e) (bitwise-bit-set? . E4e9d) (bitwise-bit-field . E4e9c) (bitwise-bit-count . E4e9b) (bitwise-xor . E4e9a) (bitwise-ior . E4e99) (bitwise-and . E4e98) (bitwise-not . E4e97) (bitwise-arithmetic-shift-right . E4e96) (bitwise-arithmetic-shift-left . E4e95) (bitwise-arithmetic-shift . E4e94) (zero? . E4e93) (vector? . E4e92) (vector-set! . E4e91) (vector-ref . E4e90) (vector-map . E4e8f) (vector-length . E4e8e) (vector-for-each . E4e8d) (vector-fill! . E4e8c) (vector->list . E4e8b) (vector . E4e8a) (values . E4e89) (truncate . E4e88) (tan . E4e87) (symbol? . E4e86) (symbol=? . E4e85) (symbol->string . E4e84) (substring . E4e83) (string? . E4e82) (string>? . E4e81) (string>=? . E4e80) (string=? . E4e7f) (string<? . E4e7e) (string<=? . E4e7d) (string-ref . E4e7c) (string-length . E4e7b) (string-for-each . E4e7a) (string-copy . E4e79) (string-append . E4e78) (string->symbol . E4e77) (string->number . E4e76) (string->list . E4e75) (string . E4e74) (sqrt . E4e73) (sin . E4e72) (round . E4e71) (reverse . E4e70) (real? . E4e6f) (real-valued? . E4e6e) (real-part . E4e6d) (rationalize . E4e6c) (rational? . E4e6b) (rational-valued? . E4e6a) (procedure? . E4e69) (positive? . E4e68) (pair? . E4e67) (odd? . E4e66) (numerator . E4e65) (number? . E4e64) (number->string . E4e63) (null? . E4e62) (not . E4e61) (negative? . E4e60) (nan? . E4e5f) (min . E4e5e) (max . E4e5d) (map . E4e5c) (make-vector . E4e5b) (make-string . E4e5a) (make-rectangular . E4e59) (make-polar . E4e58) (magnitude . E4e57) (log . E4e56) (list? . E4e55) (list-tail . E4e54) (list-ref . E4e53) (list->vector . E4e52) (list->string . E4e51) (list . E4e50) (length . E4e4f) (lcm . E4e4e) (integer? . E4e4d) (integer-valued? . E4e4c) (integer->char . E4e4b) (infinite? . E4e4a) (inexact? . E4e49) (inexact . E4e48) (imag-part . E4e47) (gcd . E4e46) (for-each . E4e45) (floor . E4e44) (finite? . E4e43) (expt . E4e42) (exp . E4e41) (exact? . E4e40) (exact-integer-sqrt . E4e3f) (exact . E4e3e) (even? . E4e3d) (error . E4e3c) (eqv? . E4e3b) (equal? . E4e3a) (eq? . E4e39) (dynamic-wind . E4e38) (div0-and-mod0 . E4e37) (mod0 . E4e36) (div0 . E4e35) (div-and-mod . E4e34) (mod . E4e33) (div . E4e32) (denominator . E4e31) (cos . E4e30) (cons . E4e2f) (complex? . E4e2e) (char? . E4e2d) (char>? . E4e2c) (char>=? . E4e2b) (char=? . E4e2a) (char<? . E4e29) (char<=? . E4e28) (char->integer . E4e27) (ceiling . E4e26) (call-with-values . E4e25) (call/cc . E4e24) (call-with-current-continuation . E4e23) (cddddr . E4e22) (cdddar . E4e21) (cddadr . E4e20) (cddaar . E4e1f) (cdaddr . E4e1e) (cdadar . E4e1d) (cdaadr . E4e1c) (cdaaar . E4e1b) (cadddr . E4e1a) (caddar . E4e19) (cadadr . E4e18) (cadaar . E4e17) (caaddr . E4e16) (caadar . E4e15) (caaadr . E4e14) (caaaar . E4e13) (cdddr . E4e12) (cddar . E4e11) (cdadr . E4e10) (cdaar . E4e0f) (caddr . E4e0e) (cadar . E4e0d) (caadr . E4e0c) (caaar . E4e0b) (cddr . E4e0a) (cdar . E4e09) (cadr . E4e08) (caar . E4e07) (cdr . E4e06) (car . E4e05) (boolean? . E4e04) (boolean=? . E4e03) (atan . E4e02) (assertion-violation . E4e01) (asin . E4e00) (apply . E4dff) (append . E4dfe) (angle . E4dfd) (acos . E4dfc) (abs . E4dfb) (/ . E4dfa) (* . E4df9) (- . E4df8) (+ . E4df7) (>= . E4df6) (> . E4df5) (= . E4df4) (<= . E4df3) (< . E4df2) (library . E4df1) (&no-nans . E4df0) (&no-infinities . E4def) (&i/o-encoding . E4dee) (&i/o-decoding . E4ded) (&i/o-port . E4dec) (&i/o-file-does-not-exist . E4deb) (&i/o-file-already-exists . E4dea) (&i/o-file-is-read-only . E4de9) (&i/o-file-protection . E4de8) (&i/o-filename . E4de7) (&i/o-invalid-position . E4de6) (&i/o-write . E4de5) (&i/o-read . E4de4) (&i/o . E4de3) (&undefined . E4de2) (&syntax . E4de1) (&lexical . E4de0) (&implementation-restriction . E4ddf) (&non-continuable . E4dde) (&who . E4ddd) (&irritants . E4ddc) (&assertion . E4ddb) (&violation . E4dda) (&error . E4dd9) (&serious . E4dd8) (&warning . E4dd7) (&message . E4dd6) (&condition . E4dd5) (define-condition-type . E4dd4) (define-enumeration . E4dd3) (define-record-type . E4dd2) (parent-rtd . E4dd1) (nongenerative . E4dd0) (opaque . E4dcf) (sealed . E4dce) (protocol . E4dcd) (parent . E4dcc) (immutable . E4dcb) (mutable . E4dca) (fields . E4dc9) (error-handling-mode . E4dc8) (file-options . E4dc7) (buffer-mode . E4dc6) (eol-style . E4dc5) (guard . E4dc4) (unsyntax-splicing . E4dc1) (unsyntax . E4dc0) (unquote-splicing . E4dbf) (unquote . E4dbe) (_ . E4dbd) (else . E4dbc) (=> . E4dbb) (... . E4dba) (assert . E4db9) (endianness . E4db8) (time . E4db6) (do . E4db5) (cond . E4db4) (let* . E4db3) (let*-values . E4db2) (let-values . E4db1) (identifier-syntax . E4db0) (with-syntax . E4daf) (quasisyntax . E4dae) (quasiquote . E4dad) (syntax-rules . E4dac) (include . E4dab) (record-constructor-descriptor . E4da9) (record-type-descriptor . E4da8) (case . E4da7) (unless . E4da5) (when . E4da4) (or . E4da3) (and . E4da2) (if . E4da1) (let . E4da0) (letrec* . E4d9f) (letrec . E4d9e) (case-lambda . E4d9c) (lambda . E4d9b) (syntax . E4d9a) (syntax-case . E4d99) (quote . E4d98) (letrec-syntax . E4d96) (let-syntax . E4d95) (set! . E4d94) (import . E4d93) (begin . E4d92) (define-syntax . E4d90) (define . E4d8f)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E5135 '(psyntax null-environment-5) '() '() '() '() '((make-promise . E4f92) (unquote-splicing . E4dbf) (unquote . E4dbe) (_ . E4dbd) (else . E4dbc) (=> . E4dbb) (... . E4dba) (delay . E4db7) (do . E4db5) (cond . E4db4) (let* . E4db3) (quasiquote . E4dad) (syntax-rules . E4dac) (case . E4da7) (or . E4da3) (and . E4da2) (if . E4da1) (let . E4da0) (letrec . E4d9e) (lambda . E4d9b) (quote . E4d98) (letrec-syntax . E4d96) (let-syntax . E4d95) (set! . E4d94) (begin . E4d92) (define-syntax . E4d90) (define . E4d8f)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E5136 '(psyntax scheme-report-environment-5) '() '() '() '() '((string-ci>? . E5043) (string-ci>=? . E5042) (string-ci=? . E5041) (string-ci<? . E5040) (string-ci<=? . E503f) (char-whitespace? . E503e) (char-upper-case? . E503d) (char-numeric? . E503b) (char-lower-case? . E503a) (char-upcase . E5038) (char-downcase . E5035) (char-ci>? . E5034) (char-ci>=? . E5033) (char-ci=? . E5032) (char-ci<? . E5031) (char-ci<=? . E5030) (char-alphabetic? . E502f) (call-with-output-file . E5003) (call-with-input-file . E5002) (write-char . E5001) (write . E5000) (with-output-to-file . E4fff) (with-input-from-file . E4ffe) (read-char . E4ffd) (read . E4ffc) (peek-char . E4ffb) (open-output-file . E4ffa) (open-input-file . E4ff9) (newline . E4ff8) (display . E4ff7) (close-output-port . E4ff6) (close-input-port . E4ff5) (eof-object . E4ff3) (current-output-port . E4ff1) (current-input-port . E4ff0) (output-port? . E4fef) (input-port? . E4fee) (scheme-report-environment . E317c) (quotient . E4f98) (null-environment . E317a) (remainder . E4f97) (modulo . E4f96) (inexact->exact . E4f95) (force . E4f94) (exact->inexact . E4f93) (make-promise . E4f92) (string-fill! . E4f90) (string-set! . E4f8f) (set-cdr! . E4f8e) (set-car! . E4f8d) (memv . E4f87) (memq . E4f86) (member . E4f84) (assv . E4f7c) (assq . E4f7b) (assoc . E4f79) (eval . E3180) (zero? . E4e93) (vector? . E4e92) (vector-set! . E4e91) (vector-ref . E4e90) (vector-length . E4e8e) (vector-fill! . E4e8c) (vector->list . E4e8b) (vector . E4e8a) (values . E4e89) (truncate . E4e88) (tan . E4e87) (symbol? . E4e86) (symbol->string . E4e84) (substring . E4e83) (string? . E4e82) (string>? . E4e81) (string>=? . E4e80) (string=? . E4e7f) (string<? . E4e7e) (string<=? . E4e7d) (string-ref . E4e7c) (string-length . E4e7b) (string-copy . E4e79) (string-append . E4e78) (string->symbol . E4e77) (string->number . E4e76) (string->list . E4e75) (string . E4e74) (sqrt . E4e73) (sin . E4e72) (round . E4e71) (reverse . E4e70) (real? . E4e6f) (real-part . E4e6d) (rationalize . E4e6c) (rational? . E4e6b) (procedure? . E4e69) (positive? . E4e68) (pair? . E4e67) (odd? . E4e66) (numerator . E4e65) (number? . E4e64) (number->string . E4e63) (not . E4e61) (negative? . E4e60) (min . E4e5e) (max . E4e5d) (map . E4e5c) (make-vector . E4e5b) (make-string . E4e5a) (make-rectangular . E4e59) (make-polar . E4e58) (magnitude . E4e57) (log . E4e56) (list? . E4e55) (list-tail . E4e54) (list-ref . E4e53) (list->vector . E4e52) (list->string . E4e51) (list . E4e50) (length . E4e4f) (lcm . E4e4e) (integer? . E4e4d) (integer->char . E4e4b) (inexact? . E4e49) (imag-part . E4e47) (gcd . E4e46) (for-each . E4e45) (floor . E4e44) (expt . E4e42) (exp . E4e41) (exact? . E4e40) (even? . E4e3d) (eqv? . E4e3b) (equal? . E4e3a) (eq? . E4e39) (dynamic-wind . E4e38) (denominator . E4e31) (cos . E4e30) (cons . E4e2f) (complex? . E4e2e) (char? . E4e2d) (char>? . E4e2c) (char>=? . E4e2b) (char=? . E4e2a) (char<? . E4e29) (char<=? . E4e28) (char->integer . E4e27) (ceiling . E4e26) (call-with-values . E4e25) (call-with-current-continuation . E4e23) (cddddr . E4e22) (cdddar . E4e21) (cddadr . E4e20) (cddaar . E4e1f) (cdaddr . E4e1e) (cdadar . E4e1d) (cdaadr . E4e1c) (cdaaar . E4e1b) (cadddr . E4e1a) (caddar . E4e19) (cadadr . E4e18) (cadaar . E4e17) (caaddr . E4e16) (caadar . E4e15) (caaadr . E4e14) (caaaar . E4e13) (cdddr . E4e12) (cddar . E4e11) (cdadr . E4e10) (cdaar . E4e0f) (caddr . E4e0e) (cadar . E4e0d) (caadr . E4e0c) (caaar . E4e0b) (cddr . E4e0a) (cdar . E4e09) (cadr . E4e08) (caar . E4e07) (cdr . E4e06) (car . E4e05) (boolean? . E4e04) (atan . E4e02) (asin . E4e00) (apply . E4dff) (append . E4dfe) (angle . E4dfd) (acos . E4dfc) (abs . E4dfb) (/ . E4dfa) (* . E4df9) (- . E4df8) (+ . E4df7) (>= . E4df6) (> . E4df5) (= . E4df4) (<= . E4df3) (< . E4df2) (unquote-splicing . E4dbf) (unquote . E4dbe) (else . E4dbc) (=> . E4dbb) (... . E4dba) (delay . E4db7) (do . E4db5) (cond . E4db4) (let* . E4db3) (quasiquote . E4dad) (syntax-rules . E4dac) (case . E4da7) (or . E4da3) (and . E4da2) (if . E4da1) (let . E4da0) (letrec . E4d9e) (lambda . E4d9b) (quote . E4d98) (letrec-syntax . E4d96) (let-syntax . E4d95) (set! . E4d94) (begin . E4d92) (define-syntax . E4d90) (define . E4d8f)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E5137 '(psyntax modules) '() '() '() '() '((module . E4d91)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E5138 '(chez parameters) '() '() '() '() '() '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E5139 '(rnrs) '(6) '() '() '() '((regexp? . E50f4) (string-upcase . E504b) (string-titlecase . E504a) (string-normalize-nfkd . E5049) (string-normalize-nfkc . E5048) (string-normalize-nfd . E5047) (string-normalize-nfc . E5046) (string-foldcase . E5045) (string-downcase . E5044) (string-ci>? . E5043) (string-ci>=? . E5042) (string-ci=? . E5041) (string-ci<? . E5040) (string-ci<=? . E503f) (char-whitespace? . E503e) (char-upper-case? . E503d) (char-title-case? . E503c) (char-numeric? . E503b) (char-lower-case? . E503a) (char-general-category . E5039) (char-upcase . E5038) (char-titlecase . E5037) (char-foldcase . E5036) (char-downcase . E5035) (char-ci>? . E5034) (char-ci>=? . E5033) (char-ci=? . E5032) (char-ci<? . E5031) (char-ci<=? . E5030) (char-alphabetic? . E502f) (make-variable-transformer . E2eeb) (identifier? . E31a2) (generate-temporaries . E318e) (free-identifier=? . E3190) (syntax->datum . E31a6) (datum->syntax . E31a4) (bound-identifier=? . E3192) (record-type-descriptor? . E502e) (record-predicate . E502d) (record-mutator . E502c) (record-constructor . E502b) (record-accessor . E502a) (make-record-type-descriptor . E5029) (make-record-constructor-descriptor . E5028) (record? . E5027) (record-type-uid . E5026) (record-type-sealed? . E5025) (record-type-parent . E5024) (record-type-opaque? . E5023) (record-type-name . E5022) (record-type-generative? . E5021) (record-type-field-names . E5020) (record-rtd . E501f) (record-field-mutable? . E501e) (delete-file . E501d) (file-exists? . E501c) (vector-sort! . E501b) (vector-sort . E501a) (list-sort . E5019) (symbol-hash . E5018) (string-ci-hash . E5017) (string-hash . E5016) (equal-hash . E5015) (hashtable-equivalence-function . E5014) (make-hashtable . E5013) (hashtable-hash-function . E5012) (make-eqv-hashtable . E5011) (make-eq-hashtable . E5010) (hashtable? . E500f) (hashtable-update! . E500e) (hashtable-size . E500d) (hashtable-set! . E500c) (hashtable-ref . E500b) (hashtable-mutable? . E500a) (hashtable-keys . E5009) (hashtable-entries . E5008) (hashtable-delete! . E5007) (hashtable-copy . E5006) (hashtable-contains? . E5005) (hashtable-clear! . E5004) (call-with-output-file . E5003) (call-with-input-file . E5002) (write-char . E5001) (write . E5000) (with-output-to-file . E4fff) (with-input-from-file . E4ffe) (read-char . E4ffd) (read . E4ffc) (peek-char . E4ffb) (open-output-file . E4ffa) (open-input-file . E4ff9) (newline . E4ff8) (display . E4ff7) (close-output-port . E4ff6) (close-input-port . E4ff5) (eof-object? . E4ff4) (eof-object . E4ff3) (current-error-port . E4ff2) (current-output-port . E4ff1) (current-input-port . E4ff0) (output-port? . E4fef) (input-port? . E4fee) (utf-8-codec . E4fed) (utf-16-codec . E4fec) (transcoder-error-handling-mode . E4feb) (transcoder-eol-style . E4fea) (transcoder-codec . E4fe9) (transcoded-port . E4fe8) (textual-port? . E4fe7) (string->bytevector . E4fe6) (standard-output-port . E4fe5) (standard-input-port . E4fe4) (standard-error-port . E4fe3) (set-port-position! . E4fe2) (put-u8 . E4fe1) (put-string . E4fe0) (put-datum . E4fdf) (put-char . E4fde) (put-bytevector . E4fdd) (port? . E4fdc) (port-transcoder . E4fdb) (port-position . E4fda) (port-has-set-port-position!? . E4fd9) (port-has-port-position? . E4fd8) (port-eof? . E4fd7) (output-port-buffer-mode . E4fd6) (open-string-output-port . E4fd5) (open-string-input-port . E4fd4) (open-file-output-port . E4fd3) (open-file-input/output-port . E4fd2) (open-file-input-port . E4fd1) (open-bytevector-output-port . E4fd0) (open-bytevector-input-port . E4fcf) (native-transcoder . E4fce) (native-eol-style . E4fcd) (make-transcoder . E4fcc) (latin-1-codec . E4fcb) (make-i/o-write-error . E4fca) (make-i/o-read-error . E4fc9) (make-i/o-port-error . E4fc8) (make-i/o-invalid-position-error . E4fc7) (make-i/o-filename-error . E4fc6) (make-i/o-file-protection-error . E4fc5) (make-i/o-file-is-read-only-error . E4fc4) (make-i/o-file-does-not-exist-error . E4fc3) (make-i/o-file-already-exists-error . E4fc2) (make-i/o-error . E4fc1) (make-i/o-encoding-error . E4fc0) (make-i/o-decoding-error . E4fbf) (make-custom-textual-output-port . E4fbe) (make-custom-textual-input/output-port . E4fbd) (make-custom-textual-input-port . E4fbc) (make-custom-binary-output-port . E4fbb) (make-custom-binary-input/output-port . E4fba) (make-custom-binary-input-port . E4fb9) (make-bytevector . E4fb8) (lookahead-u8 . E4fb7) (lookahead-char . E4fb6) (i/o-write-error? . E4fb5) (i/o-read-error? . E4fb4) (i/o-port-error? . E4fb3) (i/o-invalid-position-error? . E4fb2) (i/o-filename-error? . E4fb1) (i/o-file-protection-error? . E4fb0) (i/o-file-is-read-only-error? . E4faf) (i/o-file-does-not-exist-error? . E4fae) (i/o-file-already-exists-error? . E4fad) (i/o-error? . E4fac) (i/o-error-position . E4fab) (i/o-error-port . E4faa) (i/o-error-filename . E4fa9) (i/o-encoding-error? . E4fa8) (i/o-encoding-error-char . E4fa7) (i/o-decoding-error? . E4fa6) (get-u8 . E4fa5) (get-string-n! . E4fa4) (get-string-n . E4fa3) (get-string-all . E4fa2) (get-line . E4fa1) (get-datum . E4fa0) (get-char . E4f9f) (get-bytevector-some . E4f9e) (get-bytevector-n! . E4f9d) (get-bytevector-n . E4f9c) (get-bytevector-all . E4f9b) (flush-output-port . E4f9a) (close-port . E4f99) (exit . E4f91) (command-line . E4c23) (remove . E4f8c) (remv . E4f8b) (remp . E4f8a) (remq . E4f89) (partition . E4f88) (memv . E4f87) (memq . E4f86) (memp . E4f85) (member . E4f84) (exists . E4f83) (for-all . E4f82) (fold-right . E4f81) (fold-left . E4f80) (find . E4f7f) (filter . E4f7e) (cons* . E4f7d) (assv . E4f7c) (assq . E4f7b) (assp . E4f7a) (assoc . E4f79) (call-with-string-output-port . E4f78) (call-with-port . E4f77) (call-with-bytevector-output-port . E4f76) (bytevector->string . E4f75) (buffer-mode? . E4f74) (binary-port? . E4f73) (with-exception-handler . E4f72) (raise-continuable . E4f71) (raise . E4f70) (make-enumeration . E4f6f) (enum-set=? . E4f6e) (enum-set-universe . E4f6d) (enum-set-union . E4f6c) (enum-set-subset? . E4f6b) (enum-set-projection . E4f6a) (enum-set-member? . E4f69) (enum-set-intersection . E4f68) (enum-set-indexer . E4f67) (enum-set-difference . E4f66) (enum-set-constructor . E4f65) (enum-set-complement . E4f64) (enum-set->list . E4f63) (who-condition? . E4f62) (warning? . E4f61) (violation? . E4f60) (undefined-violation? . E4f5f) (syntax-violation? . E4f5e) (syntax-violation-subform . E4f5d) (syntax-violation-form . E4f5c) (syntax-violation . E31a0) (simple-conditions . E4f5b) (serious-condition? . E4f5a) (non-continuable-violation? . E4f59) (message-condition? . E4f58) (make-who-condition . E4f57) (make-warning . E4f56) (make-violation . E4f55) (make-undefined-violation . E4f54) (make-syntax-violation . E4f53) (make-serious-condition . E4f52) (make-non-continuable-violation . E4f51) (make-message-condition . E4f50) (make-lexical-violation . E4f4f) (make-irritants-condition . E4f4e) (make-implementation-restriction-violation . E4f4d) (make-error . E4f4c) (make-assertion-violation . E4f4b) (lexical-violation? . E4f4a) (irritants-condition? . E4f49) (implementation-restriction-violation? . E4f48) (error? . E4f47) (condition-who . E4f46) (condition-predicate . E4f45) (condition-message . E4f44) (condition-irritants . E4f43) (condition-accessor . E4f42) (condition . E4f41) (assertion-violation? . E4f40) (condition? . E4f3f) (utf32->string . E4f3e) (utf16->string . E4f3d) (utf8->string . E4f3c) (uint-list->bytevector . E4f3b) (u8-list->bytevector . E4f3a) (string->utf8 . E4f39) (string->utf32 . E4f38) (string->utf16 . E4f37) (sint-list->bytevector . E4f36) (native-endianness . E4f35) (bytevector? . E4f34) (bytevector=? . E4f33) (bytevector-uint-set! . E4f32) (bytevector-uint-ref . E4f31) (bytevector-u8-set! . E4f30) (bytevector-u8-ref . E4f2f) (bytevector-u64-set! . E4f2e) (bytevector-u64-ref . E4f2d) (bytevector-u64-native-set! . E4f2c) (bytevector-u64-native-ref . E4f2b) (bytevector-u32-set! . E4f2a) (bytevector-u32-ref . E4f29) (bytevector-u32-native-set! . E4f28) (bytevector-u32-native-ref . E4f27) (bytevector-u16-set! . E4f26) (bytevector-u16-ref . E4f25) (bytevector-u16-native-set! . E4f24) (bytevector-u16-native-ref . E4f23) (bytevector-sint-set! . E4f22) (bytevector-sint-ref . E4f21) (bytevector-s8-set! . E4f20) (bytevector-s8-ref . E4f1f) (bytevector-s64-set! . E4f1e) (bytevector-s64-ref . E4f1d) (bytevector-s64-native-set! . E4f1c) (bytevector-s64-native-ref . E4f1b) (bytevector-s32-set! . E4f1a) (bytevector-s32-ref . E4f19) (bytevector-s32-native-set! . E4f18) (bytevector-s32-native-ref . E4f17) (bytevector-s16-set! . E4f16) (bytevector-s16-ref . E4f15) (bytevector-s16-native-set! . E4f14) (bytevector-s16-native-ref . E4f13) (bytevector-length . E4f12) (bytevector-ieee-single-ref . E4f11) (bytevector-ieee-single-set! . E4f10) (bytevector-ieee-single-native-set! . E4f0f) (bytevector-ieee-single-native-ref . E4f0e) (bytevector-ieee-double-set! . E4f0d) (bytevector-ieee-double-ref . E4f0c) (bytevector-ieee-double-native-set! . E4f0b) (bytevector-ieee-double-native-ref . E4f0a) (bytevector-fill! . E4f09) (bytevector-copy! . E4f08) (bytevector-copy . E4f07) (bytevector->uint-list . E4f06) (bytevector->u8-list . E4f05) (bytevector->sint-list . E4f04) (no-nans-violation? . E4f03) (no-infinities-violation? . E4f02) (make-no-nans-violation . E4f01) (make-no-infinities-violation . E4f00) (real->flonum . E4eff) (flzero? . E4efe) (fltruncate . E4efd) (fltan . E4efc) (flsqrt . E4efb) (flsin . E4efa) (flround . E4ef9) (flpositive? . E4ef8) (flonum? . E4ef7) (flodd? . E4ef6) (flnumerator . E4ef5) (flnegative? . E4ef4) (flnan? . E4ef3) (flmod0 . E4ef2) (flmod . E4ef1) (flmin . E4ef0) (flmax . E4eef) (fllog . E4eee) (flinteger? . E4eed) (flinfinite? . E4eec) (flfloor . E4eeb) (flfinite? . E4eea) (flexpt . E4ee9) (flexp . E4ee8) (fleven? . E4ee7) (fldiv0-and-mod0 . E4ee6) (fldiv0 . E4ee5) (fldiv-and-mod . E4ee4) (fldiv . E4ee3) (fldenominator . E4ee2) (flcos . E4ee1) (flceiling . E4ee0) (flatan . E4edf) (flasin . E4ede) (flacos . E4edd) (flabs . E4edc) (fl>? . E4edb) (fl>=? . E4eda) (fl=? . E4ed9) (fl<? . E4ed8) (fl<=? . E4ed7) (fl/ . E4ed6) (fl- . E4ed5) (fl+ . E4ed4) (fl* . E4ed3) (fixnum->flonum . E4ed2) (fxzero? . E4ed1) (fxxor . E4ed0) (fxrotate-bit-field . E4ecf) (fxreverse-bit-field . E4ece) (fxpositive? . E4ecd) (fxodd? . E4ecc) (fxnot . E4ecb) (fxnegative? . E4eca) (fxmod0 . E4ec9) (fxmod . E4ec8) (fxmin . E4ec7) (fxmax . E4ec6) (fxlength . E4ec5) (fxior . E4ec4) (fxif . E4ec3) (fxfirst-bit-set . E4ec2) (fxeven? . E4ec1) (fxdiv0-and-mod0 . E4ec0) (fxdiv0 . E4ebf) (fxdiv-and-mod . E4ebe) (fxdiv . E4ebd) (fxcopy-bit-field . E4ebc) (fxcopy-bit . E4ebb) (fxbit-set? . E4eba) (fxbit-field . E4eb9) (fxbit-count . E4eb8) (fxarithmetic-shift-right . E4eb7) (fxarithmetic-shift-left . E4eb6) (fxarithmetic-shift . E4eb5) (fxand . E4eb4) (fx>? . E4eb3) (fx>=? . E4eb2) (fx=? . E4eb1) (fx<? . E4eb0) (fx<=? . E4eaf) (fx-/carry . E4eae) (fx- . E4ead) (fx+/carry . E4eac) (fx+ . E4eab) (fx*/carry . E4eaa) (fx* . E4ea9) (greatest-fixnum . E4ea8) (least-fixnum . E4ea7) (fixnum-width . E4ea6) (fixnum? . E4ea5) (bitwise-rotate-bit-field . E4ea4) (bitwise-reverse-bit-field . E4ea3) (bitwise-length . E4ea2) (bitwise-if . E4ea1) (bitwise-first-bit-set . E4ea0) (bitwise-copy-bit-field . E4e9f) (bitwise-copy-bit . E4e9e) (bitwise-bit-set? . E4e9d) (bitwise-bit-field . E4e9c) (bitwise-bit-count . E4e9b) (bitwise-xor . E4e9a) (bitwise-ior . E4e99) (bitwise-and . E4e98) (bitwise-not . E4e97) (bitwise-arithmetic-shift-right . E4e96) (bitwise-arithmetic-shift-left . E4e95) (bitwise-arithmetic-shift . E4e94) (zero? . E4e93) (vector? . E4e92) (vector-set! . E4e91) (vector-ref . E4e90) (vector-map . E4e8f) (vector-length . E4e8e) (vector-for-each . E4e8d) (vector-fill! . E4e8c) (vector->list . E4e8b) (vector . E4e8a) (values . E4e89) (truncate . E4e88) (tan . E4e87) (symbol? . E4e86) (symbol=? . E4e85) (symbol->string . E4e84) (substring . E4e83) (string? . E4e82) (string>? . E4e81) (string>=? . E4e80) (string=? . E4e7f) (string<? . E4e7e) (string<=? . E4e7d) (string-ref . E4e7c) (string-length . E4e7b) (string-for-each . E4e7a) (string-copy . E4e79) (string-append . E4e78) (string->symbol . E4e77) (string->number . E4e76) (string->list . E4e75) (string . E4e74) (sqrt . E4e73) (sin . E4e72) (round . E4e71) (reverse . E4e70) (real? . E4e6f) (real-valued? . E4e6e) (real-part . E4e6d) (rationalize . E4e6c) (rational? . E4e6b) (rational-valued? . E4e6a) (procedure? . E4e69) (positive? . E4e68) (pair? . E4e67) (odd? . E4e66) (numerator . E4e65) (number? . E4e64) (number->string . E4e63) (null? . E4e62) (not . E4e61) (negative? . E4e60) (nan? . E4e5f) (min . E4e5e) (max . E4e5d) (map . E4e5c) (make-vector . E4e5b) (make-string . E4e5a) (make-rectangular . E4e59) (make-polar . E4e58) (magnitude . E4e57) (log . E4e56) (list? . E4e55) (list-tail . E4e54) (list-ref . E4e53) (list->vector . E4e52) (list->string . E4e51) (list . E4e50) (length . E4e4f) (lcm . E4e4e) (integer? . E4e4d) (integer-valued? . E4e4c) (integer->char . E4e4b) (infinite? . E4e4a) (inexact? . E4e49) (inexact . E4e48) (imag-part . E4e47) (gcd . E4e46) (for-each . E4e45) (floor . E4e44) (finite? . E4e43) (expt . E4e42) (exp . E4e41) (exact? . E4e40) (exact-integer-sqrt . E4e3f) (exact . E4e3e) (even? . E4e3d) (error . E4e3c) (eqv? . E4e3b) (equal? . E4e3a) (eq? . E4e39) (dynamic-wind . E4e38) (div0-and-mod0 . E4e37) (mod0 . E4e36) (div0 . E4e35) (div-and-mod . E4e34) (mod . E4e33) (div . E4e32) (denominator . E4e31) (cos . E4e30) (cons . E4e2f) (complex? . E4e2e) (char? . E4e2d) (char>? . E4e2c) (char>=? . E4e2b) (char=? . E4e2a) (char<? . E4e29) (char<=? . E4e28) (char->integer . E4e27) (ceiling . E4e26) (call-with-values . E4e25) (call/cc . E4e24) (call-with-current-continuation . E4e23) (cddddr . E4e22) (cdddar . E4e21) (cddadr . E4e20) (cddaar . E4e1f) (cdaddr . E4e1e) (cdadar . E4e1d) (cdaadr . E4e1c) (cdaaar . E4e1b) (cadddr . E4e1a) (caddar . E4e19) (cadadr . E4e18) (cadaar . E4e17) (caaddr . E4e16) (caadar . E4e15) (caaadr . E4e14) (caaaar . E4e13) (cdddr . E4e12) (cddar . E4e11) (cdadr . E4e10) (cdaar . E4e0f) (caddr . E4e0e) (cadar . E4e0d) (caadr . E4e0c) (caaar . E4e0b) (cddr . E4e0a) (cdar . E4e09) (cadr . E4e08) (caar . E4e07) (cdr . E4e06) (car . E4e05) (boolean? . E4e04) (boolean=? . E4e03) (atan . E4e02) (assertion-violation . E4e01) (asin . E4e00) (apply . E4dff) (append . E4dfe) (angle . E4dfd) (acos . E4dfc) (abs . E4dfb) (/ . E4dfa) (* . E4df9) (- . E4df8) (+ . E4df7) (>= . E4df6) (> . E4df5) (= . E4df4) (<= . E4df3) (< . E4df2) (&no-nans . E4df0) (&no-infinities . E4def) (&i/o-encoding . E4dee) (&i/o-decoding . E4ded) (&i/o-port . E4dec) (&i/o-file-does-not-exist . E4deb) (&i/o-file-already-exists . E4dea) (&i/o-file-is-read-only . E4de9) (&i/o-file-protection . E4de8) (&i/o-filename . E4de7) (&i/o-invalid-position . E4de6) (&i/o-write . E4de5) (&i/o-read . E4de4) (&i/o . E4de3) (&undefined . E4de2) (&syntax . E4de1) (&lexical . E4de0) (&implementation-restriction . E4ddf) (&non-continuable . E4dde) (&who . E4ddd) (&irritants . E4ddc) (&assertion . E4ddb) (&violation . E4dda) (&error . E4dd9) (&serious . E4dd8) (&warning . E4dd7) (&message . E4dd6) (&condition . E4dd5) (define-condition-type . E4dd4) (define-enumeration . E4dd3) (define-record-type . E4dd2) (parent-rtd . E4dd1) (nongenerative . E4dd0) (opaque . E4dcf) (sealed . E4dce) (protocol . E4dcd) (parent . E4dcc) (immutable . E4dcb) (mutable . E4dca) (fields . E4dc9) (error-handling-mode . E4dc8) (file-options . E4dc7) (buffer-mode . E4dc6) (eol-style . E4dc5) (guard . E4dc4) (unsyntax-splicing . E4dc1) (unsyntax . E4dc0) (unquote-splicing . E4dbf) (unquote . E4dbe) (_ . E4dbd) (else . E4dbc) (=> . E4dbb) (... . E4dba) (assert . E4db9) (endianness . E4db8) (do . E4db5) (cond . E4db4) (let* . E4db3) (let*-values . E4db2) (let-values . E4db1) (identifier-syntax . E4db0) (with-syntax . E4daf) (quasisyntax . E4dae) (quasiquote . E4dad) (syntax-rules . E4dac) (record-constructor-descriptor . E4da9) (record-type-descriptor . E4da8) (case . E4da7) (unless . E4da5) (when . E4da4) (or . E4da3) (and . E4da2) (if . E4da1) (let . E4da0) (letrec* . E4d9f) (letrec . E4d9e) (case-lambda . E4d9c) (lambda . E4d9b) (syntax . E4d9a) (syntax-case . E4d99) (quote . E4d98) (letrec-syntax . E4d96) (let-syntax . E4d95) (set! . E4d94) (begin . E4d92) (define-syntax . E4d90) (define . E4d8f)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E513a '(rnrs r5rs) '(6) '() '() '() '((scheme-report-environment . E317c) (quotient . E4f98) (null-environment . E317a) (remainder . E4f97) (modulo . E4f96) (inexact->exact . E4f95) (force . E4f94) (exact->inexact . E4f93) (make-promise . E4f92) (delay . E4db7)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E513b '(rnrs control) '(6) '() '() '() '((do . E4db5) (unless . E4da5) (when . E4da4) (case-lambda . E4d9c)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E513c '(rnrs eval) '(6) '() '() '() '((eval . E3180) (environment . E3178)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E513d '(rnrs mutable-pairs) '(6) '() '() '() '((set-cdr! . E4f8e) (set-car! . E4f8d)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E513e '(rnrs mutable-strings) '(6) '() '() '() '((string-fill! . E4f90) (string-set! . E4f8f)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E513f '(rnrs programs) '(6) '() '() '() '((exit . E4f91) (command-line . E4c23)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E5140 '(rnrs syntax-case) '(6) '() '() '() '((make-variable-transformer . E2eeb) (identifier? . E31a2) (generate-temporaries . E318e) (free-identifier=? . E3190) (syntax->datum . E31a6) (datum->syntax . E31a4) (bound-identifier=? . E3192) (syntax-violation . E31a0) (unsyntax-splicing . E4dc1) (unsyntax . E4dc0) (_ . E4dbd) (... . E4dba) (with-syntax . E4daf) (quasisyntax . E4dae) (syntax . E4d9a) (syntax-case . E4d99)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E5141 '(rnrs files) '(6) '() '() '() '((delete-file . E501d) (file-exists? . E501c) (make-i/o-write-error . E4fca) (make-i/o-read-error . E4fc9) (make-i/o-port-error . E4fc8) (make-i/o-invalid-position-error . E4fc7) (make-i/o-filename-error . E4fc6) (make-i/o-file-protection-error . E4fc5) (make-i/o-file-is-read-only-error . E4fc4) (make-i/o-file-does-not-exist-error . E4fc3) (make-i/o-file-already-exists-error . E4fc2) (make-i/o-error . E4fc1) (i/o-write-error? . E4fb5) (i/o-read-error? . E4fb4) (i/o-port-error? . E4fb3) (i/o-invalid-position-error? . E4fb2) (i/o-filename-error? . E4fb1) (i/o-file-protection-error? . E4fb0) (i/o-file-is-read-only-error? . E4faf) (i/o-file-does-not-exist-error? . E4fae) (i/o-file-already-exists-error? . E4fad) (i/o-error? . E4fac) (i/o-error-position . E4fab) (i/o-error-port . E4faa) (i/o-error-filename . E4fa9) (&i/o-port . E4dec) (&i/o-file-does-not-exist . E4deb) (&i/o-file-already-exists . E4dea) (&i/o-file-is-read-only . E4de9) (&i/o-file-protection . E4de8) (&i/o-filename . E4de7) (&i/o-invalid-position . E4de6) (&i/o-write . E4de5) (&i/o-read . E4de4) (&i/o . E4de3)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E5142 '(rnrs sorting) '(6) '() '() '() '((vector-sort! . E501b) (vector-sort . E501a) (list-sort . E5019)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E5143 '(rnrs base) '(6) '() '() '() '((zero? . E4e93) (vector? . E4e92) (vector-set! . E4e91) (vector-ref . E4e90) (vector-map . E4e8f) (vector-length . E4e8e) (vector-for-each . E4e8d) (vector-fill! . E4e8c) (vector->list . E4e8b) (vector . E4e8a) (values . E4e89) (truncate . E4e88) (tan . E4e87) (symbol? . E4e86) (symbol=? . E4e85) (symbol->string . E4e84) (substring . E4e83) (string? . E4e82) (string>? . E4e81) (string>=? . E4e80) (string=? . E4e7f) (string<? . E4e7e) (string<=? . E4e7d) (string-ref . E4e7c) (string-length . E4e7b) (string-for-each . E4e7a) (string-copy . E4e79) (string-append . E4e78) (string->symbol . E4e77) (string->number . E4e76) (string->list . E4e75) (string . E4e74) (sqrt . E4e73) (sin . E4e72) (round . E4e71) (reverse . E4e70) (real? . E4e6f) (real-valued? . E4e6e) (real-part . E4e6d) (rationalize . E4e6c) (rational? . E4e6b) (rational-valued? . E4e6a) (procedure? . E4e69) (positive? . E4e68) (pair? . E4e67) (odd? . E4e66) (numerator . E4e65) (number? . E4e64) (number->string . E4e63) (null? . E4e62) (not . E4e61) (negative? . E4e60) (nan? . E4e5f) (min . E4e5e) (max . E4e5d) (map . E4e5c) (make-vector . E4e5b) (make-string . E4e5a) (make-rectangular . E4e59) (make-polar . E4e58) (magnitude . E4e57) (log . E4e56) (list? . E4e55) (list-tail . E4e54) (list-ref . E4e53) (list->vector . E4e52) (list->string . E4e51) (list . E4e50) (length . E4e4f) (lcm . E4e4e) (integer? . E4e4d) (integer-valued? . E4e4c) (integer->char . E4e4b) (infinite? . E4e4a) (inexact? . E4e49) (inexact . E4e48) (imag-part . E4e47) (gcd . E4e46) (for-each . E4e45) (floor . E4e44) (finite? . E4e43) (expt . E4e42) (exp . E4e41) (exact? . E4e40) (exact-integer-sqrt . E4e3f) (exact . E4e3e) (even? . E4e3d) (error . E4e3c) (eqv? . E4e3b) (equal? . E4e3a) (eq? . E4e39) (dynamic-wind . E4e38) (div0-and-mod0 . E4e37) (mod0 . E4e36) (div0 . E4e35) (div-and-mod . E4e34) (mod . E4e33) (div . E4e32) (denominator . E4e31) (cos . E4e30) (cons . E4e2f) (complex? . E4e2e) (char? . E4e2d) (char>? . E4e2c) (char>=? . E4e2b) (char=? . E4e2a) (char<? . E4e29) (char<=? . E4e28) (char->integer . E4e27) (ceiling . E4e26) (call-with-values . E4e25) (call/cc . E4e24) (call-with-current-continuation . E4e23) (cddddr . E4e22) (cdddar . E4e21) (cddadr . E4e20) (cddaar . E4e1f) (cdaddr . E4e1e) (cdadar . E4e1d) (cdaadr . E4e1c) (cdaaar . E4e1b) (cadddr . E4e1a) (caddar . E4e19) (cadadr . E4e18) (cadaar . E4e17) (caaddr . E4e16) (caadar . E4e15) (caaadr . E4e14) (caaaar . E4e13) (cdddr . E4e12) (cddar . E4e11) (cdadr . E4e10) (cdaar . E4e0f) (caddr . E4e0e) (cadar . E4e0d) (caadr . E4e0c) (caaar . E4e0b) (cddr . E4e0a) (cdar . E4e09) (cadr . E4e08) (caar . E4e07) (cdr . E4e06) (car . E4e05) (boolean? . E4e04) (boolean=? . E4e03) (atan . E4e02) (assertion-violation . E4e01) (asin . E4e00) (apply . E4dff) (append . E4dfe) (angle . E4dfd) (acos . E4dfc) (abs . E4dfb) (/ . E4dfa) (* . E4df9) (- . E4df8) (+ . E4df7) (>= . E4df6) (> . E4df5) (= . E4df4) (<= . E4df3) (< . E4df2) (unquote-splicing . E4dbf) (unquote . E4dbe) (_ . E4dbd) (else . E4dbc) (=> . E4dbb) (... . E4dba) (assert . E4db9) (cond . E4db4) (let* . E4db3) (let*-values . E4db2) (let-values . E4db1) (identifier-syntax . E4db0) (quasiquote . E4dad) (syntax-rules . E4dac) (case . E4da7) (or . E4da3) (and . E4da2) (if . E4da1) (let . E4da0) (letrec* . E4d9f) (letrec . E4d9e) (lambda . E4d9b) (quote . E4d98) (letrec-syntax . E4d96) (let-syntax . E4d95) (set! . E4d94) (begin . E4d92) (define-syntax . E4d90) (define . E4d8f)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E5144 '(rnrs lists) '(6) '() '() '() '((remove . E4f8c) (remv . E4f8b) (remp . E4f8a) (remq . E4f89) (partition . E4f88) (memv . E4f87) (memq . E4f86) (memp . E4f85) (member . E4f84) (exists . E4f83) (for-all . E4f82) (fold-right . E4f81) (fold-left . E4f80) (find . E4f7f) (filter . E4f7e) (cons* . E4f7d) (assv . E4f7c) (assq . E4f7b) (assp . E4f7a) (assoc . E4f79)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E5145 '(rnrs io simple) '(6) '() '() '() '((call-with-output-file . E5003) (call-with-input-file . E5002) (write-char . E5001) (write . E5000) (with-output-to-file . E4fff) (with-input-from-file . E4ffe) (read-char . E4ffd) (read . E4ffc) (peek-char . E4ffb) (open-output-file . E4ffa) (open-input-file . E4ff9) (newline . E4ff8) (display . E4ff7) (close-output-port . E4ff6) (close-input-port . E4ff5) (eof-object? . E4ff4) (eof-object . E4ff3) (current-error-port . E4ff2) (current-output-port . E4ff1) (current-input-port . E4ff0) (output-port? . E4fef) (input-port? . E4fee) (make-i/o-write-error . E4fca) (make-i/o-read-error . E4fc9) (make-i/o-port-error . E4fc8) (make-i/o-invalid-position-error . E4fc7) (make-i/o-filename-error . E4fc6) (make-i/o-file-protection-error . E4fc5) (make-i/o-file-is-read-only-error . E4fc4) (make-i/o-file-does-not-exist-error . E4fc3) (make-i/o-file-already-exists-error . E4fc2) (make-i/o-error . E4fc1) (i/o-write-error? . E4fb5) (i/o-read-error? . E4fb4) (i/o-port-error? . E4fb3) (i/o-invalid-position-error? . E4fb2) (i/o-filename-error? . E4fb1) (i/o-file-protection-error? . E4fb0) (i/o-file-is-read-only-error? . E4faf) (i/o-file-does-not-exist-error? . E4fae) (i/o-file-already-exists-error? . E4fad) (i/o-error? . E4fac) (i/o-error-position . E4fab) (i/o-error-port . E4faa) (i/o-error-filename . E4fa9) (&i/o-port . E4dec) (&i/o-file-does-not-exist . E4deb) (&i/o-file-already-exists . E4dea) (&i/o-file-is-read-only . E4de9) (&i/o-file-protection . E4de8) (&i/o-filename . E4de7) (&i/o-invalid-position . E4de6) (&i/o-write . E4de5) (&i/o-read . E4de4) (&i/o . E4de3)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E5146 '(rnrs bytevectors) '(6) '() '() '() '((make-bytevector . E4fb8) (utf32->string . E4f3e) (utf16->string . E4f3d) (utf8->string . E4f3c) (uint-list->bytevector . E4f3b) (u8-list->bytevector . E4f3a) (string->utf8 . E4f39) (string->utf32 . E4f38) (string->utf16 . E4f37) (sint-list->bytevector . E4f36) (native-endianness . E4f35) (bytevector? . E4f34) (bytevector=? . E4f33) (bytevector-uint-set! . E4f32) (bytevector-uint-ref . E4f31) (bytevector-u8-set! . E4f30) (bytevector-u8-ref . E4f2f) (bytevector-u64-set! . E4f2e) (bytevector-u64-ref . E4f2d) (bytevector-u64-native-set! . E4f2c) (bytevector-u64-native-ref . E4f2b) (bytevector-u32-set! . E4f2a) (bytevector-u32-ref . E4f29) (bytevector-u32-native-set! . E4f28) (bytevector-u32-native-ref . E4f27) (bytevector-u16-set! . E4f26) (bytevector-u16-ref . E4f25) (bytevector-u16-native-set! . E4f24) (bytevector-u16-native-ref . E4f23) (bytevector-sint-set! . E4f22) (bytevector-sint-ref . E4f21) (bytevector-s8-set! . E4f20) (bytevector-s8-ref . E4f1f) (bytevector-s64-set! . E4f1e) (bytevector-s64-ref . E4f1d) (bytevector-s64-native-set! . E4f1c) (bytevector-s64-native-ref . E4f1b) (bytevector-s32-set! . E4f1a) (bytevector-s32-ref . E4f19) (bytevector-s32-native-set! . E4f18) (bytevector-s32-native-ref . E4f17) (bytevector-s16-set! . E4f16) (bytevector-s16-ref . E4f15) (bytevector-s16-native-set! . E4f14) (bytevector-s16-native-ref . E4f13) (bytevector-length . E4f12) (bytevector-ieee-single-ref . E4f11) (bytevector-ieee-single-set! . E4f10) (bytevector-ieee-single-native-set! . E4f0f) (bytevector-ieee-single-native-ref . E4f0e) (bytevector-ieee-double-set! . E4f0d) (bytevector-ieee-double-ref . E4f0c) (bytevector-ieee-double-native-set! . E4f0b) (bytevector-ieee-double-native-ref . E4f0a) (bytevector-fill! . E4f09) (bytevector-copy! . E4f08) (bytevector-copy . E4f07) (bytevector->uint-list . E4f06) (bytevector->u8-list . E4f05) (bytevector->sint-list . E4f04) (endianness . E4db8)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E5147 '(rnrs unicode) '(6) '() '() '() '((string-upcase . E504b) (string-titlecase . E504a) (string-normalize-nfkd . E5049) (string-normalize-nfkc . E5048) (string-normalize-nfd . E5047) (string-normalize-nfc . E5046) (string-foldcase . E5045) (string-downcase . E5044) (string-ci>? . E5043) (string-ci>=? . E5042) (string-ci=? . E5041) (string-ci<? . E5040) (string-ci<=? . E503f) (char-whitespace? . E503e) (char-upper-case? . E503d) (char-title-case? . E503c) (char-numeric? . E503b) (char-lower-case? . E503a) (char-general-category . E5039) (char-upcase . E5038) (char-titlecase . E5037) (char-foldcase . E5036) (char-downcase . E5035) (char-ci>? . E5034) (char-ci>=? . E5033) (char-ci=? . E5032) (char-ci<? . E5031) (char-ci<=? . E5030) (char-alphabetic? . E502f)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E5148 '(rnrs exceptions) '(6) '() '() '() '((with-exception-handler . E4f72) (raise-continuable . E4f71) (raise . E4f70) (guard . E4dc4) (else . E4dbc) (=> . E4dbb)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E5149 '(rnrs arithmetic bitwise) '(6) '() '() '() '((bitwise-rotate-bit-field . E4ea4) (bitwise-reverse-bit-field . E4ea3) (bitwise-length . E4ea2) (bitwise-if . E4ea1) (bitwise-first-bit-set . E4ea0) (bitwise-copy-bit-field . E4e9f) (bitwise-copy-bit . E4e9e) (bitwise-bit-set? . E4e9d) (bitwise-bit-field . E4e9c) (bitwise-bit-count . E4e9b) (bitwise-xor . E4e9a) (bitwise-ior . E4e99) (bitwise-and . E4e98) (bitwise-not . E4e97) (bitwise-arithmetic-shift-right . E4e96) (bitwise-arithmetic-shift-left . E4e95) (bitwise-arithmetic-shift . E4e94)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E514a '(rnrs arithmetic fixnums) '(6) '() '() '() '((fxzero? . E4ed1) (fxxor . E4ed0) (fxrotate-bit-field . E4ecf) (fxreverse-bit-field . E4ece) (fxpositive? . E4ecd) (fxodd? . E4ecc) (fxnot . E4ecb) (fxnegative? . E4eca) (fxmod0 . E4ec9) (fxmod . E4ec8) (fxmin . E4ec7) (fxmax . E4ec6) (fxlength . E4ec5) (fxior . E4ec4) (fxif . E4ec3) (fxfirst-bit-set . E4ec2) (fxeven? . E4ec1) (fxdiv0-and-mod0 . E4ec0) (fxdiv0 . E4ebf) (fxdiv-and-mod . E4ebe) (fxdiv . E4ebd) (fxcopy-bit-field . E4ebc) (fxcopy-bit . E4ebb) (fxbit-set? . E4eba) (fxbit-field . E4eb9) (fxbit-count . E4eb8) (fxarithmetic-shift-right . E4eb7) (fxarithmetic-shift-left . E4eb6) (fxarithmetic-shift . E4eb5) (fxand . E4eb4) (fx>? . E4eb3) (fx>=? . E4eb2) (fx=? . E4eb1) (fx<? . E4eb0) (fx<=? . E4eaf) (fx-/carry . E4eae) (fx- . E4ead) (fx+/carry . E4eac) (fx+ . E4eab) (fx*/carry . E4eaa) (fx* . E4ea9) (greatest-fixnum . E4ea8) (least-fixnum . E4ea7) (fixnum-width . E4ea6) (fixnum? . E4ea5)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E514b '(rnrs arithmetic flonums) '(6) '() '() '() '((no-nans-violation? . E4f03) (no-infinities-violation? . E4f02) (make-no-nans-violation . E4f01) (make-no-infinities-violation . E4f00) (real->flonum . E4eff) (flzero? . E4efe) (fltruncate . E4efd) (fltan . E4efc) (flsqrt . E4efb) (flsin . E4efa) (flround . E4ef9) (flpositive? . E4ef8) (flonum? . E4ef7) (flodd? . E4ef6) (flnumerator . E4ef5) (flnegative? . E4ef4) (flnan? . E4ef3) (flmod0 . E4ef2) (flmod . E4ef1) (flmin . E4ef0) (flmax . E4eef) (fllog . E4eee) (flinteger? . E4eed) (flinfinite? . E4eec) (flfloor . E4eeb) (flfinite? . E4eea) (flexpt . E4ee9) (flexp . E4ee8) (fleven? . E4ee7) (fldiv0-and-mod0 . E4ee6) (fldiv0 . E4ee5) (fldiv-and-mod . E4ee4) (fldiv . E4ee3) (fldenominator . E4ee2) (flcos . E4ee1) (flceiling . E4ee0) (flatan . E4edf) (flasin . E4ede) (flacos . E4edd) (flabs . E4edc) (fl>? . E4edb) (fl>=? . E4eda) (fl=? . E4ed9) (fl<? . E4ed8) (fl<=? . E4ed7) (fl/ . E4ed6) (fl- . E4ed5) (fl+ . E4ed4) (fl* . E4ed3) (fixnum->flonum . E4ed2) (&no-nans . E4df0) (&no-infinities . E4def)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E514c '(rnrs hashtables) '(6) '() '() '() '((symbol-hash . E5018) (string-ci-hash . E5017) (string-hash . E5016) (equal-hash . E5015) (hashtable-equivalence-function . E5014) (make-hashtable . E5013) (hashtable-hash-function . E5012) (make-eqv-hashtable . E5011) (make-eq-hashtable . E5010) (hashtable? . E500f) (hashtable-update! . E500e) (hashtable-size . E500d) (hashtable-set! . E500c) (hashtable-ref . E500b) (hashtable-mutable? . E500a) (hashtable-keys . E5009) (hashtable-entries . E5008) (hashtable-delete! . E5007) (hashtable-copy . E5006) (hashtable-contains? . E5005) (hashtable-clear! . E5004)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E514d '(rnrs io ports) '(6) '() '() '() '((eof-object? . E4ff4) (eof-object . E4ff3) (current-error-port . E4ff2) (current-output-port . E4ff1) (current-input-port . E4ff0) (output-port? . E4fef) (input-port? . E4fee) (utf-8-codec . E4fed) (utf-16-codec . E4fec) (transcoder-error-handling-mode . E4feb) (transcoder-eol-style . E4fea) (transcoder-codec . E4fe9) (transcoded-port . E4fe8) (textual-port? . E4fe7) (string->bytevector . E4fe6) (standard-output-port . E4fe5) (standard-input-port . E4fe4) (standard-error-port . E4fe3) (set-port-position! . E4fe2) (put-u8 . E4fe1) (put-string . E4fe0) (put-datum . E4fdf) (put-char . E4fde) (put-bytevector . E4fdd) (port? . E4fdc) (port-transcoder . E4fdb) (port-position . E4fda) (port-has-set-port-position!? . E4fd9) (port-has-port-position? . E4fd8) (port-eof? . E4fd7) (output-port-buffer-mode . E4fd6) (open-string-output-port . E4fd5) (open-string-input-port . E4fd4) (open-file-output-port . E4fd3) (open-file-input/output-port . E4fd2) (open-file-input-port . E4fd1) (open-bytevector-output-port . E4fd0) (open-bytevector-input-port . E4fcf) (native-transcoder . E4fce) (native-eol-style . E4fcd) (make-transcoder . E4fcc) (latin-1-codec . E4fcb) (make-i/o-write-error . E4fca) (make-i/o-read-error . E4fc9) (make-i/o-port-error . E4fc8) (make-i/o-invalid-position-error . E4fc7) (make-i/o-filename-error . E4fc6) (make-i/o-file-protection-error . E4fc5) (make-i/o-file-is-read-only-error . E4fc4) (make-i/o-file-does-not-exist-error . E4fc3) (make-i/o-file-already-exists-error . E4fc2) (make-i/o-error . E4fc1) (make-i/o-encoding-error . E4fc0) (make-i/o-decoding-error . E4fbf) (make-custom-textual-output-port . E4fbe) (make-custom-textual-input/output-port . E4fbd) (make-custom-textual-input-port . E4fbc) (make-custom-binary-output-port . E4fbb) (make-custom-binary-input/output-port . E4fba) (make-custom-binary-input-port . E4fb9) (lookahead-u8 . E4fb7) (lookahead-char . E4fb6) (i/o-write-error? . E4fb5) (i/o-read-error? . E4fb4) (i/o-port-error? . E4fb3) (i/o-invalid-position-error? . E4fb2) (i/o-filename-error? . E4fb1) (i/o-file-protection-error? . E4fb0) (i/o-file-is-read-only-error? . E4faf) (i/o-file-does-not-exist-error? . E4fae) (i/o-file-already-exists-error? . E4fad) (i/o-error? . E4fac) (i/o-error-position . E4fab) (i/o-error-port . E4faa) (i/o-error-filename . E4fa9) (i/o-encoding-error? . E4fa8) (i/o-encoding-error-char . E4fa7) (i/o-decoding-error? . E4fa6) (get-u8 . E4fa5) (get-string-n! . E4fa4) (get-string-n . E4fa3) (get-string-all . E4fa2) (get-line . E4fa1) (get-datum . E4fa0) (get-char . E4f9f) (get-bytevector-some . E4f9e) (get-bytevector-n! . E4f9d) (get-bytevector-n . E4f9c) (get-bytevector-all . E4f9b) (flush-output-port . E4f9a) (close-port . E4f99) (call-with-string-output-port . E4f78) (call-with-port . E4f77) (call-with-bytevector-output-port . E4f76) (bytevector->string . E4f75) (buffer-mode? . E4f74) (binary-port? . E4f73) (&i/o-encoding . E4dee) (&i/o-decoding . E4ded) (&i/o-port . E4dec) (&i/o-file-does-not-exist . E4deb) (&i/o-file-already-exists . E4dea) (&i/o-file-is-read-only . E4de9) (&i/o-file-protection . E4de8) (&i/o-filename . E4de7) (&i/o-invalid-position . E4de6) (&i/o-write . E4de5) (&i/o-read . E4de4) (&i/o . E4de3) (error-handling-mode . E4dc8) (file-options . E4dc7) (buffer-mode . E4dc6) (eol-style . E4dc5)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E514e '(rnrs enums) '(6) '() '() '() '((make-enumeration . E4f6f) (enum-set=? . E4f6e) (enum-set-universe . E4f6d) (enum-set-union . E4f6c) (enum-set-subset? . E4f6b) (enum-set-projection . E4f6a) (enum-set-member? . E4f69) (enum-set-intersection . E4f68) (enum-set-indexer . E4f67) (enum-set-difference . E4f66) (enum-set-constructor . E4f65) (enum-set-complement . E4f64) (enum-set->list . E4f63) (define-enumeration . E4dd3)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E514f '(rnrs conditions) '(6) '() '() '() '((who-condition? . E4f62) (warning? . E4f61) (violation? . E4f60) (undefined-violation? . E4f5f) (syntax-violation? . E4f5e) (syntax-violation-subform . E4f5d) (syntax-violation-form . E4f5c) (syntax-violation . E31a0) (simple-conditions . E4f5b) (serious-condition? . E4f5a) (non-continuable-violation? . E4f59) (message-condition? . E4f58) (make-who-condition . E4f57) (make-warning . E4f56) (make-violation . E4f55) (make-undefined-violation . E4f54) (make-syntax-violation . E4f53) (make-serious-condition . E4f52) (make-non-continuable-violation . E4f51) (make-message-condition . E4f50) (make-lexical-violation . E4f4f) (make-irritants-condition . E4f4e) (make-implementation-restriction-violation . E4f4d) (make-error . E4f4c) (make-assertion-violation . E4f4b) (lexical-violation? . E4f4a) (irritants-condition? . E4f49) (implementation-restriction-violation? . E4f48) (error? . E4f47) (condition-who . E4f46) (condition-predicate . E4f45) (condition-message . E4f44) (condition-irritants . E4f43) (condition-accessor . E4f42) (condition . E4f41) (assertion-violation? . E4f40) (condition? . E4f3f) (&undefined . E4de2) (&syntax . E4de1) (&lexical . E4de0) (&implementation-restriction . E4ddf) (&non-continuable . E4dde) (&who . E4ddd) (&irritants . E4ddc) (&assertion . E4ddb) (&violation . E4dda) (&error . E4dd9) (&serious . E4dd8) (&warning . E4dd7) (&message . E4dd6) (&condition . E4dd5) (define-condition-type . E4dd4)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E5150 '(rnrs records inspection) '(6) '() '() '() '((record? . E5027) (record-type-uid . E5026) (record-type-sealed? . E5025) (record-type-parent . E5024) (record-type-opaque? . E5023) (record-type-name . E5022) (record-type-generative? . E5021) (record-type-field-names . E5020) (record-rtd . E501f) (record-field-mutable? . E501e)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E5151 '(rnrs records procedural) '(6) '() '() '() '((record-type-descriptor? . E502e) (record-predicate . E502d) (record-mutator . E502c) (record-constructor . E502b) (record-accessor . E502a) (make-record-type-descriptor . E5029) (make-record-constructor-descriptor . E5028)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E5152 '(rnrs records syntactic) '(6) '() '() '() '((define-record-type . E4dd2) (parent-rtd . E4dd1) (nongenerative . E4dd0) (opaque . E4dcf) (sealed . E4dce) (protocol . E4dcd) (parent . E4dcc) (immutable . E4dcb) (mutable . E4dca) (fields . E4dc9) (record-constructor-descriptor . E4da9) (record-type-descriptor . E4da8)) '() values values '#f '#f '#t '#f) (E2cd4@E2b20@install-library 'E5153 '(psyntax system $all) '() '() '() '() '((&no-nans-rcd . E5133) (&no-nans-rtd . E5132) (&no-infinities-rcd . E5131) (&no-infinities-rtd . E5130) (&i/o-encoding-rcd . E512f) (&i/o-encoding-rtd . E512e) (&i/o-decoding-rcd . E512d) (&i/o-decoding-rtd . E512c) (&i/o-port-rcd . E512b) (&i/o-port-rtd . E512a) (&i/o-file-does-not-exist-rcd . E5129) (&i/o-file-does-not-exist-rtd . E5128) (&i/o-file-already-exists-rcd . E5127) (&i/o-file-already-exists-rtd . E5126) (&i/o-file-is-read-only-rcd . E5125) (&i/o-file-is-read-only-rtd . E5124) (&i/o-file-protection-rcd . E5123) (&i/o-file-protection-rtd . E5122) (&i/o-filename-rcd . E5121) (&i/o-filename-rtd . E5120) (&i/o-invalid-position-rcd . E511f) (&i/o-invalid-position-rtd . E511e) (&i/o-write-rcd . E511d) (&i/o-write-rtd . E511c) (&i/o-read-rcd . E511b) (&i/o-read-rtd . E511a) (&i/o-rcd . E5119) (&i/o-rtd . E5118) (&undefined-rcd . E5117) (&undefined-rtd . E5116) (&syntax-rcd . E5115) (&syntax-rtd . E5114) (&lexical-rcd . E5113) (&lexical-rtd . E5112) (&implementation-restriction-rcd . E5111) (&implementation-restriction-rtd . E5110) (&non-continuable-rcd . E510f) (&non-continuable-rtd . E510e) (&who-rcd . E510d) (&who-rtd . E510c) (&irritants-rcd . E510b) (&irritants-rtd . E510a) (&assertion-rcd . E5109) (&assertion-rtd . E5108) (&violation-rcd . E5107) (&violation-rtd . E5106) (&error-rcd . E5105) (&error-rtd . E5104) (&serious-rcd . E5103) (&serious-rtd . E5102) (&warning-rcd . E5101) (&warning-rtd . E5100) (&message-rcd . E50ff) (&message-rtd . E50fe) (&condition-rcd . E50fd) (&condition-rtd . E50fc) (syntax-error . E319c) (syntax-dispatch . E30c0) (pretty-print . E50fb) (eval-core . E50fa) (set-symbol-value! . E50f9) (symbol-value . E50f8) (gensym . E50f7) (void . E50f6) (load . E4c29) (interaction-environment . E31ae) (char-ready? . E50f5) (regexp? . E50f4) (read-line . E50f3) (gensym-prefix-set! . E50f2) (ungensym . E50f1) (alist->eq-hash-table . E50f0) (assoc-ref . E50ef) (print . E50ee) (format . E50ed) (host-os . E50ec) (library-path . E2aff) (standard-library-path . E50eb) (ssl-supported? . E50ea) (ssl-socket? . E50e9) (socket-sslize! . E50e8) (%monapi-name-whereis . E50e7) (%monapi-message-send . E50e6) (file-newer? . E50e5) (stat-mtime . E50e4) (write-to-file . E50e3) (file->list . E50e2) (file->string . E50e1) (digit->integer . E50e0) (call-with-string-input-port . E50df) (call-with-string-io . E50de) (string-split . E50dd) (bytevector-for-each . E50dc) (string->regexp . E50db) (rxmatch . E50da) (regexp-replace-all . E50d9) (hashtable-for-each . E50d8) (mosh-cache-dir . E28e9) (call-process . E50d7) (local-tz-offset . E50d6) (microseconds . E50d5) (directory-list . E50d4) (set-current-directory! . E50d3) (expand-path . E50d2) (current-directory . E50d1) (%spawn . E50d0) (%waitpid . E50cf) (simple-struct-name . E50ce) (simple-struct-set! . E50cd) (simple-struct-ref . E50cc) (make-simple-struct . E50cb) (simple-struct? . E50ca) (pointer-ref-c-int64 . E50c9) (pointer-ref-c-int32 . E50c8) (pointer-ref-c-int16 . E50c7) (pointer-ref-c-int8 . E50c6) (pointer-ref-c-uint64 . E50c5) (pointer-ref-c-uint32 . E50c4) (pointer-ref-c-uint16 . E50c3) (pointer-ref-c-uint8 . E50c2) (pointer-set-c-uint64! . E50c1) (pointer-set-c-uint32! . E50c0) (pointer-set-c-uint16! . E50bf) (pointer-set-c-uint8! . E50be) (pointer-set-c-int64! . E50bd) (pointer-set-c-int32! . E50bc) (pointer-set-c-int16! . E50bb) (pointer-set-c-int8! . E50ba) (pointer-set-c-pointer! . E50b9) (pointer-set-c-double! . E50b8) (pointer-set-c-float! . E50b7) (pointer-set-c-long-long! . E50b6) (pointer-set-c-long! . E50b5) (pointer-set-c-int! . E50b4) (pointer-set-c-short! . E50b3) (pointer-set-c-char! . E50b2) (pointer-ref-c-pointer . E50b1) (pointer-ref-c-double . E50b0) (pointer-ref-c-float . E50af) (pointer-ref-c-unsigned-long-long . E50ae) (pointer-ref-c-signed-long-long . E50ad) (pointer-ref-c-unsigned-long . E50ac) (pointer-ref-c-signed-long . E50ab) (pointer-ref-c-unsigned-int . E50aa) (pointer-ref-c-signed-int . E50a9) (pointer-ref-c-unsigned-short . E50a8) (pointer-ref-c-signed-short . E50a7) (pointer-ref-c-unsigned-char . E50a6) (pointer-ref-c-signed-char . E50a5) (pointer->integer . E50a4) (integer->pointer . E50a3) (pointer? . E50a2) (shared-errno . E50a1) (%ffi-free-c-callback-trampoline . E50a0) (%ffi-make-c-callback-trampoline . E509f) (%ffi-free . E509e) (%ffi-malloc . E509d) (%ffi-supported? . E509c) (%ffi-pointer->string . E509b) (%ffi-call . E509a) (%ffi-lookup . E5099) (%ffi-open . E5098) (null-terminated-utf8->string . E5097) (null-terminated-bytevector->string . E5096) (%exec . E5095) (%fork . E5094) (%pipe . E5093) (p . E5092) (open-output-string . E5091) (get-output-string . E5090) (file-stat-ctime . E508f) (file-stat-atime . E508e) (file-stat-mtime . E508d) (file-size-in-bytes . E508c) (file-writable? . E508b) (file-executable? . E508a) (file-readable? . E5089) (file-regular? . E5088) (file-symbolic-link? . E5087) (file-directory? . E5086) (create-symbolic-link . E5085) (rename-file . E5084) (delete-directory . E5083) (create-directory . E5082) (create-mosh-cache-dir . E5081) (get-environment-variables . E5080) (current-exception-handler . E507f) (get-environment-variable . E507e) (join-wraps . E507d) (id->real-label . E507c) (same-marks? . E507b) (same-marks*? . E507a) (get-timeofday . E5079) (get-command-line . E5078) (sys-display . E5077) (whereis . E5076) (register . E5075) (vm-join! . E5074) (vm-set-value! . E5073) (vm? . E5072) (main-vm? . E5071) (vm-eval . E5070) (vm-self . E506f) (vm-start! . E506e) (make-vm . E506d) (mutex-try-lock! . E506c) (mutex-unlock! . E506b) (mutex-lock! . E506a) (mutex? . E5069) (make-mutex . E5068) (condition-variable-notify-all! . E5067) (condition-variable-notify! . E5066) (condition-variable-wait! . E5065) (make-condition-variable . E5064) (write/ss . E5063) (mosh-executable-path . E5062) (make-file-options . E5061) (source-info . E5060) (make-compiler-instruction . E505f) (make-instruction . E505e) (set-source-info! . E505d) (bignum? . E505c) (fast-equal? . E505b) (fasl-read . E505a) (fasl-write . E5059) (time-usage . E5058) (os-constant . E5057) (disasm . E5056) (make-parameter . E28e7) (socket-port . E5055) (socket-shutdown . E5054) (socket-close . E5053) (socket-send . E5052) (socket-recv! . E5051) (socket-recv . E5050) (make-server-socket . E504f) (make-client-socket . E504e) (socket-accept . E504d) (socket? . E504c) (string-upcase . E504b) (string-titlecase . E504a) (string-normalize-nfkd . E5049) (string-normalize-nfkc . E5048) (string-normalize-nfd . E5047) (string-normalize-nfc . E5046) (string-foldcase . E5045) (string-downcase . E5044) (string-ci>? . E5043) (string-ci>=? . E5042) (string-ci=? . E5041) (string-ci<? . E5040) (string-ci<=? . E503f) (char-whitespace? . E503e) (char-upper-case? . E503d) (char-title-case? . E503c) (char-numeric? . E503b) (char-lower-case? . E503a) (char-general-category . E5039) (char-upcase . E5038) (char-titlecase . E5037) (char-foldcase . E5036) (char-downcase . E5035) (char-ci>? . E5034) (char-ci>=? . E5033) (char-ci=? . E5032) (char-ci<? . E5031) (char-ci<=? . E5030) (char-alphabetic? . E502f) (make-variable-transformer . E2eeb) (identifier? . E31a2) (generate-temporaries . E318e) (free-identifier=? . E3190) (syntax->datum . E31a6) (datum->syntax . E31a4) (bound-identifier=? . E3192) (record-type-descriptor? . E502e) (record-predicate . E502d) (record-mutator . E502c) (record-constructor . E502b) (record-accessor . E502a) (make-record-type-descriptor . E5029) (make-record-constructor-descriptor . E5028) (record? . E5027) (record-type-uid . E5026) (record-type-sealed? . E5025) (record-type-parent . E5024) (record-type-opaque? . E5023) (record-type-name . E5022) (record-type-generative? . E5021) (record-type-field-names . E5020) (record-rtd . E501f) (record-field-mutable? . E501e) (delete-file . E501d) (file-exists? . E501c) (vector-sort! . E501b) (vector-sort . E501a) (list-sort . E5019) (symbol-hash . E5018) (string-ci-hash . E5017) (string-hash . E5016) (equal-hash . E5015) (hashtable-equivalence-function . E5014) (make-hashtable . E5013) (hashtable-hash-function . E5012) (make-eqv-hashtable . E5011) (make-eq-hashtable . E5010) (hashtable? . E500f) (hashtable-update! . E500e) (hashtable-size . E500d) (hashtable-set! . E500c) (hashtable-ref . E500b) (hashtable-mutable? . E500a) (hashtable-keys . E5009) (hashtable-entries . E5008) (hashtable-delete! . E5007) (hashtable-copy . E5006) (hashtable-contains? . E5005) (hashtable-clear! . E5004) (call-with-output-file . E5003) (call-with-input-file . E5002) (write-char . E5001) (write . E5000) (with-output-to-file . E4fff) (with-input-from-file . E4ffe) (read-char . E4ffd) (read . E4ffc) (peek-char . E4ffb) (open-output-file . E4ffa) (open-input-file . E4ff9) (newline . E4ff8) (display . E4ff7) (close-output-port . E4ff6) (close-input-port . E4ff5) (eof-object? . E4ff4) (eof-object . E4ff3) (current-error-port . E4ff2) (current-output-port . E4ff1) (current-input-port . E4ff0) (output-port? . E4fef) (input-port? . E4fee) (utf-8-codec . E4fed) (utf-16-codec . E4fec) (transcoder-error-handling-mode . E4feb) (transcoder-eol-style . E4fea) (transcoder-codec . E4fe9) (transcoded-port . E4fe8) (textual-port? . E4fe7) (string->bytevector . E4fe6) (standard-output-port . E4fe5) (standard-input-port . E4fe4) (standard-error-port . E4fe3) (set-port-position! . E4fe2) (put-u8 . E4fe1) (put-string . E4fe0) (put-datum . E4fdf) (put-char . E4fde) (put-bytevector . E4fdd) (port? . E4fdc) (port-transcoder . E4fdb) (port-position . E4fda) (port-has-set-port-position!? . E4fd9) (port-has-port-position? . E4fd8) (port-eof? . E4fd7) (output-port-buffer-mode . E4fd6) (open-string-output-port . E4fd5) (open-string-input-port . E4fd4) (open-file-output-port . E4fd3) (open-file-input/output-port . E4fd2) (open-file-input-port . E4fd1) (open-bytevector-output-port . E4fd0) (open-bytevector-input-port . E4fcf) (native-transcoder . E4fce) (native-eol-style . E4fcd) (make-transcoder . E4fcc) (latin-1-codec . E4fcb) (make-i/o-write-error . E4fca) (make-i/o-read-error . E4fc9) (make-i/o-port-error . E4fc8) (make-i/o-invalid-position-error . E4fc7) (make-i/o-filename-error . E4fc6) (make-i/o-file-protection-error . E4fc5) (make-i/o-file-is-read-only-error . E4fc4) (make-i/o-file-does-not-exist-error . E4fc3) (make-i/o-file-already-exists-error . E4fc2) (make-i/o-error . E4fc1) (make-i/o-encoding-error . E4fc0) (make-i/o-decoding-error . E4fbf) (make-custom-textual-output-port . E4fbe) (make-custom-textual-input/output-port . E4fbd) (make-custom-textual-input-port . E4fbc) (make-custom-binary-output-port . E4fbb) (make-custom-binary-input/output-port . E4fba) (make-custom-binary-input-port . E4fb9) (make-bytevector . E4fb8) (lookahead-u8 . E4fb7) (lookahead-char . E4fb6) (i/o-write-error? . E4fb5) (i/o-read-error? . E4fb4) (i/o-port-error? . E4fb3) (i/o-invalid-position-error? . E4fb2) (i/o-filename-error? . E4fb1) (i/o-file-protection-error? . E4fb0) (i/o-file-is-read-only-error? . E4faf) (i/o-file-does-not-exist-error? . E4fae) (i/o-file-already-exists-error? . E4fad) (i/o-error? . E4fac) (i/o-error-position . E4fab) (i/o-error-port . E4faa) (i/o-error-filename . E4fa9) (i/o-encoding-error? . E4fa8) (i/o-encoding-error-char . E4fa7) (i/o-decoding-error? . E4fa6) (get-u8 . E4fa5) (get-string-n! . E4fa4) (get-string-n . E4fa3) (get-string-all . E4fa2) (get-line . E4fa1) (get-datum . E4fa0) (get-char . E4f9f) (get-bytevector-some . E4f9e) (get-bytevector-n! . E4f9d) (get-bytevector-n . E4f9c) (get-bytevector-all . E4f9b) (flush-output-port . E4f9a) (close-port . E4f99) (scheme-report-environment . E317c) (quotient . E4f98) (null-environment . E317a) (remainder . E4f97) (modulo . E4f96) (inexact->exact . E4f95) (force . E4f94) (exact->inexact . E4f93) (make-promise . E4f92) (exit . E4f91) (command-line . E4c23) (string-fill! . E4f90) (string-set! . E4f8f) (set-cdr! . E4f8e) (set-car! . E4f8d) (remove . E4f8c) (remv . E4f8b) (remp . E4f8a) (remq . E4f89) (partition . E4f88) (memv . E4f87) (memq . E4f86) (memp . E4f85) (member . E4f84) (exists . E4f83) (for-all . E4f82) (fold-right . E4f81) (fold-left . E4f80) (find . E4f7f) (filter . E4f7e) (cons* . E4f7d) (assv . E4f7c) (assq . E4f7b) (assp . E4f7a) (assoc . E4f79) (call-with-string-output-port . E4f78) (call-with-port . E4f77) (call-with-bytevector-output-port . E4f76) (bytevector->string . E4f75) (buffer-mode? . E4f74) (binary-port? . E4f73) (with-exception-handler . E4f72) (raise-continuable . E4f71) (raise . E4f70) (eval . E3180) (environment . E3178) (make-enumeration . E4f6f) (enum-set=? . E4f6e) (enum-set-universe . E4f6d) (enum-set-union . E4f6c) (enum-set-subset? . E4f6b) (enum-set-projection . E4f6a) (enum-set-member? . E4f69) (enum-set-intersection . E4f68) (enum-set-indexer . E4f67) (enum-set-difference . E4f66) (enum-set-constructor . E4f65) (enum-set-complement . E4f64) (enum-set->list . E4f63) (who-condition? . E4f62) (warning? . E4f61) (violation? . E4f60) (undefined-violation? . E4f5f) (syntax-violation? . E4f5e) (syntax-violation-subform . E4f5d) (syntax-violation-form . E4f5c) (syntax-violation . E31a0) (simple-conditions . E4f5b) (serious-condition? . E4f5a) (non-continuable-violation? . E4f59) (message-condition? . E4f58) (make-who-condition . E4f57) (make-warning . E4f56) (make-violation . E4f55) (make-undefined-violation . E4f54) (make-syntax-violation . E4f53) (make-serious-condition . E4f52) (make-non-continuable-violation . E4f51) (make-message-condition . E4f50) (make-lexical-violation . E4f4f) (make-irritants-condition . E4f4e) (make-implementation-restriction-violation . E4f4d) (make-error . E4f4c) (make-assertion-violation . E4f4b) (lexical-violation? . E4f4a) (irritants-condition? . E4f49) (implementation-restriction-violation? . E4f48) (error? . E4f47) (condition-who . E4f46) (condition-predicate . E4f45) (condition-message . E4f44) (condition-irritants . E4f43) (condition-accessor . E4f42) (condition . E4f41) (assertion-violation? . E4f40) (condition? . E4f3f) (utf32->string . E4f3e) (utf16->string . E4f3d) (utf8->string . E4f3c) (uint-list->bytevector . E4f3b) (u8-list->bytevector . E4f3a) (string->utf8 . E4f39) (string->utf32 . E4f38) (string->utf16 . E4f37) (sint-list->bytevector . E4f36) (native-endianness . E4f35) (bytevector? . E4f34) (bytevector=? . E4f33) (bytevector-uint-set! . E4f32) (bytevector-uint-ref . E4f31) (bytevector-u8-set! . E4f30) (bytevector-u8-ref . E4f2f) (bytevector-u64-set! . E4f2e) (bytevector-u64-ref . E4f2d) (bytevector-u64-native-set! . E4f2c) (bytevector-u64-native-ref . E4f2b) (bytevector-u32-set! . E4f2a) (bytevector-u32-ref . E4f29) (bytevector-u32-native-set! . E4f28) (bytevector-u32-native-ref . E4f27) (bytevector-u16-set! . E4f26) (bytevector-u16-ref . E4f25) (bytevector-u16-native-set! . E4f24) (bytevector-u16-native-ref . E4f23) (bytevector-sint-set! . E4f22) (bytevector-sint-ref . E4f21) (bytevector-s8-set! . E4f20) (bytevector-s8-ref . E4f1f) (bytevector-s64-set! . E4f1e) (bytevector-s64-ref . E4f1d) (bytevector-s64-native-set! . E4f1c) (bytevector-s64-native-ref . E4f1b) (bytevector-s32-set! . E4f1a) (bytevector-s32-ref . E4f19) (bytevector-s32-native-set! . E4f18) (bytevector-s32-native-ref . E4f17) (bytevector-s16-set! . E4f16) (bytevector-s16-ref . E4f15) (bytevector-s16-native-set! . E4f14) (bytevector-s16-native-ref . E4f13) (bytevector-length . E4f12) (bytevector-ieee-single-ref . E4f11) (bytevector-ieee-single-set! . E4f10) (bytevector-ieee-single-native-set! . E4f0f) (bytevector-ieee-single-native-ref . E4f0e) (bytevector-ieee-double-set! . E4f0d) (bytevector-ieee-double-ref . E4f0c) (bytevector-ieee-double-native-set! . E4f0b) (bytevector-ieee-double-native-ref . E4f0a) (bytevector-fill! . E4f09) (bytevector-copy! . E4f08) (bytevector-copy . E4f07) (bytevector->uint-list . E4f06) (bytevector->u8-list . E4f05) (bytevector->sint-list . E4f04) (no-nans-violation? . E4f03) (no-infinities-violation? . E4f02) (make-no-nans-violation . E4f01) (make-no-infinities-violation . E4f00) (real->flonum . E4eff) (flzero? . E4efe) (fltruncate . E4efd) (fltan . E4efc) (flsqrt . E4efb) (flsin . E4efa) (flround . E4ef9) (flpositive? . E4ef8) (flonum? . E4ef7) (flodd? . E4ef6) (flnumerator . E4ef5) (flnegative? . E4ef4) (flnan? . E4ef3) (flmod0 . E4ef2) (flmod . E4ef1) (flmin . E4ef0) (flmax . E4eef) (fllog . E4eee) (flinteger? . E4eed) (flinfinite? . E4eec) (flfloor . E4eeb) (flfinite? . E4eea) (flexpt . E4ee9) (flexp . E4ee8) (fleven? . E4ee7) (fldiv0-and-mod0 . E4ee6) (fldiv0 . E4ee5) (fldiv-and-mod . E4ee4) (fldiv . E4ee3) (fldenominator . E4ee2) (flcos . E4ee1) (flceiling . E4ee0) (flatan . E4edf) (flasin . E4ede) (flacos . E4edd) (flabs . E4edc) (fl>? . E4edb) (fl>=? . E4eda) (fl=? . E4ed9) (fl<? . E4ed8) (fl<=? . E4ed7) (fl/ . E4ed6) (fl- . E4ed5) (fl+ . E4ed4) (fl* . E4ed3) (fixnum->flonum . E4ed2) (fxzero? . E4ed1) (fxxor . E4ed0) (fxrotate-bit-field . E4ecf) (fxreverse-bit-field . E4ece) (fxpositive? . E4ecd) (fxodd? . E4ecc) (fxnot . E4ecb) (fxnegative? . E4eca) (fxmod0 . E4ec9) (fxmod . E4ec8) (fxmin . E4ec7) (fxmax . E4ec6) (fxlength . E4ec5) (fxior . E4ec4) (fxif . E4ec3) (fxfirst-bit-set . E4ec2) (fxeven? . E4ec1) (fxdiv0-and-mod0 . E4ec0) (fxdiv0 . E4ebf) (fxdiv-and-mod . E4ebe) (fxdiv . E4ebd) (fxcopy-bit-field . E4ebc) (fxcopy-bit . E4ebb) (fxbit-set? . E4eba) (fxbit-field . E4eb9) (fxbit-count . E4eb8) (fxarithmetic-shift-right . E4eb7) (fxarithmetic-shift-left . E4eb6) (fxarithmetic-shift . E4eb5) (fxand . E4eb4) (fx>? . E4eb3) (fx>=? . E4eb2) (fx=? . E4eb1) (fx<? . E4eb0) (fx<=? . E4eaf) (fx-/carry . E4eae) (fx- . E4ead) (fx+/carry . E4eac) (fx+ . E4eab) (fx*/carry . E4eaa) (fx* . E4ea9) (greatest-fixnum . E4ea8) (least-fixnum . E4ea7) (fixnum-width . E4ea6) (fixnum? . E4ea5) (bitwise-rotate-bit-field . E4ea4) (bitwise-reverse-bit-field . E4ea3) (bitwise-length . E4ea2) (bitwise-if . E4ea1) (bitwise-first-bit-set . E4ea0) (bitwise-copy-bit-field . E4e9f) (bitwise-copy-bit . E4e9e) (bitwise-bit-set? . E4e9d) (bitwise-bit-field . E4e9c) (bitwise-bit-count . E4e9b) (bitwise-xor . E4e9a) (bitwise-ior . E4e99) (bitwise-and . E4e98) (bitwise-not . E4e97) (bitwise-arithmetic-shift-right . E4e96) (bitwise-arithmetic-shift-left . E4e95) (bitwise-arithmetic-shift . E4e94) (zero? . E4e93) (vector? . E4e92) (vector-set! . E4e91) (vector-ref . E4e90) (vector-map . E4e8f) (vector-length . E4e8e) (vector-for-each . E4e8d) (vector-fill! . E4e8c) (vector->list . E4e8b) (vector . E4e8a) (values . E4e89) (truncate . E4e88) (tan . E4e87) (symbol? . E4e86) (symbol=? . E4e85) (symbol->string . E4e84) (substring . E4e83) (string? . E4e82) (string>? . E4e81) (string>=? . E4e80) (string=? . E4e7f) (string<? . E4e7e) (string<=? . E4e7d) (string-ref . E4e7c) (string-length . E4e7b) (string-for-each . E4e7a) (string-copy . E4e79) (string-append . E4e78) (string->symbol . E4e77) (string->number . E4e76) (string->list . E4e75) (string . E4e74) (sqrt . E4e73) (sin . E4e72) (round . E4e71) (reverse . E4e70) (real? . E4e6f) (real-valued? . E4e6e) (real-part . E4e6d) (rationalize . E4e6c) (rational? . E4e6b) (rational-valued? . E4e6a) (procedure? . E4e69) (positive? . E4e68) (pair? . E4e67) (odd? . E4e66) (numerator . E4e65) (number? . E4e64) (number->string . E4e63) (null? . E4e62) (not . E4e61) (negative? . E4e60) (nan? . E4e5f) (min . E4e5e) (max . E4e5d) (map . E4e5c) (make-vector . E4e5b) (make-string . E4e5a) (make-rectangular . E4e59) (make-polar . E4e58) (magnitude . E4e57) (log . E4e56) (list? . E4e55) (list-tail . E4e54) (list-ref . E4e53) (list->vector . E4e52) (list->string . E4e51) (list . E4e50) (length . E4e4f) (lcm . E4e4e) (integer? . E4e4d) (integer-valued? . E4e4c) (integer->char . E4e4b) (infinite? . E4e4a) (inexact? . E4e49) (inexact . E4e48) (imag-part . E4e47) (gcd . E4e46) (for-each . E4e45) (floor . E4e44) (finite? . E4e43) (expt . E4e42) (exp . E4e41) (exact? . E4e40) (exact-integer-sqrt . E4e3f) (exact . E4e3e) (even? . E4e3d) (error . E4e3c) (eqv? . E4e3b) (equal? . E4e3a) (eq? . E4e39) (dynamic-wind . E4e38) (div0-and-mod0 . E4e37) (mod0 . E4e36) (div0 . E4e35) (div-and-mod . E4e34) (mod . E4e33) (div . E4e32) (denominator . E4e31) (cos . E4e30) (cons . E4e2f) (complex? . E4e2e) (char? . E4e2d) (char>? . E4e2c) (char>=? . E4e2b) (char=? . E4e2a) (char<? . E4e29) (char<=? . E4e28) (char->integer . E4e27) (ceiling . E4e26) (call-with-values . E4e25) (call/cc . E4e24) (call-with-current-continuation . E4e23) (cddddr . E4e22) (cdddar . E4e21) (cddadr . E4e20) (cddaar . E4e1f) (cdaddr . E4e1e) (cdadar . E4e1d) (cdaadr . E4e1c) (cdaaar . E4e1b) (cadddr . E4e1a) (caddar . E4e19) (cadadr . E4e18) (cadaar . E4e17) (caaddr . E4e16) (caadar . E4e15) (caaadr . E4e14) (caaaar . E4e13) (cdddr . E4e12) (cddar . E4e11) (cdadr . E4e10) (cdaar . E4e0f) (caddr . E4e0e) (cadar . E4e0d) (caadr . E4e0c) (caaar . E4e0b) (cddr . E4e0a) (cdar . E4e09) (cadr . E4e08) (caar . E4e07) (cdr . E4e06) (car . E4e05) (boolean? . E4e04) (boolean=? . E4e03) (atan . E4e02) (assertion-violation . E4e01) (assertion-error . E319a) (asin . E4e00) (apply . E4dff) (append . E4dfe) (angle . E4dfd) (acos . E4dfc) (abs . E4dfb) (/ . E4dfa) (* . E4df9) (- . E4df8) (+ . E4df7) (>= . E4df6) (> . E4df5) (= . E4df4) (<= . E4df3) (< . E4df2) (library . E4df1) (&no-nans . E4df0) (&no-infinities . E4def) (&i/o-encoding . E4dee) (&i/o-decoding . E4ded) (&i/o-port . E4dec) (&i/o-file-does-not-exist . E4deb) (&i/o-file-already-exists . E4dea) (&i/o-file-is-read-only . E4de9) (&i/o-file-protection . E4de8) (&i/o-filename . E4de7) (&i/o-invalid-position . E4de6) (&i/o-write . E4de5) (&i/o-read . E4de4) (&i/o . E4de3) (&undefined . E4de2) (&syntax . E4de1) (&lexical . E4de0) (&implementation-restriction . E4ddf) (&non-continuable . E4dde) (&who . E4ddd) (&irritants . E4ddc) (&assertion . E4ddb) (&violation . E4dda) (&error . E4dd9) (&serious . E4dd8) (&warning . E4dd7) (&message . E4dd6) (&condition . E4dd5) (define-condition-type . E4dd4) (define-enumeration . E4dd3) (define-record-type . E4dd2) (parent-rtd . E4dd1) (nongenerative . E4dd0) (opaque . E4dcf) (sealed . E4dce) (protocol . E4dcd) (parent . E4dcc) (immutable . E4dcb) (mutable . E4dca) (fields . E4dc9) (error-handling-mode . E4dc8) (file-options . E4dc7) (buffer-mode . E4dc6) (eol-style . E4dc5) (guard . E4dc4) (trace-define . E4dc3) (trace-lambda . E4dc2) (unsyntax-splicing . E4dc1) (unsyntax . E4dc0) (unquote-splicing . E4dbf) (unquote . E4dbe) (_ . E4dbd) (else . E4dbc) (=> . E4dbb) (... . E4dba) (assert . E4db9) (endianness . E4db8) (delay . E4db7) (time . E4db6) (do . E4db5) (cond . E4db4) (let* . E4db3) (let*-values . E4db2) (let-values . E4db1) (identifier-syntax . E4db0) (with-syntax . E4daf) (quasisyntax . E4dae) (quasiquote . E4dad) (syntax-rules . E4dac) (include . E4dab) (define-struct . E4daa) (record-constructor-descriptor . E4da9) (record-type-descriptor . E4da8) (case . E4da7) (parameterize . E4da6) (unless . E4da5) (when . E4da4) (or . E4da3) (and . E4da2) (if . E4da1) (let . E4da0) (letrec* . E4d9f) (letrec . E4d9e) (type-descriptor . E4d9d) (case-lambda . E4d9c) (lambda . E4d9b) (syntax . E4d9a) (syntax-case . E4d99) (quote . E4d98) (foreign-call . E4d97) (letrec-syntax . E4d96) (let-syntax . E4d95) (set! . E4d94) (import . E4d93) (begin . E4d92) (module . E4d91) (define-syntax . E4d90) (define . E4d8f)) '((E5133 core-prim . &no-nans-rcd) (E5132 core-prim . &no-nans-rtd) (E5131 core-prim . &no-infinities-rcd) (E5130 core-prim . &no-infinities-rtd) (E512f core-prim . &i/o-encoding-rcd) (E512e core-prim . &i/o-encoding-rtd) (E512d core-prim . &i/o-decoding-rcd) (E512c core-prim . &i/o-decoding-rtd) (E512b core-prim . &i/o-port-rcd) (E512a core-prim . &i/o-port-rtd) (E5129 core-prim . &i/o-file-does-not-exist-rcd) (E5128 core-prim . &i/o-file-does-not-exist-rtd) (E5127 core-prim . &i/o-file-already-exists-rcd) (E5126 core-prim . &i/o-file-already-exists-rtd) (E5125 core-prim . &i/o-file-is-read-only-rcd) (E5124 core-prim . &i/o-file-is-read-only-rtd) (E5123 core-prim . &i/o-file-protection-rcd) (E5122 core-prim . &i/o-file-protection-rtd) (E5121 core-prim . &i/o-filename-rcd) (E5120 core-prim . &i/o-filename-rtd) (E511f core-prim . &i/o-invalid-position-rcd) (E511e core-prim . &i/o-invalid-position-rtd) (E511d core-prim . &i/o-write-rcd) (E511c core-prim . &i/o-write-rtd) (E511b core-prim . &i/o-read-rcd) (E511a core-prim . &i/o-read-rtd) (E5119 core-prim . &i/o-rcd) (E5118 core-prim . &i/o-rtd) (E5117 core-prim . &undefined-rcd) (E5116 core-prim . &undefined-rtd) (E5115 core-prim . &syntax-rcd) (E5114 core-prim . &syntax-rtd) (E5113 core-prim . &lexical-rcd) (E5112 core-prim . &lexical-rtd) (E5111 core-prim . &implementation-restriction-rcd) (E5110 core-prim . &implementation-restriction-rtd) (E510f core-prim . &non-continuable-rcd) (E510e core-prim . &non-continuable-rtd) (E510d core-prim . &who-rcd) (E510c core-prim . &who-rtd) (E510b core-prim . &irritants-rcd) (E510a core-prim . &irritants-rtd) (E5109 core-prim . &assertion-rcd) (E5108 core-prim . &assertion-rtd) (E5107 core-prim . &violation-rcd) (E5106 core-prim . &violation-rtd) (E5105 core-prim . &error-rcd) (E5104 core-prim . &error-rtd) (E5103 core-prim . &serious-rcd) (E5102 core-prim . &serious-rtd) (E5101 core-prim . &warning-rcd) (E5100 core-prim . &warning-rtd) (E50ff core-prim . &message-rcd) (E50fe core-prim . &message-rtd) (E50fd core-prim . &condition-rcd) (E50fc core-prim . &condition-rtd) (E319c core-prim . syntax-error) (E30c0 core-prim . syntax-dispatch) (E50fb core-prim . pretty-print) (E50fa core-prim . eval-core) (E50f9 core-prim . set-symbol-value!) (E50f8 core-prim . symbol-value) (E50f7 core-prim . gensym) (E50f6 core-prim . void) (E4c29 core-prim . load) (E31ae core-prim . interaction-environment) (E50f5 core-prim . char-ready?) (E50f4 core-prim . regexp?) (E50f3 core-prim . read-line) (E50f2 core-prim . gensym-prefix-set!) (E50f1 core-prim . ungensym) (E50f0 core-prim . alist->eq-hash-table) (E50ef core-prim . assoc-ref) (E50ee core-prim . print) (E50ed core-prim . format) (E50ec core-prim . host-os) (E2aff core-prim . library-path) (E50eb core-prim . standard-library-path) (E50ea core-prim . ssl-supported?) (E50e9 core-prim . ssl-socket?) (E50e8 core-prim . socket-sslize!) (E50e7 core-prim . %monapi-name-whereis) (E50e6 core-prim . %monapi-message-send) (E50e5 core-prim . file-newer?) (E50e4 core-prim . stat-mtime) (E50e3 core-prim . write-to-file) (E50e2 core-prim . file->list) (E50e1 core-prim . file->string) (E50e0 core-prim . digit->integer) (E50df core-prim . call-with-string-input-port) (E50de core-prim . call-with-string-io) (E50dd core-prim . string-split) (E50dc core-prim . bytevector-for-each) (E50db core-prim . string->regexp) (E50da core-prim . rxmatch) (E50d9 core-prim . regexp-replace-all) (E50d8 core-prim . hashtable-for-each) (E28e9 core-prim . mosh-cache-dir) (E50d7 core-prim . call-process) (E50d6 core-prim . local-tz-offset) (E50d5 core-prim . microseconds) (E50d4 core-prim . directory-list) (E50d3 core-prim . set-current-directory!) (E50d2 core-prim . expand-path) (E50d1 core-prim . current-directory) (E50d0 core-prim . %spawn) (E50cf core-prim . %waitpid) (E50ce core-prim . simple-struct-name) (E50cd core-prim . simple-struct-set!) (E50cc core-prim . simple-struct-ref) (E50cb core-prim . make-simple-struct) (E50ca core-prim . simple-struct?) (E50c9 core-prim . pointer-ref-c-int64) (E50c8 core-prim . pointer-ref-c-int32) (E50c7 core-prim . pointer-ref-c-int16) (E50c6 core-prim . pointer-ref-c-int8) (E50c5 core-prim . pointer-ref-c-uint64) (E50c4 core-prim . pointer-ref-c-uint32) (E50c3 core-prim . pointer-ref-c-uint16) (E50c2 core-prim . pointer-ref-c-uint8) (E50c1 core-prim . pointer-set-c-uint64!) (E50c0 core-prim . pointer-set-c-uint32!) (E50bf core-prim . pointer-set-c-uint16!) (E50be core-prim . pointer-set-c-uint8!) (E50bd core-prim . pointer-set-c-int64!) (E50bc core-prim . pointer-set-c-int32!) (E50bb core-prim . pointer-set-c-int16!) (E50ba core-prim . pointer-set-c-int8!) (E50b9 core-prim . pointer-set-c-pointer!) (E50b8 core-prim . pointer-set-c-double!) (E50b7 core-prim . pointer-set-c-float!) (E50b6 core-prim . pointer-set-c-long-long!) (E50b5 core-prim . pointer-set-c-long!) (E50b4 core-prim . pointer-set-c-int!) (E50b3 core-prim . pointer-set-c-short!) (E50b2 core-prim . pointer-set-c-char!) (E50b1 core-prim . pointer-ref-c-pointer) (E50b0 core-prim . pointer-ref-c-double) (E50af core-prim . pointer-ref-c-float) (E50ae core-prim . pointer-ref-c-unsigned-long-long) (E50ad core-prim . pointer-ref-c-signed-long-long) (E50ac core-prim . pointer-ref-c-unsigned-long) (E50ab core-prim . pointer-ref-c-signed-long) (E50aa core-prim . pointer-ref-c-unsigned-int) (E50a9 core-prim . pointer-ref-c-signed-int) (E50a8 core-prim . pointer-ref-c-unsigned-short) (E50a7 core-prim . pointer-ref-c-signed-short) (E50a6 core-prim . pointer-ref-c-unsigned-char) (E50a5 core-prim . pointer-ref-c-signed-char) (E50a4 core-prim . pointer->integer) (E50a3 core-prim . integer->pointer) (E50a2 core-prim . pointer?) (E50a1 core-prim . shared-errno) (E50a0 core-prim . %ffi-free-c-callback-trampoline) (E509f core-prim . %ffi-make-c-callback-trampoline) (E509e core-prim . %ffi-free) (E509d core-prim . %ffi-malloc) (E509c core-prim . %ffi-supported?) (E509b core-prim . %ffi-pointer->string) (E509a core-prim . %ffi-call) (E5099 core-prim . %ffi-lookup) (E5098 core-prim . %ffi-open) (E5097 core-prim . null-terminated-utf8->string) (E5096 core-prim . null-terminated-bytevector->string) (E5095 core-prim . %exec) (E5094 core-prim . %fork) (E5093 core-prim . %pipe) (E5092 core-prim . p) (E5091 core-prim . open-output-string) (E5090 core-prim . get-output-string) (E508f core-prim . file-stat-ctime) (E508e core-prim . file-stat-atime) (E508d core-prim . file-stat-mtime) (E508c core-prim . file-size-in-bytes) (E508b core-prim . file-writable?) (E508a core-prim . file-executable?) (E5089 core-prim . file-readable?) (E5088 core-prim . file-regular?) (E5087 core-prim . file-symbolic-link?) (E5086 core-prim . file-directory?) (E5085 core-prim . create-symbolic-link) (E5084 core-prim . rename-file) (E5083 core-prim . delete-directory) (E5082 core-prim . create-directory) (E5081 core-prim . create-mosh-cache-dir) (E5080 core-prim . get-environment-variables) (E507f core-prim . current-exception-handler) (E507e core-prim . get-environment-variable) (E507d core-prim . join-wraps) (E507c core-prim . id->real-label) (E507b core-prim . same-marks?) (E507a core-prim . same-marks*?) (E5079 core-prim . get-timeofday) (E5078 core-prim . get-command-line) (E5077 core-prim . sys-display) (E5076 core-prim . whereis) (E5075 core-prim . register) (E5074 core-prim . vm-join!) (E5073 core-prim . vm-set-value!) (E5072 core-prim . vm?) (E5071 core-prim . main-vm?) (E5070 core-prim . vm-eval) (E506f core-prim . vm-self) (E506e core-prim . vm-start!) (E506d core-prim . make-vm) (E506c core-prim . mutex-try-lock!) (E506b core-prim . mutex-unlock!) (E506a core-prim . mutex-lock!) (E5069 core-prim . mutex?) (E5068 core-prim . make-mutex) (E5067 core-prim . condition-variable-notify-all!) (E5066 core-prim . condition-variable-notify!) (E5065 core-prim . condition-variable-wait!) (E5064 core-prim . make-condition-variable) (E5063 core-prim . write/ss) (E5062 core-prim . mosh-executable-path) (E5061 core-prim . make-file-options) (E5060 core-prim . source-info) (E505f core-prim . make-compiler-instruction) (E505e core-prim . make-instruction) (E505d core-prim . set-source-info!) (E505c core-prim . bignum?) (E505b core-prim . fast-equal?) (E505a core-prim . fasl-read) (E5059 core-prim . fasl-write) (E5058 core-prim . time-usage) (E5057 core-prim . os-constant) (E5056 core-prim . disasm) (E28e7 core-prim . make-parameter) (E5055 core-prim . socket-port) (E5054 core-prim . socket-shutdown) (E5053 core-prim . socket-close) (E5052 core-prim . socket-send) (E5051 core-prim . socket-recv!) (E5050 core-prim . socket-recv) (E504f core-prim . make-server-socket) (E504e core-prim . make-client-socket) (E504d core-prim . socket-accept) (E504c core-prim . socket?) (E504b core-prim . string-upcase) (E504a core-prim . string-titlecase) (E5049 core-prim . string-normalize-nfkd) (E5048 core-prim . string-normalize-nfkc) (E5047 core-prim . string-normalize-nfd) (E5046 core-prim . string-normalize-nfc) (E5045 core-prim . string-foldcase) (E5044 core-prim . string-downcase) (E5043 core-prim . string-ci>?) (E5042 core-prim . string-ci>=?) (E5041 core-prim . string-ci=?) (E5040 core-prim . string-ci<?) (E503f core-prim . string-ci<=?) (E503e core-prim . char-whitespace?) (E503d core-prim . char-upper-case?) (E503c core-prim . char-title-case?) (E503b core-prim . char-numeric?) (E503a core-prim . char-lower-case?) (E5039 core-prim . char-general-category) (E5038 core-prim . char-upcase) (E5037 core-prim . char-titlecase) (E5036 core-prim . char-foldcase) (E5035 core-prim . char-downcase) (E5034 core-prim . char-ci>?) (E5033 core-prim . char-ci>=?) (E5032 core-prim . char-ci=?) (E5031 core-prim . char-ci<?) (E5030 core-prim . char-ci<=?) (E502f core-prim . char-alphabetic?) (E2eeb core-prim . make-variable-transformer) (E31a2 core-prim . identifier?) (E318e core-prim . generate-temporaries) (E3190 core-prim . free-identifier=?) (E31a6 core-prim . syntax->datum) (E31a4 core-prim . datum->syntax) (E3192 core-prim . bound-identifier=?) (E502e core-prim . record-type-descriptor?) (E502d core-prim . record-predicate) (E502c core-prim . record-mutator) (E502b core-prim . record-constructor) (E502a core-prim . record-accessor) (E5029 core-prim . make-record-type-descriptor) (E5028 core-prim . make-record-constructor-descriptor) (E5027 core-prim . record?) (E5026 core-prim . record-type-uid) (E5025 core-prim . record-type-sealed?) (E5024 core-prim . record-type-parent) (E5023 core-prim . record-type-opaque?) (E5022 core-prim . record-type-name) (E5021 core-prim . record-type-generative?) (E5020 core-prim . record-type-field-names) (E501f core-prim . record-rtd) (E501e core-prim . record-field-mutable?) (E501d core-prim . delete-file) (E501c core-prim . file-exists?) (E501b core-prim . vector-sort!) (E501a core-prim . vector-sort) (E5019 core-prim . list-sort) (E5018 core-prim . symbol-hash) (E5017 core-prim . string-ci-hash) (E5016 core-prim . string-hash) (E5015 core-prim . equal-hash) (E5014 core-prim . hashtable-equivalence-function) (E5013 core-prim . make-hashtable) (E5012 core-prim . hashtable-hash-function) (E5011 core-prim . make-eqv-hashtable) (E5010 core-prim . make-eq-hashtable) (E500f core-prim . hashtable?) (E500e core-prim . hashtable-update!) (E500d core-prim . hashtable-size) (E500c core-prim . hashtable-set!) (E500b core-prim . hashtable-ref) (E500a core-prim . hashtable-mutable?) (E5009 core-prim . hashtable-keys) (E5008 core-prim . hashtable-entries) (E5007 core-prim . hashtable-delete!) (E5006 core-prim . hashtable-copy) (E5005 core-prim . hashtable-contains?) (E5004 core-prim . hashtable-clear!) (E5003 core-prim . call-with-output-file) (E5002 core-prim . call-with-input-file) (E5001 core-prim . write-char) (E5000 core-prim . write) (E4fff core-prim . with-output-to-file) (E4ffe core-prim . with-input-from-file) (E4ffd core-prim . read-char) (E4ffc core-prim . read) (E4ffb core-prim . peek-char) (E4ffa core-prim . open-output-file) (E4ff9 core-prim . open-input-file) (E4ff8 core-prim . newline) (E4ff7 core-prim . display) (E4ff6 core-prim . close-output-port) (E4ff5 core-prim . close-input-port) (E4ff4 core-prim . eof-object?) (E4ff3 core-prim . eof-object) (E4ff2 core-prim . current-error-port) (E4ff1 core-prim . current-output-port) (E4ff0 core-prim . current-input-port) (E4fef core-prim . output-port?) (E4fee core-prim . input-port?) (E4fed core-prim . utf-8-codec) (E4fec core-prim . utf-16-codec) (E4feb core-prim . transcoder-error-handling-mode) (E4fea core-prim . transcoder-eol-style) (E4fe9 core-prim . transcoder-codec) (E4fe8 core-prim . transcoded-port) (E4fe7 core-prim . textual-port?) (E4fe6 core-prim . string->bytevector) (E4fe5 core-prim . standard-output-port) (E4fe4 core-prim . standard-input-port) (E4fe3 core-prim . standard-error-port) (E4fe2 core-prim . set-port-position!) (E4fe1 core-prim . put-u8) (E4fe0 core-prim . put-string) (E4fdf core-prim . put-datum) (E4fde core-prim . put-char) (E4fdd core-prim . put-bytevector) (E4fdc core-prim . port?) (E4fdb core-prim . port-transcoder) (E4fda core-prim . port-position) (E4fd9 core-prim . port-has-set-port-position!?) (E4fd8 core-prim . port-has-port-position?) (E4fd7 core-prim . port-eof?) (E4fd6 core-prim . output-port-buffer-mode) (E4fd5 core-prim . open-string-output-port) (E4fd4 core-prim . open-string-input-port) (E4fd3 core-prim . open-file-output-port) (E4fd2 core-prim . open-file-input/output-port) (E4fd1 core-prim . open-file-input-port) (E4fd0 core-prim . open-bytevector-output-port) (E4fcf core-prim . open-bytevector-input-port) (E4fce core-prim . native-transcoder) (E4fcd core-prim . native-eol-style) (E4fcc core-prim . make-transcoder) (E4fcb core-prim . latin-1-codec) (E4fca core-prim . make-i/o-write-error) (E4fc9 core-prim . make-i/o-read-error) (E4fc8 core-prim . make-i/o-port-error) (E4fc7 core-prim . make-i/o-invalid-position-error) (E4fc6 core-prim . make-i/o-filename-error) (E4fc5 core-prim . make-i/o-file-protection-error) (E4fc4 core-prim . make-i/o-file-is-read-only-error) (E4fc3 core-prim . make-i/o-file-does-not-exist-error) (E4fc2 core-prim . make-i/o-file-already-exists-error) (E4fc1 core-prim . make-i/o-error) (E4fc0 core-prim . make-i/o-encoding-error) (E4fbf core-prim . make-i/o-decoding-error) (E4fbe core-prim . make-custom-textual-output-port) (E4fbd core-prim . make-custom-textual-input/output-port) (E4fbc core-prim . make-custom-textual-input-port) (E4fbb core-prim . make-custom-binary-output-port) (E4fba core-prim . make-custom-binary-input/output-port) (E4fb9 core-prim . make-custom-binary-input-port) (E4fb8 core-prim . make-bytevector) (E4fb7 core-prim . lookahead-u8) (E4fb6 core-prim . lookahead-char) (E4fb5 core-prim . i/o-write-error?) (E4fb4 core-prim . i/o-read-error?) (E4fb3 core-prim . i/o-port-error?) (E4fb2 core-prim . i/o-invalid-position-error?) (E4fb1 core-prim . i/o-filename-error?) (E4fb0 core-prim . i/o-file-protection-error?) (E4faf core-prim . i/o-file-is-read-only-error?) (E4fae core-prim . i/o-file-does-not-exist-error?) (E4fad core-prim . i/o-file-already-exists-error?) (E4fac core-prim . i/o-error?) (E4fab core-prim . i/o-error-position) (E4faa core-prim . i/o-error-port) (E4fa9 core-prim . i/o-error-filename) (E4fa8 core-prim . i/o-encoding-error?) (E4fa7 core-prim . i/o-encoding-error-char) (E4fa6 core-prim . i/o-decoding-error?) (E4fa5 core-prim . get-u8) (E4fa4 core-prim . get-string-n!) (E4fa3 core-prim . get-string-n) (E4fa2 core-prim . get-string-all) (E4fa1 core-prim . get-line) (E4fa0 core-prim . get-datum) (E4f9f core-prim . get-char) (E4f9e core-prim . get-bytevector-some) (E4f9d core-prim . get-bytevector-n!) (E4f9c core-prim . get-bytevector-n) (E4f9b core-prim . get-bytevector-all) (E4f9a core-prim . flush-output-port) (E4f99 core-prim . close-port) (E317c core-prim . scheme-report-environment) (E4f98 core-prim . quotient) (E317a core-prim . null-environment) (E4f97 core-prim . remainder) (E4f96 core-prim . modulo) (E4f95 core-prim . inexact->exact) (E4f94 core-prim . force) (E4f93 core-prim . exact->inexact) (E4f92 core-prim . make-promise) (E4f91 core-prim . exit) (E4c23 core-prim . command-line) (E4f90 core-prim . string-fill!) (E4f8f core-prim . string-set!) (E4f8e core-prim . set-cdr!) (E4f8d core-prim . set-car!) (E4f8c core-prim . remove) (E4f8b core-prim . remv) (E4f8a core-prim . remp) (E4f89 core-prim . remq) (E4f88 core-prim . partition) (E4f87 core-prim . memv) (E4f86 core-prim . memq) (E4f85 core-prim . memp) (E4f84 core-prim . member) (E4f83 core-prim . exists) (E4f82 core-prim . for-all) (E4f81 core-prim . fold-right) (E4f80 core-prim . fold-left) (E4f7f core-prim . find) (E4f7e core-prim . filter) (E4f7d core-prim . cons*) (E4f7c core-prim . assv) (E4f7b core-prim . assq) (E4f7a core-prim . assp) (E4f79 core-prim . assoc) (E4f78 core-prim . call-with-string-output-port) (E4f77 core-prim . call-with-port) (E4f76 core-prim . call-with-bytevector-output-port) (E4f75 core-prim . bytevector->string) (E4f74 core-prim . buffer-mode?) (E4f73 core-prim . binary-port?) (E4f72 core-prim . with-exception-handler) (E4f71 core-prim . raise-continuable) (E4f70 core-prim . raise) (E3180 core-prim . eval) (E3178 core-prim . environment) (E4f6f core-prim . make-enumeration) (E4f6e core-prim . enum-set=?) (E4f6d core-prim . enum-set-universe) (E4f6c core-prim . enum-set-union) (E4f6b core-prim . enum-set-subset?) (E4f6a core-prim . enum-set-projection) (E4f69 core-prim . enum-set-member?) (E4f68 core-prim . enum-set-intersection) (E4f67 core-prim . enum-set-indexer) (E4f66 core-prim . enum-set-difference) (E4f65 core-prim . enum-set-constructor) (E4f64 core-prim . enum-set-complement) (E4f63 core-prim . enum-set->list) (E4f62 core-prim . who-condition?) (E4f61 core-prim . warning?) (E4f60 core-prim . violation?) (E4f5f core-prim . undefined-violation?) (E4f5e core-prim . syntax-violation?) (E4f5d core-prim . syntax-violation-subform) (E4f5c core-prim . syntax-violation-form) (E31a0 core-prim . syntax-violation) (E4f5b core-prim . simple-conditions) (E4f5a core-prim . serious-condition?) (E4f59 core-prim . non-continuable-violation?) (E4f58 core-prim . message-condition?) (E4f57 core-prim . make-who-condition) (E4f56 core-prim . make-warning) (E4f55 core-prim . make-violation) (E4f54 core-prim . make-undefined-violation) (E4f53 core-prim . make-syntax-violation) (E4f52 core-prim . make-serious-condition) (E4f51 core-prim . make-non-continuable-violation) (E4f50 core-prim . make-message-condition) (E4f4f core-prim . make-lexical-violation) (E4f4e core-prim . make-irritants-condition) (E4f4d core-prim . make-implementation-restriction-violation) (E4f4c core-prim . make-error) (E4f4b core-prim . make-assertion-violation) (E4f4a core-prim . lexical-violation?) (E4f49 core-prim . irritants-condition?) (E4f48 core-prim . implementation-restriction-violation?) (E4f47 core-prim . error?) (E4f46 core-prim . condition-who) (E4f45 core-prim . condition-predicate) (E4f44 core-prim . condition-message) (E4f43 core-prim . condition-irritants) (E4f42 core-prim . condition-accessor) (E4f41 core-prim . condition) (E4f40 core-prim . assertion-violation?) (E4f3f core-prim . condition?) (E4f3e core-prim . utf32->string) (E4f3d core-prim . utf16->string) (E4f3c core-prim . utf8->string) (E4f3b core-prim . uint-list->bytevector) (E4f3a core-prim . u8-list->bytevector) (E4f39 core-prim . string->utf8) (E4f38 core-prim . string->utf32) (E4f37 core-prim . string->utf16) (E4f36 core-prim . sint-list->bytevector) (E4f35 core-prim . native-endianness) (E4f34 core-prim . bytevector?) (E4f33 core-prim . bytevector=?) (E4f32 core-prim . bytevector-uint-set!) (E4f31 core-prim . bytevector-uint-ref) (E4f30 core-prim . bytevector-u8-set!) (E4f2f core-prim . bytevector-u8-ref) (E4f2e core-prim . bytevector-u64-set!) (E4f2d core-prim . bytevector-u64-ref) (E4f2c core-prim . bytevector-u64-native-set!) (E4f2b core-prim . bytevector-u64-native-ref) (E4f2a core-prim . bytevector-u32-set!) (E4f29 core-prim . bytevector-u32-ref) (E4f28 core-prim . bytevector-u32-native-set!) (E4f27 core-prim . bytevector-u32-native-ref) (E4f26 core-prim . bytevector-u16-set!) (E4f25 core-prim . bytevector-u16-ref) (E4f24 core-prim . bytevector-u16-native-set!) (E4f23 core-prim . bytevector-u16-native-ref) (E4f22 core-prim . bytevector-sint-set!) (E4f21 core-prim . bytevector-sint-ref) (E4f20 core-prim . bytevector-s8-set!) (E4f1f core-prim . bytevector-s8-ref) (E4f1e core-prim . bytevector-s64-set!) (E4f1d core-prim . bytevector-s64-ref) (E4f1c core-prim . bytevector-s64-native-set!) (E4f1b core-prim . bytevector-s64-native-ref) (E4f1a core-prim . bytevector-s32-set!) (E4f19 core-prim . bytevector-s32-ref) (E4f18 core-prim . bytevector-s32-native-set!) (E4f17 core-prim . bytevector-s32-native-ref) (E4f16 core-prim . bytevector-s16-set!) (E4f15 core-prim . bytevector-s16-ref) (E4f14 core-prim . bytevector-s16-native-set!) (E4f13 core-prim . bytevector-s16-native-ref) (E4f12 core-prim . bytevector-length) (E4f11 core-prim . bytevector-ieee-single-ref) (E4f10 core-prim . bytevector-ieee-single-set!) (E4f0f core-prim . bytevector-ieee-single-native-set!) (E4f0e core-prim . bytevector-ieee-single-native-ref) (E4f0d core-prim . bytevector-ieee-double-set!) (E4f0c core-prim . bytevector-ieee-double-ref) (E4f0b core-prim . bytevector-ieee-double-native-set!) (E4f0a core-prim . bytevector-ieee-double-native-ref) (E4f09 core-prim . bytevector-fill!) (E4f08 core-prim . bytevector-copy!) (E4f07 core-prim . bytevector-copy) (E4f06 core-prim . bytevector->uint-list) (E4f05 core-prim . bytevector->u8-list) (E4f04 core-prim . bytevector->sint-list) (E4f03 core-prim . no-nans-violation?) (E4f02 core-prim . no-infinities-violation?) (E4f01 core-prim . make-no-nans-violation) (E4f00 core-prim . make-no-infinities-violation) (E4eff core-prim . real->flonum) (E4efe core-prim . flzero?) (E4efd core-prim . fltruncate) (E4efc core-prim . fltan) (E4efb core-prim . flsqrt) (E4efa core-prim . flsin) (E4ef9 core-prim . flround) (E4ef8 core-prim . flpositive?) (E4ef7 core-prim . flonum?) (E4ef6 core-prim . flodd?) (E4ef5 core-prim . flnumerator) (E4ef4 core-prim . flnegative?) (E4ef3 core-prim . flnan?) (E4ef2 core-prim . flmod0) (E4ef1 core-prim . flmod) (E4ef0 core-prim . flmin) (E4eef core-prim . flmax) (E4eee core-prim . fllog) (E4eed core-prim . flinteger?) (E4eec core-prim . flinfinite?) (E4eeb core-prim . flfloor) (E4eea core-prim . flfinite?) (E4ee9 core-prim . flexpt) (E4ee8 core-prim . flexp) (E4ee7 core-prim . fleven?) (E4ee6 core-prim . fldiv0-and-mod0) (E4ee5 core-prim . fldiv0) (E4ee4 core-prim . fldiv-and-mod) (E4ee3 core-prim . fldiv) (E4ee2 core-prim . fldenominator) (E4ee1 core-prim . flcos) (E4ee0 core-prim . flceiling) (E4edf core-prim . flatan) (E4ede core-prim . flasin) (E4edd core-prim . flacos) (E4edc core-prim . flabs) (E4edb core-prim . fl>?) (E4eda core-prim . fl>=?) (E4ed9 core-prim . fl=?) (E4ed8 core-prim . fl<?) (E4ed7 core-prim . fl<=?) (E4ed6 core-prim . fl/) (E4ed5 core-prim . fl-) (E4ed4 core-prim . fl+) (E4ed3 core-prim . fl*) (E4ed2 core-prim . fixnum->flonum) (E4ed1 core-prim . fxzero?) (E4ed0 core-prim . fxxor) (E4ecf core-prim . fxrotate-bit-field) (E4ece core-prim . fxreverse-bit-field) (E4ecd core-prim . fxpositive?) (E4ecc core-prim . fxodd?) (E4ecb core-prim . fxnot) (E4eca core-prim . fxnegative?) (E4ec9 core-prim . fxmod0) (E4ec8 core-prim . fxmod) (E4ec7 core-prim . fxmin) (E4ec6 core-prim . fxmax) (E4ec5 core-prim . fxlength) (E4ec4 core-prim . fxior) (E4ec3 core-prim . fxif) (E4ec2 core-prim . fxfirst-bit-set) (E4ec1 core-prim . fxeven?) (E4ec0 core-prim . fxdiv0-and-mod0) (E4ebf core-prim . fxdiv0) (E4ebe core-prim . fxdiv-and-mod) (E4ebd core-prim . fxdiv) (E4ebc core-prim . fxcopy-bit-field) (E4ebb core-prim . fxcopy-bit) (E4eba core-prim . fxbit-set?) (E4eb9 core-prim . fxbit-field) (E4eb8 core-prim . fxbit-count) (E4eb7 core-prim . fxarithmetic-shift-right) (E4eb6 core-prim . fxarithmetic-shift-left) (E4eb5 core-prim . fxarithmetic-shift) (E4eb4 core-prim . fxand) (E4eb3 core-prim . fx>?) (E4eb2 core-prim . fx>=?) (E4eb1 core-prim . fx=?) (E4eb0 core-prim . fx<?) (E4eaf core-prim . fx<=?) (E4eae core-prim . fx-/carry) (E4ead core-prim . fx-) (E4eac core-prim . fx+/carry) (E4eab core-prim . fx+) (E4eaa core-prim . fx*/carry) (E4ea9 core-prim . fx*) (E4ea8 core-prim . greatest-fixnum) (E4ea7 core-prim . least-fixnum) (E4ea6 core-prim . fixnum-width) (E4ea5 core-prim . fixnum?) (E4ea4 core-prim . bitwise-rotate-bit-field) (E4ea3 core-prim . bitwise-reverse-bit-field) (E4ea2 core-prim . bitwise-length) (E4ea1 core-prim . bitwise-if) (E4ea0 core-prim . bitwise-first-bit-set) (E4e9f core-prim . bitwise-copy-bit-field) (E4e9e core-prim . bitwise-copy-bit) (E4e9d core-prim . bitwise-bit-set?) (E4e9c core-prim . bitwise-bit-field) (E4e9b core-prim . bitwise-bit-count) (E4e9a core-prim . bitwise-xor) (E4e99 core-prim . bitwise-ior) (E4e98 core-prim . bitwise-and) (E4e97 core-prim . bitwise-not) (E4e96 core-prim . bitwise-arithmetic-shift-right) (E4e95 core-prim . bitwise-arithmetic-shift-left) (E4e94 core-prim . bitwise-arithmetic-shift) (E4e93 core-prim . zero?) (E4e92 core-prim . vector?) (E4e91 core-prim . vector-set!) (E4e90 core-prim . vector-ref) (E4e8f core-prim . vector-map) (E4e8e core-prim . vector-length) (E4e8d core-prim . vector-for-each) (E4e8c core-prim . vector-fill!) (E4e8b core-prim . vector->list) (E4e8a core-prim . vector) (E4e89 core-prim . values) (E4e88 core-prim . truncate) (E4e87 core-prim . tan) (E4e86 core-prim . symbol?) (E4e85 core-prim . symbol=?) (E4e84 core-prim . symbol->string) (E4e83 core-prim . substring) (E4e82 core-prim . string?) (E4e81 core-prim . string>?) (E4e80 core-prim . string>=?) (E4e7f core-prim . string=?) (E4e7e core-prim . string<?) (E4e7d core-prim . string<=?) (E4e7c core-prim . string-ref) (E4e7b core-prim . string-length) (E4e7a core-prim . string-for-each) (E4e79 core-prim . string-copy) (E4e78 core-prim . string-append) (E4e77 core-prim . string->symbol) (E4e76 core-prim . string->number) (E4e75 core-prim . string->list) (E4e74 core-prim . string) (E4e73 core-prim . sqrt) (E4e72 core-prim . sin) (E4e71 core-prim . round) (E4e70 core-prim . reverse) (E4e6f core-prim . real?) (E4e6e core-prim . real-valued?) (E4e6d core-prim . real-part) (E4e6c core-prim . rationalize) (E4e6b core-prim . rational?) (E4e6a core-prim . rational-valued?) (E4e69 core-prim . procedure?) (E4e68 core-prim . positive?) (E4e67 core-prim . pair?) (E4e66 core-prim . odd?) (E4e65 core-prim . numerator) (E4e64 core-prim . number?) (E4e63 core-prim . number->string) (E4e62 core-prim . null?) (E4e61 core-prim . not) (E4e60 core-prim . negative?) (E4e5f core-prim . nan?) (E4e5e core-prim . min) (E4e5d core-prim . max) (E4e5c core-prim . map) (E4e5b core-prim . make-vector) (E4e5a core-prim . make-string) (E4e59 core-prim . make-rectangular) (E4e58 core-prim . make-polar) (E4e57 core-prim . magnitude) (E4e56 core-prim . log) (E4e55 core-prim . list?) (E4e54 core-prim . list-tail) (E4e53 core-prim . list-ref) (E4e52 core-prim . list->vector) (E4e51 core-prim . list->string) (E4e50 core-prim . list) (E4e4f core-prim . length) (E4e4e core-prim . lcm) (E4e4d core-prim . integer?) (E4e4c core-prim . integer-valued?) (E4e4b core-prim . integer->char) (E4e4a core-prim . infinite?) (E4e49 core-prim . inexact?) (E4e48 core-prim . inexact) (E4e47 core-prim . imag-part) (E4e46 core-prim . gcd) (E4e45 core-prim . for-each) (E4e44 core-prim . floor) (E4e43 core-prim . finite?) (E4e42 core-prim . expt) (E4e41 core-prim . exp) (E4e40 core-prim . exact?) (E4e3f core-prim . exact-integer-sqrt) (E4e3e core-prim . exact) (E4e3d core-prim . even?) (E4e3c core-prim . error) (E4e3b core-prim . eqv?) (E4e3a core-prim . equal?) (E4e39 core-prim . eq?) (E4e38 core-prim . dynamic-wind) (E4e37 core-prim . div0-and-mod0) (E4e36 core-prim . mod0) (E4e35 core-prim . div0) (E4e34 core-prim . div-and-mod) (E4e33 core-prim . mod) (E4e32 core-prim . div) (E4e31 core-prim . denominator) (E4e30 core-prim . cos) (E4e2f core-prim . cons) (E4e2e core-prim . complex?) (E4e2d core-prim . char?) (E4e2c core-prim . char>?) (E4e2b core-prim . char>=?) (E4e2a core-prim . char=?) (E4e29 core-prim . char<?) (E4e28 core-prim . char<=?) (E4e27 core-prim . char->integer) (E4e26 core-prim . ceiling) (E4e25 core-prim . call-with-values) (E4e24 core-prim . call/cc) (E4e23 core-prim . call-with-current-continuation) (E4e22 core-prim . cddddr) (E4e21 core-prim . cdddar) (E4e20 core-prim . cddadr) (E4e1f core-prim . cddaar) (E4e1e core-prim . cdaddr) (E4e1d core-prim . cdadar) (E4e1c core-prim . cdaadr) (E4e1b core-prim . cdaaar) (E4e1a core-prim . cadddr) (E4e19 core-prim . caddar) (E4e18 core-prim . cadadr) (E4e17 core-prim . cadaar) (E4e16 core-prim . caaddr) (E4e15 core-prim . caadar) (E4e14 core-prim . caaadr) (E4e13 core-prim . caaaar) (E4e12 core-prim . cdddr) (E4e11 core-prim . cddar) (E4e10 core-prim . cdadr) (E4e0f core-prim . cdaar) (E4e0e core-prim . caddr) (E4e0d core-prim . cadar) (E4e0c core-prim . caadr) (E4e0b core-prim . caaar) (E4e0a core-prim . cddr) (E4e09 core-prim . cdar) (E4e08 core-prim . cadr) (E4e07 core-prim . caar) (E4e06 core-prim . cdr) (E4e05 core-prim . car) (E4e04 core-prim . boolean?) (E4e03 core-prim . boolean=?) (E4e02 core-prim . atan) (E4e01 core-prim . assertion-violation) (E319a core-prim . assertion-error) (E4e00 core-prim . asin) (E4dff core-prim . apply) (E4dfe core-prim . append) (E4dfd core-prim . angle) (E4dfc core-prim . acos) (E4dfb core-prim . abs) (E4dfa core-prim . /) (E4df9 core-prim . *) (E4df8 core-prim . -) (E4df7 core-prim . +) (E4df6 core-prim . >=) (E4df5 core-prim . >) (E4df4 core-prim . =) (E4df3 core-prim . <=) (E4df2 core-prim . <) (E4df1 core-prim . library) (E4df0 $core-rtd &no-nans-rtd &no-nans-rcd) (E4def $core-rtd &no-infinities-rtd &no-infinities-rcd) (E4dee $core-rtd &i/o-encoding-rtd &i/o-encoding-rcd) (E4ded $core-rtd &i/o-decoding-rtd &i/o-decoding-rcd) (E4dec $core-rtd &i/o-port-rtd &i/o-port-rcd) (E4deb $core-rtd &i/o-file-does-not-exist-rtd &i/o-file-does-not-exist-rcd) (E4dea $core-rtd &i/o-file-already-exists-rtd &i/o-file-already-exists-rcd) (E4de9 $core-rtd &i/o-file-is-read-only-rtd &i/o-fie-is-read-only-rcd) (E4de8 $core-rtd &i/o-file-protection-rtd &i/o-file-protection-rcd) (E4de7 $core-rtd &i/o-filename-rtd &i/o-filename-rcd) (E4de6 $core-rtd &i/o-invalid-position-rtd &i/o-invalid-position-rcd) (E4de5 $core-rtd &i/o-write-rtd &i/o-write-rcd) (E4de4 $core-rtd &i/o-read-rtd &i/o-read-rcd) (E4de3 $core-rtd &i/o-rtd &i/o-rcd) (E4de2 $core-rtd &undefined-rtd &undefined-rcd) (E4de1 $core-rtd &syntax-rtd &syntax-rcd) (E4de0 $core-rtd &lexical-rtd &lexical-rcd) (E4ddf $core-rtd &implementation-restriction-rtd &implementation-restriction-rcd) (E4dde $core-rtd &non-continuable-rtd &non-continuable-rcd) (E4ddd $core-rtd &who-rtd &who-rcd) (E4ddc $core-rtd &irritants-rtd &irritants-rcd) (E4ddb $core-rtd &assertion-rtd &assertion-rcd) (E4dda $core-rtd &violation-rtd &violation-rcd) (E4dd9 $core-rtd &error-rtd &error-rcd) (E4dd8 $core-rtd &serious-rtd &serious-rcd) (E4dd7 $core-rtd &warning-rtd &warning-rcd) (E4dd6 $core-rtd &message-rtd &message-rcd) (E4dd5 $core-rtd &condition-rtd &condition-rcd) (E4dd4 macro . define-condition-type) (E4dd3 macro . define-enumeration) (E4dd2 macro . define-record-type) (E4dd1 macro . parent-rtd) (E4dd0 macro . nongenerative) (E4dcf macro . opaque) (E4dce macro . sealed) (E4dcd macro . protocol) (E4dcc macro . parent) (E4dcb macro . immutable) (E4dca macro . mutable) (E4dc9 macro . fields) (E4dc8 macro . error-handling-mode) (E4dc7 macro . file-options) (E4dc6 macro . buffer-mode) (E4dc5 macro . eol-style) (E4dc4 macro . guard) (E4dc3 macro . trace-define) (E4dc2 macro . trace-lambda) (E4dc1 macro . unsyntax-splicing) (E4dc0 macro . unsyntax) (E4dbf macro . unquote-splicing) (E4dbe macro . unquote) (E4dbd macro . _) (E4dbc macro . else) (E4dbb macro . =>) (E4dba macro . ...) (E4db9 macro . assert) (E4db8 macro . endianness) (E4db7 macro . delay) (E4db6 macro . time) (E4db5 macro . do) (E4db4 macro . cond) (E4db3 macro . let*) (E4db2 macro . let*-values) (E4db1 macro . let-values) (E4db0 macro . identifier-syntax) (E4daf macro . with-syntax) (E4dae macro . quasisyntax) (E4dad macro . quasiquote) (E4dac macro . syntax-rules) (E4dab macro . include) (E4daa macro . define-struct) (E4da9 core-macro . record-constructor-descriptor) (E4da8 core-macro . record-type-descriptor) (E4da7 macro . case) (E4da6 macro . parameterize) (E4da5 macro . unless) (E4da4 macro . when) (E4da3 core-macro . or) (E4da2 core-macro . and) (E4da1 core-macro . if) (E4da0 core-macro . let) (E4d9f core-macro . letrec*) (E4d9e core-macro . letrec) (E4d9d core-macro . type-descriptor) (E4d9c core-macro . case-lambda) (E4d9b core-macro . lambda) (E4d9a core-macro . syntax) (E4d99 core-macro . syntax-case) (E4d98 core-macro . quote) (E4d97 core-macro . foreign-call) (E4d96 letrec-syntax) (E4d95 let-syntax) (E4d94 set!) (E4d93 import) (E4d92 begin) (E4d91 module) (E4d90 define-syntax) (E4d8f define)) values values '#f '#f '#f '#f) (E2cd4@E2b20@install-library 'E5154 '(psyntax system $bootstrap) '() '() '() '() '((pretty-print . E50fb) (eval-core . E50fa) (set-symbol-value! . E50f9) (symbol-value . E50f8) (gensym . E50f7) (void . E50f6)) '() values values '#f '#f '#f '#f) (E2cd4@E2b20@install-library 'E5155 '(mosh) '() '() '() '() '((set-symbol-value! . E50f9) (symbol-value . E50f8) (regexp? . E50f4) (read-line . E50f3) (ungensym . E50f1) (alist->eq-hash-table . E50f0) (assoc-ref . E50ef) (print . E50ee) (format . E50ed) (host-os . E50ec) (library-path . E2aff) (standard-library-path . E50eb) (file-newer? . E50e5) (stat-mtime . E50e4) (digit->integer . E50e0) (call-with-string-input-port . E50df) (call-with-string-io . E50de) (string-split . E50dd) (bytevector-for-each . E50dc) (string->regexp . E50db) (rxmatch . E50da) (regexp-replace-all . E50d9) (hashtable-for-each . E50d8) (set-current-directory! . E50d3) (expand-path . E50d2) (current-directory . E50d1) (p . E5092) (get-timeofday . E5079) (get-command-line . E5078) (sys-display . E5077) (whereis . E5076) (register . E5075) (vm-join! . E5074) (vm-set-value! . E5073) (vm? . E5072) (main-vm? . E5071) (vm-eval . E5070) (vm-self . E506f) (vm-start! . E506e) (make-vm . E506d) (mutex-try-lock! . E506c) (mutex-unlock! . E506b) (mutex-lock! . E506a) (mutex? . E5069) (make-mutex . E5068) (condition-variable-notify-all! . E5067) (condition-variable-notify! . E5066) (condition-variable-wait! . E5065) (make-condition-variable . E5064) (write/ss . E5063) (mosh-executable-path . E5062) (make-file-options . E5061) (source-info . E5060) (make-compiler-instruction . E505f) (make-instruction . E505e) (set-source-info! . E505d) (bignum? . E505c) (fast-equal? . E505b) (fasl-read . E505a) (fasl-write . E5059) (time-usage . E5058) (os-constant . E5057) (time . E4db6) (include . E4dab)) '() values values '#f '#f '#f '#f) (E2cd4@E2b20@install-library 'E5156 '(system) '() '() '() '() '((gensym-prefix-set! . E50f2) (ssl-supported? . E50ea) (ssl-socket? . E50e9) (socket-sslize! . E50e8) (%monapi-name-whereis . E50e7) (%monapi-message-send . E50e6) (write-to-file . E50e3) (file->list . E50e2) (file->string . E50e1) (mosh-cache-dir . E28e9) (call-process . E50d7) (local-tz-offset . E50d6) (microseconds . E50d5) (directory-list . E50d4) (expand-path . E50d2) (%spawn . E50d0) (%waitpid . E50cf) (simple-struct-name . E50ce) (simple-struct-set! . E50cd) (simple-struct-ref . E50cc) (make-simple-struct . E50cb) (simple-struct? . E50ca) (pointer-ref-c-int64 . E50c9) (pointer-ref-c-int32 . E50c8) (pointer-ref-c-int16 . E50c7) (pointer-ref-c-int8 . E50c6) (pointer-ref-c-uint64 . E50c5) (pointer-ref-c-uint32 . E50c4) (pointer-ref-c-uint16 . E50c3) (pointer-ref-c-uint8 . E50c2) (pointer-set-c-uint64! . E50c1) (pointer-set-c-uint32! . E50c0) (pointer-set-c-uint16! . E50bf) (pointer-set-c-uint8! . E50be) (pointer-set-c-int64! . E50bd) (pointer-set-c-int32! . E50bc) (pointer-set-c-int16! . E50bb) (pointer-set-c-int8! . E50ba) (pointer-set-c-pointer! . E50b9) (pointer-set-c-double! . E50b8) (pointer-set-c-float! . E50b7) (pointer-set-c-long-long! . E50b6) (pointer-set-c-long! . E50b5) (pointer-set-c-int! . E50b4) (pointer-set-c-short! . E50b3) (pointer-set-c-char! . E50b2) (pointer-ref-c-pointer . E50b1) (pointer-ref-c-double . E50b0) (pointer-ref-c-float . E50af) (pointer-ref-c-unsigned-long-long . E50ae) (pointer-ref-c-signed-long-long . E50ad) (pointer-ref-c-unsigned-long . E50ac) (pointer-ref-c-signed-long . E50ab) (pointer-ref-c-unsigned-int . E50aa) (pointer-ref-c-signed-int . E50a9) (pointer-ref-c-unsigned-short . E50a8) (pointer-ref-c-signed-short . E50a7) (pointer-ref-c-unsigned-char . E50a6) (pointer-ref-c-signed-char . E50a5) (pointer->integer . E50a4) (integer->pointer . E50a3) (pointer? . E50a2) (shared-errno . E50a1) (%ffi-free-c-callback-trampoline . E50a0) (%ffi-make-c-callback-trampoline . E509f) (%ffi-free . E509e) (%ffi-malloc . E509d) (%ffi-supported? . E509c) (%ffi-pointer->string . E509b) (%ffi-call . E509a) (%ffi-lookup . E5099) (%ffi-open . E5098) (null-terminated-utf8->string . E5097) (null-terminated-bytevector->string . E5096) (%exec . E5095) (%fork . E5094) (%pipe . E5093) (open-output-string . E5091) (get-output-string . E5090) (file-stat-ctime . E508f) (file-stat-atime . E508e) (file-stat-mtime . E508d) (file-size-in-bytes . E508c) (file-writable? . E508b) (file-executable? . E508a) (file-readable? . E5089) (file-regular? . E5088) (file-symbolic-link? . E5087) (file-directory? . E5086) (create-symbolic-link . E5085) (rename-file . E5084) (delete-directory . E5083) (create-directory . E5082) (create-mosh-cache-dir . E5081) (get-environment-variables . E5080) (current-exception-handler . E507f) (get-environment-variable . E507e) (join-wraps . E507d) (id->real-label . E507c) (same-marks? . E507b) (same-marks*? . E507a) (disasm . E5056) (make-parameter . E28e7) (socket-port . E5055) (socket-shutdown . E5054) (socket-close . E5053) (socket-send . E5052) (socket-recv! . E5051) (socket-recv . E5050) (make-server-socket . E504f) (make-client-socket . E504e) (socket-accept . E504d) (socket? . E504c) (parameterize . E4da6)) '() values values '#f '#f '#f '#f)))
(begin (set! E4c0e@ref (unspecified)) (set! E4c10@x* (unspecified)) (set! E4c12@add-library-path! (unspecified)) (set! E4c14@parse-and-add-library-path (unspecified)) (set! E4c16@for-each-with-index (unspecified)) (set! E4c18@rpad (unspecified)) (set! E4c1a@condition-printer (unspecified)) (set! E4c1c@record->field-alist (unspecified)) (set! E4c1e@map-with-index (unspecified)) (set! E4c20@repl (unspecified)) (set! E4c22@trace-printer (unspecified)) (set! E4c24@command-line (unspecified)) (set! E4c26@local-library-path (unspecified)) (set! E4c28@load/args (unspecified)) (set! E4c2a@load (unspecified)) (set! E4c2c@ironscheme-build (unspecified)) (set! E4c2e@eval-top-level (unspecified)) (set! E4c30@compile-system-libraries (unspecified)) (set! E4c32@compile (unspecified)) (set! E4c34@compile->closure (unspecified)) (set! E4c36@pre-compile-r6rs-file (unspecified)) (set! E4c38@load-r6rs-top-level (unspecified)) (set! E4c3a@load-r6rs-top-level-sexp (unspecified)) (set! E4c3c@prefix-inc (unspecified)) (set! E4c3e@prefix-inc! (unspecified)) (set! E4c0e@ref (lambda (E4c79@rtd E4c7a@i E4c7b@x) (let ((E4c7f@val ((record-accessor E4c79@rtd E4c7a@i) E4c7b@x))) (if (symbol? E4c7f@val) (ungensym E4c7f@val) E4c7f@val)))) (set! E4d75@E4c0e@ref E4c0e@ref) (set! E4c10@x* '()) (set! E4d76@E4c10@x* E4c10@x*) (set! E4c12@add-library-path! (lambda (E4c81@path) (E2cc4@E2b00@library-path (append (E2cc4@E2b00@library-path) (list E4c81@path))))) (set! E4d77@E4c12@add-library-path! E4c12@add-library-path!) (set! E4c14@parse-and-add-library-path (lambda (E4c83@paths E4c84@message) (letrec* ((E4c88@separator (if (string=? (host-os) '"win32") '#\; '#\:))) (let ((E4c89@t E4c83@paths)) (if E4c89@t ((lambda (E4c8b@paths) (for-each (lambda (E4c8d@path) (if (file-exists? E4c8d@path) (E4c12@add-library-path! (expand-path E4c8d@path)) (format (current-error-port) E4c84@message E4c8d@path))) (string-split E4c8b@paths E4c88@separator))) E4c89@t) (void)))))) (set! E4d78@E4c14@parse-and-add-library-path E4c14@parse-and-add-library-path) (set! E4c16@for-each-with-index (lambda (E4c8f@proc E4c90@lst) (letrec ((E4c93@loop (lambda (E4c95@i E4c96@lst) (if (null? E4c96@lst) (if '#f '#f (void)) (begin (E4c8f@proc E4c95@i (car E4c96@lst)) (E4c93@loop (+ E4c95@i '1) (cdr E4c96@lst))))))) (E4c93@loop '1 E4c90@lst)))) (set! E4d79@E4c16@for-each-with-index E4c16@for-each-with-index) (set! E4c18@rpad (lambda (E4c99@str E4c9a@pad E4c9b@n) (let ((E4c9f@rest (- E4c9b@n (string-length (format '"~a" E4c99@str))))) (let E4ca5@loop ((E4ca1@rest E4c9f@rest) (E4ca2@ret (format '"~a" E4c99@str))) (if (<= E4ca1@rest '0) E4ca2@ret (E4ca5@loop (- E4ca1@rest '1) (string-append E4ca2@ret E4c9a@pad))))))) (set! E4d7a@E4c18@rpad E4c18@rpad) (set! E4c1a@condition-printer (lambda (E4ca7@e E4ca8@port) (letrec* ((E4cac@max-condition-len (apply max (map (lambda (E4cbd@c) (string-length (symbol->string (record-type-name (record-rtd E4cbd@c))))) (simple-conditions E4ca7@e))))) (begin (display '" Condition components:\n" E4ca8@port) (E4c16@for-each-with-index (lambda (E4cad@i E4cae@x) (let ((E4cb1@rtd (record-rtd E4cae@x)) (E4cb2@fields-alist (E4c1c@record->field-alist E4cae@x))) (begin (format E4ca8@port '" ~d. ~a" E4cad@i (E4c18@rpad (symbol->string (record-type-name E4cb1@rtd)) '" " E4cac@max-condition-len)) (if (null? E4cb2@fields-alist) (newline E4ca8@port) (void)) (let E4cb9@loop ((E4cb5@first '#t) (E4cb6@fields-alist E4cb2@fields-alist)) (if (null? E4cb6@fields-alist) '() (let ((E4cbb@field (car E4cb6@fields-alist))) (begin (if (not E4cb5@first) (display (E4c18@rpad '"" '" " (+ '4 E4cac@max-condition-len)) E4ca8@port) (void)) (display '"       " E4ca8@port) (display (car E4cbb@field) E4ca8@port) (display '": " E4ca8@port) (write (cdr E4cbb@field) E4ca8@port) (newline E4ca8@port) (E4cb9@loop '#f (cdr E4cb6@fields-alist))))))))) (simple-conditions E4ca7@e)))))) (set! E4d7b@E4c1a@condition-printer E4c1a@condition-printer) (set! E4c1c@record->field-alist (lambda (E4cbf@r) (letrec* ((E4cc2@ref (lambda (E4ccd@rtd E4cce@i E4ccf@x) (let ((E4cd3@val ((record-accessor E4ccd@rtd E4cce@i) E4ccf@x))) (if (symbol? E4cd3@val) (ungensym E4cd3@val) E4cd3@val))))) (let E4cc7@loop ((E4cc3@ret '()) (E4cc4@rtd (record-rtd E4cbf@r))) (if E4cc4@rtd (E4cc7@loop (append E4cc3@ret (E4c1e@map-with-index (lambda (E4cc9@i E4cca@field) (cons E4cca@field (E4cc2@ref E4cc4@rtd E4cc9@i E4cbf@r))) (vector->list (record-type-field-names E4cc4@rtd)))) (record-type-parent E4cc4@rtd)) E4cc3@ret))))) (set! E4d7c@E4c1c@record->field-alist E4c1c@record->field-alist) (set! E4c1e@map-with-index (lambda (E4cd5@proc E4cd6@lst) (let E4cdf@loop ((E4cd9@i '0) (E4cda@lst E4cd6@lst) (E4cdb@ret '())) (if (null? E4cda@lst) (reverse E4cdb@ret) (E4cdf@loop (+ E4cd9@i '1) (cdr E4cda@lst) (cons (E4cd5@proc E4cd9@i (car E4cda@lst)) E4cdb@ret)))))) (set! E4d7d@E4c1e@map-with-index E4c1e@map-with-index) (set! E4c20@repl (lambda E4ce1@x (letrec* ((E4ce4@rec (lambda () (begin (display '"mosh> ") ((call/cc (lambda (E4ce7@E4ce5) (lambda () (with-exception-handler (lambda (E4ce9@e) ((call/cc (lambda (E4ceb@E4ce6) (E4ce7@E4ce5 (lambda () (if '#t (begin (display '"\nUnhandled exception:\n\n" (current-error-port)) (if (condition? E4ce9@e) (E4c1a@condition-printer E4ce9@e (current-error-port)) (format (current-error-port) '"  Non-condition object:\n     ~a\n" E4ce9@e))) (E4ceb@E4ce6 (lambda () (raise-continuable E4ce9@e)))))))))) (lambda () (let E4cf1@loop ((E4ced@line (get-line (current-input-port))) (E4cee@accum '"")) (letrec* ((E4cf4@parentheses-ok? (lambda (E4cff@text) (let E4d07@loop ((E4d01@chars (string->list E4cff@text)) (E4d02@p0 '0) (E4d03@p1 '0)) (if (null? E4d01@chars) (= '0 E4d02@p0 E4d03@p1) (let ((E4d09@t (car E4d01@chars))) (if (memv E4d09@t '(#\()) (E4d07@loop (cdr E4d01@chars) (+ E4d02@p0 '1) E4d03@p1) (if (memv E4d09@t '(#\))) (E4d07@loop (cdr E4d01@chars) (- E4d02@p0 '1) E4d03@p1) (if (memv E4d09@t '(#\[)) (E4d07@loop (cdr E4d01@chars) E4d02@p0 (+ E4d03@p1 '1)) (if (memv E4d09@t '(#\])) (E4d07@loop (cdr E4d01@chars) E4d02@p0 (- E4d03@p1 '1)) (E4d07@loop (cdr E4d01@chars) E4d02@p0 E4d03@p1)))))))))) (E4cf6@eval-string-print (lambda (E4cf9@text) (if (not (or (string=? '"\n" E4cf9@text) (= '0 (string-length E4cf9@text)))) (call-with-values (lambda () (E4c2e@eval-top-level (call-with-port (open-string-input-port E4cf9@text) read))) (lambda E4cfb@out* (for-each (lambda (E4cfd@out) (begin (write E4cfd@out) (newline))) E4cfb@out*))) (void))))) (if (eof-object? E4ced@line) (begin (E4cf6@eval-string-print E4cee@accum) (exit)) (let ((E4cf7@current (string-append E4cee@accum E4ced@line))) (if (E4cf4@parentheses-ok? E4cf7@current) (E4cf6@eval-string-print E4cf7@current) (E4cf1@loop (get-line (current-input-port)) E4cf7@current)))))))))))) (newline) (E4ce4@rec))))) (E4ce4@rec)))) (set! E4d7e@E4c20@repl E4c20@repl) (set! E4c22@trace-printer (E2a0a@E28e8@make-parameter write)) (set! E4d7f@E4c22@trace-printer E4c22@trace-printer) (set! E4c24@command-line (E2a0a@E28e8@make-parameter (get-command-line))) (set! E4d80@E4c24@command-line E4c24@command-line) (set! E4c26@local-library-path (lambda (E4d0b@filename) (E2cc4@E2b00@library-path))) (set! E4d81@E4c26@local-library-path E4c26@local-library-path) (set! E4c28@load/args (lambda (E4d0d@filename . E4d0f@args) (begin (apply E4c38@load-r6rs-top-level E4d0d@filename 'load E4d0f@args) (void)))) (set! E4d82@E4c28@load/args E4c28@load/args) (set! E4c2a@load (lambda (E4d11@filename) (begin (apply E4c38@load-r6rs-top-level E4d11@filename 'load (E4c24@command-line)) (void)))) (set! E4d83@E4c2a@load E4c2a@load) (set! E4c2c@ironscheme-build (lambda () (E4c2a@load '"ironscheme-buildscript.ss"))) (set! E4d84@E4c2c@ironscheme-build E4c2c@ironscheme-build) (set! E4c2e@eval-top-level (lambda (E4d13@x) (E4beb@E3181@eval E4d13@x (E4c02@E31af@interaction-environment)))) (set! E4d85@E4c2e@eval-top-level E4c2e@eval-top-level) (set! E4c30@compile-system-libraries (lambda () (E4c2e@eval-top-level '(begin (include "system-libraries.ss") (compile "system-libraries.ss"))))) (set! E4d86@E4c30@compile-system-libraries E4c30@compile-system-libraries) (set! E4c32@compile (lambda (E4d15@filename) (E4c38@load-r6rs-top-level E4d15@filename 'compile))) (set! E4d87@E4c32@compile E4c32@compile) (set! E4c34@compile->closure (lambda (E4d17@filename) (E4c38@load-r6rs-top-level E4d17@filename 'closure))) (set! E4d88@E4c34@compile->closure E4c34@compile->closure) (set! E4c36@pre-compile-r6rs-file (lambda (E4d19@filename) (E4c38@load-r6rs-top-level E4d19@filename 'compile))) (set! E4d89@E4c36@pre-compile-r6rs-file E4c36@pre-compile-r6rs-file) (set! E4c38@load-r6rs-top-level (lambda (E4d1b@filename E4d1c@how . E4d1f@args) (begin (E2cc4@E2b00@library-path (E4c26@local-library-path E4d1b@filename)) (let ((E4d21@x* (with-input-from-file E4d1b@filename (lambda () (let E4d23@f () (let ((E4d25@x (E29fc@E28cc@read-annotated))) (if (eof-object? E4d25@x) '() (cons E4d25@x (E4d23@f))))))))) (let ((E4d27@t E4d1c@how)) (if (memv E4d27@t '(closure)) (E4c01@E31ad@pre-compile-r6rs-top-level E4d21@x*) (if (memv E4d27@t '(load)) (begin (E4c24@command-line (cons E4d1b@filename (car E4d1f@args))) (E2a0b@E28ea@mosh-cache-dir (create-mosh-cache-dir)) (if (E2a0b@E28ea@mosh-cache-dir) (gensym-prefix-set! (E4c3e@prefix-inc! (string-append (E2a0b@E28ea@mosh-cache-dir) '"/prefix.txt"))) (void)) (if (symbol-value '%clean-acc) (for-each (lambda (E4d29@file) ((call/cc (lambda (E4d2d@E4d2b) (lambda () (with-exception-handler (lambda (E4d2f@c) ((call/cc (lambda (E4d31@E4d2c) (E4d2d@E4d2b (lambda () (if '#t '#t (E4d31@E4d2c (lambda () (raise-continuable E4d2f@c)))))))))) (lambda () (delete-file (string-append (E2a0b@E28ea@mosh-cache-dir) '"/" E4d29@file))))))))) (directory-list (E2a0b@E28ea@mosh-cache-dir))) (void)) (let ((E4d33@compiled (E4c00@E31ab@compile-r6rs-top-level E4d21@x*))) (begin (if (and (E2a0b@E28ea@mosh-cache-dir) (not (symbol-value '%disable-acc))) (E2cc8@E2b08@serialize-all E2a05@E28de@serialize-library E2a61@E2a1a@compile-core-expr) (void)) (E4d33@compiled)))) (if (memv E4d27@t '(compile)) (begin (E4c00@E31ab@compile-r6rs-top-level E4d21@x*) (E2cc8@E2b08@serialize-all E2a05@E28de@serialize-library E2a61@E2a1a@compile-core-expr)) (if '#f '#f (void)))))))))) (set! E4d8a@E4c38@load-r6rs-top-level E4c38@load-r6rs-top-level) (set! E4c3a@load-r6rs-top-level-sexp (lambda (E4d35@import-spec E4d36@thunk) (let ((E4d41@E4d3a E2cc4@E2b00@library-path) (E4d42@E4d3c E2a0b@E28ea@mosh-cache-dir) (E4d43@E4d3e (E4c26@local-library-path '"")) (E4d44@E4d40 (create-mosh-cache-dir))) (let ((E4d49@swap (lambda () (begin (let ((E4d4b@t (E4d41@E4d3a))) (begin (E4d41@E4d3a E4d43@E4d3e) (set! E4d43@E4d3e E4d4b@t))) (let ((E4d4d@t (E4d42@E4d3c))) (begin (E4d42@E4d3c E4d44@E4d40) (set! E4d44@E4d40 E4d4d@t))))))) (dynamic-wind E4d49@swap (lambda () (begin (if (E2a0b@E28ea@mosh-cache-dir) (gensym-prefix-set! (E4c3e@prefix-inc! (string-append (E2a0b@E28ea@mosh-cache-dir) '"/prefix.txt"))) (void)) (let ((E4d53@E4d50 E4c24@command-line) (E4d54@E4d52 '())) (let ((E4d57@swap (lambda () (let ((E4d59@t (E4d53@E4d50))) (begin (E4d53@E4d50 E4d54@E4d52) (set! E4d54@E4d52 E4d59@t)))))) (dynamic-wind E4d57@swap (lambda () ((E4c00@E31ab@compile-r6rs-top-level (list (cons 'import E4d35@import-spec) (list E4d36@thunk))))) E4d57@swap))))) E4d49@swap))))) (set! E4d8b@E4c3a@load-r6rs-top-level-sexp E4c3a@load-r6rs-top-level-sexp) (set! E4c3c@prefix-inc (lambda (E4d5b@prefix-string) (let ((E4d5d@prefix (symbol->string E4d5b@prefix-string))) (let ((E4d5f@len (string-length E4d5d@prefix))) (let E4d67@loop ((E4d61@i (- E4d5f@len '1)) (E4d62@carry? '#t) (E4d63@accum '())) (if (< E4d61@i '0) (string->symbol (list->string (if E4d62@carry? (cons '#\a E4d63@accum) E4d63@accum))) (if E4d62@carry? (let ((E4d69@next-integer (+ '1 (char->integer (string-ref E4d5d@prefix E4d61@i))))) (if (= E4d69@next-integer '123) (E4d67@loop (- E4d61@i '1) '#f (cons '#\A E4d63@accum)) (if (= E4d69@next-integer '91) (E4d67@loop (- E4d61@i '1) '#t (cons '#\a E4d63@accum)) (E4d67@loop (- E4d61@i '1) '#f (cons (integer->char E4d69@next-integer) E4d63@accum))))) (E4d67@loop (- E4d61@i '1) '#f (cons (string-ref E4d5d@prefix E4d61@i) E4d63@accum))))))))) (set! E4d8c@E4c3c@prefix-inc E4c3c@prefix-inc) (set! E4c3e@prefix-inc! (lambda (E4d6b@file) (begin (if (not (file-exists? E4d6b@file)) (call-with-output-file E4d6b@file (lambda (E4d6d@port) (write 'd E4d6d@port))) (void)) (let ((E4d6f@prefix (call-with-input-file E4d6b@file read))) (if (main-vm?) (let ((E4d71@next-prefix (E4c3c@prefix-inc E4d6f@prefix))) (begin (call-with-port (open-file-output-port E4d6b@file (make-file-options '(no-fail)) 'block (native-transcoder)) (lambda (E4d73@port) (write E4d71@next-prefix E4d73@port))) E4d6f@prefix)) E4d6f@prefix))))) (set! E4d8d@E4c3e@prefix-inc! E4c3e@prefix-inc!) (begin (E2cc9@E2b0a@current-precompiled-library-loader E2a06@E28e0@load-serialized-library) (set-symbol-value! 'load E4c2a@load) (set-symbol-value! 'pre-compile-r6rs-file E4c36@pre-compile-r6rs-file) (set-symbol-value! 'eval-r6rs E4c2e@eval-top-level) (set-symbol-value! 'int-env-syms E4be2@E316f@interaction-environment-symbols) (set-symbol-value! 'expanded2core E2a60@E2a18@expanded->core) (set-symbol-value! 'trace-printer E4c22@trace-printer) (set-symbol-value! 'compile-r6rs-top-level 'compile-r6rs-top-level) (set-symbol-value! 'create-non-continuable-violation (lambda (E4c3f@c) (condition (make-non-continuable-violation) (make-who-condition 'raise) (make-message-condition '"returned from non-continuable exception") (make-irritants-condition (list E4c3f@c))))) (E4c14@parse-and-add-library-path (get-environment-variable '"MOSH_LOADPATH") '"** WARN in environment variable 'MOSH_LOADPATH': directory ~s not exist\n") (E4c14@parse-and-add-library-path (symbol-value '%loadpath) '"** WARN in command-line option '--loadpath': directory ~s not exist\n") (if (mosh-executable-path) (if (file-exists? (string-append (mosh-executable-path) '"/lib")) (E4c12@add-library-path! (string-append (mosh-executable-path) '"/lib")) (void)) (if (file-exists? (string-append (current-directory) '"/lib")) (E4c12@add-library-path! (string-append (current-directory) '"/lib")) (void))) (if (file-exists? (string-append (standard-library-path) '"/lib")) (E4c12@add-library-path! (string-append (standard-library-path) '"/lib")) (void)) (let ((E4c41@prefix (lambda (E4c43@ext E4c44@ls) (append (map (lambda (E4c47@x) (string-append E4c43@ext E4c47@x)) E4c44@ls) E4c44@ls)))) (E2cc5@E2b02@library-extensions (E4c41@prefix '".mosh" (E2cc5@E2b02@library-extensions)))) (current-exception-handler (lambda (E4c49@c) (begin (if (condition? E4c49@c) (E4c1a@condition-printer E4c49@c (current-error-port)) (format (current-error-port) '"\n Non-condition object:\n     ~a\n" E4c49@c)) E4c49@c))) (if ((call/cc (lambda (E4c4d@E4c4b) (lambda () (with-exception-handler (lambda (E4c4f@c) ((call/cc (lambda (E4c51@E4c4c) (E4c4d@E4c4b (lambda () (if '#t '#f (E4c51@E4c4c (lambda () (raise-continuable E4c4f@c)))))))))) (lambda () (symbol-value '%vm-import-spec))))))) (E4c3a@load-r6rs-top-level-sexp (symbol-value '%vm-import-spec) (symbol-value '%vm-thunk)) (if (null? (E4c24@command-line)) (let ((E4c5b@E4c54 E4c24@command-line) (E4c5c@E4c56 E2a0b@E28ea@mosh-cache-dir) (E4c5d@E4c58 '()) (E4c5e@E4c5a (create-mosh-cache-dir))) (let ((E4c63@swap (lambda () (begin (let ((E4c65@t (E4c5b@E4c54))) (begin (E4c5b@E4c54 E4c5d@E4c58) (set! E4c5d@E4c58 E4c65@t))) (let ((E4c67@t (E4c5c@E4c56))) (begin (E4c5c@E4c56 E4c5e@E4c5a) (set! E4c5e@E4c5a E4c67@t))))))) (dynamic-wind E4c63@swap (lambda () (begin (if (E2a0b@E28ea@mosh-cache-dir) (gensym-prefix-set! (E4c3e@prefix-inc! (string-append (E2a0b@E28ea@mosh-cache-dir) '"/prefix.txt"))) (void)) (E4c20@repl))) E4c63@swap))) (begin (E2cc4@E2b00@library-path (E4c26@local-library-path (car (E4c24@command-line)))) (set! E4c10@x* (with-input-from-file (car (E4c24@command-line)) (lambda () (let E4c69@f () (let ((E4c6b@x (E29fc@E28cc@read-annotated))) (if (eof-object? E4c6b@x) '() (cons E4c6b@x (E4c69@f)))))))) (E4c24@command-line (cons (car (E4c24@command-line)) (cdr (E4c24@command-line)))) (E2a0b@E28ea@mosh-cache-dir (create-mosh-cache-dir)) (if (E2a0b@E28ea@mosh-cache-dir) (gensym-prefix-set! (E4c3e@prefix-inc! (string-append (E2a0b@E28ea@mosh-cache-dir) '"/prefix.txt"))) (void)) (if (symbol-value '%clean-acc) (for-each (lambda (E4c6d@file) ((call/cc (lambda (E4c71@E4c6f) (lambda () (with-exception-handler (lambda (E4c73@c) ((call/cc (lambda (E4c75@E4c70) (E4c71@E4c6f (lambda () (if '#t '#t (E4c75@E4c70 (lambda () (raise-continuable E4c73@c)))))))))) (lambda () (delete-file (string-append (E2a0b@E28ea@mosh-cache-dir) '"/" E4c6d@file))))))))) (directory-list (E2a0b@E28ea@mosh-cache-dir))) (void)) (let ((E4c77@compiled (E4c00@E31ab@compile-r6rs-top-level E4c10@x*))) (begin (if (and (E2a0b@E28ea@mosh-cache-dir) (not (symbol-value '%disable-acc))) (E2cc8@E2b08@serialize-all E2a05@E28de@serialize-library E2a61@E2a1a@compile-core-expr) (void)) (E4c77@compiled))))))))
